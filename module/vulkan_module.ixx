/*
 * Copyright 2021 Charles Giessen (cdgiessen@gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// clang-format off
module;

#include <stdint.h>
#include <cstddef>
#include <array>
#include <new>
#include <optional>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
#include "vk_platform.h"

#if defined(VK_USE_PLATFORM_FUCHSIA)
#include <zircon/types.h>
#endif

#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#include <wayland-client.h>
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
#include <xcb/xcb.h>
#endif

#if defined(VK_USE_PLATFORM_XLIB_KHR)
#include <X11/Xlib.h>
#endif

#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#include <directfb.h>
#endif

#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#include <X11/Xlib.h>
#include <X11/extensions/Xrandr.h>
#endif

#if defined(VK_USE_PLATFORM_GGP)
#include <ggp_c/vulkan_types.h>
#endif

// Compatability with compilers that don't support __has_feature
#if !defined(__has_feature)
#define __has_feature(x) 0
#endif

#if !defined(VK_MODULE_DISABLE_LEAK_SANITIZER_SUPPRESSION) && (__has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__) )
#include <sanitizer/lsan_interface.h>
#define VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE __lsan::ScopedDisabler lsan_scope{};
#else
#define VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
#endif

#if !defined(__has_feature)
#undef __has_feature
#endif

#if !defined(VULKAN_CUSTOM_ASSERT)
#include <cassert>
#define VULKAN_CUSTOM_ASSERT assert
#endif

export module vulkan_module;

export namespace vk {

constexpr uint32_t make_vk_version(uint32_t major, uint32_t minor, uint32_t patch) {
    return major << 22 | minor << 12 | patch;
}

#if !defined(VK_DEFINE_HANDLE)
#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;
#endif

#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
constexpr uint32_t MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
constexpr uint32_t UUID_SIZE = 16;
constexpr uint32_t LUID_SIZE = 8;
constexpr auto LUID_SIZE_KHR = LUID_SIZE;
constexpr uint32_t MAX_EXTENSION_NAME_SIZE = 256;
constexpr uint32_t MAX_DESCRIPTION_SIZE = 256;
constexpr uint32_t MAX_MEMORY_TYPES = 32;
constexpr uint32_t MAX_MEMORY_HEAPS = 16;
constexpr float LOD_CLAMP_NONE = 1000.0F;
constexpr uint32_t REMAINING_MIP_LEVELS = (~0U);
constexpr uint32_t REMAINING_ARRAY_LAYERS = (~0U);
constexpr uint64_t WHOLE_SIZE = (~0ULL);
constexpr uint32_t ATTACHMENT_UNUSED = (~0U);
constexpr uint32_t QUEUE_FAMILY_IGNORED = (~0U);
constexpr uint32_t QUEUE_FAMILY_EXTERNAL = (~1U);
constexpr auto QUEUE_FAMILY_EXTERNAL_KHR = QUEUE_FAMILY_EXTERNAL;
constexpr uint32_t QUEUE_FAMILY_FOREIGN_EXT = (~2U);
constexpr uint32_t SUBPASS_EXTERNAL = (~0U);
constexpr uint32_t MAX_DEVICE_GROUP_SIZE = 32;
constexpr auto MAX_DEVICE_GROUP_SIZE_KHR = MAX_DEVICE_GROUP_SIZE;
constexpr uint32_t MAX_DRIVER_NAME_SIZE = 256;
constexpr auto MAX_DRIVER_NAME_SIZE_KHR = MAX_DRIVER_NAME_SIZE;
constexpr uint32_t MAX_DRIVER_INFO_SIZE = 256;
constexpr auto MAX_DRIVER_INFO_SIZE_KHR = MAX_DRIVER_INFO_SIZE;
constexpr uint32_t SHADER_UNUSED_KHR = (~0U);
constexpr auto SHADER_UNUSED_NV = SHADER_UNUSED_KHR;
using SampleMask = uint32_t;
using Bool32 = uint32_t;
using Flags = uint32_t;
using Flags64 = uint64_t;
using DeviceSize = uint64_t;
using DeviceAddress = uint64_t;
enum class AttachmentLoadOp : uint32_t {
    Load = 0,
    Clear = 1,
    DontCare = 2,
};
enum class AttachmentStoreOp : uint32_t {
    Store = 0,
    DontCare = 1,
    NoneQCOM = 1000301000,
};
enum class BlendFactor : uint32_t {
    Zero = 0,
    One = 1,
    SrcColor = 2,
    OneMinusSrcColor = 3,
    DstColor = 4,
    OneMinusDstColor = 5,
    SrcAlpha = 6,
    OneMinusSrcAlpha = 7,
    DstAlpha = 8,
    OneMinusDstAlpha = 9,
    ConstantColor = 10,
    OneMinusConstantColor = 11,
    ConstantAlpha = 12,
    OneMinusConstantAlpha = 13,
    SrcAlphaSaturate = 14,
    Src1Color = 15,
    OneMinusSrc1Color = 16,
    Src1Alpha = 17,
    OneMinusSrc1Alpha = 18,
};
enum class BlendOp : uint32_t {
    Add = 0,
    Subtract = 1,
    ReverseSubtract = 2,
    Min = 3,
    Max = 4,
    ZeroEXT = 1000148000,
    SrcEXT = 1000148001,
    DstEXT = 1000148002,
    SrcOverEXT = 1000148003,
    DstOverEXT = 1000148004,
    SrcInEXT = 1000148005,
    DstInEXT = 1000148006,
    SrcOutEXT = 1000148007,
    DstOutEXT = 1000148008,
    SrcAtopEXT = 1000148009,
    DstAtopEXT = 1000148010,
    XorEXT = 1000148011,
    MultiplyEXT = 1000148012,
    ScreenEXT = 1000148013,
    OverlayEXT = 1000148014,
    DarkenEXT = 1000148015,
    LightenEXT = 1000148016,
    ColordodgeEXT = 1000148017,
    ColorburnEXT = 1000148018,
    HardlightEXT = 1000148019,
    SoftlightEXT = 1000148020,
    DifferenceEXT = 1000148021,
    ExclusionEXT = 1000148022,
    InvertEXT = 1000148023,
    InvertRgbEXT = 1000148024,
    LineardodgeEXT = 1000148025,
    LinearburnEXT = 1000148026,
    VividlightEXT = 1000148027,
    LinearlightEXT = 1000148028,
    PinlightEXT = 1000148029,
    HardmixEXT = 1000148030,
    HslHueEXT = 1000148031,
    HslSaturationEXT = 1000148032,
    HslColorEXT = 1000148033,
    HslLuminosityEXT = 1000148034,
    PlusEXT = 1000148035,
    PlusClampedEXT = 1000148036,
    PlusClampedAlphaEXT = 1000148037,
    PlusDarkerEXT = 1000148038,
    MinusEXT = 1000148039,
    MinusClampedEXT = 1000148040,
    ContrastEXT = 1000148041,
    InvertOvgEXT = 1000148042,
    RedEXT = 1000148043,
    GreenEXT = 1000148044,
    BlueEXT = 1000148045,
};
enum class BorderColor : uint32_t {
    FloatTransparentBlack = 0,
    IntTransparentBlack = 1,
    FloatOpaqueBlack = 2,
    IntOpaqueBlack = 3,
    FloatOpaqueWhite = 4,
    IntOpaqueWhite = 5,
    FloatCustomEXT = 1000287003,
    IntCustomEXT = 1000287004,
};
enum class PipelineCacheHeaderVersion : uint32_t {
    One = 1,
};
enum class ComponentSwizzle : uint32_t {
    Identity = 0,
    Zero = 1,
    One = 2,
    R = 3,
    G = 4,
    B = 5,
    A = 6,
};
enum class CommandBufferLevel : uint32_t {
    Primary = 0,
    Secondary = 1,
};
enum class CompareOp : uint32_t {
    Never = 0,
    Less = 1,
    Equal = 2,
    LessOrEqual = 3,
    Greater = 4,
    NotEqual = 5,
    GreaterOrEqual = 6,
    Always = 7,
};
enum class DescriptorType : uint32_t {
    Sampler = 0,
    CombinedImageSampler = 1,
    SampledImage = 2,
    StorageImage = 3,
    UniformTexelBuffer = 4,
    StorageTexelBuffer = 5,
    UniformBuffer = 6,
    StorageBuffer = 7,
    UniformBufferDynamic = 8,
    StorageBufferDynamic = 9,
    InputAttachment = 10,
    InlineUniformBlockEXT = 1000138000,
    AccelerationStructureKHR = 1000150000,
    AccelerationStructureNV = 1000165000,
    MutableVALVE = 1000351000,
};
enum class DynamicState : uint32_t {
    Viewport = 0,
    Scissor = 1,
    LineWidth = 2,
    DepthBias = 3,
    BlendConstants = 4,
    DepthBounds = 5,
    StencilCompareMask = 6,
    StencilWriteMask = 7,
    StencilReference = 8,
    ViewportWScalingNV = 1000087000,
    DiscardRectangleEXT = 1000099000,
    SampleLocationsEXT = 1000143000,
    RayTracingPipelineStackSizeKHR = 1000347000,
    ViewportShadingRatePaletteNV = 1000164004,
    ViewportCoarseSampleOrderNV = 1000164006,
    ExclusiveScissorNV = 1000205001,
    FragmentShadingRateKHR = 1000226000,
    LineStippleEXT = 1000259000,
    CullModeEXT = 1000267000,
    FrontFaceEXT = 1000267001,
    PrimitiveTopologyEXT = 1000267002,
    ViewportWithCountEXT = 1000267003,
    ScissorWithCountEXT = 1000267004,
    VertexInputBindingStrideEXT = 1000267005,
    DepthTestEnableEXT = 1000267006,
    DepthWriteEnableEXT = 1000267007,
    DepthCompareOpEXT = 1000267008,
    DepthBoundsTestEnableEXT = 1000267009,
    StencilTestEnableEXT = 1000267010,
    StencilOpEXT = 1000267011,
    VertexInputEXT = 1000352000,
    PatchControlPointsEXT = 1000377000,
    RasterizerDiscardEnableEXT = 1000377001,
    DepthBiasEnableEXT = 1000377002,
    LogicOpEXT = 1000377003,
    PrimitiveRestartEnableEXT = 1000377004,
    ColorWriteEnableEXT = 1000381000,
};
enum class PolygonMode : uint32_t {
    Fill = 0,
    Line = 1,
    Point = 2,
    FillRectangleNV = 1000153000,
};
enum class Format : uint32_t {
    Undefined = 0,
    R4G4UnormPack8 = 1,
    R4G4B4A4UnormPack16 = 2,
    B4G4R4A4UnormPack16 = 3,
    R5G6B5UnormPack16 = 4,
    B5G6R5UnormPack16 = 5,
    R5G5B5A1UnormPack16 = 6,
    B5G5R5A1UnormPack16 = 7,
    A1R5G5B5UnormPack16 = 8,
    R8Unorm = 9,
    R8Snorm = 10,
    R8Uscaled = 11,
    R8Sscaled = 12,
    R8Uint = 13,
    R8Sint = 14,
    R8Srgb = 15,
    R8G8Unorm = 16,
    R8G8Snorm = 17,
    R8G8Uscaled = 18,
    R8G8Sscaled = 19,
    R8G8Uint = 20,
    R8G8Sint = 21,
    R8G8Srgb = 22,
    R8G8B8Unorm = 23,
    R8G8B8Snorm = 24,
    R8G8B8Uscaled = 25,
    R8G8B8Sscaled = 26,
    R8G8B8Uint = 27,
    R8G8B8Sint = 28,
    R8G8B8Srgb = 29,
    B8G8R8Unorm = 30,
    B8G8R8Snorm = 31,
    B8G8R8Uscaled = 32,
    B8G8R8Sscaled = 33,
    B8G8R8Uint = 34,
    B8G8R8Sint = 35,
    B8G8R8Srgb = 36,
    R8G8B8A8Unorm = 37,
    R8G8B8A8Snorm = 38,
    R8G8B8A8Uscaled = 39,
    R8G8B8A8Sscaled = 40,
    R8G8B8A8Uint = 41,
    R8G8B8A8Sint = 42,
    R8G8B8A8Srgb = 43,
    B8G8R8A8Unorm = 44,
    B8G8R8A8Snorm = 45,
    B8G8R8A8Uscaled = 46,
    B8G8R8A8Sscaled = 47,
    B8G8R8A8Uint = 48,
    B8G8R8A8Sint = 49,
    B8G8R8A8Srgb = 50,
    A8B8G8R8UnormPack32 = 51,
    A8B8G8R8SnormPack32 = 52,
    A8B8G8R8UscaledPack32 = 53,
    A8B8G8R8SscaledPack32 = 54,
    A8B8G8R8UintPack32 = 55,
    A8B8G8R8SintPack32 = 56,
    A8B8G8R8SrgbPack32 = 57,
    A2R10G10B10UnormPack32 = 58,
    A2R10G10B10SnormPack32 = 59,
    A2R10G10B10UscaledPack32 = 60,
    A2R10G10B10SscaledPack32 = 61,
    A2R10G10B10UintPack32 = 62,
    A2R10G10B10SintPack32 = 63,
    A2B10G10R10UnormPack32 = 64,
    A2B10G10R10SnormPack32 = 65,
    A2B10G10R10UscaledPack32 = 66,
    A2B10G10R10SscaledPack32 = 67,
    A2B10G10R10UintPack32 = 68,
    A2B10G10R10SintPack32 = 69,
    R16Unorm = 70,
    R16Snorm = 71,
    R16Uscaled = 72,
    R16Sscaled = 73,
    R16Uint = 74,
    R16Sint = 75,
    R16Sfloat = 76,
    R16G16Unorm = 77,
    R16G16Snorm = 78,
    R16G16Uscaled = 79,
    R16G16Sscaled = 80,
    R16G16Uint = 81,
    R16G16Sint = 82,
    R16G16Sfloat = 83,
    R16G16B16Unorm = 84,
    R16G16B16Snorm = 85,
    R16G16B16Uscaled = 86,
    R16G16B16Sscaled = 87,
    R16G16B16Uint = 88,
    R16G16B16Sint = 89,
    R16G16B16Sfloat = 90,
    R16G16B16A16Unorm = 91,
    R16G16B16A16Snorm = 92,
    R16G16B16A16Uscaled = 93,
    R16G16B16A16Sscaled = 94,
    R16G16B16A16Uint = 95,
    R16G16B16A16Sint = 96,
    R16G16B16A16Sfloat = 97,
    R32Uint = 98,
    R32Sint = 99,
    R32Sfloat = 100,
    R32G32Uint = 101,
    R32G32Sint = 102,
    R32G32Sfloat = 103,
    R32G32B32Uint = 104,
    R32G32B32Sint = 105,
    R32G32B32Sfloat = 106,
    R32G32B32A32Uint = 107,
    R32G32B32A32Sint = 108,
    R32G32B32A32Sfloat = 109,
    R64Uint = 110,
    R64Sint = 111,
    R64Sfloat = 112,
    R64G64Uint = 113,
    R64G64Sint = 114,
    R64G64Sfloat = 115,
    R64G64B64Uint = 116,
    R64G64B64Sint = 117,
    R64G64B64Sfloat = 118,
    R64G64B64A64Uint = 119,
    R64G64B64A64Sint = 120,
    R64G64B64A64Sfloat = 121,
    B10G11R11UfloatPack32 = 122,
    E5B9G9R9UfloatPack32 = 123,
    D16Unorm = 124,
    X8D24UnormPack32 = 125,
    D32Sfloat = 126,
    S8Uint = 127,
    D16UnormS8Uint = 128,
    D24UnormS8Uint = 129,
    D32SfloatS8Uint = 130,
    Bc1RgbUnormBlock = 131,
    Bc1RgbSrgbBlock = 132,
    Bc1RgbaUnormBlock = 133,
    Bc1RgbaSrgbBlock = 134,
    Bc2UnormBlock = 135,
    Bc2SrgbBlock = 136,
    Bc3UnormBlock = 137,
    Bc3SrgbBlock = 138,
    Bc4UnormBlock = 139,
    Bc4SnormBlock = 140,
    Bc5UnormBlock = 141,
    Bc5SnormBlock = 142,
    Bc6HUfloatBlock = 143,
    Bc6HSfloatBlock = 144,
    Bc7UnormBlock = 145,
    Bc7SrgbBlock = 146,
    Etc2R8G8B8UnormBlock = 147,
    Etc2R8G8B8SrgbBlock = 148,
    Etc2R8G8B8A1UnormBlock = 149,
    Etc2R8G8B8A1SrgbBlock = 150,
    Etc2R8G8B8A8UnormBlock = 151,
    Etc2R8G8B8A8SrgbBlock = 152,
    EacR11UnormBlock = 153,
    EacR11SnormBlock = 154,
    EacR11G11UnormBlock = 155,
    EacR11G11SnormBlock = 156,
    Astc4X4UnormBlock = 157,
    Astc4X4SrgbBlock = 158,
    Astc5X4UnormBlock = 159,
    Astc5X4SrgbBlock = 160,
    Astc5X5UnormBlock = 161,
    Astc5X5SrgbBlock = 162,
    Astc6X5UnormBlock = 163,
    Astc6X5SrgbBlock = 164,
    Astc6X6UnormBlock = 165,
    Astc6X6SrgbBlock = 166,
    Astc8X5UnormBlock = 167,
    Astc8X5SrgbBlock = 168,
    Astc8X6UnormBlock = 169,
    Astc8X6SrgbBlock = 170,
    Astc8X8UnormBlock = 171,
    Astc8X8SrgbBlock = 172,
    Astc10X5UnormBlock = 173,
    Astc10X5SrgbBlock = 174,
    Astc10X6UnormBlock = 175,
    Astc10X6SrgbBlock = 176,
    Astc10X8UnormBlock = 177,
    Astc10X8SrgbBlock = 178,
    Astc10X10UnormBlock = 179,
    Astc10X10SrgbBlock = 180,
    Astc12X10UnormBlock = 181,
    Astc12X10SrgbBlock = 182,
    Astc12X12UnormBlock = 183,
    Astc12X12SrgbBlock = 184,
    Pvrtc12BppUnormBlockIMG = 1000054000,
    Pvrtc14BppUnormBlockIMG = 1000054001,
    Pvrtc22BppUnormBlockIMG = 1000054002,
    Pvrtc24BppUnormBlockIMG = 1000054003,
    Pvrtc12BppSrgbBlockIMG = 1000054004,
    Pvrtc14BppSrgbBlockIMG = 1000054005,
    Pvrtc22BppSrgbBlockIMG = 1000054006,
    Pvrtc24BppSrgbBlockIMG = 1000054007,
    Astc4X4SfloatBlockEXT = 1000066000,
    Astc5X4SfloatBlockEXT = 1000066001,
    Astc5X5SfloatBlockEXT = 1000066002,
    Astc6X5SfloatBlockEXT = 1000066003,
    Astc6X6SfloatBlockEXT = 1000066004,
    Astc8X5SfloatBlockEXT = 1000066005,
    Astc8X6SfloatBlockEXT = 1000066006,
    Astc8X8SfloatBlockEXT = 1000066007,
    Astc10X5SfloatBlockEXT = 1000066008,
    Astc10X6SfloatBlockEXT = 1000066009,
    Astc10X8SfloatBlockEXT = 1000066010,
    Astc10X10SfloatBlockEXT = 1000066011,
    Astc12X10SfloatBlockEXT = 1000066012,
    Astc12X12SfloatBlockEXT = 1000066013,
    G8B8R82Plane444UnormEXT = 1000330000,
    G10X6B10X6R10X62Plane444Unorm3Pack16EXT = 1000330001,
    G12X4B12X4R12X42Plane444Unorm3Pack16EXT = 1000330002,
    G16B16R162Plane444UnormEXT = 1000330003,
    A4R4G4B4UnormPack16EXT = 1000340000,
    A4B4G4R4UnormPack16EXT = 1000340001,
    G8B8G8R8422Unorm = 1000156000,
    B8G8R8G8422Unorm = 1000156001,
    G8B8R83Plane420Unorm = 1000156002,
    G8B8R82Plane420Unorm = 1000156003,
    G8B8R83Plane422Unorm = 1000156004,
    G8B8R82Plane422Unorm = 1000156005,
    G8B8R83Plane444Unorm = 1000156006,
    R10X6UnormPack16 = 1000156007,
    R10X6G10X6Unorm2Pack16 = 1000156008,
    R10X6G10X6B10X6A10X6Unorm4Pack16 = 1000156009,
    G10X6B10X6G10X6R10X6422Unorm4Pack16 = 1000156010,
    B10X6G10X6R10X6G10X6422Unorm4Pack16 = 1000156011,
    G10X6B10X6R10X63Plane420Unorm3Pack16 = 1000156012,
    G10X6B10X6R10X62Plane420Unorm3Pack16 = 1000156013,
    G10X6B10X6R10X63Plane422Unorm3Pack16 = 1000156014,
    G10X6B10X6R10X62Plane422Unorm3Pack16 = 1000156015,
    G10X6B10X6R10X63Plane444Unorm3Pack16 = 1000156016,
    R12X4UnormPack16 = 1000156017,
    R12X4G12X4Unorm2Pack16 = 1000156018,
    R12X4G12X4B12X4A12X4Unorm4Pack16 = 1000156019,
    G12X4B12X4G12X4R12X4422Unorm4Pack16 = 1000156020,
    B12X4G12X4R12X4G12X4422Unorm4Pack16 = 1000156021,
    G12X4B12X4R12X43Plane420Unorm3Pack16 = 1000156022,
    G12X4B12X4R12X42Plane420Unorm3Pack16 = 1000156023,
    G12X4B12X4R12X43Plane422Unorm3Pack16 = 1000156024,
    G12X4B12X4R12X42Plane422Unorm3Pack16 = 1000156025,
    G12X4B12X4R12X43Plane444Unorm3Pack16 = 1000156026,
    G16B16G16R16422Unorm = 1000156027,
    B16G16R16G16422Unorm = 1000156028,
    G16B16R163Plane420Unorm = 1000156029,
    G16B16R162Plane420Unorm = 1000156030,
    G16B16R163Plane422Unorm = 1000156031,
    G16B16R162Plane422Unorm = 1000156032,
    G16B16R163Plane444Unorm = 1000156033,
};
enum class FrontFace : uint32_t {
    CounterClockwise = 0,
    Clockwise = 1,
};
enum class ImageLayout : uint32_t {
    Undefined = 0,
    General = 1,
    ColorAttachmentOptimal = 2,
    DepthStencilAttachmentOptimal = 3,
    DepthStencilReadOnlyOptimal = 4,
    ShaderReadOnlyOptimal = 5,
    TransferSrcOptimal = 6,
    TransferDstOptimal = 7,
    Preinitialized = 8,
    PresentSrcKHR = 1000001002,
    VideoDecodeDstKHR = 1000024000,
    VideoDecodeSrcKHR = 1000024001,
    VideoDecodeDpbKHR = 1000024002,
    VideoEncodeDstKHR = 1000299000,
    VideoEncodeSrcKHR = 1000299001,
    VideoEncodeDpbKHR = 1000299002,
    SharedPresentKHR = 1000111000,
    ShadingRateOptimalNV = 1000164003,
    FragmentDensityMapOptimalEXT = 1000218000,
    ReadOnlyOptimalKHR = 1000314000,
    AttachmentOptimalKHR = 1000314001,
    DepthReadOnlyStencilAttachmentOptimal = 1000117000,
    DepthAttachmentStencilReadOnlyOptimal = 1000117001,
    DepthAttachmentOptimal = 1000241000,
    DepthReadOnlyOptimal = 1000241001,
    StencilAttachmentOptimal = 1000241002,
    StencilReadOnlyOptimal = 1000241003,
};
enum class ImageTiling : uint32_t {
    Optimal = 0,
    Linear = 1,
    DrmFormatModifierEXT = 1000158000,
};
enum class ImageType : uint32_t {
    e1D = 0,
    e2D = 1,
    e3D = 2,
};
enum class ImageViewType : uint32_t {
    e1D = 0,
    e2D = 1,
    e3D = 2,
    Cube = 3,
    e1DArray = 4,
    e2DArray = 5,
    CubeArray = 6,
};
enum class SharingMode : uint32_t {
    Exclusive = 0,
    Concurrent = 1,
};
enum class IndexType : uint32_t {
    Uint16 = 0,
    Uint32 = 1,
    NoneKHR = 1000165000,
    Uint8EXT = 1000265000,
};
enum class LogicOp : uint32_t {
    Clear = 0,
    And = 1,
    AndReverse = 2,
    Copy = 3,
    AndInverted = 4,
    NoOp = 5,
    Xor = 6,
    Or = 7,
    Nor = 8,
    Equivalent = 9,
    Invert = 10,
    OrReverse = 11,
    CopyInverted = 12,
    OrInverted = 13,
    Nand = 14,
    Set = 15,
};
enum class PhysicalDeviceType : uint32_t {
    Other = 0,
    IntegratedGpu = 1,
    DiscreteGpu = 2,
    VirtualGpu = 3,
    Cpu = 4,
};
enum class PipelineBindPoint : uint32_t {
    Graphics = 0,
    Compute = 1,
    RayTracingKHR = 1000165000,
};
enum class PrimitiveTopology : uint32_t {
    PointList = 0,
    LineList = 1,
    LineStrip = 2,
    TriangleList = 3,
    TriangleStrip = 4,
    TriangleFan = 5,
    LineListWithAdjacency = 6,
    LineStripWithAdjacency = 7,
    TriangleListWithAdjacency = 8,
    TriangleStripWithAdjacency = 9,
    PatchList = 10,
};
enum class QueryType : uint32_t {
    Occlusion = 0,
    PipelineStatistics = 1,
    Timestamp = 2,
    ResultStatusOnlyKHR = 1000023000,
    VideoEncodeBitstreamBufferRangeKHR = 1000299000,
    TransformFeedbackStreamEXT = 1000028004,
    PerformanceQueryKHR = 1000116000,
    AccelerationStructureCompactedSizeKHR = 1000150000,
    AccelerationStructureSerializationSizeKHR = 1000150001,
    AccelerationStructureCompactedSizeNV = 1000165000,
    PerformanceQueryINTEL = 1000210000,
};
enum class SubpassContents : uint32_t {
    Inline = 0,
    SecondaryCommandBuffers = 1,
};
enum class Result : int32_t {
    Success = 0,
    NotReady = 1,
    Timeout = 2,
    EventSet = 3,
    EventReset = 4,
    Incomplete = 5,
    ErrorOutOfHostMemory = -1,
    ErrorOutOfDeviceMemory = -2,
    ErrorInitializationFailed = -3,
    ErrorDeviceLost = -4,
    ErrorMemoryMapFailed = -5,
    ErrorLayerNotPresent = -6,
    ErrorExtensionNotPresent = -7,
    ErrorFeatureNotPresent = -8,
    ErrorIncompatibleDriver = -9,
    ErrorTooManyObjects = -10,
    ErrorFormatNotSupported = -11,
    ErrorFragmentedPool = -12,
    ErrorUnknown = -13,
    ErrorSurfaceLostKHR = -1000000000,
    ErrorNativeWindowInUseKHR = -1000000001,
    SuboptimalKHR = 1000001003,
    ErrorOutOfDateKHR = -1000001004,
    ErrorIncompatibleDisplayKHR = -1000003001,
    ErrorValidationFailedEXT = -1000011001,
    ErrorInvalidShaderNV = -1000012000,
    ErrorInvalidDrmFormatModifierPlaneLayoutEXT = -1000158000,
    ErrorNotPermittedEXT = -1000174001,
    ErrorFullScreenExclusiveModeLostEXT = -1000255000,
    ThreadIdleKHR = 1000268000,
    ThreadDoneKHR = 1000268001,
    OperationDeferredKHR = 1000268002,
    OperationNotDeferredKHR = 1000268003,
    PipelineCompileRequiredEXT = 1000297000,
    ErrorOutOfPoolMemory = -1000069000,
    ErrorInvalidExternalHandle = -1000072003,
    ErrorFragmentation = -1000161000,
    ErrorInvalidOpaqueCaptureAddress = -1000257000,
};
enum class StencilOp : uint32_t {
    Keep = 0,
    Zero = 1,
    Replace = 2,
    IncrementAndClamp = 3,
    DecrementAndClamp = 4,
    Invert = 5,
    IncrementAndWrap = 6,
    DecrementAndWrap = 7,
};
enum class StructureType : uint32_t {
    ApplicationInfo = 0,
    InstanceCreateInfo = 1,
    DeviceQueueCreateInfo = 2,
    DeviceCreateInfo = 3,
    SubmitInfo = 4,
    MemoryAllocateInfo = 5,
    MappedMemoryRange = 6,
    BindSparseInfo = 7,
    FenceCreateInfo = 8,
    SemaphoreCreateInfo = 9,
    EventCreateInfo = 10,
    QueryPoolCreateInfo = 11,
    BufferCreateInfo = 12,
    BufferViewCreateInfo = 13,
    ImageCreateInfo = 14,
    ImageViewCreateInfo = 15,
    ShaderModuleCreateInfo = 16,
    PipelineCacheCreateInfo = 17,
    PipelineShaderStageCreateInfo = 18,
    PipelineVertexInputStateCreateInfo = 19,
    PipelineInputAssemblyStateCreateInfo = 20,
    PipelineTessellationStateCreateInfo = 21,
    PipelineViewportStateCreateInfo = 22,
    PipelineRasterizationStateCreateInfo = 23,
    PipelineMultisampleStateCreateInfo = 24,
    PipelineDepthStencilStateCreateInfo = 25,
    PipelineColorBlendStateCreateInfo = 26,
    PipelineDynamicStateCreateInfo = 27,
    GraphicsPipelineCreateInfo = 28,
    ComputePipelineCreateInfo = 29,
    PipelineLayoutCreateInfo = 30,
    SamplerCreateInfo = 31,
    DescriptorSetLayoutCreateInfo = 32,
    DescriptorPoolCreateInfo = 33,
    DescriptorSetAllocateInfo = 34,
    WriteDescriptorSet = 35,
    CopyDescriptorSet = 36,
    FramebufferCreateInfo = 37,
    RenderPassCreateInfo = 38,
    CommandPoolCreateInfo = 39,
    CommandBufferAllocateInfo = 40,
    CommandBufferInheritanceInfo = 41,
    CommandBufferBeginInfo = 42,
    RenderPassBeginInfo = 43,
    BufferMemoryBarrier = 44,
    ImageMemoryBarrier = 45,
    MemoryBarrier = 46,
    LoaderInstanceCreateInfo = 47,
    LoaderDeviceCreateInfo = 48,
    SwapchainCreateInfoKHR = 1000001000,
    PresentInfoKHR = 1000001001,
    DeviceGroupPresentCapabilitiesKHR = 1000060007,
    ImageSwapchainCreateInfoKHR = 1000060008,
    BindImageMemorySwapchainInfoKHR = 1000060009,
    AcquireNextImageInfoKHR = 1000060010,
    DeviceGroupPresentInfoKHR = 1000060011,
    DeviceGroupSwapchainCreateInfoKHR = 1000060012,
    DisplayModeCreateInfoKHR = 1000002000,
    DisplaySurfaceCreateInfoKHR = 1000002001,
    DisplayPresentInfoKHR = 1000003000,
    XlibSurfaceCreateInfoKHR = 1000004000,
    XcbSurfaceCreateInfoKHR = 1000005000,
    WaylandSurfaceCreateInfoKHR = 1000006000,
    AndroidSurfaceCreateInfoKHR = 1000008000,
    Win32SurfaceCreateInfoKHR = 1000009000,
    DebugReportCallbackCreateInfoEXT = 1000011000,
    PipelineRasterizationStateRasterizationOrderAMD = 1000018000,
    DebugMarkerObjectNameInfoEXT = 1000022000,
    DebugMarkerObjectTagInfoEXT = 1000022001,
    DebugMarkerMarkerInfoEXT = 1000022002,
    VideoProfileKHR = 1000023000,
    VideoCapabilitiesKHR = 1000023001,
    VideoPictureResourceKHR = 1000023002,
    VideoGetMemoryPropertiesKHR = 1000023003,
    VideoBindMemoryKHR = 1000023004,
    VideoSessionCreateInfoKHR = 1000023005,
    VideoSessionParametersCreateInfoKHR = 1000023006,
    VideoSessionParametersUpdateInfoKHR = 1000023007,
    VideoBeginCodingInfoKHR = 1000023008,
    VideoEndCodingInfoKHR = 1000023009,
    VideoCodingControlInfoKHR = 1000023010,
    VideoReferenceSlotKHR = 1000023011,
    VideoQueueFamilyProperties2KHR = 1000023012,
    VideoProfilesKHR = 1000023013,
    PhysicalDeviceVideoFormatInfoKHR = 1000023014,
    VideoFormatPropertiesKHR = 1000023015,
    VideoDecodeInfoKHR = 1000024000,
    VideoEncodeInfoKHR = 1000299000,
    VideoEncodeRateControlInfoKHR = 1000299001,
    DedicatedAllocationImageCreateInfoNV = 1000026000,
    DedicatedAllocationBufferCreateInfoNV = 1000026001,
    DedicatedAllocationMemoryAllocateInfoNV = 1000026002,
    PhysicalDeviceTransformFeedbackFeaturesEXT = 1000028000,
    PhysicalDeviceTransformFeedbackPropertiesEXT = 1000028001,
    PipelineRasterizationStateStreamCreateInfoEXT = 1000028002,
    ImageViewHandleInfoNVX = 1000030000,
    ImageViewAddressPropertiesNVX = 1000030001,
    VideoEncodeH264CapabilitiesEXT = 1000038000,
    VideoEncodeH264SessionCreateInfoEXT = 1000038001,
    VideoEncodeH264SessionParametersCreateInfoEXT = 1000038002,
    VideoEncodeH264SessionParametersAddInfoEXT = 1000038003,
    VideoEncodeH264VclFrameInfoEXT = 1000038004,
    VideoEncodeH264DpbSlotInfoEXT = 1000038005,
    VideoEncodeH264NaluSliceEXT = 1000038006,
    VideoEncodeH264EmitPictureParametersEXT = 1000038007,
    VideoEncodeH264ProfileEXT = 1000038008,
    VideoDecodeH264CapabilitiesEXT = 1000040000,
    VideoDecodeH264SessionCreateInfoEXT = 1000040001,
    VideoDecodeH264PictureInfoEXT = 1000040002,
    VideoDecodeH264MvcEXT = 1000040003,
    VideoDecodeH264ProfileEXT = 1000040004,
    VideoDecodeH264SessionParametersCreateInfoEXT = 1000040005,
    VideoDecodeH264SessionParametersAddInfoEXT = 1000040006,
    VideoDecodeH264DpbSlotInfoEXT = 1000040007,
    TextureLodGatherFormatPropertiesAMD = 1000041000,
    StreamDescriptorSurfaceCreateInfoGGP = 1000049000,
    PhysicalDeviceCornerSampledImageFeaturesNV = 1000050000,
    ExternalMemoryImageCreateInfoNV = 1000056000,
    ExportMemoryAllocateInfoNV = 1000056001,
    ImportMemoryWin32HandleInfoNV = 1000057000,
    ExportMemoryWin32HandleInfoNV = 1000057001,
    Win32KeyedMutexAcquireReleaseInfoNV = 1000058000,
    ValidationFlagsEXT = 1000061000,
    ViSurfaceCreateInfoNN = 1000062000,
    PhysicalDeviceTextureCompressionAstcHdrFeaturesEXT = 1000066000,
    ImageViewAstcDecodeModeEXT = 1000067000,
    PhysicalDeviceAstcDecodeFeaturesEXT = 1000067001,
    ImportMemoryWin32HandleInfoKHR = 1000073000,
    ExportMemoryWin32HandleInfoKHR = 1000073001,
    MemoryWin32HandlePropertiesKHR = 1000073002,
    MemoryGetWin32HandleInfoKHR = 1000073003,
    ImportMemoryFdInfoKHR = 1000074000,
    MemoryFdPropertiesKHR = 1000074001,
    MemoryGetFdInfoKHR = 1000074002,
    Win32KeyedMutexAcquireReleaseInfoKHR = 1000075000,
    ImportSemaphoreWin32HandleInfoKHR = 1000078000,
    ExportSemaphoreWin32HandleInfoKHR = 1000078001,
    D3D12FenceSubmitInfoKHR = 1000078002,
    SemaphoreGetWin32HandleInfoKHR = 1000078003,
    ImportSemaphoreFdInfoKHR = 1000079000,
    SemaphoreGetFdInfoKHR = 1000079001,
    PhysicalDevicePushDescriptorPropertiesKHR = 1000080000,
    CommandBufferInheritanceConditionalRenderingInfoEXT = 1000081000,
    PhysicalDeviceConditionalRenderingFeaturesEXT = 1000081001,
    ConditionalRenderingBeginInfoEXT = 1000081002,
    PresentRegionsKHR = 1000084000,
    PipelineViewportWScalingStateCreateInfoNV = 1000087000,
    SurfaceCapabilities2EXT = 1000090000,
    DisplayPowerInfoEXT = 1000091000,
    DeviceEventInfoEXT = 1000091001,
    DisplayEventInfoEXT = 1000091002,
    SwapchainCounterCreateInfoEXT = 1000091003,
    PresentTimesInfoGOOGLE = 1000092000,
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = 1000097000,
    PipelineViewportSwizzleStateCreateInfoNV = 1000098000,
    PhysicalDeviceDiscardRectanglePropertiesEXT = 1000099000,
    PipelineDiscardRectangleStateCreateInfoEXT = 1000099001,
    PhysicalDeviceConservativeRasterizationPropertiesEXT = 1000101000,
    PipelineRasterizationConservativeStateCreateInfoEXT = 1000101001,
    PhysicalDeviceDepthClipEnableFeaturesEXT = 1000102000,
    PipelineRasterizationDepthClipStateCreateInfoEXT = 1000102001,
    HdrMetadataEXT = 1000105000,
    SharedPresentSurfaceCapabilitiesKHR = 1000111000,
    ImportFenceWin32HandleInfoKHR = 1000114000,
    ExportFenceWin32HandleInfoKHR = 1000114001,
    FenceGetWin32HandleInfoKHR = 1000114002,
    ImportFenceFdInfoKHR = 1000115000,
    FenceGetFdInfoKHR = 1000115001,
    PhysicalDevicePerformanceQueryFeaturesKHR = 1000116000,
    PhysicalDevicePerformanceQueryPropertiesKHR = 1000116001,
    QueryPoolPerformanceCreateInfoKHR = 1000116002,
    PerformanceQuerySubmitInfoKHR = 1000116003,
    AcquireProfilingLockInfoKHR = 1000116004,
    PerformanceCounterKHR = 1000116005,
    PerformanceCounterDescriptionKHR = 1000116006,
    PhysicalDeviceSurfaceInfo2KHR = 1000119000,
    SurfaceCapabilities2KHR = 1000119001,
    SurfaceFormat2KHR = 1000119002,
    DisplayProperties2KHR = 1000121000,
    DisplayPlaneProperties2KHR = 1000121001,
    DisplayModeProperties2KHR = 1000121002,
    DisplayPlaneInfo2KHR = 1000121003,
    DisplayPlaneCapabilities2KHR = 1000121004,
    IosSurfaceCreateInfoMVK = 1000122000,
    MacosSurfaceCreateInfoMVK = 1000123000,
    DebugUtilsObjectNameInfoEXT = 1000128000,
    DebugUtilsObjectTagInfoEXT = 1000128001,
    DebugUtilsLabelEXT = 1000128002,
    DebugUtilsMessengerCallbackDataEXT = 1000128003,
    DebugUtilsMessengerCreateInfoEXT = 1000128004,
    AndroidHardwareBufferUsageANDROID = 1000129000,
    AndroidHardwareBufferPropertiesANDROID = 1000129001,
    AndroidHardwareBufferFormatPropertiesANDROID = 1000129002,
    ImportAndroidHardwareBufferInfoANDROID = 1000129003,
    MemoryGetAndroidHardwareBufferInfoANDROID = 1000129004,
    ExternalFormatANDROID = 1000129005,
    PhysicalDeviceInlineUniformBlockFeaturesEXT = 1000138000,
    PhysicalDeviceInlineUniformBlockPropertiesEXT = 1000138001,
    WriteDescriptorSetInlineUniformBlockEXT = 1000138002,
    DescriptorPoolInlineUniformBlockCreateInfoEXT = 1000138003,
    SampleLocationsInfoEXT = 1000143000,
    RenderPassSampleLocationsBeginInfoEXT = 1000143001,
    PipelineSampleLocationsStateCreateInfoEXT = 1000143002,
    PhysicalDeviceSampleLocationsPropertiesEXT = 1000143003,
    MultisamplePropertiesEXT = 1000143004,
    PhysicalDeviceBlendOperationAdvancedFeaturesEXT = 1000148000,
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT = 1000148001,
    PipelineColorBlendAdvancedStateCreateInfoEXT = 1000148002,
    PipelineCoverageToColorStateCreateInfoNV = 1000149000,
    WriteDescriptorSetAccelerationStructureKHR = 1000150007,
    AccelerationStructureBuildGeometryInfoKHR = 1000150000,
    AccelerationStructureDeviceAddressInfoKHR = 1000150002,
    AccelerationStructureGeometryAabbsDataKHR = 1000150003,
    AccelerationStructureGeometryInstancesDataKHR = 1000150004,
    AccelerationStructureGeometryTrianglesDataKHR = 1000150005,
    AccelerationStructureGeometryKHR = 1000150006,
    AccelerationStructureVersionInfoKHR = 1000150009,
    CopyAccelerationStructureInfoKHR = 1000150010,
    CopyAccelerationStructureToMemoryInfoKHR = 1000150011,
    CopyMemoryToAccelerationStructureInfoKHR = 1000150012,
    PhysicalDeviceAccelerationStructureFeaturesKHR = 1000150013,
    PhysicalDeviceAccelerationStructurePropertiesKHR = 1000150014,
    AccelerationStructureCreateInfoKHR = 1000150017,
    AccelerationStructureBuildSizesInfoKHR = 1000150020,
    PhysicalDeviceRayTracingPipelineFeaturesKHR = 1000347000,
    PhysicalDeviceRayTracingPipelinePropertiesKHR = 1000347001,
    RayTracingPipelineCreateInfoKHR = 1000150015,
    RayTracingShaderGroupCreateInfoKHR = 1000150016,
    RayTracingPipelineInterfaceCreateInfoKHR = 1000150018,
    PhysicalDeviceRayQueryFeaturesKHR = 1000348013,
    PipelineCoverageModulationStateCreateInfoNV = 1000152000,
    PhysicalDeviceShaderSmBuiltinsFeaturesNV = 1000154000,
    PhysicalDeviceShaderSmBuiltinsPropertiesNV = 1000154001,
    DrmFormatModifierPropertiesListEXT = 1000158000,
    PhysicalDeviceImageDrmFormatModifierInfoEXT = 1000158002,
    ImageDrmFormatModifierListCreateInfoEXT = 1000158003,
    ImageDrmFormatModifierExplicitCreateInfoEXT = 1000158004,
    ImageDrmFormatModifierPropertiesEXT = 1000158005,
    ValidationCacheCreateInfoEXT = 1000160000,
    ShaderModuleValidationCacheCreateInfoEXT = 1000160001,
    PhysicalDevicePortabilitySubsetFeaturesKHR = 1000163000,
    PhysicalDevicePortabilitySubsetPropertiesKHR = 1000163001,
    PipelineViewportShadingRateImageStateCreateInfoNV = 1000164000,
    PhysicalDeviceShadingRateImageFeaturesNV = 1000164001,
    PhysicalDeviceShadingRateImagePropertiesNV = 1000164002,
    PipelineViewportCoarseSampleOrderStateCreateInfoNV = 1000164005,
    RayTracingPipelineCreateInfoNV = 1000165000,
    AccelerationStructureCreateInfoNV = 1000165001,
    GeometryNV = 1000165003,
    GeometryTrianglesNV = 1000165004,
    GeometryAabbNV = 1000165005,
    BindAccelerationStructureMemoryInfoNV = 1000165006,
    WriteDescriptorSetAccelerationStructureNV = 1000165007,
    AccelerationStructureMemoryRequirementsInfoNV = 1000165008,
    PhysicalDeviceRayTracingPropertiesNV = 1000165009,
    RayTracingShaderGroupCreateInfoNV = 1000165011,
    AccelerationStructureInfoNV = 1000165012,
    PhysicalDeviceRepresentativeFragmentTestFeaturesNV = 1000166000,
    PipelineRepresentativeFragmentTestStateCreateInfoNV = 1000166001,
    PhysicalDeviceImageViewImageFormatInfoEXT = 1000170000,
    FilterCubicImageViewImageFormatPropertiesEXT = 1000170001,
    DeviceQueueGlobalPriorityCreateInfoEXT = 1000174000,
    ImportMemoryHostPointerInfoEXT = 1000178000,
    MemoryHostPointerPropertiesEXT = 1000178001,
    PhysicalDeviceExternalMemoryHostPropertiesEXT = 1000178002,
    PhysicalDeviceShaderClockFeaturesKHR = 1000181000,
    PipelineCompilerControlCreateInfoAMD = 1000183000,
    CalibratedTimestampInfoEXT = 1000184000,
    PhysicalDeviceShaderCorePropertiesAMD = 1000185000,
    VideoDecodeH265CapabilitiesEXT = 1000187000,
    VideoDecodeH265SessionCreateInfoEXT = 1000187001,
    VideoDecodeH265SessionParametersCreateInfoEXT = 1000187002,
    VideoDecodeH265SessionParametersAddInfoEXT = 1000187003,
    VideoDecodeH265ProfileEXT = 1000187004,
    VideoDecodeH265PictureInfoEXT = 1000187005,
    VideoDecodeH265DpbSlotInfoEXT = 1000187006,
    DeviceMemoryOverallocationCreateInfoAMD = 1000189000,
    PhysicalDeviceVertexAttributeDivisorPropertiesEXT = 1000190000,
    PipelineVertexInputDivisorStateCreateInfoEXT = 1000190001,
    PhysicalDeviceVertexAttributeDivisorFeaturesEXT = 1000190002,
    PresentFrameTokenGGP = 1000191000,
    PipelineCreationFeedbackCreateInfoEXT = 1000192000,
    PhysicalDeviceComputeShaderDerivativesFeaturesNV = 1000201000,
    PhysicalDeviceMeshShaderFeaturesNV = 1000202000,
    PhysicalDeviceMeshShaderPropertiesNV = 1000202001,
    PhysicalDeviceFragmentShaderBarycentricFeaturesNV = 1000203000,
    PhysicalDeviceShaderImageFootprintFeaturesNV = 1000204000,
    PipelineViewportExclusiveScissorStateCreateInfoNV = 1000205000,
    PhysicalDeviceExclusiveScissorFeaturesNV = 1000205002,
    CheckpointDataNV = 1000206000,
    QueueFamilyCheckpointPropertiesNV = 1000206001,
    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = 1000209000,
    QueryPoolPerformanceQueryCreateInfoINTEL = 1000210000,
    InitializePerformanceApiInfoINTEL = 1000210001,
    PerformanceMarkerInfoINTEL = 1000210002,
    PerformanceStreamMarkerInfoINTEL = 1000210003,
    PerformanceOverrideInfoINTEL = 1000210004,
    PerformanceConfigurationAcquireInfoINTEL = 1000210005,
    PhysicalDevicePciBusInfoPropertiesEXT = 1000212000,
    DisplayNativeHdrSurfaceCapabilitiesAMD = 1000213000,
    SwapchainDisplayNativeHdrCreateInfoAMD = 1000213001,
    ImagepipeSurfaceCreateInfoFUCHSIA = 1000214000,
    PhysicalDeviceShaderTerminateInvocationFeaturesKHR = 1000215000,
    MetalSurfaceCreateInfoEXT = 1000217000,
    PhysicalDeviceFragmentDensityMapFeaturesEXT = 1000218000,
    PhysicalDeviceFragmentDensityMapPropertiesEXT = 1000218001,
    RenderPassFragmentDensityMapCreateInfoEXT = 1000218002,
    PhysicalDeviceSubgroupSizeControlPropertiesEXT = 1000225000,
    PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = 1000225001,
    PhysicalDeviceSubgroupSizeControlFeaturesEXT = 1000225002,
    FragmentShadingRateAttachmentInfoKHR = 1000226000,
    PipelineFragmentShadingRateStateCreateInfoKHR = 1000226001,
    PhysicalDeviceFragmentShadingRatePropertiesKHR = 1000226002,
    PhysicalDeviceFragmentShadingRateFeaturesKHR = 1000226003,
    PhysicalDeviceFragmentShadingRateKHR = 1000226004,
    PhysicalDeviceShaderCoreProperties2AMD = 1000227000,
    PhysicalDeviceCoherentMemoryFeaturesAMD = 1000229000,
    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT = 1000234000,
    PhysicalDeviceMemoryBudgetPropertiesEXT = 1000237000,
    PhysicalDeviceMemoryPriorityFeaturesEXT = 1000238000,
    MemoryPriorityAllocateInfoEXT = 1000238001,
    SurfaceProtectedCapabilitiesKHR = 1000239000,
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = 1000240000,
    PhysicalDeviceBufferDeviceAddressFeaturesEXT = 1000244000,
    BufferDeviceAddressCreateInfoEXT = 1000244002,
    PhysicalDeviceToolPropertiesEXT = 1000245000,
    ValidationFeaturesEXT = 1000247000,
    PhysicalDeviceCooperativeMatrixFeaturesNV = 1000249000,
    CooperativeMatrixPropertiesNV = 1000249001,
    PhysicalDeviceCooperativeMatrixPropertiesNV = 1000249002,
    PhysicalDeviceCoverageReductionModeFeaturesNV = 1000250000,
    PipelineCoverageReductionStateCreateInfoNV = 1000250001,
    FramebufferMixedSamplesCombinationNV = 1000250002,
    PhysicalDeviceFragmentShaderInterlockFeaturesEXT = 1000251000,
    PhysicalDeviceYcbcrImageArraysFeaturesEXT = 1000252000,
    SurfaceFullScreenExclusiveInfoEXT = 1000255000,
    SurfaceCapabilitiesFullScreenExclusiveEXT = 1000255002,
    SurfaceFullScreenExclusiveWin32InfoEXT = 1000255001,
    HeadlessSurfaceCreateInfoEXT = 1000256000,
    PhysicalDeviceLineRasterizationFeaturesEXT = 1000259000,
    PipelineRasterizationLineStateCreateInfoEXT = 1000259001,
    PhysicalDeviceLineRasterizationPropertiesEXT = 1000259002,
    PhysicalDeviceShaderAtomicFloatFeaturesEXT = 1000260000,
    PhysicalDeviceIndexTypeUint8FeaturesEXT = 1000265000,
    PhysicalDeviceExtendedDynamicStateFeaturesEXT = 1000267000,
    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR = 1000269000,
    PipelineInfoKHR = 1000269001,
    PipelineExecutablePropertiesKHR = 1000269002,
    PipelineExecutableInfoKHR = 1000269003,
    PipelineExecutableStatisticKHR = 1000269004,
    PipelineExecutableInternalRepresentationKHR = 1000269005,
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = 1000276000,
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV = 1000277000,
    GraphicsShaderGroupCreateInfoNV = 1000277001,
    GraphicsPipelineShaderGroupsCreateInfoNV = 1000277002,
    IndirectCommandsLayoutTokenNV = 1000277003,
    IndirectCommandsLayoutCreateInfoNV = 1000277004,
    GeneratedCommandsInfoNV = 1000277005,
    GeneratedCommandsMemoryRequirementsInfoNV = 1000277006,
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV = 1000277007,
    PhysicalDeviceInheritedViewportScissorFeaturesNV = 1000278000,
    CommandBufferInheritanceViewportScissorInfoNV = 1000278001,
    PhysicalDeviceTexelBufferAlignmentFeaturesEXT = 1000281000,
    PhysicalDeviceTexelBufferAlignmentPropertiesEXT = 1000281001,
    CommandBufferInheritanceRenderPassTransformInfoQCOM = 1000282000,
    RenderPassTransformBeginInfoQCOM = 1000282001,
    PhysicalDeviceDeviceMemoryReportFeaturesEXT = 1000284000,
    DeviceDeviceMemoryReportCreateInfoEXT = 1000284001,
    DeviceMemoryReportCallbackDataEXT = 1000284002,
    PhysicalDeviceRobustness2FeaturesEXT = 1000286000,
    PhysicalDeviceRobustness2PropertiesEXT = 1000286001,
    SamplerCustomBorderColorCreateInfoEXT = 1000287000,
    PhysicalDeviceCustomBorderColorPropertiesEXT = 1000287001,
    PhysicalDeviceCustomBorderColorFeaturesEXT = 1000287002,
    PipelineLibraryCreateInfoKHR = 1000290000,
    PhysicalDevicePrivateDataFeaturesEXT = 1000295000,
    DevicePrivateDataCreateInfoEXT = 1000295001,
    PrivateDataSlotCreateInfoEXT = 1000295002,
    PhysicalDevicePipelineCreationCacheControlFeaturesEXT = 1000297000,
    PhysicalDeviceDiagnosticsConfigFeaturesNV = 1000300000,
    DeviceDiagnosticsConfigCreateInfoNV = 1000300001,
    MemoryBarrier2KHR = 1000314000,
    BufferMemoryBarrier2KHR = 1000314001,
    ImageMemoryBarrier2KHR = 1000314002,
    DependencyInfoKHR = 1000314003,
    SubmitInfo2KHR = 1000314004,
    SemaphoreSubmitInfoKHR = 1000314005,
    CommandBufferSubmitInfoKHR = 1000314006,
    PhysicalDeviceSynchronization2FeaturesKHR = 1000314007,
    QueueFamilyCheckpointProperties2NV = 1000314008,
    CheckpointData2NV = 1000314009,
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = 1000325000,
    PhysicalDeviceFragmentShadingRateEnumsPropertiesNV = 1000326000,
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV = 1000326001,
    PipelineFragmentShadingRateEnumStateCreateInfoNV = 1000326002,
    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = 1000330000,
    PhysicalDeviceFragmentDensityMap2FeaturesEXT = 1000332000,
    PhysicalDeviceFragmentDensityMap2PropertiesEXT = 1000332001,
    CopyCommandTransformInfoQCOM = 1000333000,
    PhysicalDeviceImageRobustnessFeaturesEXT = 1000335000,
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = 1000336000,
    CopyBufferInfo2KHR = 1000337000,
    CopyImageInfo2KHR = 1000337001,
    CopyBufferToImageInfo2KHR = 1000337002,
    CopyImageToBufferInfo2KHR = 1000337003,
    BlitImageInfo2KHR = 1000337004,
    ResolveImageInfo2KHR = 1000337005,
    BufferCopy2KHR = 1000337006,
    ImageCopy2KHR = 1000337007,
    ImageBlit2KHR = 1000337008,
    BufferImageCopy2KHR = 1000337009,
    ImageResolve2KHR = 1000337010,
    PhysicalDevice4444FormatsFeaturesEXT = 1000340000,
    DirectfbSurfaceCreateInfoEXT = 1000346000,
    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = 1000351000,
    MutableDescriptorTypeCreateInfoVALVE = 1000351002,
    PhysicalDeviceVertexInputDynamicStateFeaturesEXT = 1000352000,
    VertexInputBindingDescription2EXT = 1000352001,
    VertexInputAttributeDescription2EXT = 1000352002,
    ImportMemoryZirconHandleInfoFUCHSIA = 1000364000,
    MemoryZirconHandlePropertiesFUCHSIA = 1000364001,
    MemoryGetZirconHandleInfoFUCHSIA = 1000364002,
    ImportSemaphoreZirconHandleInfoFUCHSIA = 1000365000,
    SemaphoreGetZirconHandleInfoFUCHSIA = 1000365001,
    PhysicalDeviceExtendedDynamicState2FeaturesEXT = 1000377000,
    ScreenSurfaceCreateInfoQNX = 1000378000,
    PhysicalDeviceColorWriteEnableFeaturesEXT = 1000381000,
    PipelineColorWriteCreateInfoEXT = 1000381001,
    PhysicalDeviceSubgroupProperties = 1000094000,
    BindBufferMemoryInfo = 1000157000,
    BindImageMemoryInfo = 1000157001,
    PhysicalDevice16BitStorageFeatures = 1000083000,
    MemoryDedicatedRequirements = 1000127000,
    MemoryDedicatedAllocateInfo = 1000127001,
    MemoryAllocateFlagsInfo = 1000060000,
    DeviceGroupRenderPassBeginInfo = 1000060003,
    DeviceGroupCommandBufferBeginInfo = 1000060004,
    DeviceGroupSubmitInfo = 1000060005,
    DeviceGroupBindSparseInfo = 1000060006,
    BindBufferMemoryDeviceGroupInfo = 1000060013,
    BindImageMemoryDeviceGroupInfo = 1000060014,
    PhysicalDeviceGroupProperties = 1000070000,
    DeviceGroupDeviceCreateInfo = 1000070001,
    BufferMemoryRequirementsInfo2 = 1000146000,
    ImageMemoryRequirementsInfo2 = 1000146001,
    ImageSparseMemoryRequirementsInfo2 = 1000146002,
    MemoryRequirements2 = 1000146003,
    SparseImageMemoryRequirements2 = 1000146004,
    PhysicalDeviceFeatures2 = 1000059000,
    PhysicalDeviceProperties2 = 1000059001,
    FormatProperties2 = 1000059002,
    ImageFormatProperties2 = 1000059003,
    PhysicalDeviceImageFormatInfo2 = 1000059004,
    QueueFamilyProperties2 = 1000059005,
    PhysicalDeviceMemoryProperties2 = 1000059006,
    SparseImageFormatProperties2 = 1000059007,
    PhysicalDeviceSparseImageFormatInfo2 = 1000059008,
    PhysicalDevicePointClippingProperties = 1000117000,
    RenderPassInputAttachmentAspectCreateInfo = 1000117001,
    ImageViewUsageCreateInfo = 1000117002,
    PipelineTessellationDomainOriginStateCreateInfo = 1000117003,
    RenderPassMultiviewCreateInfo = 1000053000,
    PhysicalDeviceMultiviewFeatures = 1000053001,
    PhysicalDeviceMultiviewProperties = 1000053002,
    PhysicalDeviceVariablePointersFeatures = 1000120000,
    ProtectedSubmitInfo = 1000145000,
    PhysicalDeviceProtectedMemoryFeatures = 1000145001,
    PhysicalDeviceProtectedMemoryProperties = 1000145002,
    DeviceQueueInfo2 = 1000145003,
    SamplerYcbcrConversionCreateInfo = 1000156000,
    SamplerYcbcrConversionInfo = 1000156001,
    BindImagePlaneMemoryInfo = 1000156002,
    ImagePlaneMemoryRequirementsInfo = 1000156003,
    PhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
    SamplerYcbcrConversionImageFormatProperties = 1000156005,
    DescriptorUpdateTemplateCreateInfo = 1000085000,
    PhysicalDeviceExternalImageFormatInfo = 1000071000,
    ExternalImageFormatProperties = 1000071001,
    PhysicalDeviceExternalBufferInfo = 1000071002,
    ExternalBufferProperties = 1000071003,
    PhysicalDeviceIdProperties = 1000071004,
    ExternalMemoryBufferCreateInfo = 1000072000,
    ExternalMemoryImageCreateInfo = 1000072001,
    ExportMemoryAllocateInfo = 1000072002,
    PhysicalDeviceExternalFenceInfo = 1000112000,
    ExternalFenceProperties = 1000112001,
    ExportFenceCreateInfo = 1000113000,
    ExportSemaphoreCreateInfo = 1000077000,
    PhysicalDeviceExternalSemaphoreInfo = 1000076000,
    ExternalSemaphoreProperties = 1000076001,
    PhysicalDeviceMaintenance3Properties = 1000168000,
    DescriptorSetLayoutSupport = 1000168001,
    PhysicalDeviceShaderDrawParametersFeatures = 1000063000,
    PhysicalDeviceVulkan11Features = 49,
    PhysicalDeviceVulkan11Properties = 50,
    PhysicalDeviceVulkan12Features = 51,
    PhysicalDeviceVulkan12Properties = 52,
    ImageFormatListCreateInfo = 1000147000,
    AttachmentDescription2 = 1000109000,
    AttachmentReference2 = 1000109001,
    SubpassDescription2 = 1000109002,
    SubpassDependency2 = 1000109003,
    RenderPassCreateInfo2 = 1000109004,
    SubpassBeginInfo = 1000109005,
    SubpassEndInfo = 1000109006,
    PhysicalDevice8BitStorageFeatures = 1000177000,
    PhysicalDeviceDriverProperties = 1000196000,
    PhysicalDeviceShaderAtomicInt64Features = 1000180000,
    PhysicalDeviceShaderFloat16Int8Features = 1000082000,
    PhysicalDeviceFloatControlsProperties = 1000197000,
    DescriptorSetLayoutBindingFlagsCreateInfo = 1000161000,
    PhysicalDeviceDescriptorIndexingFeatures = 1000161001,
    PhysicalDeviceDescriptorIndexingProperties = 1000161002,
    DescriptorSetVariableDescriptorCountAllocateInfo = 1000161003,
    DescriptorSetVariableDescriptorCountLayoutSupport = 1000161004,
    PhysicalDeviceDepthStencilResolveProperties = 1000199000,
    SubpassDescriptionDepthStencilResolve = 1000199001,
    PhysicalDeviceScalarBlockLayoutFeatures = 1000221000,
    ImageStencilUsageCreateInfo = 1000246000,
    PhysicalDeviceSamplerFilterMinmaxProperties = 1000130000,
    SamplerReductionModeCreateInfo = 1000130001,
    PhysicalDeviceVulkanMemoryModelFeatures = 1000211000,
    PhysicalDeviceImagelessFramebufferFeatures = 1000108000,
    FramebufferAttachmentsCreateInfo = 1000108001,
    FramebufferAttachmentImageInfo = 1000108002,
    RenderPassAttachmentBeginInfo = 1000108003,
    PhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000,
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000,
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000,
    AttachmentReferenceStencilLayout = 1000241001,
    AttachmentDescriptionStencilLayout = 1000241002,
    PhysicalDeviceHostQueryResetFeatures = 1000261000,
    PhysicalDeviceTimelineSemaphoreFeatures = 1000207000,
    PhysicalDeviceTimelineSemaphoreProperties = 1000207001,
    SemaphoreTypeCreateInfo = 1000207002,
    TimelineSemaphoreSubmitInfo = 1000207003,
    SemaphoreWaitInfo = 1000207004,
    SemaphoreSignalInfo = 1000207005,
    PhysicalDeviceBufferDeviceAddressFeatures = 1000257000,
    BufferDeviceAddressInfo = 1000244001,
    BufferOpaqueCaptureAddressCreateInfo = 1000257002,
    MemoryOpaqueCaptureAddressAllocateInfo = 1000257003,
    DeviceMemoryOpaqueCaptureAddressInfo = 1000257004,
};
enum class SystemAllocationScope : uint32_t {
    Command = 0,
    Object = 1,
    Cache = 2,
    Device = 3,
    Instance = 4,
};
enum class InternalAllocationType : uint32_t {
    Executable = 0,
};
enum class SamplerAddressMode : uint32_t {
    Repeat = 0,
    MirroredRepeat = 1,
    ClampToEdge = 2,
    ClampToBorder = 3,
    MirrorClampToEdge = 4,
};
enum class Filter : uint32_t {
    Nearest = 0,
    Linear = 1,
    CubicIMG = 1000015000,
};
enum class SamplerMipmapMode : uint32_t {
    Nearest = 0,
    Linear = 1,
};
enum class VertexInputRate : uint32_t {
    Vertex = 0,
    Instance = 1,
};
enum class ObjectType : uint32_t {
    Unknown = 0,
    Instance = 1,
    PhysicalDevice = 2,
    Device = 3,
    Queue = 4,
    Semaphore = 5,
    CommandBuffer = 6,
    Fence = 7,
    DeviceMemory = 8,
    Buffer = 9,
    Image = 10,
    Event = 11,
    QueryPool = 12,
    BufferView = 13,
    ImageView = 14,
    ShaderModule = 15,
    PipelineCache = 16,
    PipelineLayout = 17,
    RenderPass = 18,
    Pipeline = 19,
    DescriptorSetLayout = 20,
    Sampler = 21,
    DescriptorPool = 22,
    DescriptorSet = 23,
    Framebuffer = 24,
    CommandPool = 25,
    SurfaceKHR = 1000000000,
    SwapchainKHR = 1000001000,
    DisplayKHR = 1000002000,
    DisplayModeKHR = 1000002001,
    DebugReportCallbackEXT = 1000011000,
    VideoSessionKHR = 1000023000,
    VideoSessionParametersKHR = 1000023001,
    DebugUtilsMessengerEXT = 1000128000,
    AccelerationStructureKHR = 1000150000,
    ValidationCacheEXT = 1000160000,
    AccelerationStructureNV = 1000165000,
    PerformanceConfigurationINTEL = 1000210000,
    DeferredOperationKHR = 1000268000,
    IndirectCommandsLayoutNV = 1000277000,
    PrivateDataSlotEXT = 1000295000,
    SamplerYcbcrConversion = 1000156000,
    DescriptorUpdateTemplate = 1000085000,
};
enum class IndirectCommandsTokenTypeNV : uint32_t {
    ShaderGroupNV = 0,
    StateFlagsNV = 1,
    IndexBufferNV = 2,
    VertexBufferNV = 3,
    PushConstantNV = 4,
    DrawIndexedNV = 5,
    DrawNV = 6,
    DrawTasksNV = 7,
};
enum class DescriptorUpdateTemplateType : uint32_t {
    DescriptorSet = 0,
    PushDescriptorsKHR = 1,
};
using DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;
enum class ViewportCoordinateSwizzleNV : uint32_t {
    PositiveXNV = 0,
    NegativeXNV = 1,
    PositiveYNV = 2,
    NegativeYNV = 3,
    PositiveZNV = 4,
    NegativeZNV = 5,
    PositiveWNV = 6,
    NegativeWNV = 7,
};
enum class DiscardRectangleModeEXT : uint32_t {
    InclusiveEXT = 0,
    ExclusiveEXT = 1,
};
enum class PointClippingBehavior : uint32_t {
    AllClipPlanes = 0,
    UserClipPlanesOnly = 1,
};
using PointClippingBehaviorKHR = PointClippingBehavior;
enum class CoverageModulationModeNV : uint32_t {
    NoneNV = 0,
    RgbNV = 1,
    AlphaNV = 2,
    RgbaNV = 3,
};
enum class CoverageReductionModeNV : uint32_t {
    MergeNV = 0,
    TruncateNV = 1,
};
enum class ValidationCacheHeaderVersionEXT : uint32_t {
    OneEXT = 1,
};
enum class ShaderInfoTypeAMD : uint32_t {
    StatisticsAMD = 0,
    BinaryAMD = 1,
    DisassemblyAMD = 2,
};
enum class QueueGlobalPriorityEXT : uint32_t {
    LowEXT = 128,
    MediumEXT = 256,
    HighEXT = 512,
    RealtimeEXT = 1024,
};
enum class TimeDomainEXT : uint32_t {
    DeviceEXT = 0,
    ClockMonotonicEXT = 1,
    ClockMonotonicRawEXT = 2,
    QueryPerformanceCounterEXT = 3,
};
enum class ConservativeRasterizationModeEXT : uint32_t {
    DisabledEXT = 0,
    OverestimateEXT = 1,
    UnderestimateEXT = 2,
};
enum class SemaphoreType : uint32_t {
    Binary = 0,
    Timeline = 1,
};
using SemaphoreTypeKHR = SemaphoreType;
enum class BuildAccelerationStructureModeKHR : uint32_t {
    BuildKHR = 0,
    UpdateKHR = 1,
};
enum class CopyAccelerationStructureModeKHR : uint32_t {
    CloneKHR = 0,
    CompactKHR = 1,
    SerializeKHR = 2,
    DeserializeKHR = 3,
};
using CopyAccelerationStructureModeNV = CopyAccelerationStructureModeKHR;
enum class AccelerationStructureTypeKHR : uint32_t {
    TopLevelKHR = 0,
    BottomLevelKHR = 1,
    GenericKHR = 2,
};
using AccelerationStructureTypeNV = AccelerationStructureTypeKHR;
enum class GeometryTypeKHR : uint32_t {
    TrianglesKHR = 0,
    AabbsKHR = 1,
    InstancesKHR = 2,
};
using GeometryTypeNV = GeometryTypeKHR;
enum class RayTracingShaderGroupTypeKHR : uint32_t {
    GeneralKHR = 0,
    TrianglesHitGroupKHR = 1,
    ProceduralHitGroupKHR = 2,
};
using RayTracingShaderGroupTypeNV = RayTracingShaderGroupTypeKHR;
enum class AccelerationStructureMemoryRequirementsTypeNV : uint32_t {
    ObjectNV = 0,
    BuildScratchNV = 1,
    UpdateScratchNV = 2,
};
enum class AccelerationStructureBuildTypeKHR : uint32_t {
    HostKHR = 0,
    DeviceKHR = 1,
    HostOrDeviceKHR = 2,
};
enum class AccelerationStructureCompatibilityKHR : uint32_t {
    CompatibleKHR = 0,
    IncompatibleKHR = 1,
};
enum class ShaderGroupShaderKHR : uint32_t {
    GeneralKHR = 0,
    ClosestHitKHR = 1,
    AnyHitKHR = 2,
    IntersectionKHR = 3,
};
enum class MemoryOverallocationBehaviorAMD : uint32_t {
    DefaultAMD = 0,
    AllowedAMD = 1,
    DisallowedAMD = 2,
};
enum class ScopeNV : uint32_t {
    DeviceNV = 1,
    WorkgroupNV = 2,
    SubgroupNV = 3,
    QueueFamilyNV = 5,
};
enum class ComponentTypeNV : uint32_t {
    Float16NV = 0,
    Float32NV = 1,
    Float64NV = 2,
    Sint8NV = 3,
    Sint16NV = 4,
    Sint32NV = 5,
    Sint64NV = 6,
    Uint8NV = 7,
    Uint16NV = 8,
    Uint32NV = 9,
    Uint64NV = 10,
};
enum class PerformanceCounterScopeKHR : uint32_t {
    CommandBufferKHR = 0,
    RenderPassKHR = 1,
    CommandKHR = 2,
};
enum class PerformanceCounterUnitKHR : uint32_t {
    GenericKHR = 0,
    PercentageKHR = 1,
    NanosecondsKHR = 2,
    BytesKHR = 3,
    BytesPerSecondKHR = 4,
    KelvinKHR = 5,
    WattsKHR = 6,
    VoltsKHR = 7,
    AmpsKHR = 8,
    HertzKHR = 9,
    CyclesKHR = 10,
};
enum class PerformanceCounterStorageKHR : uint32_t {
    Int32KHR = 0,
    Int64KHR = 1,
    Uint32KHR = 2,
    Uint64KHR = 3,
    Float32KHR = 4,
    Float64KHR = 5,
};
enum class PerformanceConfigurationTypeINTEL : uint32_t {
    CommandQueueMetricsDiscoveryActivatedINTEL = 0,
};
enum class QueryPoolSamplingModeINTEL : uint32_t {
    ManualINTEL = 0,
};
enum class PerformanceOverrideTypeINTEL : uint32_t {
    NullHardwareINTEL = 0,
    FlushGpuCachesINTEL = 1,
};
enum class PerformanceParameterTypeINTEL : uint32_t {
    HwCountersSupportedINTEL = 0,
    StreamMarkerValidBitsINTEL = 1,
};
enum class PerformanceValueTypeINTEL : uint32_t {
    Uint32INTEL = 0,
    Uint64INTEL = 1,
    FloatINTEL = 2,
    BoolINTEL = 3,
    StringINTEL = 4,
};
enum class LineRasterizationModeEXT : uint32_t {
    DefaultEXT = 0,
    RectangularEXT = 1,
    BresenhamEXT = 2,
    RectangularSmoothEXT = 3,
};
enum class FragmentShadingRateNV : uint32_t {
    e1InvocationPerPixelNV = 0,
    e1InvocationPer1X2PixelsNV = 1,
    e1InvocationPer2X1PixelsNV = 4,
    e1InvocationPer2X2PixelsNV = 5,
    e1InvocationPer2X4PixelsNV = 6,
    e1InvocationPer4X2PixelsNV = 9,
    e1InvocationPer4X4PixelsNV = 10,
    e2InvocationsPerPixelNV = 11,
    e4InvocationsPerPixelNV = 12,
    e8InvocationsPerPixelNV = 13,
    e16InvocationsPerPixelNV = 14,
    NoInvocationsNV = 15,
};
enum class FragmentShadingRateTypeNV : uint32_t {
    FragmentSizeNV = 0,
    EnumsNV = 1,
};
enum class ColorSpaceKHR : uint32_t {
    SrgbNonlinearKHR = 0,
    DisplayP3NonlinearEXT = 1000104001,
    ExtendedSrgbLinearEXT = 1000104002,
    DisplayP3LinearEXT = 1000104003,
    DciP3NonlinearEXT = 1000104004,
    Bt709LinearEXT = 1000104005,
    Bt709NonlinearEXT = 1000104006,
    Bt2020LinearEXT = 1000104007,
    Hdr10St2084EXT = 1000104008,
    DolbyvisionEXT = 1000104009,
    Hdr10HlgEXT = 1000104010,
    AdobergbLinearEXT = 1000104011,
    AdobergbNonlinearEXT = 1000104012,
    PassThroughEXT = 1000104013,
    ExtendedSrgbNonlinearEXT = 1000104014,
    DisplayNativeAMD = 1000213000,
};
enum class PresentModeKHR : uint32_t {
    ImmediateKHR = 0,
    MailboxKHR = 1,
    FifoKHR = 2,
    FifoRelaxedKHR = 3,
    SharedDemandRefreshKHR = 1000111000,
    SharedContinuousRefreshKHR = 1000111001,
};
enum class DebugReportObjectTypeEXT : uint32_t {
    UnknownEXT = 0,
    InstanceEXT = 1,
    PhysicalDeviceEXT = 2,
    DeviceEXT = 3,
    QueueEXT = 4,
    SemaphoreEXT = 5,
    CommandBufferEXT = 6,
    FenceEXT = 7,
    DeviceMemoryEXT = 8,
    BufferEXT = 9,
    ImageEXT = 10,
    EventEXT = 11,
    QueryPoolEXT = 12,
    BufferViewEXT = 13,
    ImageViewEXT = 14,
    ShaderModuleEXT = 15,
    PipelineCacheEXT = 16,
    PipelineLayoutEXT = 17,
    RenderPassEXT = 18,
    PipelineEXT = 19,
    DescriptorSetLayoutEXT = 20,
    SamplerEXT = 21,
    DescriptorPoolEXT = 22,
    DescriptorSetEXT = 23,
    FramebufferEXT = 24,
    CommandPoolEXT = 25,
    SurfaceKhrEXT = 26,
    SwapchainKhrEXT = 27,
    DebugReportCallbackExtEXT = 28,
    DisplayKhrEXT = 29,
    DisplayModeKhrEXT = 30,
    ValidationCacheExtEXT = 33,
    SamplerYcbcrConversionEXT = 1000156000,
    DescriptorUpdateTemplateEXT = 1000085000,
    AccelerationStructureKhrEXT = 1000150000,
    AccelerationStructureNvEXT = 1000165000,
};
enum class DeviceMemoryReportEventTypeEXT : uint32_t {
    AllocateEXT = 0,
    FreeEXT = 1,
    ImportEXT = 2,
    UnimportEXT = 3,
    AllocationFailedEXT = 4,
};
enum class RasterizationOrderAMD : uint32_t {
    StrictAMD = 0,
    RelaxedAMD = 1,
};
enum class ValidationCheckEXT : uint32_t {
    AllEXT = 0,
    ShadersEXT = 1,
};
enum class ValidationFeatureEnableEXT : uint32_t {
    GpuAssistedEXT = 0,
    GpuAssistedReserveBindingSlotEXT = 1,
    BestPracticesEXT = 2,
    DebugPrintfEXT = 3,
    SynchronizationValidationEXT = 4,
};
enum class ValidationFeatureDisableEXT : uint32_t {
    AllEXT = 0,
    ShadersEXT = 1,
    ThreadSafetyEXT = 2,
    ApiParametersEXT = 3,
    ObjectLifetimesEXT = 4,
    CoreChecksEXT = 5,
    UniqueHandlesEXT = 6,
};
enum class DisplayPowerStateEXT : uint32_t {
    OffEXT = 0,
    SuspendEXT = 1,
    OnEXT = 2,
};
enum class DeviceEventTypeEXT : uint32_t {
    DisplayHotplugEXT = 0,
};
enum class DisplayEventTypeEXT : uint32_t {
    FirstPixelOutEXT = 0,
};
enum class TessellationDomainOrigin : uint32_t {
    UpperLeft = 0,
    LowerLeft = 1,
};
using TessellationDomainOriginKHR = TessellationDomainOrigin;
enum class SamplerYcbcrModelConversion : uint32_t {
    RgbIdentity = 0,
    YcbcrIdentity = 1,
    Ycbcr709 = 2,
    Ycbcr601 = 3,
    Ycbcr2020 = 4,
};
using SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
enum class SamplerYcbcrRange : uint32_t {
    ItuFull = 0,
    ItuNarrow = 1,
};
using SamplerYcbcrRangeKHR = SamplerYcbcrRange;
enum class ChromaLocation : uint32_t {
    CositedEven = 0,
    Midpoint = 1,
};
using ChromaLocationKHR = ChromaLocation;
enum class SamplerReductionMode : uint32_t {
    WeightedAverage = 0,
    Min = 1,
    Max = 2,
};
using SamplerReductionModeEXT = SamplerReductionMode;
enum class BlendOverlapEXT : uint32_t {
    UncorrelatedEXT = 0,
    DisjointEXT = 1,
    ConjointEXT = 2,
};
#if defined(VK_USE_PLATFORM_WIN32_KHR)
enum class FullScreenExclusiveEXT : uint32_t {
    DefaultEXT = 0,
    AllowedEXT = 1,
    DisallowedEXT = 2,
    ApplicationControlledEXT = 3,
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
enum class ShaderFloatControlsIndependence : uint32_t {
    e32BitOnly = 0,
    All = 1,
    None = 2,
};
using ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;
enum class FragmentShadingRateCombinerOpKHR : uint32_t {
    KeepKHR = 0,
    ReplaceKHR = 1,
    MinKHR = 2,
    MaxKHR = 3,
    MulKHR = 4,
};
enum class VendorId : uint32_t {
    VIV = 0x10001,
    VSI = 0x10002,
    Kazan = 0x10003,
    Codeplay = 0x10004,
    MESA = 0x10005,
    Pocl = 0x10006,
};
enum class DriverId : uint32_t {
    AmdProprietary = 1,
    AmdOpenSource = 2,
    MesaRadv = 3,
    NvidiaProprietary = 4,
    IntelProprietaryWindows = 5,
    IntelOpenSourceMESA = 6,
    ImaginationProprietary = 7,
    QualcommProprietary = 8,
    ArmProprietary = 9,
    GoogleSwiftshader = 10,
    GgpProprietary = 11,
    BroadcomProprietary = 12,
    MesaLlvmpipe = 13,
    Moltenvk = 14,
    CoreaviProprietary = 15,
};
using DriverIdKHR = DriverId;
enum class ShadingRatePaletteEntryNV : uint32_t {
    NoInvocationsNV = 0,
    e16InvocationsPerPixelNV = 1,
    e8InvocationsPerPixelNV = 2,
    e4InvocationsPerPixelNV = 3,
    e2InvocationsPerPixelNV = 4,
    e1InvocationPerPixelNV = 5,
    e1InvocationPer2X1PixelsNV = 6,
    e1InvocationPer1X2PixelsNV = 7,
    e1InvocationPer2X2PixelsNV = 8,
    e1InvocationPer4X2PixelsNV = 9,
    e1InvocationPer2X4PixelsNV = 10,
    e1InvocationPer4X4PixelsNV = 11,
};
enum class CoarseSampleOrderTypeNV : uint32_t {
    DefaultNV = 0,
    CustomNV = 1,
    PixelMajorNV = 2,
    SampleMajorNV = 3,
};
enum class PipelineExecutableStatisticFormatKHR : uint32_t {
    Bool32KHR = 0,
    Int64KHR = 1,
    Uint64KHR = 2,
    Float64KHR = 3,
};
#if defined(VK_ENABLE_BETA_EXTENSIONS)
enum class QueryResultStatusKHR : uint32_t {
    ErrorKHR = -1,
    NotReadyKHR = 0,
    CompleteKHR = 1,
};
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
enum class PipelineCacheCreateFlagBits: uint32_t {
    ExternallySynchronizedBitEXT = 1,
};
enum class QueueFlagBits: uint32_t {
    Graphics = 1,
    Compute = 2,
    Transfer = 4,
    SparseBinding = 8,
    VideoDecodeBitKHR = 32,
    VideoEncodeBitKHR = 64,
    Protected = 16,
};
enum class CullModeFlagBits: uint32_t {
    None = 0,
    Front = 1,
    Back = 2,
    FrontAndBack = 0x00000003,
};
enum class RenderPassCreateFlagBits: uint32_t {
    TransformBitQCOM = 2,
};
enum class DeviceQueueCreateFlagBits: uint32_t {
    Protected = 1,
};
enum class MemoryPropertyFlagBits: uint32_t {
    DeviceLocal = 1,
    HostVisible = 2,
    HostCoherent = 4,
    HostCached = 8,
    LazilyAllocated = 16,
    DeviceCoherentBitAMD = 64,
    DeviceUncachedBitAMD = 128,
    Protected = 32,
};
enum class MemoryHeapFlagBits: uint32_t {
    DeviceLocal = 1,
    MultiInstance = 2,
};
enum class AccessFlagBits: uint32_t {
    NoneKHR = 1,
    IndexRead = 2,
    VertexAttributeRead = 4,
    UniformRead = 8,
    InputAttachmentRead = 16,
    ShaderRead = 32,
    ShaderWrite = 64,
    ColorAttachmentRead = 128,
    ColorAttachmentWrite = 256,
    DepthStencilAttachmentRead = 512,
    DepthStencilAttachmentWrite = 1024,
    TransferRead = 2048,
    TransferWrite = 4096,
    HostRead = 8192,
    HostWrite = 16384,
    MemoryRead = 32768,
    MemoryWrite = 65536,
    TransformFeedbackWriteBitEXT = 33554432,
    TransformFeedbackCounterReadBitEXT = 67108864,
    TransformFeedbackCounterWriteBitEXT = 134217728,
    ConditionalRenderingReadBitEXT = 1048576,
    ColorAttachmentReadNoncoherentBitEXT = 524288,
    AccelerationStructureReadBitKHR = 2097152,
    AccelerationStructureWriteBitKHR = 4194304,
    ShadingRateImageReadBitNV = 8388608,
    FragmentDensityMapReadBitEXT = 16777216,
    CommandPreprocessReadBitNV = 131072,
    CommandPreprocessWriteBitNV = 262144,
};
enum class BufferUsageFlagBits: uint32_t {
    TransferSrc = 1,
    TransferDst = 2,
    UniformTexelBuffer = 4,
    StorageTexelBuffer = 8,
    UniformBuffer = 16,
    StorageBuffer = 32,
    IndexBuffer = 64,
    VertexBuffer = 128,
    IndirectBuffer = 256,
    VideoDecodeSrcBitKHR = 8192,
    VideoDecodeDstBitKHR = 16384,
    VideoEncodeDstBitKHR = 32768,
    VideoEncodeSrcBitKHR = 65536,
    TransformFeedbackBufferBitEXT = 2048,
    TransformFeedbackCounterBufferBitEXT = 4096,
    ConditionalRenderingBitEXT = 512,
    AccelerationStructureBuildInputReadOnlyBitKHR = 524288,
    AccelerationStructureStorageBitKHR = 1048576,
    ShaderBindingTableBitKHR = 1024,
    ShaderDeviceAddress = 131072,
};
enum class BufferCreateFlagBits: uint32_t {
    SparseBinding = 1,
    SparseResidency = 2,
    SparseAliased = 4,
    Protected = 8,
    DeviceAddressCaptureReplay = 16,
};
enum class ShaderStageFlagBits: uint32_t {
    Vertex = 1,
    TessellationControl = 2,
    TessellationEvaluation = 4,
    Geometry = 8,
    Fragment = 16,
    Compute = 32,
    AllGraphics = 0x0000001F,
    All = 0x7FFFFFFF,
    RaygenBitKHR = 256,
    AnyHitBitKHR = 512,
    ClosestHitBitKHR = 1024,
    MissBitKHR = 2048,
    IntersectionBitKHR = 4096,
    CallableBitKHR = 8192,
    TaskBitNV = 64,
    MeshBitNV = 128,
};
enum class ImageUsageFlagBits: uint32_t {
    TransferSrc = 1,
    TransferDst = 2,
    Sampled = 4,
    Storage = 8,
    ColorAttachment = 16,
    DepthStencilAttachment = 32,
    TransientAttachment = 64,
    InputAttachment = 128,
    VideoDecodeDstBitKHR = 1024,
    VideoDecodeSrcBitKHR = 2048,
    VideoDecodeDpbBitKHR = 4096,
    VideoEncodeDstBitKHR = 8192,
    VideoEncodeSrcBitKHR = 16384,
    VideoEncodeDpbBitKHR = 32768,
    ShadingRateImageBitNV = 256,
    FragmentDensityMapBitEXT = 512,
};
enum class ImageCreateFlagBits: uint32_t {
    SparseBinding = 1,
    SparseResidency = 2,
    SparseAliased = 4,
    MutableFormat = 8,
    CubeCompatible = 16,
    CornerSampledBitNV = 8192,
    SampleLocationsCompatibleDepthBitEXT = 4096,
    SubsampledBitEXT = 16384,
    Alias = 1024,
    SplitInstanceBindRegions = 64,
    e2DArrayCompatible = 32,
    BlockTexelViewCompatible = 128,
    ExtendedUsage = 256,
    Protected = 2048,
    Disjoint = 512,
};
enum class ImageViewCreateFlagBits: uint32_t {
    FragmentDensityMapDynamicBitEXT = 1,
    FragmentDensityMapDeferredBitEXT = 2,
};
enum class SamplerCreateFlagBits: uint32_t {
    SubsampledBitEXT = 1,
    SubsampledCoarseReconstructionBitEXT = 2,
};
enum class PipelineCreateFlagBits: uint32_t {
    DisableOptimization = 1,
    AllowDerivatives = 2,
    Derivative = 4,
    RayTracingNoNullAnyHitShadersBitKHR = 16384,
    RayTracingNoNullClosestHitShadersBitKHR = 32768,
    RayTracingNoNullMissShadersBitKHR = 65536,
    RayTracingNoNullIntersectionShadersBitKHR = 131072,
    RayTracingSkipTrianglesBitKHR = 4096,
    RayTracingSkipAabbsBitKHR = 8192,
    RayTracingShaderGroupHandleCaptureReplayBitKHR = 524288,
    DeferCompileBitNV = 32,
    CaptureStatisticsBitKHR = 64,
    CaptureInternalRepresentationsBitKHR = 128,
    IndirectBindableBitNV = 262144,
    LibraryBitKHR = 2048,
    FailOnPipelineCompileRequiredBitEXT = 256,
    EarlyReturnOnFailureBitEXT = 512,
    ViewIndexFromDeviceIndex = 8,
    DispatchBase = 16,
};
enum class PipelineShaderStageCreateFlagBits: uint32_t {
    AllowVaryingSubgroupSizeBitEXT = 1,
    RequireFullSubgroupsBitEXT = 2,
};
enum class ColorComponentFlagBits: uint32_t {
    R = 1,
    G = 2,
    B = 4,
    A = 8,
};
enum class FenceCreateFlagBits: uint32_t {
    Signaled = 1,
};
enum class FormatFeatureFlagBits: uint32_t {
    SampledImage = 1,
    StorageImage = 2,
    StorageImageAtomic = 4,
    UniformTexelBuffer = 8,
    StorageTexelBuffer = 16,
    StorageTexelBufferAtomic = 32,
    VertexBuffer = 64,
    ColorAttachment = 128,
    ColorAttachmentBlend = 256,
    DepthStencilAttachment = 512,
    BlitSrc = 1024,
    BlitDst = 2048,
    SampledImageFilterLinear = 4096,
    SampledImageFilterCubicBitIMG = 8192,
    VideoDecodeOutputBitKHR = 33554432,
    VideoDecodeDpbBitKHR = 67108864,
    VideoEncodeInputBitKHR = 134217728,
    VideoEncodeDpbBitKHR = 268435456,
    AccelerationStructureVertexBufferBitKHR = 536870912,
    FragmentDensityMapBitEXT = 16777216,
    FragmentShadingRateAttachmentBitKHR = 1073741824,
    TransferSrc = 16384,
    TransferDst = 32768,
    MidpointChromaSamples = 131072,
    SampledImageYcbcrConversionLinearFilter = 262144,
    SampledImageYcbcrConversionSeparateReconstructionFilter = 524288,
    SampledImageYcbcrConversionChromaReconstructionExplicit = 1048576,
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 2097152,
    Disjoint = 4194304,
    CositedChromaSamples = 8388608,
    SampledImageFilterMinmax = 65536,
};
enum class QueryControlFlagBits: uint32_t {
    Precise = 1,
};
enum class QueryResultFlagBits: uint32_t {
    e64 = 1,
    Wait = 2,
    WithAvailability = 4,
    Partial = 8,
    WithStatusBitKHR = 16,
};
enum class CommandBufferUsageFlagBits: uint32_t {
    OneTimeSubmit = 1,
    RenderPassContinue = 2,
    SimultaneousUse = 4,
};
enum class QueryPipelineStatisticFlagBits: uint32_t {
    InputAssemblyVertices = 1,
    InputAssemblyPrimitives = 2,
    VertexShaderInvocations = 4,
    GeometryShaderInvocations = 8,
    GeometryShaderPrimitives = 16,
    ClippingInvocations = 32,
    ClippingPrimitives = 64,
    FragmentShaderInvocations = 128,
    TessellationControlShaderPatches = 256,
    TessellationEvaluationShaderInvocations = 512,
    ComputeShaderInvocations = 1024,
};
enum class ImageAspectFlagBits: uint32_t {
    Color = 1,
    Depth = 2,
    Stencil = 4,
    Metadata = 8,
    MemoryPlane0BitEXT = 128,
    MemoryPlane1BitEXT = 256,
    MemoryPlane2BitEXT = 512,
    MemoryPlane3BitEXT = 1024,
    Plane0 = 16,
    Plane1 = 32,
    Plane2 = 64,
};
enum class SparseImageFormatFlagBits: uint32_t {
    SingleMiptail = 1,
    AlignedMipSize = 2,
    NonstandardBlockSize = 4,
};
enum class SparseMemoryBindFlagBits: uint32_t {
    Metadata = 1,
};
enum class PipelineStageFlagBits: uint32_t {
    NoneKHR = 1,
    DrawIndirect = 2,
    VertexInput = 4,
    VertexShader = 8,
    TessellationControlShader = 16,
    TessellationEvaluationShader = 32,
    GeometryShader = 64,
    FragmentShader = 128,
    EarlyFragmentTests = 256,
    LateFragmentTests = 512,
    ColorAttachmentOutput = 1024,
    ComputeShader = 2048,
    Transfer = 4096,
    BottomOfPipe = 8192,
    Host = 16384,
    AllGraphics = 32768,
    AllCommands = 65536,
    TransformFeedbackBitEXT = 16777216,
    ConditionalRenderingBitEXT = 262144,
    AccelerationStructureBuildBitKHR = 33554432,
    RayTracingShaderBitKHR = 2097152,
    ShadingRateImageBitNV = 4194304,
    TaskShaderBitNV = 524288,
    MeshShaderBitNV = 1048576,
    FragmentDensityProcessBitEXT = 8388608,
    CommandPreprocessBitNV = 131072,
};
enum class CommandPoolCreateFlagBits: uint32_t {
    Transient = 1,
    ResetCommandBuffer = 2,
    Protected = 4,
};
enum class CommandPoolResetFlagBits: uint32_t {
    ReleaseResources = 1,
};
enum class CommandBufferResetFlagBits: uint32_t {
    ReleaseResources = 1,
};
enum class SampleCountFlagBits: uint32_t {
    e1 = 1,
    e2 = 2,
    e4 = 4,
    e8 = 8,
    e16 = 16,
    e32 = 32,
    e64 = 64,
};
enum class AttachmentDescriptionFlagBits: uint32_t {
    MayAlias = 1,
};
enum class StencilFaceFlagBits: uint32_t {
    Front = 1,
    Back = 2,
    FrontAndBack = 0x00000003,
};
enum class DescriptorPoolCreateFlagBits: uint32_t {
    FreeDescriptorSet = 1,
    HostOnlyBitVALVE = 4,
    UpdateAfterBind = 2,
};
enum class DependencyFlagBits: uint32_t {
    ByRegion = 1,
    DeviceGroup = 4,
    ViewLocal = 2,
};
enum class SemaphoreWaitFlagBits: uint32_t {
    Any = 1,
};
enum class DisplayPlaneAlphaFlagBitsKHR: uint32_t {
    OpaqueBitKHR = 1,
    GlobalBitKHR = 2,
    PerPixelBitKHR = 4,
    PerPixelPremultipliedBitKHR = 8,
};
enum class CompositeAlphaFlagBitsKHR: uint32_t {
    OpaqueBitKHR = 1,
    PreMultipliedBitKHR = 2,
    PostMultipliedBitKHR = 4,
    InheritBitKHR = 8,
};
enum class SurfaceTransformFlagBitsKHR: uint32_t {
    IdentityBitKHR = 1,
    Rotate90BitKHR = 2,
    Rotate180BitKHR = 4,
    Rotate270BitKHR = 8,
    HorizontalMirrorBitKHR = 16,
    HorizontalMirrorRotate90BitKHR = 32,
    HorizontalMirrorRotate180BitKHR = 64,
    HorizontalMirrorRotate270BitKHR = 128,
    InheritBitKHR = 256,
};
enum class DebugReportFlagBitsEXT: uint32_t {
    InformationBitEXT = 1,
    WarningBitEXT = 2,
    PerformanceWarningBitEXT = 4,
    ErrorBitEXT = 8,
    DebugBitEXT = 16,
};
enum class ExternalMemoryHandleTypeFlagBitsNV: uint32_t {
    OpaqueWin32BitNV = 1,
    OpaqueWin32KmtBitNV = 2,
    D3D11ImageBitNV = 4,
    D3D11ImageKmtBitNV = 8,
};
enum class ExternalMemoryFeatureFlagBitsNV: uint32_t {
    DedicatedOnlyBitNV = 1,
    ExportableBitNV = 2,
    ImportableBitNV = 4,
};
enum class SubgroupFeatureFlagBits: uint32_t {
    Basic = 1,
    Vote = 2,
    Arithmetic = 4,
    Ballot = 8,
    Shuffle = 16,
    ShuffleRelative = 32,
    Clustered = 64,
    Quad = 128,
    PartitionedBitNV = 256,
};
enum class IndirectCommandsLayoutUsageFlagBitsNV: uint32_t {
    ExplicitPreprocessBitNV = 1,
    IndexedSequencesBitNV = 2,
    UnorderedSequencesBitNV = 4,
};
enum class IndirectStateFlagBitsNV: uint32_t {
    FlagFrontfaceBitNV = 1,
};
enum class PrivateDataSlotCreateFlagBitsEXT: uint32_t {
};
enum class DescriptorSetLayoutCreateFlagBits: uint32_t {
    PushDescriptorBitKHR = 1,
    HostOnlyPoolBitVALVE = 4,
    UpdateAfterBindPool = 2,
};
enum class ExternalMemoryHandleTypeFlagBits: uint32_t {
    OpaqueFd = 1,
    OpaqueWin32 = 2,
    OpaqueWin32Kmt = 4,
    D3D11Texture = 8,
    D3D11TextureKmt = 16,
    D3D12Heap = 32,
    D3D12Resource = 64,
    DmaBufBitEXT = 512,
    AndroidHardwareBufferBitANDROID = 1024,
    HostAllocationBitEXT = 128,
    HostMappedForeignMemoryBitEXT = 256,
    ZirconVmoBitFUCHSIA = 2048,
};
enum class ExternalMemoryFeatureFlagBits: uint32_t {
    DedicatedOnly = 1,
    Exportable = 2,
    Importable = 4,
};
enum class ExternalSemaphoreHandleTypeFlagBits: uint32_t {
    OpaqueFd = 1,
    OpaqueWin32 = 2,
    OpaqueWin32Kmt = 4,
    D3D12Fence = 8,
    D3D11Fence = D3D12Fence,
    SyncFd = 16,
    ZirconEventBitFUCHSIA = 128,
};
enum class ExternalSemaphoreFeatureFlagBits: uint32_t {
    Exportable = 1,
    Importable = 2,
};
enum class SemaphoreImportFlagBits: uint32_t {
    Temporary = 1,
};
enum class ExternalFenceHandleTypeFlagBits: uint32_t {
    OpaqueFd = 1,
    OpaqueWin32 = 2,
    OpaqueWin32Kmt = 4,
    SyncFd = 8,
};
enum class ExternalFenceFeatureFlagBits: uint32_t {
    Exportable = 1,
    Importable = 2,
};
enum class FenceImportFlagBits: uint32_t {
    Temporary = 1,
};
enum class SurfaceCounterFlagBitsEXT: uint32_t {
    VblankBitEXT = 1,
    VblankEXT = VblankBitEXT,
};
enum class PeerMemoryFeatureFlagBits: uint32_t {
    CopySrc = 1,
    CopyDst = 2,
    GenericSrc = 4,
    GenericDst = 8,
};
enum class MemoryAllocateFlagBits: uint32_t {
    DeviceMask = 1,
    DeviceAddress = 2,
    DeviceAddressCaptureReplay = 4,
};
enum class DeviceGroupPresentModeFlagBitsKHR: uint32_t {
    LocalBitKHR = 1,
    RemoteBitKHR = 2,
    SumBitKHR = 4,
    LocalMultiDeviceBitKHR = 8,
};
enum class SwapchainCreateFlagBitsKHR: uint32_t {
    SplitInstanceBindRegionsBitKHR = 1,
    ProtectedBitKHR = 2,
    MutableFormatBitKHR = 4,
};
enum class SubpassDescriptionFlagBits: uint32_t {
    PerViewAttributesBitNVX = 1,
    PerViewPositionXOnlyBitNVX = 2,
    FragmentRegionBitQCOM = 4,
    ShaderResolveBitQCOM = 8,
};
enum class DebugUtilsMessageSeverityFlagBitsEXT: uint32_t {
    VerboseBitEXT = 1,
    InfoBitEXT = 16,
    WarningBitEXT = 256,
    ErrorBitEXT = 4096,
};
enum class DebugUtilsMessageTypeFlagBitsEXT: uint32_t {
    GeneralBitEXT = 1,
    ValidationBitEXT = 2,
    PerformanceBitEXT = 4,
};
enum class DescriptorBindingFlagBits: uint32_t {
    UpdateAfterBind = 1,
    UpdateUnusedWhilePending = 2,
    PartiallyBound = 4,
    VariableDescriptorCount = 8,
};
enum class ConditionalRenderingFlagBitsEXT: uint32_t {
    InvertedBitEXT = 1,
};
enum class ResolveModeFlagBits: uint32_t {
    None = 0,
    SampleZero = 1,
    Average = 2,
    Min = 4,
    Max = 8,
};
enum class GeometryInstanceFlagBitsKHR: uint32_t {
    TriangleFacingCullDisableBitKHR = 1,
    TriangleFrontCounterclockwiseBitKHR = 2,
    ForceOpaqueBitKHR = 4,
    ForceNoOpaqueBitKHR = 8,
};
enum class GeometryFlagBitsKHR: uint32_t {
    OpaqueBitKHR = 1,
    NoDuplicateAnyHitInvocationBitKHR = 2,
};
enum class BuildAccelerationStructureFlagBitsKHR: uint32_t {
    AllowUpdateBitKHR = 1,
    AllowCompactionBitKHR = 2,
    PreferFastTraceBitKHR = 4,
    PreferFastBuildBitKHR = 8,
    LowMemoryBitKHR = 16,
};
enum class AccelerationStructureCreateFlagBitsKHR: uint32_t {
    DeviceAddressCaptureReplayBitKHR = 1,
};
enum class FramebufferCreateFlagBits: uint32_t {
    Imageless = 1,
};
enum class DeviceDiagnosticsConfigFlagBitsNV: uint32_t {
    EnableShaderDebugInfoBitNV = 1,
    EnableResourceTrackingBitNV = 2,
    EnableAutomaticCheckpointsBitNV = 4,
};
enum class PipelineCreationFeedbackFlagBitsEXT: uint32_t {
    ValidBitEXT = 1,
    ApplicationPipelineCacheHitBitEXT = 2,
    BasePipelineAccelerationBitEXT = 4,
};
enum class PerformanceCounterDescriptionFlagBitsKHR: uint32_t {
    PerformanceImpactingBitKHR = 1,
    PerformanceImpactingKHR = PerformanceImpactingBitKHR,
    ConcurrentlyImpactedBitKHR = 2,
    ConcurrentlyImpactedKHR = ConcurrentlyImpactedBitKHR,
};
enum class AcquireProfilingLockFlagBitsKHR: uint32_t {
};
enum class ShaderCorePropertiesFlagBitsAMD: uint32_t {
};
enum class ShaderModuleCreateFlagBits: uint32_t {
};
enum class PipelineCompilerControlFlagBitsAMD: uint32_t {
};
enum class ToolPurposeFlagBitsEXT: uint32_t {
    ValidationBitEXT = 1,
    ProfilingBitEXT = 2,
    TracingBitEXT = 4,
    AdditionalFeaturesBitEXT = 8,
    ModifyingFeaturesBitEXT = 16,
    DebugReportingBitEXT = 32,
    DebugMarkersBitEXT = 64,
};
enum class AccessFlagBits2KHR: uint64_t {
    e2NoneKHR = 0,
    e2IndirectCommandReadBitKHR = 1,
    e2IndexReadBitKHR = 2,
    e2VertexAttributeReadBitKHR = 4,
    e2UniformReadBitKHR = 8,
    e2InputAttachmentReadBitKHR = 16,
    e2ShaderReadBitKHR = 32,
    e2ShaderWriteBitKHR = 64,
    e2ColorAttachmentReadBitKHR = 128,
    e2ColorAttachmentWriteBitKHR = 256,
    e2DepthStencilAttachmentReadBitKHR = 512,
    e2DepthStencilAttachmentWriteBitKHR = 1024,
    e2TransferReadBitKHR = 2048,
    e2TransferWriteBitKHR = 4096,
    e2HostReadBitKHR = 8192,
    e2HostWriteBitKHR = 16384,
    e2MemoryReadBitKHR = 32768,
    e2MemoryWriteBitKHR = 65536,
    e2ShaderSampledReadBitKHR = 4294967296,
    e2ShaderStorageReadBitKHR = 8589934592,
    e2ShaderStorageWriteBitKHR = 17179869184,
    e2VideoDecodeReadBitKHR = 34359738368,
    e2VideoDecodeWriteBitKHR = 68719476736,
    e2VideoEncodeReadBitKHR = 137438953472,
    e2VideoEncodeWriteBitKHR = 274877906944,
    e2TransformFeedbackWriteBitEXT = 33554432,
    e2TransformFeedbackCounterReadBitEXT = 67108864,
    e2TransformFeedbackCounterWriteBitEXT = 134217728,
    e2ConditionalRenderingReadBitEXT = 1048576,
    e2CommandPreprocessReadBitNV = 131072,
    e2CommandPreprocessWriteBitNV = 262144,
    e2FragmentShadingRateAttachmentReadBitKHR = 8388608,
    e2AccelerationStructureReadBitKHR = 2097152,
    e2AccelerationStructureWriteBitKHR = 4194304,
    e2FragmentDensityMapReadBitEXT = 16777216,
    e2ColorAttachmentReadNoncoherentBitEXT = 524288,
};
enum class PipelineStageFlagBits2KHR: uint64_t {
    e2NoneKHR = 0,
    e2TopOfPipeBitKHR = 1,
    e2DrawIndirectBitKHR = 2,
    e2VertexInputBitKHR = 4,
    e2VertexShaderBitKHR = 8,
    e2TessellationControlShaderBitKHR = 16,
    e2TessellationEvaluationShaderBitKHR = 32,
    e2GeometryShaderBitKHR = 64,
    e2FragmentShaderBitKHR = 128,
    e2EarlyFragmentTestsBitKHR = 256,
    e2LateFragmentTestsBitKHR = 512,
    e2ColorAttachmentOutputBitKHR = 1024,
    e2ComputeShaderBitKHR = 2048,
    e2AllTransferBitKHR = 4096,
    e2TransferBitKHR = e2AllTransferBitKHR,
    e2BottomOfPipeBitKHR = 8192,
    e2HostBitKHR = 16384,
    e2AllGraphicsBitKHR = 32768,
    e2AllCommandsBitKHR = 65536,
    e2CopyBitKHR = 4294967296,
    e2ResolveBitKHR = 8589934592,
    e2BlitBitKHR = 17179869184,
    e2ClearBitKHR = 34359738368,
    e2IndexInputBitKHR = 68719476736,
    e2VertexAttributeInputBitKHR = 137438953472,
    e2PreRasterizationShadersBitKHR = 274877906944,
    e2VideoDecodeBitKHR = 67108864,
    e2VideoEncodeBitKHR = 134217728,
    e2TransformFeedbackBitEXT = 16777216,
    e2ConditionalRenderingBitEXT = 262144,
    e2CommandPreprocessBitNV = 131072,
    e2FragmentShadingRateAttachmentBitKHR = 4194304,
    e2AccelerationStructureBuildBitKHR = 33554432,
    e2RayTracingShaderBitKHR = 2097152,
    e2FragmentDensityProcessBitEXT = 8388608,
    e2TaskShaderBitNV = 524288,
    e2MeshShaderBitNV = 1048576,
};
enum class SubmitFlagBitsKHR: uint32_t {
    ProtectedBitKHR = 1,
};
enum class EventCreateFlagBits: uint32_t {
    DeviceOnlyBitKHR = 1,
};
#if defined(VK_ENABLE_BETA_EXTENSIONS)
enum class VideoCodecOperationFlagBitsKHR: uint32_t {
    InvalidBitKHR = 0,
    EncodeH264BitEXT = 65536,
    DecodeH264BitEXT = 1,
    DecodeH265BitEXT = 2,
};
enum class VideoChromaSubsamplingFlagBitsKHR: uint32_t {
    InvalidBitKHR = 0,
    MonochromeBitKHR = 1,
    e420BitKHR = 2,
    e422BitKHR = 4,
    e444BitKHR = 8,
};
enum class VideoComponentBitDepthFlagBitsKHR: uint32_t {
    InvalidKHR = 0,
    e8BitKHR = 1,
    e10BitKHR = 4,
    e12BitKHR = 16,
};
enum class VideoCapabilitiesFlagBitsKHR: uint32_t {
    ProtectedContentBitKHR = 1,
    SeparateReferenceImagesBitKHR = 2,
};
enum class VideoSessionCreateFlagBitsKHR: uint32_t {
    DefaultKHR = 0,
    ProtectedContentBitKHR = 1,
};
enum class VideoCodingQualityPresetFlagBitsKHR: uint32_t {
    DefaultBitKHR = 0,
    NormalBitKHR = 1,
    PowerBitKHR = 2,
    QualityBitKHR = 4,
};
enum class VideoDecodeH264FieldLayoutFlagBitsEXT: uint32_t {
    OnlyEXT = 0,
    LineInterlacedPlaneBitEXT = 1,
    SeparateInterlacedPlaneBitEXT = 2,
};
enum class VideoCodingControlFlagBitsKHR: uint32_t {
    DefaultKHR = 0,
    ResetBitKHR = 1,
};
enum class VideoDecodeFlagBitsKHR: uint32_t {
    DefaultKHR = 0,
    Reserved0BitKHR = 1,
};
enum class VideoEncodeFlagBitsKHR: uint32_t {
    DefaultKHR = 0,
    Reserved0BitKHR = 1,
};
enum class VideoEncodeRateControlFlagBitsKHR: uint32_t {
    DefaultKHR = 0,
    ResetBitKHR = 1,
};
enum class VideoEncodeRateControlModeFlagBitsKHR: uint32_t {
    NoneBitKHR = 0,
    CbrBitKHR = 1,
    VbrBitKHR = 2,
};
enum class VideoEncodeH264CapabilitiesFlagBitsEXT: uint32_t {
    CabacBitEXT = 1,
    CavlcBitEXT = 2,
    WeightedBiPredImplicitBitEXT = 4,
    Transform8X8BitEXT = 8,
    ChromaQpOffsetBitEXT = 16,
    SecondChromaQpOffsetBitEXT = 32,
    DeblockingFilterDisabledBitEXT = 64,
    DeblockingFilterEnabledBitEXT = 128,
    DeblockingFilterPartialBitEXT = 256,
    MultipleSlicePerFrameBitEXT = 512,
    EvenlyDistributedSliceSizeBitEXT = 1024,
};
enum class VideoEncodeH264InputModeFlagBitsEXT: uint32_t {
    FrameBitEXT = 1,
    SliceBitEXT = 2,
    NonVclBitEXT = 4,
};
enum class VideoEncodeH264OutputModeFlagBitsEXT: uint32_t {
    FrameBitEXT = 1,
    SliceBitEXT = 2,
    NonVclBitEXT = 4,
};
enum class VideoEncodeH264CreateFlagBitsEXT: uint32_t {
    DefaultEXT = 0,
    Reserved0BitEXT = 1,
};
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
enum class QueryPoolCreateFlagBits: uint32_t { };
enum class PipelineLayoutCreateFlagBits: uint32_t { };
enum class PipelineDepthStencilStateCreateFlagBits: uint32_t { };
enum class PipelineDynamicStateCreateFlagBits: uint32_t { };
enum class PipelineColorBlendStateCreateFlagBits: uint32_t { };
enum class PipelineMultisampleStateCreateFlagBits: uint32_t { };
enum class PipelineRasterizationStateCreateFlagBits: uint32_t { };
enum class PipelineViewportStateCreateFlagBits: uint32_t { };
enum class PipelineTessellationStateCreateFlagBits: uint32_t { };
enum class PipelineInputAssemblyStateCreateFlagBits: uint32_t { };
enum class PipelineVertexInputStateCreateFlagBits: uint32_t { };
enum class BufferViewCreateFlagBits: uint32_t { };
enum class InstanceCreateFlagBits: uint32_t { };
enum class DeviceCreateFlagBits: uint32_t { };
enum class SemaphoreCreateFlagBits: uint32_t { };
enum class MemoryMapFlagBits: uint32_t { };
enum class DescriptorPoolResetFlagBits: uint32_t { };
enum class DescriptorUpdateTemplateCreateFlagBits: uint32_t { };
enum class DisplayModeCreateFlagBitsKHR: uint32_t { };
enum class DisplaySurfaceCreateFlagBitsKHR: uint32_t { };
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
enum class AndroidSurfaceCreateFlagBitsKHR: uint32_t { };
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_VI_NN)
enum class ViSurfaceCreateFlagBitsNN: uint32_t { };
#endif // defined(VK_USE_PLATFORM_VI_NN)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
enum class WaylandSurfaceCreateFlagBitsKHR: uint32_t { };
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
enum class Win32SurfaceCreateFlagBitsKHR: uint32_t { };
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_XLIB_KHR)
enum class XlibSurfaceCreateFlagBitsKHR: uint32_t { };
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
enum class XcbSurfaceCreateFlagBitsKHR: uint32_t { };
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
enum class DirectFBSurfaceCreateFlagBitsEXT: uint32_t { };
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_IOS_MVK)
enum class IOSSurfaceCreateFlagBitsMVK: uint32_t { };
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
enum class MacOSSurfaceCreateFlagBitsMVK: uint32_t { };
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
#if defined(VK_USE_PLATFORM_METAL_EXT)
enum class MetalSurfaceCreateFlagBitsEXT: uint32_t { };
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
#if defined(VK_USE_PLATFORM_FUCHSIA)
enum class ImagePipeSurfaceCreateFlagBitsFUCHSIA: uint32_t { };
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_GGP)
enum class StreamDescriptorSurfaceCreateFlagBitsGGP: uint32_t { };
#endif // defined(VK_USE_PLATFORM_GGP)
enum class HeadlessSurfaceCreateFlagBitsEXT: uint32_t { };
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
enum class ScreenSurfaceCreateFlagBitsQNX: uint32_t { };
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
enum class CommandPoolTrimFlagBits: uint32_t { };
enum class PipelineViewportSwizzleStateCreateFlagBitsNV: uint32_t { };
enum class PipelineDiscardRectangleStateCreateFlagBitsEXT: uint32_t { };
enum class PipelineCoverageToColorStateCreateFlagBitsNV: uint32_t { };
enum class PipelineCoverageModulationStateCreateFlagBitsNV: uint32_t { };
enum class PipelineCoverageReductionStateCreateFlagBitsNV: uint32_t { };
enum class ValidationCacheCreateFlagBitsEXT: uint32_t { };
enum class DebugUtilsMessengerCreateFlagBitsEXT: uint32_t { };
enum class DebugUtilsMessengerCallbackDataFlagBitsEXT: uint32_t { };
enum class DeviceMemoryReportFlagBitsEXT: uint32_t { };
enum class PipelineRasterizationConservativeStateCreateFlagBitsEXT: uint32_t { };
enum class PipelineRasterizationStateStreamCreateFlagBitsEXT: uint32_t { };
enum class PipelineRasterizationDepthClipStateCreateFlagBitsEXT: uint32_t { };
#if defined(VK_ENABLE_BETA_EXTENSIONS)
enum class VideoBeginCodingFlagBitsKHR: uint32_t { };
enum class VideoEndCodingFlagBitsKHR: uint32_t { };
enum class VideoDecodeH264CreateFlagBitsEXT: uint32_t { };
enum class VideoDecodeH265CreateFlagBitsEXT: uint32_t { };
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)

#define DECLARE_ENUM_FLAG_OPERATORS(FLAG_TYPE, FLAG_BITS, BASE_TYPE)                       \
                                                                                           \
struct FLAG_TYPE {                                                                         \
    BASE_TYPE flags = static_cast<BASE_TYPE>(0);                                           \
                                                                                           \
    constexpr FLAG_TYPE() noexcept = default;                                              \
    constexpr explicit FLAG_TYPE(BASE_TYPE in) noexcept: flags(in){ }                      \
    constexpr FLAG_TYPE(FLAG_BITS in) noexcept: flags(static_cast<BASE_TYPE>(in)){ }       \
    constexpr bool operator==(FLAG_TYPE const& right) const { return flags == right.flags;}\
    constexpr bool operator!=(FLAG_TYPE const& right) const { return flags != right.flags;}\
    constexpr explicit operator BASE_TYPE() const { return flags;}                         \
    constexpr explicit operator bool() const noexcept {                                    \
      return flags != 0;                                                                   \
    }                                                                                      \
};                                                                                         \
constexpr FLAG_TYPE operator|(FLAG_TYPE a, FLAG_TYPE b) noexcept {                         \
    return static_cast<FLAG_TYPE>(a.flags | b.flags);                                      \
}                                                                                          \
constexpr FLAG_TYPE operator&(FLAG_TYPE a, FLAG_TYPE b) noexcept {                         \
    return static_cast<FLAG_TYPE>(a.flags & b.flags);                                      \
}                                                                                          \
constexpr FLAG_TYPE operator^(FLAG_TYPE a, FLAG_TYPE b) noexcept {                         \
    return static_cast<FLAG_TYPE>(a.flags ^ b.flags);                                      \
}                                                                                          \
constexpr FLAG_TYPE operator~(FLAG_TYPE a) noexcept {                                      \
    return static_cast<FLAG_TYPE>(~a.flags);                                               \
}                                                                                          \
constexpr FLAG_TYPE& operator|=(FLAG_TYPE& a, FLAG_TYPE b) noexcept {                      \
    return a.flags = (a.flags | b.flags), a;                                                                              \
}                                                                                          \
constexpr FLAG_TYPE& operator&=(FLAG_TYPE& a, FLAG_TYPE b) noexcept {                      \
    return a.flags = (a.flags & b.flags), a;                                                                              \
}                                                                                          \
constexpr FLAG_TYPE operator^=(FLAG_TYPE& a, FLAG_TYPE b) noexcept {                       \
    return  a.flags = (a.flags ^ b.flags), a;                                                                              \
}                                                                                          \
constexpr FLAG_TYPE operator|(FLAG_BITS a, FLAG_BITS b) noexcept {                         \
    return static_cast<FLAG_TYPE>(static_cast<BASE_TYPE>(a) | static_cast<BASE_TYPE>(b));  \
}                                                                                          \
constexpr FLAG_TYPE operator&(FLAG_BITS a, FLAG_BITS b) noexcept {                         \
    return static_cast<FLAG_TYPE>(static_cast<BASE_TYPE>(a) & static_cast<BASE_TYPE>(b));  \
}                                                                                          \
constexpr FLAG_TYPE operator~(FLAG_BITS key) noexcept {                                    \
    return static_cast<FLAG_TYPE>(~static_cast<BASE_TYPE>(key));                           \
}                                                                                          \
constexpr FLAG_TYPE operator^(FLAG_BITS a, FLAG_BITS b) noexcept {                         \
    return static_cast<FLAG_TYPE>(static_cast<BASE_TYPE>(a) ^ static_cast<BASE_TYPE>(b));  \
}                                                                                          \

DECLARE_ENUM_FLAG_OPERATORS(FramebufferCreateFlags, FramebufferCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(QueryPoolCreateFlags, QueryPoolCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(RenderPassCreateFlags, RenderPassCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SamplerCreateFlags, SamplerCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineLayoutCreateFlags, PipelineLayoutCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineCacheCreateFlags, PipelineCacheCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineDepthStencilStateCreateFlags, PipelineDepthStencilStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineDynamicStateCreateFlags, PipelineDynamicStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineColorBlendStateCreateFlags, PipelineColorBlendStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineMultisampleStateCreateFlags, PipelineMultisampleStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineRasterizationStateCreateFlags, PipelineRasterizationStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineViewportStateCreateFlags, PipelineViewportStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineTessellationStateCreateFlags, PipelineTessellationStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineInputAssemblyStateCreateFlags, PipelineInputAssemblyStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineVertexInputStateCreateFlags, PipelineVertexInputStateCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineShaderStageCreateFlags, PipelineShaderStageCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DescriptorSetLayoutCreateFlags, DescriptorSetLayoutCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(BufferViewCreateFlags, BufferViewCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(InstanceCreateFlags, InstanceCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DeviceCreateFlags, DeviceCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DeviceQueueCreateFlags, DeviceQueueCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(QueueFlags, QueueFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(MemoryPropertyFlags, MemoryPropertyFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(MemoryHeapFlags, MemoryHeapFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(AccessFlags, AccessFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(BufferUsageFlags, BufferUsageFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(BufferCreateFlags, BufferCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ShaderStageFlags, ShaderStageFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ImageUsageFlags, ImageUsageFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ImageCreateFlags, ImageCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ImageViewCreateFlags, ImageViewCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineCreateFlags, PipelineCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ColorComponentFlags, ColorComponentFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(FenceCreateFlags, FenceCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SemaphoreCreateFlags, SemaphoreCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(FormatFeatureFlags, FormatFeatureFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(QueryControlFlags, QueryControlFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(QueryResultFlags, QueryResultFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ShaderModuleCreateFlags, ShaderModuleCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(EventCreateFlags, EventCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(CommandPoolCreateFlags, CommandPoolCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(CommandPoolResetFlags, CommandPoolResetFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(CommandBufferResetFlags, CommandBufferResetFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(CommandBufferUsageFlags, CommandBufferUsageFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(QueryPipelineStatisticFlags, QueryPipelineStatisticFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(MemoryMapFlags, MemoryMapFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ImageAspectFlags, ImageAspectFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SparseMemoryBindFlags, SparseMemoryBindFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SparseImageFormatFlags, SparseImageFormatFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SubpassDescriptionFlags, SubpassDescriptionFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineStageFlags, PipelineStageFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SampleCountFlags, SampleCountFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(AttachmentDescriptionFlags, AttachmentDescriptionFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(StencilFaceFlags, StencilFaceFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(CullModeFlags, CullModeFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DescriptorPoolCreateFlags, DescriptorPoolCreateFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DescriptorPoolResetFlags, DescriptorPoolResetFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DependencyFlags, DependencyFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SubgroupFeatureFlags, SubgroupFeatureFlagBits, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(IndirectCommandsLayoutUsageFlagsNV, IndirectCommandsLayoutUsageFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(IndirectStateFlagsNV, IndirectStateFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(GeometryFlagsKHR, GeometryFlagBitsKHR, uint32_t)
using GeometryFlagsNV = GeometryFlagsKHR;
DECLARE_ENUM_FLAG_OPERATORS(GeometryInstanceFlagsKHR, GeometryInstanceFlagBitsKHR, uint32_t)
using GeometryInstanceFlagsNV = GeometryInstanceFlagsKHR;
DECLARE_ENUM_FLAG_OPERATORS(BuildAccelerationStructureFlagsKHR, BuildAccelerationStructureFlagBitsKHR, uint32_t)
using BuildAccelerationStructureFlagsNV = BuildAccelerationStructureFlagsKHR;
DECLARE_ENUM_FLAG_OPERATORS(PrivateDataSlotCreateFlagsEXT, PrivateDataSlotCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(AccelerationStructureCreateFlagsKHR, AccelerationStructureCreateFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DescriptorUpdateTemplateCreateFlags, DescriptorUpdateTemplateCreateFlagBits, uint32_t)
using DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;
DECLARE_ENUM_FLAG_OPERATORS(PipelineCreationFeedbackFlagsEXT, PipelineCreationFeedbackFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PerformanceCounterDescriptionFlagsKHR, PerformanceCounterDescriptionFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(AcquireProfilingLockFlagsKHR, AcquireProfilingLockFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SemaphoreWaitFlags, SemaphoreWaitFlagBits, uint32_t)
using SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;
DECLARE_ENUM_FLAG_OPERATORS(PipelineCompilerControlFlagsAMD, PipelineCompilerControlFlagBitsAMD, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ShaderCorePropertiesFlagsAMD, ShaderCorePropertiesFlagBitsAMD, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DeviceDiagnosticsConfigFlagsNV, DeviceDiagnosticsConfigFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(AccessFlags2KHR, AccessFlagBits2KHR, uint64_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineStageFlags2KHR, PipelineStageFlagBits2KHR, uint64_t)
DECLARE_ENUM_FLAG_OPERATORS(CompositeAlphaFlagsKHR, CompositeAlphaFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DisplayPlaneAlphaFlagsKHR, DisplayPlaneAlphaFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SurfaceTransformFlagsKHR, SurfaceTransformFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SwapchainCreateFlagsKHR, SwapchainCreateFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DisplayModeCreateFlagsKHR, DisplayModeCreateFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DisplaySurfaceCreateFlagsKHR, DisplaySurfaceCreateFlagBitsKHR, uint32_t)
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
DECLARE_ENUM_FLAG_OPERATORS(AndroidSurfaceCreateFlagsKHR, AndroidSurfaceCreateFlagBitsKHR, uint32_t)
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_VI_NN)
DECLARE_ENUM_FLAG_OPERATORS(ViSurfaceCreateFlagsNN, ViSurfaceCreateFlagBitsNN, uint32_t)
#endif // defined(VK_USE_PLATFORM_VI_NN)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
DECLARE_ENUM_FLAG_OPERATORS(WaylandSurfaceCreateFlagsKHR, WaylandSurfaceCreateFlagBitsKHR, uint32_t)
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
DECLARE_ENUM_FLAG_OPERATORS(Win32SurfaceCreateFlagsKHR, Win32SurfaceCreateFlagBitsKHR, uint32_t)
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_XLIB_KHR)
DECLARE_ENUM_FLAG_OPERATORS(XlibSurfaceCreateFlagsKHR, XlibSurfaceCreateFlagBitsKHR, uint32_t)
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
DECLARE_ENUM_FLAG_OPERATORS(XcbSurfaceCreateFlagsKHR, XcbSurfaceCreateFlagBitsKHR, uint32_t)
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
DECLARE_ENUM_FLAG_OPERATORS(DirectFBSurfaceCreateFlagsEXT, DirectFBSurfaceCreateFlagBitsEXT, uint32_t)
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_IOS_MVK)
DECLARE_ENUM_FLAG_OPERATORS(IOSSurfaceCreateFlagsMVK, IOSSurfaceCreateFlagBitsMVK, uint32_t)
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
DECLARE_ENUM_FLAG_OPERATORS(MacOSSurfaceCreateFlagsMVK, MacOSSurfaceCreateFlagBitsMVK, uint32_t)
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
#if defined(VK_USE_PLATFORM_METAL_EXT)
DECLARE_ENUM_FLAG_OPERATORS(MetalSurfaceCreateFlagsEXT, MetalSurfaceCreateFlagBitsEXT, uint32_t)
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
#if defined(VK_USE_PLATFORM_FUCHSIA)
DECLARE_ENUM_FLAG_OPERATORS(ImagePipeSurfaceCreateFlagsFUCHSIA, ImagePipeSurfaceCreateFlagBitsFUCHSIA, uint32_t)
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_GGP)
DECLARE_ENUM_FLAG_OPERATORS(StreamDescriptorSurfaceCreateFlagsGGP, StreamDescriptorSurfaceCreateFlagBitsGGP, uint32_t)
#endif // defined(VK_USE_PLATFORM_GGP)
DECLARE_ENUM_FLAG_OPERATORS(HeadlessSurfaceCreateFlagsEXT, HeadlessSurfaceCreateFlagBitsEXT, uint32_t)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
DECLARE_ENUM_FLAG_OPERATORS(ScreenSurfaceCreateFlagsQNX, ScreenSurfaceCreateFlagBitsQNX, uint32_t)
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
DECLARE_ENUM_FLAG_OPERATORS(PeerMemoryFeatureFlags, PeerMemoryFeatureFlagBits, uint32_t)
using PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
DECLARE_ENUM_FLAG_OPERATORS(MemoryAllocateFlags, MemoryAllocateFlagBits, uint32_t)
using MemoryAllocateFlagsKHR = MemoryAllocateFlags;
DECLARE_ENUM_FLAG_OPERATORS(DeviceGroupPresentModeFlagsKHR, DeviceGroupPresentModeFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DebugReportFlagsEXT, DebugReportFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(CommandPoolTrimFlags, CommandPoolTrimFlagBits, uint32_t)
using CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;
DECLARE_ENUM_FLAG_OPERATORS(ExternalMemoryHandleTypeFlagsNV, ExternalMemoryHandleTypeFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ExternalMemoryFeatureFlagsNV, ExternalMemoryFeatureFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ExternalMemoryHandleTypeFlags, ExternalMemoryHandleTypeFlagBits, uint32_t)
using ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
DECLARE_ENUM_FLAG_OPERATORS(ExternalMemoryFeatureFlags, ExternalMemoryFeatureFlagBits, uint32_t)
using ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
DECLARE_ENUM_FLAG_OPERATORS(ExternalSemaphoreHandleTypeFlags, ExternalSemaphoreHandleTypeFlagBits, uint32_t)
using ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
DECLARE_ENUM_FLAG_OPERATORS(ExternalSemaphoreFeatureFlags, ExternalSemaphoreFeatureFlagBits, uint32_t)
using ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
DECLARE_ENUM_FLAG_OPERATORS(SemaphoreImportFlags, SemaphoreImportFlagBits, uint32_t)
using SemaphoreImportFlagsKHR = SemaphoreImportFlags;
DECLARE_ENUM_FLAG_OPERATORS(ExternalFenceHandleTypeFlags, ExternalFenceHandleTypeFlagBits, uint32_t)
using ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
DECLARE_ENUM_FLAG_OPERATORS(ExternalFenceFeatureFlags, ExternalFenceFeatureFlagBits, uint32_t)
using ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
DECLARE_ENUM_FLAG_OPERATORS(FenceImportFlags, FenceImportFlagBits, uint32_t)
using FenceImportFlagsKHR = FenceImportFlags;
DECLARE_ENUM_FLAG_OPERATORS(SurfaceCounterFlagsEXT, SurfaceCounterFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineViewportSwizzleStateCreateFlagsNV, PipelineViewportSwizzleStateCreateFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineDiscardRectangleStateCreateFlagsEXT, PipelineDiscardRectangleStateCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineCoverageToColorStateCreateFlagsNV, PipelineCoverageToColorStateCreateFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineCoverageModulationStateCreateFlagsNV, PipelineCoverageModulationStateCreateFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineCoverageReductionStateCreateFlagsNV, PipelineCoverageReductionStateCreateFlagBitsNV, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ValidationCacheCreateFlagsEXT, ValidationCacheCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DebugUtilsMessageSeverityFlagsEXT, DebugUtilsMessageSeverityFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DebugUtilsMessageTypeFlagsEXT, DebugUtilsMessageTypeFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DebugUtilsMessengerCreateFlagsEXT, DebugUtilsMessengerCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DebugUtilsMessengerCallbackDataFlagsEXT, DebugUtilsMessengerCallbackDataFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DeviceMemoryReportFlagsEXT, DeviceMemoryReportFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineRasterizationConservativeStateCreateFlagsEXT, PipelineRasterizationConservativeStateCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(DescriptorBindingFlags, DescriptorBindingFlagBits, uint32_t)
using DescriptorBindingFlagsEXT = DescriptorBindingFlags;
DECLARE_ENUM_FLAG_OPERATORS(ConditionalRenderingFlagsEXT, ConditionalRenderingFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ResolveModeFlags, ResolveModeFlagBits, uint32_t)
using ResolveModeFlagsKHR = ResolveModeFlags;
DECLARE_ENUM_FLAG_OPERATORS(PipelineRasterizationStateStreamCreateFlagsEXT, PipelineRasterizationStateStreamCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(PipelineRasterizationDepthClipStateCreateFlagsEXT, PipelineRasterizationDepthClipStateCreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(ToolPurposeFlagsEXT, ToolPurposeFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(SubmitFlagsKHR, SubmitFlagBitsKHR, uint32_t)
#if defined(VK_ENABLE_BETA_EXTENSIONS)
DECLARE_ENUM_FLAG_OPERATORS(VideoCodecOperationFlagsKHR, VideoCodecOperationFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoCapabilitiesFlagsKHR, VideoCapabilitiesFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoSessionCreateFlagsKHR, VideoSessionCreateFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoBeginCodingFlagsKHR, VideoBeginCodingFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEndCodingFlagsKHR, VideoEndCodingFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoCodingQualityPresetFlagsKHR, VideoCodingQualityPresetFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoCodingControlFlagsKHR, VideoCodingControlFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoDecodeFlagsKHR, VideoDecodeFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoDecodeH264FieldLayoutFlagsEXT, VideoDecodeH264FieldLayoutFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoDecodeH264CreateFlagsEXT, VideoDecodeH264CreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoDecodeH265CreateFlagsEXT, VideoDecodeH265CreateFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeFlagsKHR, VideoEncodeFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeRateControlFlagsKHR, VideoEncodeRateControlFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeRateControlModeFlagsKHR, VideoEncodeRateControlModeFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoChromaSubsamplingFlagsKHR, VideoChromaSubsamplingFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoComponentBitDepthFlagsKHR, VideoComponentBitDepthFlagBitsKHR, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeH264CapabilitiesFlagsEXT, VideoEncodeH264CapabilitiesFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeH264InputModeFlagsEXT, VideoEncodeH264InputModeFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeH264OutputModeFlagsEXT, VideoEncodeH264OutputModeFlagBitsEXT, uint32_t)
DECLARE_ENUM_FLAG_OPERATORS(VideoEncodeH264CreateFlagsEXT, VideoEncodeH264CreateFlagBitsEXT, uint32_t)
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
} //namespace vk
VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_HANDLE(VkCommandBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectCommandsLayoutNV)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)
using VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversion)
using VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkValidationCacheEXT)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureNV)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPerformanceConfigurationINTEL)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeferredOperationKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPrivateDataSlotEXT)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugUtilsMessengerEXT)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkVideoSessionKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkVideoSessionParametersKHR)
export namespace vk {

class Instance {
    VkInstance handle = 0;
    public:
    Instance() = default;
    Instance([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Instance(VkInstance handle) noexcept : handle(handle){}
    VkInstance get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class PhysicalDevice {
    VkPhysicalDevice handle = 0;
    public:
    PhysicalDevice() = default;
    PhysicalDevice([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit PhysicalDevice(VkPhysicalDevice handle) noexcept : handle(handle){}
    VkPhysicalDevice get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Device {
    VkDevice handle = 0;
    public:
    Device() = default;
    Device([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Device(VkDevice handle) noexcept : handle(handle){}
    VkDevice get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Queue {
    VkQueue handle = 0;
    public:
    Queue() = default;
    Queue([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Queue(VkQueue handle) noexcept : handle(handle){}
    VkQueue get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class CommandBuffer {
    VkCommandBuffer handle = 0;
    public:
    CommandBuffer() = default;
    CommandBuffer([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit CommandBuffer(VkCommandBuffer handle) noexcept : handle(handle){}
    VkCommandBuffer get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DeviceMemory {
    VkDeviceMemory handle = 0;
    public:
    DeviceMemory() = default;
    DeviceMemory([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DeviceMemory(VkDeviceMemory handle) noexcept : handle(handle){}
    VkDeviceMemory get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class CommandPool {
    VkCommandPool handle = 0;
    public:
    CommandPool() = default;
    CommandPool([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit CommandPool(VkCommandPool handle) noexcept : handle(handle){}
    VkCommandPool get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Buffer {
    VkBuffer handle = 0;
    public:
    Buffer() = default;
    Buffer([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Buffer(VkBuffer handle) noexcept : handle(handle){}
    VkBuffer get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class BufferView {
    VkBufferView handle = 0;
    public:
    BufferView() = default;
    BufferView([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit BufferView(VkBufferView handle) noexcept : handle(handle){}
    VkBufferView get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Image {
    VkImage handle = 0;
    public:
    Image() = default;
    Image([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Image(VkImage handle) noexcept : handle(handle){}
    VkImage get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class ImageView {
    VkImageView handle = 0;
    public:
    ImageView() = default;
    ImageView([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit ImageView(VkImageView handle) noexcept : handle(handle){}
    VkImageView get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class ShaderModule {
    VkShaderModule handle = 0;
    public:
    ShaderModule() = default;
    ShaderModule([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit ShaderModule(VkShaderModule handle) noexcept : handle(handle){}
    VkShaderModule get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Pipeline {
    VkPipeline handle = 0;
    public:
    Pipeline() = default;
    Pipeline([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Pipeline(VkPipeline handle) noexcept : handle(handle){}
    VkPipeline get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class PipelineLayout {
    VkPipelineLayout handle = 0;
    public:
    PipelineLayout() = default;
    PipelineLayout([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit PipelineLayout(VkPipelineLayout handle) noexcept : handle(handle){}
    VkPipelineLayout get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Sampler {
    VkSampler handle = 0;
    public:
    Sampler() = default;
    Sampler([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Sampler(VkSampler handle) noexcept : handle(handle){}
    VkSampler get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DescriptorSet {
    VkDescriptorSet handle = 0;
    public:
    DescriptorSet() = default;
    DescriptorSet([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DescriptorSet(VkDescriptorSet handle) noexcept : handle(handle){}
    VkDescriptorSet get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DescriptorSetLayout {
    VkDescriptorSetLayout handle = 0;
    public:
    DescriptorSetLayout() = default;
    DescriptorSetLayout([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DescriptorSetLayout(VkDescriptorSetLayout handle) noexcept : handle(handle){}
    VkDescriptorSetLayout get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DescriptorPool {
    VkDescriptorPool handle = 0;
    public:
    DescriptorPool() = default;
    DescriptorPool([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DescriptorPool(VkDescriptorPool handle) noexcept : handle(handle){}
    VkDescriptorPool get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Fence {
    VkFence handle = 0;
    public:
    Fence() = default;
    Fence([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Fence(VkFence handle) noexcept : handle(handle){}
    VkFence get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Semaphore {
    VkSemaphore handle = 0;
    public:
    Semaphore() = default;
    Semaphore([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Semaphore(VkSemaphore handle) noexcept : handle(handle){}
    VkSemaphore get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Event {
    VkEvent handle = 0;
    public:
    Event() = default;
    Event([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Event(VkEvent handle) noexcept : handle(handle){}
    VkEvent get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class QueryPool {
    VkQueryPool handle = 0;
    public:
    QueryPool() = default;
    QueryPool([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit QueryPool(VkQueryPool handle) noexcept : handle(handle){}
    VkQueryPool get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class Framebuffer {
    VkFramebuffer handle = 0;
    public:
    Framebuffer() = default;
    Framebuffer([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit Framebuffer(VkFramebuffer handle) noexcept : handle(handle){}
    VkFramebuffer get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class RenderPass {
    VkRenderPass handle = 0;
    public:
    RenderPass() = default;
    RenderPass([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit RenderPass(VkRenderPass handle) noexcept : handle(handle){}
    VkRenderPass get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class PipelineCache {
    VkPipelineCache handle = 0;
    public:
    PipelineCache() = default;
    PipelineCache([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit PipelineCache(VkPipelineCache handle) noexcept : handle(handle){}
    VkPipelineCache get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class IndirectCommandsLayoutNV {
    VkIndirectCommandsLayoutNV handle = 0;
    public:
    IndirectCommandsLayoutNV() = default;
    IndirectCommandsLayoutNV([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit IndirectCommandsLayoutNV(VkIndirectCommandsLayoutNV handle) noexcept : handle(handle){}
    VkIndirectCommandsLayoutNV get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DescriptorUpdateTemplate {
    VkDescriptorUpdateTemplate handle = 0;
    public:
    DescriptorUpdateTemplate() = default;
    DescriptorUpdateTemplate([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DescriptorUpdateTemplate(VkDescriptorUpdateTemplate handle) noexcept : handle(handle){}
    VkDescriptorUpdateTemplate get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};
using DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;

class SamplerYcbcrConversion {
    VkSamplerYcbcrConversion handle = 0;
    public:
    SamplerYcbcrConversion() = default;
    SamplerYcbcrConversion([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit SamplerYcbcrConversion(VkSamplerYcbcrConversion handle) noexcept : handle(handle){}
    VkSamplerYcbcrConversion get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};
using SamplerYcbcrConversionKHR = SamplerYcbcrConversion;

class ValidationCacheEXT {
    VkValidationCacheEXT handle = 0;
    public:
    ValidationCacheEXT() = default;
    ValidationCacheEXT([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit ValidationCacheEXT(VkValidationCacheEXT handle) noexcept : handle(handle){}
    VkValidationCacheEXT get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class AccelerationStructureKHR {
    VkAccelerationStructureKHR handle = 0;
    public:
    AccelerationStructureKHR() = default;
    AccelerationStructureKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit AccelerationStructureKHR(VkAccelerationStructureKHR handle) noexcept : handle(handle){}
    VkAccelerationStructureKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class AccelerationStructureNV {
    VkAccelerationStructureNV handle = 0;
    public:
    AccelerationStructureNV() = default;
    AccelerationStructureNV([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit AccelerationStructureNV(VkAccelerationStructureNV handle) noexcept : handle(handle){}
    VkAccelerationStructureNV get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class PerformanceConfigurationINTEL {
    VkPerformanceConfigurationINTEL handle = 0;
    public:
    PerformanceConfigurationINTEL() = default;
    PerformanceConfigurationINTEL([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit PerformanceConfigurationINTEL(VkPerformanceConfigurationINTEL handle) noexcept : handle(handle){}
    VkPerformanceConfigurationINTEL get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DeferredOperationKHR {
    VkDeferredOperationKHR handle = 0;
    public:
    DeferredOperationKHR() = default;
    DeferredOperationKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DeferredOperationKHR(VkDeferredOperationKHR handle) noexcept : handle(handle){}
    VkDeferredOperationKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class PrivateDataSlotEXT {
    VkPrivateDataSlotEXT handle = 0;
    public:
    PrivateDataSlotEXT() = default;
    PrivateDataSlotEXT([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit PrivateDataSlotEXT(VkPrivateDataSlotEXT handle) noexcept : handle(handle){}
    VkPrivateDataSlotEXT get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DisplayKHR {
    VkDisplayKHR handle = 0;
    public:
    DisplayKHR() = default;
    DisplayKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DisplayKHR(VkDisplayKHR handle) noexcept : handle(handle){}
    VkDisplayKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DisplayModeKHR {
    VkDisplayModeKHR handle = 0;
    public:
    DisplayModeKHR() = default;
    DisplayModeKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DisplayModeKHR(VkDisplayModeKHR handle) noexcept : handle(handle){}
    VkDisplayModeKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class SurfaceKHR {
    VkSurfaceKHR handle = 0;
    public:
    SurfaceKHR() = default;
    SurfaceKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit SurfaceKHR(VkSurfaceKHR handle) noexcept : handle(handle){}
    VkSurfaceKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class SwapchainKHR {
    VkSwapchainKHR handle = 0;
    public:
    SwapchainKHR() = default;
    SwapchainKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit SwapchainKHR(VkSwapchainKHR handle) noexcept : handle(handle){}
    VkSwapchainKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DebugReportCallbackEXT {
    VkDebugReportCallbackEXT handle = 0;
    public:
    DebugReportCallbackEXT() = default;
    DebugReportCallbackEXT([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DebugReportCallbackEXT(VkDebugReportCallbackEXT handle) noexcept : handle(handle){}
    VkDebugReportCallbackEXT get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class DebugUtilsMessengerEXT {
    VkDebugUtilsMessengerEXT handle = 0;
    public:
    DebugUtilsMessengerEXT() = default;
    DebugUtilsMessengerEXT([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit DebugUtilsMessengerEXT(VkDebugUtilsMessengerEXT handle) noexcept : handle(handle){}
    VkDebugUtilsMessengerEXT get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class VideoSessionKHR {
    VkVideoSessionKHR handle = 0;
    public:
    VideoSessionKHR() = default;
    VideoSessionKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit VideoSessionKHR(VkVideoSessionKHR handle) noexcept : handle(handle){}
    VkVideoSessionKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

class VideoSessionParametersKHR {
    VkVideoSessionParametersKHR handle = 0;
    public:
    VideoSessionParametersKHR() = default;
    VideoSessionParametersKHR([[maybe_unused]] std::nullptr_t none) noexcept {}
    explicit VideoSessionParametersKHR(VkVideoSessionParametersKHR handle) noexcept : handle(handle){}
    VkVideoSessionParametersKHR get() { return handle; }
    bool valid() { return handle != 0; }
    explicit operator bool() const {return handle != 0;};
    bool operator!() { return handle == 0; }
};

/* Return type for Vulkan Module API functions which return a value or values
 * Holds a T value or a vk::Result for indicating the error
 * Do not use with success codes other than zero
 * Example in function definition
 * vk::expected<vk::Buffer> CreateBuffer(const BufferCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = nullptr) { ... }
 * Example usage:
 * auto buffer_return  = CreateBuffer( ... );
 * if (!buffer_return)
 *     error_exit("Failed to create buffer", buffer_return.error());
 * vk::Buffer buffer = buffer_return.value(); //Get value now that we've check for errors
 */
template<typename T>
struct expected {
	explicit expected (T const& value, Result result) noexcept: _value{ value}, _result{ result } {}
	explicit expected (T&& value, Result result) noexcept: _value{ std::move(value) }, _result{ result } {}

    const T* operator-> () const noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return &_value; }
	T*       operator-> ()       noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return &_value; }
	const T& operator* () const& noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return _value; }
	T&       operator* () &      noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return _value; }
	T&&      operator* () &&	 noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return std::move (_value); }
	const T&  value () const&    noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return _value; }
	T&        value () &         noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return _value; }
	const T&& value () const&&   noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return std::move(_value); }
	T&&       value () &&        noexcept { VULKAN_CUSTOM_ASSERT (_result == Result::Success); return std::move(_value); }

    Result error() const noexcept { VULKAN_CUSTOM_ASSERT (_result != Result::Success); return _result; }
    Result raw_result() const noexcept { return _result; }

    bool has_value () const noexcept { return _result == Result::Success; }
	explicit operator bool () const noexcept { return _result == Result::Success; }
    bool operator!() const noexcept { return _result != Result::Success; }

    template <size_t N>
    auto const& get() const noexcept {
       if constexpr (N == 0) return _value;
       else if constexpr (N == 1) return _result;
    }
    template <size_t N>
    auto& get() noexcept {
       if constexpr (N == 0) return _value;
       else if constexpr (N == 1) return _result;
    }

private:
    T _value;
    Result _result = Result::Success;
};

} //namespace vk

export namespace std {
    template<typename T>
    struct tuple_size<vk::expected<T>>: std::integral_constant<size_t, 2> {};
    template<typename T> struct tuple_element<0, vk::expected<T>> { using type = T; };
    template<typename T> struct tuple_element<1, vk::expected<T>> { using type = vk::Result; };
}

export namespace vk {
namespace detail {
template<typename T>
class span {
public:
    constexpr span() noexcept = default;
    constexpr span(T const& value) noexcept : _data{ std::addressof(const_cast<T&>(value)) }, _count{1} {}
    constexpr explicit span(T* data, uint32_t count) noexcept : _data{data}, _count{count} {}

    // requires std::data(Range const&)
    // requires std::size(Range const&)
    template <typename Range>
    explicit span(Range const& range) noexcept :
        _data{std::data(range)}, _count{std::size(range)} {}

    template< std::size_t N >
    span(std::array<T, N>& arr ) noexcept :
        _data{std::data(arr)}, _count{std::size(arr)} {}

    template< std::size_t N >
    span(std::array<T, N> const& arr ) noexcept :
        _data{std::data(arr)}, _count{std::size(arr)} {}

    span( std::initializer_list<T>& data ) noexcept :
        _data{data.begin()}, _count{static_cast<uint32_t>(data.size())} {}

    span( std::initializer_list<T> const& data ) noexcept :
        _data{data.begin()}, _count{static_cast<uint32_t>(data.size())} {}

    template <typename A = T, typename std::enable_if<std::is_const<A>::value, int>::type = 0>
    span( std::initializer_list<typename std::remove_const<T>::type> const& data ) noexcept :
        _data{data.begin()}, _count{static_cast<uint32_t>(data.size())} {}

    template <typename A = T, typename std::enable_if<std::is_const<A>::value, int>::type = 0>
    span( std::initializer_list<typename std::remove_const<T>::type> & data ) noexcept :
        _data{data.begin()}, _count{static_cast<uint32_t>(data.size())} {}

    [[nodiscard]] uint32_t size() noexcept { return _count; }
    [[nodiscard]] uint32_t size() const noexcept { return _count; }
    [[nodiscard]] uint32_t size_bytes() const noexcept { return _count * sizeof(T); }

    [[nodiscard]] T* data() noexcept { return _data; }
    [[nodiscard]] const T* data() const noexcept { return _data; }
    [[nodiscard]] bool empty() const noexcept { return _count == 0; }

    [[nodiscard]] T const& operator[](uint32_t count) & noexcept { return _data[count]; }
    [[nodiscard]] T const& operator[](uint32_t count) const& noexcept { return _data[count]; }

    [[nodiscard]] const T* begin() const noexcept { return _data + 0; }
    [[nodiscard]] const T* begin() noexcept { return _data + 0; }
    [[nodiscard]] const T* end() const noexcept { return _data + _count; }
    [[nodiscard]] const T* end() noexcept { return _data + _count; }
private:
    T* _data;
    uint32_t _count;
};
} // namespace detail

// Unique Handle wrapper for RAII handle types
// DispatchableHandle is a `VkInstance` or `VkDevice` handle
// HandleType is a `vk::Handle` type
// Delete is a PFN_vk*** function that matches the desired type
template <typename DispatchableHandle, typename HandleType, typename Deleter>
class unique_handle
{
public:
    unique_handle() = default;
    explicit unique_handle(DispatchableHandle dispatch_handle, HandleType handle, Deleter deleter) noexcept
        : dispatch_handle(dispatch_handle), handle(handle), deleter(deleter) { }
    ~unique_handle() noexcept { reset(); };
    unique_handle(unique_handle const& other) = delete;
    unique_handle& operator=(unique_handle const& other) = delete;

    unique_handle(unique_handle&& other) noexcept
        : dispatch_handle{other.dispatch_handle},
          handle{std::exchange(other.handle, nullptr)},
          deleter{other.deleter} { }
    unique_handle& operator=(unique_handle&& other) noexcept
    {
        if (this != &other)
        {
            reset();
            dispatch_handle = other.dispatch_handle;
            handle = std::exchange(other.handle, {});
            deleter = other.deleter;
        }
        return *this;
    }

    HandleType release() noexcept {
        return std::exchange(handle, {});
    }

    void reset() noexcept {
        if (handle)
        {
            deleter(dispatch_handle, handle.get(), nullptr);
        }
    }

    const HandleType address() const noexcept {
        return std::addressof(handle.get());
    }

    HandleType operator*() const noexcept {
        return handle;
    }

    [[nodiscard]] HandleType get() const noexcept { return handle; }

    HandleType operator->() const noexcept { return handle; }

    explicit operator bool() const noexcept { return handle; }

    DispatchableHandle dispatch_handle;
    HandleType handle;
    Deleter deleter;
};

// Add special case for VkInstance

struct DebugUtilsMessengerCallbackDataEXT;
struct DeviceMemoryReportCallbackDataEXT;
typedef void (VKAPI_PTR *PFN_InternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    InternalAllocationType                    allocationType,
    SystemAllocationScope                     allocationScope);
typedef void (VKAPI_PTR *PFN_InternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    InternalAllocationType                    allocationType,
    SystemAllocationScope                     allocationScope);
typedef void* (VKAPI_PTR *PFN_ReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    SystemAllocationScope                     allocationScope);
typedef void* (VKAPI_PTR *PFN_AllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    SystemAllocationScope                     allocationScope);
typedef void (VKAPI_PTR *PFN_FreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);
typedef void (VKAPI_PTR *PFN_VoidFunction)(void);
typedef Bool32 (VKAPI_PTR *PFN_DebugReportCallbackEXT)(
    DebugReportFlagsEXT                       flags,
    DebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    void*                                       pUserData);
typedef Bool32 (VKAPI_PTR *PFN_DebugUtilsMessengerCallbackEXT)(
    DebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,
    DebugUtilsMessageTypeFlagsEXT                  messageTypes,
    const DebugUtilsMessengerCallbackDataEXT*      pCallbackData,
    void*                                            pUserData);
typedef void (VKAPI_PTR *PFN_DeviceMemoryReportCallbackEXT)(
    const DeviceMemoryReportCallbackDataEXT*  pCallbackData,
    void*                                       pUserData);
struct BaseOutStructure {
    StructureType sType{static_cast<StructureType>(0)};
    BaseOutStructure* pNext = nullptr;
};
struct BaseInStructure {
    StructureType sType{static_cast<StructureType>(0)};
    const BaseInStructure* pNext = nullptr;
};
struct Offset2D {
    int32_t x{0};
    int32_t y{0};
    constexpr bool operator==(Offset2D const& value) const {
        return x == value.x && y == value.y ;}
    constexpr bool operator!=(Offset2D const& value) const {return !(*this == value);}
    Offset2D& setX(int32_t x_) {this->x = x_; return *this; }
    Offset2D& setY(int32_t y_) {this->y = y_; return *this; }
};
struct Offset3D {
    int32_t x{0};
    int32_t y{0};
    int32_t z{0};
    constexpr bool operator==(Offset3D const& value) const {
        return x == value.x && y == value.y && z == value.z ;}
    constexpr bool operator!=(Offset3D const& value) const {return !(*this == value);}
    Offset3D& setX(int32_t x_) {this->x = x_; return *this; }
    Offset3D& setY(int32_t y_) {this->y = y_; return *this; }
    Offset3D& setZ(int32_t z_) {this->z = z_; return *this; }
};
struct Extent2D {
    uint32_t width{0};
    uint32_t height{0};
    constexpr bool operator==(Extent2D const& value) const {
        return width == value.width && height == value.height ;}
    constexpr bool operator!=(Extent2D const& value) const {return !(*this == value);}
    Extent2D& setWidth(uint32_t width_) {this->width = width_; return *this; }
    Extent2D& setHeight(uint32_t height_) {this->height = height_; return *this; }
};
struct Extent3D {
    uint32_t width{0};
    uint32_t height{0};
    uint32_t depth{0};
    constexpr bool operator==(Extent3D const& value) const {
        return width == value.width && height == value.height && depth == value.depth ;}
    constexpr bool operator!=(Extent3D const& value) const {return !(*this == value);}
    Extent3D& setWidth(uint32_t width_) {this->width = width_; return *this; }
    Extent3D& setHeight(uint32_t height_) {this->height = height_; return *this; }
    Extent3D& setDepth(uint32_t depth_) {this->depth = depth_; return *this; }
};
struct Viewport {
    float x{0.f};
    float y{0.f};
    float width{0.f};
    float height{0.f};
    float minDepth{0.f};
    float maxDepth{0.f};
    constexpr bool operator==(Viewport const& value) const {
        return x == value.x && y == value.y && width == value.width && height == value.height && minDepth == value.minDepth && maxDepth == value.maxDepth ;}
    constexpr bool operator!=(Viewport const& value) const {return !(*this == value);}
    Viewport& setX(float x_) {this->x = x_; return *this; }
    Viewport& setY(float y_) {this->y = y_; return *this; }
    Viewport& setWidth(float width_) {this->width = width_; return *this; }
    Viewport& setHeight(float height_) {this->height = height_; return *this; }
    Viewport& setMinDepth(float minDepth_) {this->minDepth = minDepth_; return *this; }
    Viewport& setMaxDepth(float maxDepth_) {this->maxDepth = maxDepth_; return *this; }
};
struct Rect2D {
    Offset2D offset{};
    Extent2D extent{};
    constexpr bool operator==(Rect2D const& value) const {
        return offset == value.offset && extent == value.extent ;}
    constexpr bool operator!=(Rect2D const& value) const {return !(*this == value);}
    Rect2D& setOffset(Offset2D offset_) {this->offset = offset_; return *this; }
    Rect2D& setExtent(Extent2D extent_) {this->extent = extent_; return *this; }
};
struct ClearRect {
    Rect2D rect{};
    uint32_t baseArrayLayer{0};
    uint32_t layerCount{0};
    constexpr bool operator==(ClearRect const& value) const {
        return rect == value.rect && baseArrayLayer == value.baseArrayLayer && layerCount == value.layerCount ;}
    constexpr bool operator!=(ClearRect const& value) const {return !(*this == value);}
    ClearRect& setRect(Rect2D rect_) {this->rect = rect_; return *this; }
    ClearRect& setBaseArrayLayer(uint32_t baseArrayLayer_) {this->baseArrayLayer = baseArrayLayer_; return *this; }
    ClearRect& setLayerCount(uint32_t layerCount_) {this->layerCount = layerCount_; return *this; }
};
struct ComponentMapping {
    ComponentSwizzle r{static_cast<ComponentSwizzle>(0)};
    ComponentSwizzle g{static_cast<ComponentSwizzle>(0)};
    ComponentSwizzle b{static_cast<ComponentSwizzle>(0)};
    ComponentSwizzle a{static_cast<ComponentSwizzle>(0)};
    constexpr bool operator==(ComponentMapping const& value) const {
        return r == value.r && g == value.g && b == value.b && a == value.a ;}
    constexpr bool operator!=(ComponentMapping const& value) const {return !(*this == value);}
    ComponentMapping& setR(ComponentSwizzle r_) {this->r = r_; return *this; }
    ComponentMapping& setG(ComponentSwizzle g_) {this->g = g_; return *this; }
    ComponentMapping& setB(ComponentSwizzle b_) {this->b = b_; return *this; }
    ComponentMapping& setA(ComponentSwizzle a_) {this->a = a_; return *this; }
};
struct PhysicalDeviceSparseProperties {
    Bool32 residencyStandard2DBlockShape{0};
    Bool32 residencyStandard2DMultisampleBlockShape{0};
    Bool32 residencyStandard3DBlockShape{0};
    Bool32 residencyAlignedMipSize{0};
    Bool32 residencyNonResidentStrict{0};
    constexpr bool operator==(PhysicalDeviceSparseProperties const& value) const {
        return residencyStandard2DBlockShape == value.residencyStandard2DBlockShape && residencyStandard2DMultisampleBlockShape == value.residencyStandard2DMultisampleBlockShape 
        && residencyStandard3DBlockShape == value.residencyStandard3DBlockShape && residencyAlignedMipSize == value.residencyAlignedMipSize 
        && residencyNonResidentStrict == value.residencyNonResidentStrict ;}
    constexpr bool operator!=(PhysicalDeviceSparseProperties const& value) const {return !(*this == value);}
    PhysicalDeviceSparseProperties& setResidencyStandard2DBlockShape(Bool32 residencyStandard2DBlockShape_) {this->residencyStandard2DBlockShape = residencyStandard2DBlockShape_; return *this; }
    PhysicalDeviceSparseProperties& setResidencyStandard2DMultisampleBlockShape(Bool32 residencyStandard2DMultisampleBlockShape_) {this->residencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape_; return *this; }
    PhysicalDeviceSparseProperties& setResidencyStandard3DBlockShape(Bool32 residencyStandard3DBlockShape_) {this->residencyStandard3DBlockShape = residencyStandard3DBlockShape_; return *this; }
    PhysicalDeviceSparseProperties& setResidencyAlignedMipSize(Bool32 residencyAlignedMipSize_) {this->residencyAlignedMipSize = residencyAlignedMipSize_; return *this; }
    PhysicalDeviceSparseProperties& setResidencyNonResidentStrict(Bool32 residencyNonResidentStrict_) {this->residencyNonResidentStrict = residencyNonResidentStrict_; return *this; }
};
struct PhysicalDeviceLimits {
    uint32_t maxImageDimension1D{0};
    uint32_t maxImageDimension2D{0};
    uint32_t maxImageDimension3D{0};
    uint32_t maxImageDimensionCube{0};
    uint32_t maxImageArrayLayers{0};
    uint32_t maxTexelBufferElements{0};
    uint32_t maxUniformBufferRange{0};
    uint32_t maxStorageBufferRange{0};
    uint32_t maxPushConstantsSize{0};
    uint32_t maxMemoryAllocationCount{0};
    uint32_t maxSamplerAllocationCount{0};
    DeviceSize bufferImageGranularity{0};
    DeviceSize sparseAddressSpaceSize{0};
    uint32_t maxBoundDescriptorSets{0};
    uint32_t maxPerStageDescriptorSamplers{0};
    uint32_t maxPerStageDescriptorUniformBuffers{0};
    uint32_t maxPerStageDescriptorStorageBuffers{0};
    uint32_t maxPerStageDescriptorSampledImages{0};
    uint32_t maxPerStageDescriptorStorageImages{0};
    uint32_t maxPerStageDescriptorInputAttachments{0};
    uint32_t maxPerStageResources{0};
    uint32_t maxDescriptorSetSamplers{0};
    uint32_t maxDescriptorSetUniformBuffers{0};
    uint32_t maxDescriptorSetUniformBuffersDynamic{0};
    uint32_t maxDescriptorSetStorageBuffers{0};
    uint32_t maxDescriptorSetStorageBuffersDynamic{0};
    uint32_t maxDescriptorSetSampledImages{0};
    uint32_t maxDescriptorSetStorageImages{0};
    uint32_t maxDescriptorSetInputAttachments{0};
    uint32_t maxVertexInputAttributes{0};
    uint32_t maxVertexInputBindings{0};
    uint32_t maxVertexInputAttributeOffset{0};
    uint32_t maxVertexInputBindingStride{0};
    uint32_t maxVertexOutputComponents{0};
    uint32_t maxTessellationGenerationLevel{0};
    uint32_t maxTessellationPatchSize{0};
    uint32_t maxTessellationControlPerVertexInputComponents{0};
    uint32_t maxTessellationControlPerVertexOutputComponents{0};
    uint32_t maxTessellationControlPerPatchOutputComponents{0};
    uint32_t maxTessellationControlTotalOutputComponents{0};
    uint32_t maxTessellationEvaluationInputComponents{0};
    uint32_t maxTessellationEvaluationOutputComponents{0};
    uint32_t maxGeometryShaderInvocations{0};
    uint32_t maxGeometryInputComponents{0};
    uint32_t maxGeometryOutputComponents{0};
    uint32_t maxGeometryOutputVertices{0};
    uint32_t maxGeometryTotalOutputComponents{0};
    uint32_t maxFragmentInputComponents{0};
    uint32_t maxFragmentOutputAttachments{0};
    uint32_t maxFragmentDualSrcAttachments{0};
    uint32_t maxFragmentCombinedOutputResources{0};
    uint32_t maxComputeSharedMemorySize{0};
    uint32_t maxComputeWorkGroupCount[3];
    uint32_t maxComputeWorkGroupInvocations{0};
    uint32_t maxComputeWorkGroupSize[3];
    uint32_t subPixelPrecisionBits{0};
    uint32_t subTexelPrecisionBits{0};
    uint32_t mipmapPrecisionBits{0};
    uint32_t maxDrawIndexedIndexValue{0};
    uint32_t maxDrawIndirectCount{0};
    float maxSamplerLodBias{0.f};
    float maxSamplerAnisotropy{0.f};
    uint32_t maxViewports{0};
    uint32_t maxViewportDimensions[2];
    float viewportBoundsRange[2];
    uint32_t viewportSubPixelBits{0};
    size_t minMemoryMapAlignment{0};
    DeviceSize minTexelBufferOffsetAlignment{0};
    DeviceSize minUniformBufferOffsetAlignment{0};
    DeviceSize minStorageBufferOffsetAlignment{0};
    int32_t minTexelOffset{0};
    uint32_t maxTexelOffset{0};
    int32_t minTexelGatherOffset{0};
    uint32_t maxTexelGatherOffset{0};
    float minInterpolationOffset{0.f};
    float maxInterpolationOffset{0.f};
    uint32_t subPixelInterpolationOffsetBits{0};
    uint32_t maxFramebufferWidth{0};
    uint32_t maxFramebufferHeight{0};
    uint32_t maxFramebufferLayers{0};
    SampleCountFlags framebufferColorSampleCounts{};
    SampleCountFlags framebufferDepthSampleCounts{};
    SampleCountFlags framebufferStencilSampleCounts{};
    SampleCountFlags framebufferNoAttachmentsSampleCounts{};
    uint32_t maxColorAttachments{0};
    SampleCountFlags sampledImageColorSampleCounts{};
    SampleCountFlags sampledImageIntegerSampleCounts{};
    SampleCountFlags sampledImageDepthSampleCounts{};
    SampleCountFlags sampledImageStencilSampleCounts{};
    SampleCountFlags storageImageSampleCounts{};
    uint32_t maxSampleMaskWords{0};
    Bool32 timestampComputeAndGraphics{0};
    float timestampPeriod{0.f};
    uint32_t maxClipDistances{0};
    uint32_t maxCullDistances{0};
    uint32_t maxCombinedClipAndCullDistances{0};
    uint32_t discreteQueuePriorities{0};
    float pointSizeRange[2];
    float lineWidthRange[2];
    float pointSizeGranularity{0.f};
    float lineWidthGranularity{0.f};
    Bool32 strictLines{0};
    Bool32 standardSampleLocations{0};
    DeviceSize optimalBufferCopyOffsetAlignment{0};
    DeviceSize optimalBufferCopyRowPitchAlignment{0};
    DeviceSize nonCoherentAtomSize{0};
    constexpr bool operator==(PhysicalDeviceLimits const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 3; i++)
            is_equal &= maxComputeWorkGroupCount[i] == value.maxComputeWorkGroupCount[i];
        for(uint32_t i = 0; i < 3; i++)
            is_equal &= maxComputeWorkGroupSize[i] == value.maxComputeWorkGroupSize[i];
        for(uint32_t i = 0; i < 2; i++)
            is_equal &= maxViewportDimensions[i] == value.maxViewportDimensions[i];
        for(uint32_t i = 0; i < 2; i++)
            is_equal &= viewportBoundsRange[i] == value.viewportBoundsRange[i];
        for(uint32_t i = 0; i < 2; i++)
            is_equal &= pointSizeRange[i] == value.pointSizeRange[i];
        for(uint32_t i = 0; i < 2; i++)
            is_equal &= lineWidthRange[i] == value.lineWidthRange[i];
        return is_equal && maxImageDimension1D == value.maxImageDimension1D && maxImageDimension2D == value.maxImageDimension2D && maxImageDimension3D == value.maxImageDimension3D 
        && maxImageDimensionCube == value.maxImageDimensionCube && maxImageArrayLayers == value.maxImageArrayLayers && maxTexelBufferElements == value.maxTexelBufferElements 
        && maxUniformBufferRange == value.maxUniformBufferRange && maxStorageBufferRange == value.maxStorageBufferRange && maxPushConstantsSize == value.maxPushConstantsSize 
        && maxMemoryAllocationCount == value.maxMemoryAllocationCount && maxSamplerAllocationCount == value.maxSamplerAllocationCount && bufferImageGranularity == value.bufferImageGranularity 
        && sparseAddressSpaceSize == value.sparseAddressSpaceSize && maxBoundDescriptorSets == value.maxBoundDescriptorSets && maxPerStageDescriptorSamplers == value.maxPerStageDescriptorSamplers 
        && maxPerStageDescriptorUniformBuffers == value.maxPerStageDescriptorUniformBuffers && maxPerStageDescriptorStorageBuffers == value.maxPerStageDescriptorStorageBuffers 
        && maxPerStageDescriptorSampledImages == value.maxPerStageDescriptorSampledImages && maxPerStageDescriptorStorageImages == value.maxPerStageDescriptorStorageImages 
        && maxPerStageDescriptorInputAttachments == value.maxPerStageDescriptorInputAttachments && maxPerStageResources == value.maxPerStageResources 
        && maxDescriptorSetSamplers == value.maxDescriptorSetSamplers && maxDescriptorSetUniformBuffers == value.maxDescriptorSetUniformBuffers 
        && maxDescriptorSetUniformBuffersDynamic == value.maxDescriptorSetUniformBuffersDynamic && maxDescriptorSetStorageBuffers == value.maxDescriptorSetStorageBuffers 
        && maxDescriptorSetStorageBuffersDynamic == value.maxDescriptorSetStorageBuffersDynamic && maxDescriptorSetSampledImages == value.maxDescriptorSetSampledImages 
        && maxDescriptorSetStorageImages == value.maxDescriptorSetStorageImages && maxDescriptorSetInputAttachments == value.maxDescriptorSetInputAttachments 
        && maxVertexInputAttributes == value.maxVertexInputAttributes && maxVertexInputBindings == value.maxVertexInputBindings && maxVertexInputAttributeOffset == value.maxVertexInputAttributeOffset 
        && maxVertexInputBindingStride == value.maxVertexInputBindingStride && maxVertexOutputComponents == value.maxVertexOutputComponents 
        && maxTessellationGenerationLevel == value.maxTessellationGenerationLevel && maxTessellationPatchSize == value.maxTessellationPatchSize 
        && maxTessellationControlPerVertexInputComponents == value.maxTessellationControlPerVertexInputComponents && maxTessellationControlPerVertexOutputComponents == value.maxTessellationControlPerVertexOutputComponents 
        && maxTessellationControlPerPatchOutputComponents == value.maxTessellationControlPerPatchOutputComponents && maxTessellationControlTotalOutputComponents == value.maxTessellationControlTotalOutputComponents 
        && maxTessellationEvaluationInputComponents == value.maxTessellationEvaluationInputComponents && maxTessellationEvaluationOutputComponents == value.maxTessellationEvaluationOutputComponents 
        && maxGeometryShaderInvocations == value.maxGeometryShaderInvocations && maxGeometryInputComponents == value.maxGeometryInputComponents 
        && maxGeometryOutputComponents == value.maxGeometryOutputComponents && maxGeometryOutputVertices == value.maxGeometryOutputVertices 
        && maxGeometryTotalOutputComponents == value.maxGeometryTotalOutputComponents && maxFragmentInputComponents == value.maxFragmentInputComponents 
        && maxFragmentOutputAttachments == value.maxFragmentOutputAttachments && maxFragmentDualSrcAttachments == value.maxFragmentDualSrcAttachments 
        && maxFragmentCombinedOutputResources == value.maxFragmentCombinedOutputResources && maxComputeSharedMemorySize == value.maxComputeSharedMemorySize 
        && maxComputeWorkGroupInvocations == value.maxComputeWorkGroupInvocations && subPixelPrecisionBits == value.subPixelPrecisionBits 
        && subTexelPrecisionBits == value.subTexelPrecisionBits && mipmapPrecisionBits == value.mipmapPrecisionBits && maxDrawIndexedIndexValue == value.maxDrawIndexedIndexValue 
        && maxDrawIndirectCount == value.maxDrawIndirectCount && maxSamplerLodBias == value.maxSamplerLodBias && maxSamplerAnisotropy == value.maxSamplerAnisotropy 
        && maxViewports == value.maxViewports && viewportSubPixelBits == value.viewportSubPixelBits && minMemoryMapAlignment == value.minMemoryMapAlignment 
        && minTexelBufferOffsetAlignment == value.minTexelBufferOffsetAlignment && minUniformBufferOffsetAlignment == value.minUniformBufferOffsetAlignment 
        && minStorageBufferOffsetAlignment == value.minStorageBufferOffsetAlignment && minTexelOffset == value.minTexelOffset && maxTexelOffset == value.maxTexelOffset 
        && minTexelGatherOffset == value.minTexelGatherOffset && maxTexelGatherOffset == value.maxTexelGatherOffset && minInterpolationOffset == value.minInterpolationOffset 
        && maxInterpolationOffset == value.maxInterpolationOffset && subPixelInterpolationOffsetBits == value.subPixelInterpolationOffsetBits 
        && maxFramebufferWidth == value.maxFramebufferWidth && maxFramebufferHeight == value.maxFramebufferHeight && maxFramebufferLayers == value.maxFramebufferLayers 
        && framebufferColorSampleCounts == value.framebufferColorSampleCounts && framebufferDepthSampleCounts == value.framebufferDepthSampleCounts 
        && framebufferStencilSampleCounts == value.framebufferStencilSampleCounts && framebufferNoAttachmentsSampleCounts == value.framebufferNoAttachmentsSampleCounts 
        && maxColorAttachments == value.maxColorAttachments && sampledImageColorSampleCounts == value.sampledImageColorSampleCounts && sampledImageIntegerSampleCounts == value.sampledImageIntegerSampleCounts 
        && sampledImageDepthSampleCounts == value.sampledImageDepthSampleCounts && sampledImageStencilSampleCounts == value.sampledImageStencilSampleCounts 
        && storageImageSampleCounts == value.storageImageSampleCounts && maxSampleMaskWords == value.maxSampleMaskWords && timestampComputeAndGraphics == value.timestampComputeAndGraphics 
        && timestampPeriod == value.timestampPeriod && maxClipDistances == value.maxClipDistances && maxCullDistances == value.maxCullDistances 
        && maxCombinedClipAndCullDistances == value.maxCombinedClipAndCullDistances && discreteQueuePriorities == value.discreteQueuePriorities 
        && pointSizeGranularity == value.pointSizeGranularity && lineWidthGranularity == value.lineWidthGranularity && strictLines == value.strictLines 
        && standardSampleLocations == value.standardSampleLocations && optimalBufferCopyOffsetAlignment == value.optimalBufferCopyOffsetAlignment 
        && optimalBufferCopyRowPitchAlignment == value.optimalBufferCopyRowPitchAlignment && nonCoherentAtomSize == value.nonCoherentAtomSize 
        ;}
    constexpr bool operator!=(PhysicalDeviceLimits const& value) const {return !(*this == value);}
    PhysicalDeviceLimits& setMaxImageDimension1D(uint32_t maxImageDimension1D_) {this->maxImageDimension1D = maxImageDimension1D_; return *this; }
    PhysicalDeviceLimits& setMaxImageDimension2D(uint32_t maxImageDimension2D_) {this->maxImageDimension2D = maxImageDimension2D_; return *this; }
    PhysicalDeviceLimits& setMaxImageDimension3D(uint32_t maxImageDimension3D_) {this->maxImageDimension3D = maxImageDimension3D_; return *this; }
    PhysicalDeviceLimits& setMaxImageDimensionCube(uint32_t maxImageDimensionCube_) {this->maxImageDimensionCube = maxImageDimensionCube_; return *this; }
    PhysicalDeviceLimits& setMaxImageArrayLayers(uint32_t maxImageArrayLayers_) {this->maxImageArrayLayers = maxImageArrayLayers_; return *this; }
    PhysicalDeviceLimits& setMaxTexelBufferElements(uint32_t maxTexelBufferElements_) {this->maxTexelBufferElements = maxTexelBufferElements_; return *this; }
    PhysicalDeviceLimits& setMaxUniformBufferRange(uint32_t maxUniformBufferRange_) {this->maxUniformBufferRange = maxUniformBufferRange_; return *this; }
    PhysicalDeviceLimits& setMaxStorageBufferRange(uint32_t maxStorageBufferRange_) {this->maxStorageBufferRange = maxStorageBufferRange_; return *this; }
    PhysicalDeviceLimits& setMaxPushConstantsSize(uint32_t maxPushConstantsSize_) {this->maxPushConstantsSize = maxPushConstantsSize_; return *this; }
    PhysicalDeviceLimits& setMaxMemoryAllocationCount(uint32_t maxMemoryAllocationCount_) {this->maxMemoryAllocationCount = maxMemoryAllocationCount_; return *this; }
    PhysicalDeviceLimits& setMaxSamplerAllocationCount(uint32_t maxSamplerAllocationCount_) {this->maxSamplerAllocationCount = maxSamplerAllocationCount_; return *this; }
    PhysicalDeviceLimits& setBufferImageGranularity(DeviceSize bufferImageGranularity_) {this->bufferImageGranularity = bufferImageGranularity_; return *this; }
    PhysicalDeviceLimits& setSparseAddressSpaceSize(DeviceSize sparseAddressSpaceSize_) {this->sparseAddressSpaceSize = sparseAddressSpaceSize_; return *this; }
    PhysicalDeviceLimits& setMaxBoundDescriptorSets(uint32_t maxBoundDescriptorSets_) {this->maxBoundDescriptorSets = maxBoundDescriptorSets_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageDescriptorSamplers(uint32_t maxPerStageDescriptorSamplers_) {this->maxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageDescriptorUniformBuffers(uint32_t maxPerStageDescriptorUniformBuffers_) {this->maxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageDescriptorStorageBuffers(uint32_t maxPerStageDescriptorStorageBuffers_) {this->maxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageDescriptorSampledImages(uint32_t maxPerStageDescriptorSampledImages_) {this->maxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageDescriptorStorageImages(uint32_t maxPerStageDescriptorStorageImages_) {this->maxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageDescriptorInputAttachments(uint32_t maxPerStageDescriptorInputAttachments_) {this->maxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments_; return *this; }
    PhysicalDeviceLimits& setMaxPerStageResources(uint32_t maxPerStageResources_) {this->maxPerStageResources = maxPerStageResources_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetSamplers(uint32_t maxDescriptorSetSamplers_) {this->maxDescriptorSetSamplers = maxDescriptorSetSamplers_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetUniformBuffers(uint32_t maxDescriptorSetUniformBuffers_) {this->maxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetUniformBuffersDynamic(uint32_t maxDescriptorSetUniformBuffersDynamic_) {this->maxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetStorageBuffers(uint32_t maxDescriptorSetStorageBuffers_) {this->maxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetStorageBuffersDynamic(uint32_t maxDescriptorSetStorageBuffersDynamic_) {this->maxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetSampledImages(uint32_t maxDescriptorSetSampledImages_) {this->maxDescriptorSetSampledImages = maxDescriptorSetSampledImages_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetStorageImages(uint32_t maxDescriptorSetStorageImages_) {this->maxDescriptorSetStorageImages = maxDescriptorSetStorageImages_; return *this; }
    PhysicalDeviceLimits& setMaxDescriptorSetInputAttachments(uint32_t maxDescriptorSetInputAttachments_) {this->maxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments_; return *this; }
    PhysicalDeviceLimits& setMaxVertexInputAttributes(uint32_t maxVertexInputAttributes_) {this->maxVertexInputAttributes = maxVertexInputAttributes_; return *this; }
    PhysicalDeviceLimits& setMaxVertexInputBindings(uint32_t maxVertexInputBindings_) {this->maxVertexInputBindings = maxVertexInputBindings_; return *this; }
    PhysicalDeviceLimits& setMaxVertexInputAttributeOffset(uint32_t maxVertexInputAttributeOffset_) {this->maxVertexInputAttributeOffset = maxVertexInputAttributeOffset_; return *this; }
    PhysicalDeviceLimits& setMaxVertexInputBindingStride(uint32_t maxVertexInputBindingStride_) {this->maxVertexInputBindingStride = maxVertexInputBindingStride_; return *this; }
    PhysicalDeviceLimits& setMaxVertexOutputComponents(uint32_t maxVertexOutputComponents_) {this->maxVertexOutputComponents = maxVertexOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationGenerationLevel(uint32_t maxTessellationGenerationLevel_) {this->maxTessellationGenerationLevel = maxTessellationGenerationLevel_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationPatchSize(uint32_t maxTessellationPatchSize_) {this->maxTessellationPatchSize = maxTessellationPatchSize_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationControlPerVertexInputComponents(uint32_t maxTessellationControlPerVertexInputComponents_) {this->maxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationControlPerVertexOutputComponents(uint32_t maxTessellationControlPerVertexOutputComponents_) {this->maxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationControlPerPatchOutputComponents(uint32_t maxTessellationControlPerPatchOutputComponents_) {this->maxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationControlTotalOutputComponents(uint32_t maxTessellationControlTotalOutputComponents_) {this->maxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationEvaluationInputComponents(uint32_t maxTessellationEvaluationInputComponents_) {this->maxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxTessellationEvaluationOutputComponents(uint32_t maxTessellationEvaluationOutputComponents_) {this->maxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxGeometryShaderInvocations(uint32_t maxGeometryShaderInvocations_) {this->maxGeometryShaderInvocations = maxGeometryShaderInvocations_; return *this; }
    PhysicalDeviceLimits& setMaxGeometryInputComponents(uint32_t maxGeometryInputComponents_) {this->maxGeometryInputComponents = maxGeometryInputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxGeometryOutputComponents(uint32_t maxGeometryOutputComponents_) {this->maxGeometryOutputComponents = maxGeometryOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxGeometryOutputVertices(uint32_t maxGeometryOutputVertices_) {this->maxGeometryOutputVertices = maxGeometryOutputVertices_; return *this; }
    PhysicalDeviceLimits& setMaxGeometryTotalOutputComponents(uint32_t maxGeometryTotalOutputComponents_) {this->maxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxFragmentInputComponents(uint32_t maxFragmentInputComponents_) {this->maxFragmentInputComponents = maxFragmentInputComponents_; return *this; }
    PhysicalDeviceLimits& setMaxFragmentOutputAttachments(uint32_t maxFragmentOutputAttachments_) {this->maxFragmentOutputAttachments = maxFragmentOutputAttachments_; return *this; }
    PhysicalDeviceLimits& setMaxFragmentDualSrcAttachments(uint32_t maxFragmentDualSrcAttachments_) {this->maxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments_; return *this; }
    PhysicalDeviceLimits& setMaxFragmentCombinedOutputResources(uint32_t maxFragmentCombinedOutputResources_) {this->maxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources_; return *this; }
    PhysicalDeviceLimits& setMaxComputeSharedMemorySize(uint32_t maxComputeSharedMemorySize_) {this->maxComputeSharedMemorySize = maxComputeSharedMemorySize_; return *this; }
    PhysicalDeviceLimits& setMaxComputeWorkGroupCount(uint32_t maxComputeWorkGroupCount_[3]) {for(uint32_t i = 0; i < 3; i++) this->maxComputeWorkGroupCount[i] = maxComputeWorkGroupCount_[i]; return *this; }
    PhysicalDeviceLimits& setMaxComputeWorkGroupInvocations(uint32_t maxComputeWorkGroupInvocations_) {this->maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations_; return *this; }
    PhysicalDeviceLimits& setMaxComputeWorkGroupSize(uint32_t maxComputeWorkGroupSize_[3]) {for(uint32_t i = 0; i < 3; i++) this->maxComputeWorkGroupSize[i] = maxComputeWorkGroupSize_[i]; return *this; }
    PhysicalDeviceLimits& setSubPixelPrecisionBits(uint32_t subPixelPrecisionBits_) {this->subPixelPrecisionBits = subPixelPrecisionBits_; return *this; }
    PhysicalDeviceLimits& setSubTexelPrecisionBits(uint32_t subTexelPrecisionBits_) {this->subTexelPrecisionBits = subTexelPrecisionBits_; return *this; }
    PhysicalDeviceLimits& setMipmapPrecisionBits(uint32_t mipmapPrecisionBits_) {this->mipmapPrecisionBits = mipmapPrecisionBits_; return *this; }
    PhysicalDeviceLimits& setMaxDrawIndexedIndexValue(uint32_t maxDrawIndexedIndexValue_) {this->maxDrawIndexedIndexValue = maxDrawIndexedIndexValue_; return *this; }
    PhysicalDeviceLimits& setMaxDrawIndirectCount(uint32_t maxDrawIndirectCount_) {this->maxDrawIndirectCount = maxDrawIndirectCount_; return *this; }
    PhysicalDeviceLimits& setMaxSamplerLodBias(float maxSamplerLodBias_) {this->maxSamplerLodBias = maxSamplerLodBias_; return *this; }
    PhysicalDeviceLimits& setMaxSamplerAnisotropy(float maxSamplerAnisotropy_) {this->maxSamplerAnisotropy = maxSamplerAnisotropy_; return *this; }
    PhysicalDeviceLimits& setMaxViewports(uint32_t maxViewports_) {this->maxViewports = maxViewports_; return *this; }
    PhysicalDeviceLimits& setMaxViewportDimensions(uint32_t maxViewportDimensions_[2]) {for(uint32_t i = 0; i < 2; i++) this->maxViewportDimensions[i] = maxViewportDimensions_[i]; return *this; }
    PhysicalDeviceLimits& setViewportBoundsRange(float viewportBoundsRange_[2]) {for(uint32_t i = 0; i < 2; i++) this->viewportBoundsRange[i] = viewportBoundsRange_[i]; return *this; }
    PhysicalDeviceLimits& setViewportSubPixelBits(uint32_t viewportSubPixelBits_) {this->viewportSubPixelBits = viewportSubPixelBits_; return *this; }
    PhysicalDeviceLimits& setMinMemoryMapAlignment(size_t minMemoryMapAlignment_) {this->minMemoryMapAlignment = minMemoryMapAlignment_; return *this; }
    PhysicalDeviceLimits& setMinTexelBufferOffsetAlignment(DeviceSize minTexelBufferOffsetAlignment_) {this->minTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment_; return *this; }
    PhysicalDeviceLimits& setMinUniformBufferOffsetAlignment(DeviceSize minUniformBufferOffsetAlignment_) {this->minUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment_; return *this; }
    PhysicalDeviceLimits& setMinStorageBufferOffsetAlignment(DeviceSize minStorageBufferOffsetAlignment_) {this->minStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment_; return *this; }
    PhysicalDeviceLimits& setMinTexelOffset(int32_t minTexelOffset_) {this->minTexelOffset = minTexelOffset_; return *this; }
    PhysicalDeviceLimits& setMaxTexelOffset(uint32_t maxTexelOffset_) {this->maxTexelOffset = maxTexelOffset_; return *this; }
    PhysicalDeviceLimits& setMinTexelGatherOffset(int32_t minTexelGatherOffset_) {this->minTexelGatherOffset = minTexelGatherOffset_; return *this; }
    PhysicalDeviceLimits& setMaxTexelGatherOffset(uint32_t maxTexelGatherOffset_) {this->maxTexelGatherOffset = maxTexelGatherOffset_; return *this; }
    PhysicalDeviceLimits& setMinInterpolationOffset(float minInterpolationOffset_) {this->minInterpolationOffset = minInterpolationOffset_; return *this; }
    PhysicalDeviceLimits& setMaxInterpolationOffset(float maxInterpolationOffset_) {this->maxInterpolationOffset = maxInterpolationOffset_; return *this; }
    PhysicalDeviceLimits& setSubPixelInterpolationOffsetBits(uint32_t subPixelInterpolationOffsetBits_) {this->subPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits_; return *this; }
    PhysicalDeviceLimits& setMaxFramebufferWidth(uint32_t maxFramebufferWidth_) {this->maxFramebufferWidth = maxFramebufferWidth_; return *this; }
    PhysicalDeviceLimits& setMaxFramebufferHeight(uint32_t maxFramebufferHeight_) {this->maxFramebufferHeight = maxFramebufferHeight_; return *this; }
    PhysicalDeviceLimits& setMaxFramebufferLayers(uint32_t maxFramebufferLayers_) {this->maxFramebufferLayers = maxFramebufferLayers_; return *this; }
    PhysicalDeviceLimits& setFramebufferColorSampleCounts(SampleCountFlags framebufferColorSampleCounts_) {this->framebufferColorSampleCounts = framebufferColorSampleCounts_; return *this; }
    PhysicalDeviceLimits& setFramebufferDepthSampleCounts(SampleCountFlags framebufferDepthSampleCounts_) {this->framebufferDepthSampleCounts = framebufferDepthSampleCounts_; return *this; }
    PhysicalDeviceLimits& setFramebufferStencilSampleCounts(SampleCountFlags framebufferStencilSampleCounts_) {this->framebufferStencilSampleCounts = framebufferStencilSampleCounts_; return *this; }
    PhysicalDeviceLimits& setFramebufferNoAttachmentsSampleCounts(SampleCountFlags framebufferNoAttachmentsSampleCounts_) {this->framebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts_; return *this; }
    PhysicalDeviceLimits& setMaxColorAttachments(uint32_t maxColorAttachments_) {this->maxColorAttachments = maxColorAttachments_; return *this; }
    PhysicalDeviceLimits& setSampledImageColorSampleCounts(SampleCountFlags sampledImageColorSampleCounts_) {this->sampledImageColorSampleCounts = sampledImageColorSampleCounts_; return *this; }
    PhysicalDeviceLimits& setSampledImageIntegerSampleCounts(SampleCountFlags sampledImageIntegerSampleCounts_) {this->sampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts_; return *this; }
    PhysicalDeviceLimits& setSampledImageDepthSampleCounts(SampleCountFlags sampledImageDepthSampleCounts_) {this->sampledImageDepthSampleCounts = sampledImageDepthSampleCounts_; return *this; }
    PhysicalDeviceLimits& setSampledImageStencilSampleCounts(SampleCountFlags sampledImageStencilSampleCounts_) {this->sampledImageStencilSampleCounts = sampledImageStencilSampleCounts_; return *this; }
    PhysicalDeviceLimits& setStorageImageSampleCounts(SampleCountFlags storageImageSampleCounts_) {this->storageImageSampleCounts = storageImageSampleCounts_; return *this; }
    PhysicalDeviceLimits& setMaxSampleMaskWords(uint32_t maxSampleMaskWords_) {this->maxSampleMaskWords = maxSampleMaskWords_; return *this; }
    PhysicalDeviceLimits& setTimestampComputeAndGraphics(Bool32 timestampComputeAndGraphics_) {this->timestampComputeAndGraphics = timestampComputeAndGraphics_; return *this; }
    PhysicalDeviceLimits& setTimestampPeriod(float timestampPeriod_) {this->timestampPeriod = timestampPeriod_; return *this; }
    PhysicalDeviceLimits& setMaxClipDistances(uint32_t maxClipDistances_) {this->maxClipDistances = maxClipDistances_; return *this; }
    PhysicalDeviceLimits& setMaxCullDistances(uint32_t maxCullDistances_) {this->maxCullDistances = maxCullDistances_; return *this; }
    PhysicalDeviceLimits& setMaxCombinedClipAndCullDistances(uint32_t maxCombinedClipAndCullDistances_) {this->maxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances_; return *this; }
    PhysicalDeviceLimits& setDiscreteQueuePriorities(uint32_t discreteQueuePriorities_) {this->discreteQueuePriorities = discreteQueuePriorities_; return *this; }
    PhysicalDeviceLimits& setPointSizeRange(float pointSizeRange_[2]) {for(uint32_t i = 0; i < 2; i++) this->pointSizeRange[i] = pointSizeRange_[i]; return *this; }
    PhysicalDeviceLimits& setLineWidthRange(float lineWidthRange_[2]) {for(uint32_t i = 0; i < 2; i++) this->lineWidthRange[i] = lineWidthRange_[i]; return *this; }
    PhysicalDeviceLimits& setPointSizeGranularity(float pointSizeGranularity_) {this->pointSizeGranularity = pointSizeGranularity_; return *this; }
    PhysicalDeviceLimits& setLineWidthGranularity(float lineWidthGranularity_) {this->lineWidthGranularity = lineWidthGranularity_; return *this; }
    PhysicalDeviceLimits& setStrictLines(Bool32 strictLines_) {this->strictLines = strictLines_; return *this; }
    PhysicalDeviceLimits& setStandardSampleLocations(Bool32 standardSampleLocations_) {this->standardSampleLocations = standardSampleLocations_; return *this; }
    PhysicalDeviceLimits& setOptimalBufferCopyOffsetAlignment(DeviceSize optimalBufferCopyOffsetAlignment_) {this->optimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment_; return *this; }
    PhysicalDeviceLimits& setOptimalBufferCopyRowPitchAlignment(DeviceSize optimalBufferCopyRowPitchAlignment_) {this->optimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment_; return *this; }
    PhysicalDeviceLimits& setNonCoherentAtomSize(DeviceSize nonCoherentAtomSize_) {this->nonCoherentAtomSize = nonCoherentAtomSize_; return *this; }
};
struct PhysicalDeviceProperties {
    uint32_t apiVersion{0};
    uint32_t driverVersion{0};
    uint32_t vendorID{0};
    uint32_t deviceID{0};
    PhysicalDeviceType deviceType{static_cast<PhysicalDeviceType>(0)};
    char deviceName[MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t pipelineCacheUUID[UUID_SIZE];
    PhysicalDeviceLimits limits{};
    PhysicalDeviceSparseProperties sparseProperties{};
    constexpr bool operator==(PhysicalDeviceProperties const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 256; i++)
            is_equal &= deviceName[i] == value.deviceName[i];
        for(uint32_t i = 0; i < 16; i++)
            is_equal &= pipelineCacheUUID[i] == value.pipelineCacheUUID[i];
        return is_equal && apiVersion == value.apiVersion && driverVersion == value.driverVersion && vendorID == value.vendorID && deviceID == value.deviceID && deviceType == value.deviceType 
        && limits == value.limits && sparseProperties == value.sparseProperties ;}
    constexpr bool operator!=(PhysicalDeviceProperties const& value) const {return !(*this == value);}
    PhysicalDeviceProperties& setApiVersion(uint32_t apiVersion_) {this->apiVersion = apiVersion_; return *this; }
    PhysicalDeviceProperties& setDriverVersion(uint32_t driverVersion_) {this->driverVersion = driverVersion_; return *this; }
    PhysicalDeviceProperties& setVendorID(uint32_t vendorID_) {this->vendorID = vendorID_; return *this; }
    PhysicalDeviceProperties& setDeviceID(uint32_t deviceID_) {this->deviceID = deviceID_; return *this; }
    PhysicalDeviceProperties& setDeviceType(PhysicalDeviceType deviceType_) {this->deviceType = deviceType_; return *this; }
    PhysicalDeviceProperties& setDeviceName(char deviceName_[MAX_PHYSICAL_DEVICE_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_PHYSICAL_DEVICE_NAME_SIZE; i++) this->deviceName[i] = deviceName_[i]; return *this; }
    PhysicalDeviceProperties& setPipelineCacheUUID(uint8_t pipelineCacheUUID_[UUID_SIZE]) {for(uint32_t i = 0; i < UUID_SIZE; i++) this->pipelineCacheUUID[i] = pipelineCacheUUID_[i]; return *this; }
    PhysicalDeviceProperties& setLimits(PhysicalDeviceLimits limits_) {this->limits = limits_; return *this; }
    PhysicalDeviceProperties& setSparseProperties(PhysicalDeviceSparseProperties sparseProperties_) {this->sparseProperties = sparseProperties_; return *this; }
};
struct ExtensionProperties {
    char extensionName[MAX_EXTENSION_NAME_SIZE];
    uint32_t specVersion{0};
    constexpr bool operator==(ExtensionProperties const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 256; i++)
            is_equal &= extensionName[i] == value.extensionName[i];
        return is_equal && specVersion == value.specVersion ;}
    constexpr bool operator!=(ExtensionProperties const& value) const {return !(*this == value);}
    ExtensionProperties& setExtensionName(char extensionName_[MAX_EXTENSION_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_EXTENSION_NAME_SIZE; i++) this->extensionName[i] = extensionName_[i]; return *this; }
    ExtensionProperties& setSpecVersion(uint32_t specVersion_) {this->specVersion = specVersion_; return *this; }
};
struct LayerProperties {
    char layerName[MAX_EXTENSION_NAME_SIZE];
    uint32_t specVersion{0};
    uint32_t implementationVersion{0};
    char description[MAX_DESCRIPTION_SIZE];
    constexpr bool operator==(LayerProperties const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 256; i++)
            is_equal &= layerName[i] == value.layerName[i];
        for(uint32_t i = 0; i < 256; i++)
            is_equal &= description[i] == value.description[i];
        return is_equal && specVersion == value.specVersion && implementationVersion == value.implementationVersion ;}
    constexpr bool operator!=(LayerProperties const& value) const {return !(*this == value);}
    LayerProperties& setLayerName(char layerName_[MAX_EXTENSION_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_EXTENSION_NAME_SIZE; i++) this->layerName[i] = layerName_[i]; return *this; }
    LayerProperties& setSpecVersion(uint32_t specVersion_) {this->specVersion = specVersion_; return *this; }
    LayerProperties& setImplementationVersion(uint32_t implementationVersion_) {this->implementationVersion = implementationVersion_; return *this; }
    LayerProperties& setDescription(char description_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->description[i] = description_[i]; return *this; }
};
struct ApplicationInfo {
    StructureType sType{StructureType::ApplicationInfo};
    const void* pNext = nullptr;
    const char* pApplicationName = nullptr;
    uint32_t applicationVersion{0};
    const char* pEngineName = nullptr;
    uint32_t engineVersion{0};
    uint32_t apiVersion{0};
    ApplicationInfo& setPApplicationName(const char* pApplicationName_) {this->pApplicationName = pApplicationName_; return *this; }
    ApplicationInfo& setApplicationVersion(uint32_t applicationVersion_) {this->applicationVersion = applicationVersion_; return *this; }
    ApplicationInfo& setPEngineName(const char* pEngineName_) {this->pEngineName = pEngineName_; return *this; }
    ApplicationInfo& setEngineVersion(uint32_t engineVersion_) {this->engineVersion = engineVersion_; return *this; }
    ApplicationInfo& setApiVersion(uint32_t apiVersion_) {this->apiVersion = apiVersion_; return *this; }
};
struct AllocationCallbacks {
    void* pUserData = nullptr;
    PFN_AllocationFunction pfnAllocation{};
    PFN_ReallocationFunction pfnReallocation{};
    PFN_FreeFunction pfnFree{};
    PFN_InternalAllocationNotification pfnInternalAllocation{};
    PFN_InternalFreeNotification pfnInternalFree{};
    AllocationCallbacks& setPUserData(void* pUserData_) {this->pUserData = pUserData_; return *this; }
    AllocationCallbacks& setPfnAllocation(PFN_AllocationFunction pfnAllocation_) {this->pfnAllocation = pfnAllocation_; return *this; }
    AllocationCallbacks& setPfnReallocation(PFN_ReallocationFunction pfnReallocation_) {this->pfnReallocation = pfnReallocation_; return *this; }
    AllocationCallbacks& setPfnFree(PFN_FreeFunction pfnFree_) {this->pfnFree = pfnFree_; return *this; }
    AllocationCallbacks& setPfnInternalAllocation(PFN_InternalAllocationNotification pfnInternalAllocation_) {this->pfnInternalAllocation = pfnInternalAllocation_; return *this; }
    AllocationCallbacks& setPfnInternalFree(PFN_InternalFreeNotification pfnInternalFree_) {this->pfnInternalFree = pfnInternalFree_; return *this; }
};
struct DeviceQueueCreateInfo {
    StructureType sType{StructureType::DeviceQueueCreateInfo};
    const void* pNext = nullptr;
    DeviceQueueCreateFlags flags{};
    uint32_t queueFamilyIndex{0};
    uint32_t queueCount{0};
    const float* pQueuePriorities = nullptr;
    DeviceQueueCreateInfo& setFlags(DeviceQueueCreateFlags flags_) {this->flags = flags_; return *this; }
    DeviceQueueCreateInfo& setQueueFamilyIndex(uint32_t queueFamilyIndex_) {this->queueFamilyIndex = queueFamilyIndex_; return *this; }
    DeviceQueueCreateInfo& setQueueCount(uint32_t queueCount_) {this->queueCount = queueCount_; return *this; }
    DeviceQueueCreateInfo& setPQueuePriorities(const float* pQueuePriorities_) {this->pQueuePriorities = pQueuePriorities_; return *this; }
    DeviceQueueCreateInfo& setPQueuePriorities(detail::span<const float> pQueuePriorities_) {this->queueCount = pQueuePriorities_.size(); this->pQueuePriorities = pQueuePriorities_.data();  return *this; }
};
struct PhysicalDeviceFeatures {
    Bool32 robustBufferAccess{0};
    Bool32 fullDrawIndexUint32{0};
    Bool32 imageCubeArray{0};
    Bool32 independentBlend{0};
    Bool32 geometryShader{0};
    Bool32 tessellationShader{0};
    Bool32 sampleRateShading{0};
    Bool32 dualSrcBlend{0};
    Bool32 logicOp{0};
    Bool32 multiDrawIndirect{0};
    Bool32 drawIndirectFirstInstance{0};
    Bool32 depthClamp{0};
    Bool32 depthBiasClamp{0};
    Bool32 fillModeNonSolid{0};
    Bool32 depthBounds{0};
    Bool32 wideLines{0};
    Bool32 largePoints{0};
    Bool32 alphaToOne{0};
    Bool32 multiViewport{0};
    Bool32 samplerAnisotropy{0};
    Bool32 textureCompressionETC2{0};
    Bool32 textureCompressionASTC_LDR{0};
    Bool32 textureCompressionBC{0};
    Bool32 occlusionQueryPrecise{0};
    Bool32 pipelineStatisticsQuery{0};
    Bool32 vertexPipelineStoresAndAtomics{0};
    Bool32 fragmentStoresAndAtomics{0};
    Bool32 shaderTessellationAndGeometryPointSize{0};
    Bool32 shaderImageGatherExtended{0};
    Bool32 shaderStorageImageExtendedFormats{0};
    Bool32 shaderStorageImageMultisample{0};
    Bool32 shaderStorageImageReadWithoutFormat{0};
    Bool32 shaderStorageImageWriteWithoutFormat{0};
    Bool32 shaderUniformBufferArrayDynamicIndexing{0};
    Bool32 shaderSampledImageArrayDynamicIndexing{0};
    Bool32 shaderStorageBufferArrayDynamicIndexing{0};
    Bool32 shaderStorageImageArrayDynamicIndexing{0};
    Bool32 shaderClipDistance{0};
    Bool32 shaderCullDistance{0};
    Bool32 shaderFloat64{0};
    Bool32 shaderInt64{0};
    Bool32 shaderInt16{0};
    Bool32 shaderResourceResidency{0};
    Bool32 shaderResourceMinLod{0};
    Bool32 sparseBinding{0};
    Bool32 sparseResidencyBuffer{0};
    Bool32 sparseResidencyImage2D{0};
    Bool32 sparseResidencyImage3D{0};
    Bool32 sparseResidency2Samples{0};
    Bool32 sparseResidency4Samples{0};
    Bool32 sparseResidency8Samples{0};
    Bool32 sparseResidency16Samples{0};
    Bool32 sparseResidencyAliased{0};
    Bool32 variableMultisampleRate{0};
    Bool32 inheritedQueries{0};
    constexpr bool operator==(PhysicalDeviceFeatures const& value) const {
        return robustBufferAccess == value.robustBufferAccess && fullDrawIndexUint32 == value.fullDrawIndexUint32 && imageCubeArray == value.imageCubeArray 
        && independentBlend == value.independentBlend && geometryShader == value.geometryShader && tessellationShader == value.tessellationShader 
        && sampleRateShading == value.sampleRateShading && dualSrcBlend == value.dualSrcBlend && logicOp == value.logicOp && multiDrawIndirect == value.multiDrawIndirect 
        && drawIndirectFirstInstance == value.drawIndirectFirstInstance && depthClamp == value.depthClamp && depthBiasClamp == value.depthBiasClamp 
        && fillModeNonSolid == value.fillModeNonSolid && depthBounds == value.depthBounds && wideLines == value.wideLines && largePoints == value.largePoints 
        && alphaToOne == value.alphaToOne && multiViewport == value.multiViewport && samplerAnisotropy == value.samplerAnisotropy && textureCompressionETC2 == value.textureCompressionETC2 
        && textureCompressionASTC_LDR == value.textureCompressionASTC_LDR && textureCompressionBC == value.textureCompressionBC && occlusionQueryPrecise == value.occlusionQueryPrecise 
        && pipelineStatisticsQuery == value.pipelineStatisticsQuery && vertexPipelineStoresAndAtomics == value.vertexPipelineStoresAndAtomics 
        && fragmentStoresAndAtomics == value.fragmentStoresAndAtomics && shaderTessellationAndGeometryPointSize == value.shaderTessellationAndGeometryPointSize 
        && shaderImageGatherExtended == value.shaderImageGatherExtended && shaderStorageImageExtendedFormats == value.shaderStorageImageExtendedFormats 
        && shaderStorageImageMultisample == value.shaderStorageImageMultisample && shaderStorageImageReadWithoutFormat == value.shaderStorageImageReadWithoutFormat 
        && shaderStorageImageWriteWithoutFormat == value.shaderStorageImageWriteWithoutFormat && shaderUniformBufferArrayDynamicIndexing == value.shaderUniformBufferArrayDynamicIndexing 
        && shaderSampledImageArrayDynamicIndexing == value.shaderSampledImageArrayDynamicIndexing && shaderStorageBufferArrayDynamicIndexing == value.shaderStorageBufferArrayDynamicIndexing 
        && shaderStorageImageArrayDynamicIndexing == value.shaderStorageImageArrayDynamicIndexing && shaderClipDistance == value.shaderClipDistance 
        && shaderCullDistance == value.shaderCullDistance && shaderFloat64 == value.shaderFloat64 && shaderInt64 == value.shaderInt64 && shaderInt16 == value.shaderInt16 
        && shaderResourceResidency == value.shaderResourceResidency && shaderResourceMinLod == value.shaderResourceMinLod && sparseBinding == value.sparseBinding 
        && sparseResidencyBuffer == value.sparseResidencyBuffer && sparseResidencyImage2D == value.sparseResidencyImage2D && sparseResidencyImage3D == value.sparseResidencyImage3D 
        && sparseResidency2Samples == value.sparseResidency2Samples && sparseResidency4Samples == value.sparseResidency4Samples && sparseResidency8Samples == value.sparseResidency8Samples 
        && sparseResidency16Samples == value.sparseResidency16Samples && sparseResidencyAliased == value.sparseResidencyAliased && variableMultisampleRate == value.variableMultisampleRate 
        && inheritedQueries == value.inheritedQueries ;}
    constexpr bool operator!=(PhysicalDeviceFeatures const& value) const {return !(*this == value);}
    PhysicalDeviceFeatures& setRobustBufferAccess(Bool32 robustBufferAccess_) {this->robustBufferAccess = robustBufferAccess_; return *this; }
    PhysicalDeviceFeatures& setFullDrawIndexUint32(Bool32 fullDrawIndexUint32_) {this->fullDrawIndexUint32 = fullDrawIndexUint32_; return *this; }
    PhysicalDeviceFeatures& setImageCubeArray(Bool32 imageCubeArray_) {this->imageCubeArray = imageCubeArray_; return *this; }
    PhysicalDeviceFeatures& setIndependentBlend(Bool32 independentBlend_) {this->independentBlend = independentBlend_; return *this; }
    PhysicalDeviceFeatures& setGeometryShader(Bool32 geometryShader_) {this->geometryShader = geometryShader_; return *this; }
    PhysicalDeviceFeatures& setTessellationShader(Bool32 tessellationShader_) {this->tessellationShader = tessellationShader_; return *this; }
    PhysicalDeviceFeatures& setSampleRateShading(Bool32 sampleRateShading_) {this->sampleRateShading = sampleRateShading_; return *this; }
    PhysicalDeviceFeatures& setDualSrcBlend(Bool32 dualSrcBlend_) {this->dualSrcBlend = dualSrcBlend_; return *this; }
    PhysicalDeviceFeatures& setLogicOp(Bool32 logicOp_) {this->logicOp = logicOp_; return *this; }
    PhysicalDeviceFeatures& setMultiDrawIndirect(Bool32 multiDrawIndirect_) {this->multiDrawIndirect = multiDrawIndirect_; return *this; }
    PhysicalDeviceFeatures& setDrawIndirectFirstInstance(Bool32 drawIndirectFirstInstance_) {this->drawIndirectFirstInstance = drawIndirectFirstInstance_; return *this; }
    PhysicalDeviceFeatures& setDepthClamp(Bool32 depthClamp_) {this->depthClamp = depthClamp_; return *this; }
    PhysicalDeviceFeatures& setDepthBiasClamp(Bool32 depthBiasClamp_) {this->depthBiasClamp = depthBiasClamp_; return *this; }
    PhysicalDeviceFeatures& setFillModeNonSolid(Bool32 fillModeNonSolid_) {this->fillModeNonSolid = fillModeNonSolid_; return *this; }
    PhysicalDeviceFeatures& setDepthBounds(Bool32 depthBounds_) {this->depthBounds = depthBounds_; return *this; }
    PhysicalDeviceFeatures& setWideLines(Bool32 wideLines_) {this->wideLines = wideLines_; return *this; }
    PhysicalDeviceFeatures& setLargePoints(Bool32 largePoints_) {this->largePoints = largePoints_; return *this; }
    PhysicalDeviceFeatures& setAlphaToOne(Bool32 alphaToOne_) {this->alphaToOne = alphaToOne_; return *this; }
    PhysicalDeviceFeatures& setMultiViewport(Bool32 multiViewport_) {this->multiViewport = multiViewport_; return *this; }
    PhysicalDeviceFeatures& setSamplerAnisotropy(Bool32 samplerAnisotropy_) {this->samplerAnisotropy = samplerAnisotropy_; return *this; }
    PhysicalDeviceFeatures& setTextureCompressionETC2(Bool32 textureCompressionETC2_) {this->textureCompressionETC2 = textureCompressionETC2_; return *this; }
    PhysicalDeviceFeatures& setTextureCompressionASTC_LDR(Bool32 textureCompressionASTC_LDR_) {this->textureCompressionASTC_LDR = textureCompressionASTC_LDR_; return *this; }
    PhysicalDeviceFeatures& setTextureCompressionBC(Bool32 textureCompressionBC_) {this->textureCompressionBC = textureCompressionBC_; return *this; }
    PhysicalDeviceFeatures& setOcclusionQueryPrecise(Bool32 occlusionQueryPrecise_) {this->occlusionQueryPrecise = occlusionQueryPrecise_; return *this; }
    PhysicalDeviceFeatures& setPipelineStatisticsQuery(Bool32 pipelineStatisticsQuery_) {this->pipelineStatisticsQuery = pipelineStatisticsQuery_; return *this; }
    PhysicalDeviceFeatures& setVertexPipelineStoresAndAtomics(Bool32 vertexPipelineStoresAndAtomics_) {this->vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics_; return *this; }
    PhysicalDeviceFeatures& setFragmentStoresAndAtomics(Bool32 fragmentStoresAndAtomics_) {this->fragmentStoresAndAtomics = fragmentStoresAndAtomics_; return *this; }
    PhysicalDeviceFeatures& setShaderTessellationAndGeometryPointSize(Bool32 shaderTessellationAndGeometryPointSize_) {this->shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize_; return *this; }
    PhysicalDeviceFeatures& setShaderImageGatherExtended(Bool32 shaderImageGatherExtended_) {this->shaderImageGatherExtended = shaderImageGatherExtended_; return *this; }
    PhysicalDeviceFeatures& setShaderStorageImageExtendedFormats(Bool32 shaderStorageImageExtendedFormats_) {this->shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats_; return *this; }
    PhysicalDeviceFeatures& setShaderStorageImageMultisample(Bool32 shaderStorageImageMultisample_) {this->shaderStorageImageMultisample = shaderStorageImageMultisample_; return *this; }
    PhysicalDeviceFeatures& setShaderStorageImageReadWithoutFormat(Bool32 shaderStorageImageReadWithoutFormat_) {this->shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat_; return *this; }
    PhysicalDeviceFeatures& setShaderStorageImageWriteWithoutFormat(Bool32 shaderStorageImageWriteWithoutFormat_) {this->shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat_; return *this; }
    PhysicalDeviceFeatures& setShaderUniformBufferArrayDynamicIndexing(Bool32 shaderUniformBufferArrayDynamicIndexing_) {this->shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing_; return *this; }
    PhysicalDeviceFeatures& setShaderSampledImageArrayDynamicIndexing(Bool32 shaderSampledImageArrayDynamicIndexing_) {this->shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing_; return *this; }
    PhysicalDeviceFeatures& setShaderStorageBufferArrayDynamicIndexing(Bool32 shaderStorageBufferArrayDynamicIndexing_) {this->shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing_; return *this; }
    PhysicalDeviceFeatures& setShaderStorageImageArrayDynamicIndexing(Bool32 shaderStorageImageArrayDynamicIndexing_) {this->shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing_; return *this; }
    PhysicalDeviceFeatures& setShaderClipDistance(Bool32 shaderClipDistance_) {this->shaderClipDistance = shaderClipDistance_; return *this; }
    PhysicalDeviceFeatures& setShaderCullDistance(Bool32 shaderCullDistance_) {this->shaderCullDistance = shaderCullDistance_; return *this; }
    PhysicalDeviceFeatures& setShaderFloat64(Bool32 shaderFloat64_) {this->shaderFloat64 = shaderFloat64_; return *this; }
    PhysicalDeviceFeatures& setShaderInt64(Bool32 shaderInt64_) {this->shaderInt64 = shaderInt64_; return *this; }
    PhysicalDeviceFeatures& setShaderInt16(Bool32 shaderInt16_) {this->shaderInt16 = shaderInt16_; return *this; }
    PhysicalDeviceFeatures& setShaderResourceResidency(Bool32 shaderResourceResidency_) {this->shaderResourceResidency = shaderResourceResidency_; return *this; }
    PhysicalDeviceFeatures& setShaderResourceMinLod(Bool32 shaderResourceMinLod_) {this->shaderResourceMinLod = shaderResourceMinLod_; return *this; }
    PhysicalDeviceFeatures& setSparseBinding(Bool32 sparseBinding_) {this->sparseBinding = sparseBinding_; return *this; }
    PhysicalDeviceFeatures& setSparseResidencyBuffer(Bool32 sparseResidencyBuffer_) {this->sparseResidencyBuffer = sparseResidencyBuffer_; return *this; }
    PhysicalDeviceFeatures& setSparseResidencyImage2D(Bool32 sparseResidencyImage2D_) {this->sparseResidencyImage2D = sparseResidencyImage2D_; return *this; }
    PhysicalDeviceFeatures& setSparseResidencyImage3D(Bool32 sparseResidencyImage3D_) {this->sparseResidencyImage3D = sparseResidencyImage3D_; return *this; }
    PhysicalDeviceFeatures& setSparseResidency2Samples(Bool32 sparseResidency2Samples_) {this->sparseResidency2Samples = sparseResidency2Samples_; return *this; }
    PhysicalDeviceFeatures& setSparseResidency4Samples(Bool32 sparseResidency4Samples_) {this->sparseResidency4Samples = sparseResidency4Samples_; return *this; }
    PhysicalDeviceFeatures& setSparseResidency8Samples(Bool32 sparseResidency8Samples_) {this->sparseResidency8Samples = sparseResidency8Samples_; return *this; }
    PhysicalDeviceFeatures& setSparseResidency16Samples(Bool32 sparseResidency16Samples_) {this->sparseResidency16Samples = sparseResidency16Samples_; return *this; }
    PhysicalDeviceFeatures& setSparseResidencyAliased(Bool32 sparseResidencyAliased_) {this->sparseResidencyAliased = sparseResidencyAliased_; return *this; }
    PhysicalDeviceFeatures& setVariableMultisampleRate(Bool32 variableMultisampleRate_) {this->variableMultisampleRate = variableMultisampleRate_; return *this; }
    PhysicalDeviceFeatures& setInheritedQueries(Bool32 inheritedQueries_) {this->inheritedQueries = inheritedQueries_; return *this; }
};
struct DeviceCreateInfo {
    StructureType sType{StructureType::DeviceCreateInfo};
    const void* pNext = nullptr;
    DeviceCreateFlags flags{};
    uint32_t queueCreateInfoCount{0};
    const DeviceQueueCreateInfo* pQueueCreateInfos = nullptr;
/*deprecated*/    uint32_t enabledLayerCount{0};
/*deprecated*/    const char* const* ppEnabledLayerNames = nullptr;
    uint32_t enabledExtensionCount{0};
    const char* const* ppEnabledExtensionNames = nullptr;
    const PhysicalDeviceFeatures* pEnabledFeatures = nullptr;
    DeviceCreateInfo& setFlags(DeviceCreateFlags flags_) {this->flags = flags_; return *this; }
    DeviceCreateInfo& setQueueCreateInfoCount(uint32_t queueCreateInfoCount_) {this->queueCreateInfoCount = queueCreateInfoCount_; return *this; }
    DeviceCreateInfo& setPQueueCreateInfos(const DeviceQueueCreateInfo* pQueueCreateInfos_) {this->pQueueCreateInfos = pQueueCreateInfos_; return *this; }
    DeviceCreateInfo& setPQueueCreateInfos(detail::span<const DeviceQueueCreateInfo> pQueueCreateInfos_) {this->queueCreateInfoCount = pQueueCreateInfos_.size(); this->pQueueCreateInfos = pQueueCreateInfos_.data();  return *this; }
    DeviceCreateInfo& setEnabledExtensionCount(uint32_t enabledExtensionCount_) {this->enabledExtensionCount = enabledExtensionCount_; return *this; }
    DeviceCreateInfo& setPpEnabledExtensionNames(const char* const* ppEnabledExtensionNames_) {this->ppEnabledExtensionNames = ppEnabledExtensionNames_; return *this; }
    DeviceCreateInfo& setpEnabledExtensionNames(detail::span<const char*> pEnabledExtensionNames_) { this->enabledExtensionCount = pEnabledExtensionNames_.size(); this->ppEnabledExtensionNames = pEnabledExtensionNames_.data();  return *this; }
    DeviceCreateInfo& setPEnabledFeatures(const PhysicalDeviceFeatures* pEnabledFeatures_) {this->pEnabledFeatures = pEnabledFeatures_; return *this; }
    DeviceCreateInfo& setPEnabledFeatures(PhysicalDeviceFeatures const& pEnabledFeatures_) {this->pEnabledFeatures = &pEnabledFeatures_; return *this; }
};
struct InstanceCreateInfo {
    StructureType sType{StructureType::InstanceCreateInfo};
    const void* pNext = nullptr;
    InstanceCreateFlags flags{};
    const ApplicationInfo* pApplicationInfo = nullptr;
    uint32_t enabledLayerCount{0};
    const char* const* ppEnabledLayerNames = nullptr;
    uint32_t enabledExtensionCount{0};
    const char* const* ppEnabledExtensionNames = nullptr;
    InstanceCreateInfo& setFlags(InstanceCreateFlags flags_) {this->flags = flags_; return *this; }
    InstanceCreateInfo& setPApplicationInfo(const ApplicationInfo* pApplicationInfo_) {this->pApplicationInfo = pApplicationInfo_; return *this; }
    InstanceCreateInfo& setPApplicationInfo(ApplicationInfo const& pApplicationInfo_) {this->pApplicationInfo = &pApplicationInfo_; return *this; }
    InstanceCreateInfo& setEnabledLayerCount(uint32_t enabledLayerCount_) {this->enabledLayerCount = enabledLayerCount_; return *this; }
    InstanceCreateInfo& setPpEnabledLayerNames(const char* const* ppEnabledLayerNames_) {this->ppEnabledLayerNames = ppEnabledLayerNames_; return *this; }
    InstanceCreateInfo& setpEnabledLayerNames(detail::span<const char*> pEnabledLayerNames_) { this->enabledLayerCount = pEnabledLayerNames_.size(); this->ppEnabledLayerNames = pEnabledLayerNames_.data();  return *this; }
    InstanceCreateInfo& setEnabledExtensionCount(uint32_t enabledExtensionCount_) {this->enabledExtensionCount = enabledExtensionCount_; return *this; }
    InstanceCreateInfo& setPpEnabledExtensionNames(const char* const* ppEnabledExtensionNames_) {this->ppEnabledExtensionNames = ppEnabledExtensionNames_; return *this; }
    InstanceCreateInfo& setpEnabledExtensionNames(detail::span<const char*> pEnabledExtensionNames_) { this->enabledExtensionCount = pEnabledExtensionNames_.size(); this->ppEnabledExtensionNames = pEnabledExtensionNames_.data();  return *this; }
};
struct QueueFamilyProperties {
    QueueFlags queueFlags{};
    uint32_t queueCount{0};
    uint32_t timestampValidBits{0};
    Extent3D minImageTransferGranularity{};
    constexpr bool operator==(QueueFamilyProperties const& value) const {
        return queueFlags == value.queueFlags && queueCount == value.queueCount && timestampValidBits == value.timestampValidBits && minImageTransferGranularity == value.minImageTransferGranularity 
        ;}
    constexpr bool operator!=(QueueFamilyProperties const& value) const {return !(*this == value);}
    QueueFamilyProperties& setQueueFlags(QueueFlags queueFlags_) {this->queueFlags = queueFlags_; return *this; }
    QueueFamilyProperties& setQueueCount(uint32_t queueCount_) {this->queueCount = queueCount_; return *this; }
    QueueFamilyProperties& setTimestampValidBits(uint32_t timestampValidBits_) {this->timestampValidBits = timestampValidBits_; return *this; }
    QueueFamilyProperties& setMinImageTransferGranularity(Extent3D minImageTransferGranularity_) {this->minImageTransferGranularity = minImageTransferGranularity_; return *this; }
};
struct MemoryHeap {
    DeviceSize size{0};
    MemoryHeapFlags flags{};
    constexpr bool operator==(MemoryHeap const& value) const {
        return size == value.size && flags == value.flags ;}
    constexpr bool operator!=(MemoryHeap const& value) const {return !(*this == value);}
    MemoryHeap& setSize(DeviceSize size_) {this->size = size_; return *this; }
    MemoryHeap& setFlags(MemoryHeapFlags flags_) {this->flags = flags_; return *this; }
};
struct MemoryType {
    MemoryPropertyFlags propertyFlags{};
    uint32_t heapIndex{0};
    constexpr bool operator==(MemoryType const& value) const {
        return propertyFlags == value.propertyFlags && heapIndex == value.heapIndex ;}
    constexpr bool operator!=(MemoryType const& value) const {return !(*this == value);}
    MemoryType& setPropertyFlags(MemoryPropertyFlags propertyFlags_) {this->propertyFlags = propertyFlags_; return *this; }
    MemoryType& setHeapIndex(uint32_t heapIndex_) {this->heapIndex = heapIndex_; return *this; }
};
struct PhysicalDeviceMemoryProperties {
    uint32_t memoryTypeCount{0};
    MemoryType memoryTypes[MAX_MEMORY_TYPES];
    uint32_t memoryHeapCount{0};
    MemoryHeap memoryHeaps[MAX_MEMORY_HEAPS];
    constexpr bool operator==(PhysicalDeviceMemoryProperties const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 32; i++)
            is_equal &= memoryTypes[i] == value.memoryTypes[i];
        for(uint32_t i = 0; i < 16; i++)
            is_equal &= memoryHeaps[i] == value.memoryHeaps[i];
        return is_equal && memoryTypeCount == value.memoryTypeCount && memoryHeapCount == value.memoryHeapCount ;}
    constexpr bool operator!=(PhysicalDeviceMemoryProperties const& value) const {return !(*this == value);}
    PhysicalDeviceMemoryProperties& setMemoryTypeCount(uint32_t memoryTypeCount_) {this->memoryTypeCount = memoryTypeCount_; return *this; }
    PhysicalDeviceMemoryProperties& setMemoryTypes(MemoryType memoryTypes_[MAX_MEMORY_TYPES]) {for(uint32_t i = 0; i < MAX_MEMORY_TYPES; i++) this->memoryTypes[i] = memoryTypes_[i]; return *this; }
    PhysicalDeviceMemoryProperties& setMemoryHeapCount(uint32_t memoryHeapCount_) {this->memoryHeapCount = memoryHeapCount_; return *this; }
    PhysicalDeviceMemoryProperties& setMemoryHeaps(MemoryHeap memoryHeaps_[MAX_MEMORY_HEAPS]) {for(uint32_t i = 0; i < MAX_MEMORY_HEAPS; i++) this->memoryHeaps[i] = memoryHeaps_[i]; return *this; }
};
struct MemoryAllocateInfo {
    StructureType sType{StructureType::MemoryAllocateInfo};
    const void* pNext = nullptr;
    DeviceSize allocationSize{0};
    uint32_t memoryTypeIndex{0};
    MemoryAllocateInfo& setAllocationSize(DeviceSize allocationSize_) {this->allocationSize = allocationSize_; return *this; }
    MemoryAllocateInfo& setMemoryTypeIndex(uint32_t memoryTypeIndex_) {this->memoryTypeIndex = memoryTypeIndex_; return *this; }
};
struct MemoryRequirements {
    DeviceSize size{0};
    DeviceSize alignment{0};
    uint32_t memoryTypeBits{0};
    constexpr bool operator==(MemoryRequirements const& value) const {
        return size == value.size && alignment == value.alignment && memoryTypeBits == value.memoryTypeBits ;}
    constexpr bool operator!=(MemoryRequirements const& value) const {return !(*this == value);}
    MemoryRequirements& setSize(DeviceSize size_) {this->size = size_; return *this; }
    MemoryRequirements& setAlignment(DeviceSize alignment_) {this->alignment = alignment_; return *this; }
    MemoryRequirements& setMemoryTypeBits(uint32_t memoryTypeBits_) {this->memoryTypeBits = memoryTypeBits_; return *this; }
};
struct SparseImageFormatProperties {
    ImageAspectFlags aspectMask{};
    Extent3D imageGranularity{};
    SparseImageFormatFlags flags{};
    constexpr bool operator==(SparseImageFormatProperties const& value) const {
        return aspectMask == value.aspectMask && imageGranularity == value.imageGranularity && flags == value.flags ;}
    constexpr bool operator!=(SparseImageFormatProperties const& value) const {return !(*this == value);}
    SparseImageFormatProperties& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
    SparseImageFormatProperties& setImageGranularity(Extent3D imageGranularity_) {this->imageGranularity = imageGranularity_; return *this; }
    SparseImageFormatProperties& setFlags(SparseImageFormatFlags flags_) {this->flags = flags_; return *this; }
};
struct SparseImageMemoryRequirements {
    SparseImageFormatProperties formatProperties{};
    uint32_t imageMipTailFirstLod{0};
    DeviceSize imageMipTailSize{0};
    DeviceSize imageMipTailOffset{0};
    DeviceSize imageMipTailStride{0};
    constexpr bool operator==(SparseImageMemoryRequirements const& value) const {
        return formatProperties == value.formatProperties && imageMipTailFirstLod == value.imageMipTailFirstLod && imageMipTailSize == value.imageMipTailSize 
        && imageMipTailOffset == value.imageMipTailOffset && imageMipTailStride == value.imageMipTailStride ;}
    constexpr bool operator!=(SparseImageMemoryRequirements const& value) const {return !(*this == value);}
    SparseImageMemoryRequirements& setFormatProperties(SparseImageFormatProperties formatProperties_) {this->formatProperties = formatProperties_; return *this; }
    SparseImageMemoryRequirements& setImageMipTailFirstLod(uint32_t imageMipTailFirstLod_) {this->imageMipTailFirstLod = imageMipTailFirstLod_; return *this; }
    SparseImageMemoryRequirements& setImageMipTailSize(DeviceSize imageMipTailSize_) {this->imageMipTailSize = imageMipTailSize_; return *this; }
    SparseImageMemoryRequirements& setImageMipTailOffset(DeviceSize imageMipTailOffset_) {this->imageMipTailOffset = imageMipTailOffset_; return *this; }
    SparseImageMemoryRequirements& setImageMipTailStride(DeviceSize imageMipTailStride_) {this->imageMipTailStride = imageMipTailStride_; return *this; }
};
struct MappedMemoryRange {
    StructureType sType{StructureType::MappedMemoryRange};
    const void* pNext = nullptr;
    DeviceMemory memory{};
    DeviceSize offset{0};
    DeviceSize size{0};
    MappedMemoryRange& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    MappedMemoryRange& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    MappedMemoryRange& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
struct FormatProperties {
    FormatFeatureFlags linearTilingFeatures{};
    FormatFeatureFlags optimalTilingFeatures{};
    FormatFeatureFlags bufferFeatures{};
    constexpr bool operator==(FormatProperties const& value) const {
        return linearTilingFeatures == value.linearTilingFeatures && optimalTilingFeatures == value.optimalTilingFeatures && bufferFeatures == value.bufferFeatures 
        ;}
    constexpr bool operator!=(FormatProperties const& value) const {return !(*this == value);}
    FormatProperties& setLinearTilingFeatures(FormatFeatureFlags linearTilingFeatures_) {this->linearTilingFeatures = linearTilingFeatures_; return *this; }
    FormatProperties& setOptimalTilingFeatures(FormatFeatureFlags optimalTilingFeatures_) {this->optimalTilingFeatures = optimalTilingFeatures_; return *this; }
    FormatProperties& setBufferFeatures(FormatFeatureFlags bufferFeatures_) {this->bufferFeatures = bufferFeatures_; return *this; }
};
struct ImageFormatProperties {
    Extent3D maxExtent{};
    uint32_t maxMipLevels{0};
    uint32_t maxArrayLayers{0};
    SampleCountFlags sampleCounts{};
    DeviceSize maxResourceSize{0};
    constexpr bool operator==(ImageFormatProperties const& value) const {
        return maxExtent == value.maxExtent && maxMipLevels == value.maxMipLevels && maxArrayLayers == value.maxArrayLayers && sampleCounts == value.sampleCounts 
        && maxResourceSize == value.maxResourceSize ;}
    constexpr bool operator!=(ImageFormatProperties const& value) const {return !(*this == value);}
    ImageFormatProperties& setMaxExtent(Extent3D maxExtent_) {this->maxExtent = maxExtent_; return *this; }
    ImageFormatProperties& setMaxMipLevels(uint32_t maxMipLevels_) {this->maxMipLevels = maxMipLevels_; return *this; }
    ImageFormatProperties& setMaxArrayLayers(uint32_t maxArrayLayers_) {this->maxArrayLayers = maxArrayLayers_; return *this; }
    ImageFormatProperties& setSampleCounts(SampleCountFlags sampleCounts_) {this->sampleCounts = sampleCounts_; return *this; }
    ImageFormatProperties& setMaxResourceSize(DeviceSize maxResourceSize_) {this->maxResourceSize = maxResourceSize_; return *this; }
};
struct DescriptorBufferInfo {
    Buffer buffer{};
    DeviceSize offset{0};
    DeviceSize range{0};
    DescriptorBufferInfo& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    DescriptorBufferInfo& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    DescriptorBufferInfo& setRange(DeviceSize range_) {this->range = range_; return *this; }
};
struct DescriptorImageInfo {
    Sampler sampler{};
    ImageView imageView{};
    ImageLayout imageLayout{static_cast<ImageLayout>(0)};
    DescriptorImageInfo& setSampler(Sampler sampler_) {this->sampler = sampler_; return *this; }
    DescriptorImageInfo& setImageView(ImageView imageView_) {this->imageView = imageView_; return *this; }
    DescriptorImageInfo& setImageLayout(ImageLayout imageLayout_) {this->imageLayout = imageLayout_; return *this; }
};
struct WriteDescriptorSet {
    StructureType sType{StructureType::WriteDescriptorSet};
    const void* pNext = nullptr;
    DescriptorSet dstSet{};
    uint32_t dstBinding{0};
    uint32_t dstArrayElement{0};
    uint32_t descriptorCount{0};
    DescriptorType descriptorType{static_cast<DescriptorType>(0)};
    const DescriptorImageInfo* pImageInfo = nullptr;
    const DescriptorBufferInfo* pBufferInfo = nullptr;
    const BufferView* pTexelBufferView = nullptr;
    WriteDescriptorSet& setDstSet(DescriptorSet dstSet_) {this->dstSet = dstSet_; return *this; }
    WriteDescriptorSet& setDstBinding(uint32_t dstBinding_) {this->dstBinding = dstBinding_; return *this; }
    WriteDescriptorSet& setDstArrayElement(uint32_t dstArrayElement_) {this->dstArrayElement = dstArrayElement_; return *this; }
    WriteDescriptorSet& setDescriptorCount(uint32_t descriptorCount_) {this->descriptorCount = descriptorCount_; return *this; }
    WriteDescriptorSet& setDescriptorType(DescriptorType descriptorType_) {this->descriptorType = descriptorType_; return *this; }
    WriteDescriptorSet& setPImageInfo(const DescriptorImageInfo* pImageInfo_) {this->pImageInfo = pImageInfo_; return *this; }
    WriteDescriptorSet& setPImageInfo(detail::span<const DescriptorImageInfo> pImageInfo_) {this->descriptorCount = pImageInfo_.size(); this->pImageInfo = pImageInfo_.data();  return *this; }
    WriteDescriptorSet& setPBufferInfo(const DescriptorBufferInfo* pBufferInfo_) {this->pBufferInfo = pBufferInfo_; return *this; }
    WriteDescriptorSet& setPBufferInfo(detail::span<const DescriptorBufferInfo> pBufferInfo_) {this->descriptorCount = pBufferInfo_.size(); this->pBufferInfo = pBufferInfo_.data();  return *this; }
    WriteDescriptorSet& setPTexelBufferView(const BufferView* pTexelBufferView_) {this->pTexelBufferView = pTexelBufferView_; return *this; }
    WriteDescriptorSet& setPTexelBufferView(detail::span<const BufferView> pTexelBufferView_) {this->descriptorCount = pTexelBufferView_.size(); this->pTexelBufferView = pTexelBufferView_.data();  return *this; }
};
struct CopyDescriptorSet {
    StructureType sType{StructureType::CopyDescriptorSet};
    const void* pNext = nullptr;
    DescriptorSet srcSet{};
    uint32_t srcBinding{0};
    uint32_t srcArrayElement{0};
    DescriptorSet dstSet{};
    uint32_t dstBinding{0};
    uint32_t dstArrayElement{0};
    uint32_t descriptorCount{0};
    CopyDescriptorSet& setSrcSet(DescriptorSet srcSet_) {this->srcSet = srcSet_; return *this; }
    CopyDescriptorSet& setSrcBinding(uint32_t srcBinding_) {this->srcBinding = srcBinding_; return *this; }
    CopyDescriptorSet& setSrcArrayElement(uint32_t srcArrayElement_) {this->srcArrayElement = srcArrayElement_; return *this; }
    CopyDescriptorSet& setDstSet(DescriptorSet dstSet_) {this->dstSet = dstSet_; return *this; }
    CopyDescriptorSet& setDstBinding(uint32_t dstBinding_) {this->dstBinding = dstBinding_; return *this; }
    CopyDescriptorSet& setDstArrayElement(uint32_t dstArrayElement_) {this->dstArrayElement = dstArrayElement_; return *this; }
    CopyDescriptorSet& setDescriptorCount(uint32_t descriptorCount_) {this->descriptorCount = descriptorCount_; return *this; }
};
struct BufferCreateInfo {
    StructureType sType{StructureType::BufferCreateInfo};
    const void* pNext = nullptr;
    BufferCreateFlags flags{};
    DeviceSize size{0};
    BufferUsageFlags usage{};
    SharingMode sharingMode{static_cast<SharingMode>(0)};
    uint32_t queueFamilyIndexCount{0};
    const uint32_t* pQueueFamilyIndices = nullptr;
    BufferCreateInfo& setFlags(BufferCreateFlags flags_) {this->flags = flags_; return *this; }
    BufferCreateInfo& setSize(DeviceSize size_) {this->size = size_; return *this; }
    BufferCreateInfo& setUsage(BufferUsageFlags usage_) {this->usage = usage_; return *this; }
    BufferCreateInfo& setSharingMode(SharingMode sharingMode_) {this->sharingMode = sharingMode_; return *this; }
    BufferCreateInfo& setQueueFamilyIndexCount(uint32_t queueFamilyIndexCount_) {this->queueFamilyIndexCount = queueFamilyIndexCount_; return *this; }
    BufferCreateInfo& setPQueueFamilyIndices(const uint32_t* pQueueFamilyIndices_) {this->pQueueFamilyIndices = pQueueFamilyIndices_; return *this; }
    BufferCreateInfo& setPQueueFamilyIndices(detail::span<const uint32_t> pQueueFamilyIndices_) {this->queueFamilyIndexCount = pQueueFamilyIndices_.size(); this->pQueueFamilyIndices = pQueueFamilyIndices_.data();  return *this; }
};
struct BufferViewCreateInfo {
    StructureType sType{StructureType::BufferViewCreateInfo};
    const void* pNext = nullptr;
    BufferViewCreateFlags flags{};
    Buffer buffer{};
    Format format{static_cast<Format>(0)};
    DeviceSize offset{0};
    DeviceSize range{0};
    BufferViewCreateInfo& setFlags(BufferViewCreateFlags flags_) {this->flags = flags_; return *this; }
    BufferViewCreateInfo& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    BufferViewCreateInfo& setFormat(Format format_) {this->format = format_; return *this; }
    BufferViewCreateInfo& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    BufferViewCreateInfo& setRange(DeviceSize range_) {this->range = range_; return *this; }
};
struct ImageSubresource {
    ImageAspectFlags aspectMask{};
    uint32_t mipLevel{0};
    uint32_t arrayLayer{0};
    constexpr bool operator==(ImageSubresource const& value) const {
        return aspectMask == value.aspectMask && mipLevel == value.mipLevel && arrayLayer == value.arrayLayer ;}
    constexpr bool operator!=(ImageSubresource const& value) const {return !(*this == value);}
    ImageSubresource& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
    ImageSubresource& setMipLevel(uint32_t mipLevel_) {this->mipLevel = mipLevel_; return *this; }
    ImageSubresource& setArrayLayer(uint32_t arrayLayer_) {this->arrayLayer = arrayLayer_; return *this; }
};
struct ImageSubresourceLayers {
    ImageAspectFlags aspectMask{};
    uint32_t mipLevel{0};
    uint32_t baseArrayLayer{0};
    uint32_t layerCount{0};
    constexpr bool operator==(ImageSubresourceLayers const& value) const {
        return aspectMask == value.aspectMask && mipLevel == value.mipLevel && baseArrayLayer == value.baseArrayLayer && layerCount == value.layerCount 
        ;}
    constexpr bool operator!=(ImageSubresourceLayers const& value) const {return !(*this == value);}
    ImageSubresourceLayers& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
    ImageSubresourceLayers& setMipLevel(uint32_t mipLevel_) {this->mipLevel = mipLevel_; return *this; }
    ImageSubresourceLayers& setBaseArrayLayer(uint32_t baseArrayLayer_) {this->baseArrayLayer = baseArrayLayer_; return *this; }
    ImageSubresourceLayers& setLayerCount(uint32_t layerCount_) {this->layerCount = layerCount_; return *this; }
};
struct ImageSubresourceRange {
    ImageAspectFlags aspectMask{};
    uint32_t baseMipLevel{0};
    uint32_t levelCount{0};
    uint32_t baseArrayLayer{0};
    uint32_t layerCount{0};
    constexpr bool operator==(ImageSubresourceRange const& value) const {
        return aspectMask == value.aspectMask && baseMipLevel == value.baseMipLevel && levelCount == value.levelCount && baseArrayLayer == value.baseArrayLayer 
        && layerCount == value.layerCount ;}
    constexpr bool operator!=(ImageSubresourceRange const& value) const {return !(*this == value);}
    ImageSubresourceRange& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
    ImageSubresourceRange& setBaseMipLevel(uint32_t baseMipLevel_) {this->baseMipLevel = baseMipLevel_; return *this; }
    ImageSubresourceRange& setLevelCount(uint32_t levelCount_) {this->levelCount = levelCount_; return *this; }
    ImageSubresourceRange& setBaseArrayLayer(uint32_t baseArrayLayer_) {this->baseArrayLayer = baseArrayLayer_; return *this; }
    ImageSubresourceRange& setLayerCount(uint32_t layerCount_) {this->layerCount = layerCount_; return *this; }
};
struct MemoryBarrier {
    StructureType sType{StructureType::MemoryBarrier};
    const void* pNext = nullptr;
    AccessFlags srcAccessMask{};
    AccessFlags dstAccessMask{};
    MemoryBarrier& setSrcAccessMask(AccessFlags srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    MemoryBarrier& setDstAccessMask(AccessFlags dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
};
struct BufferMemoryBarrier {
    StructureType sType{StructureType::BufferMemoryBarrier};
    const void* pNext = nullptr;
    AccessFlags srcAccessMask{};
    AccessFlags dstAccessMask{};
    uint32_t srcQueueFamilyIndex{0};
    uint32_t dstQueueFamilyIndex{0};
    Buffer buffer{};
    DeviceSize offset{0};
    DeviceSize size{0};
    BufferMemoryBarrier& setSrcAccessMask(AccessFlags srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    BufferMemoryBarrier& setDstAccessMask(AccessFlags dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
    BufferMemoryBarrier& setSrcQueueFamilyIndex(uint32_t srcQueueFamilyIndex_) {this->srcQueueFamilyIndex = srcQueueFamilyIndex_; return *this; }
    BufferMemoryBarrier& setDstQueueFamilyIndex(uint32_t dstQueueFamilyIndex_) {this->dstQueueFamilyIndex = dstQueueFamilyIndex_; return *this; }
    BufferMemoryBarrier& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    BufferMemoryBarrier& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    BufferMemoryBarrier& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
struct ImageMemoryBarrier {
    StructureType sType{StructureType::ImageMemoryBarrier};
    const void* pNext = nullptr;
    AccessFlags srcAccessMask{};
    AccessFlags dstAccessMask{};
    ImageLayout oldLayout{static_cast<ImageLayout>(0)};
    ImageLayout newLayout{static_cast<ImageLayout>(0)};
    uint32_t srcQueueFamilyIndex{0};
    uint32_t dstQueueFamilyIndex{0};
    Image image{};
    ImageSubresourceRange subresourceRange{};
    ImageMemoryBarrier& setSrcAccessMask(AccessFlags srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    ImageMemoryBarrier& setDstAccessMask(AccessFlags dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
    ImageMemoryBarrier& setOldLayout(ImageLayout oldLayout_) {this->oldLayout = oldLayout_; return *this; }
    ImageMemoryBarrier& setNewLayout(ImageLayout newLayout_) {this->newLayout = newLayout_; return *this; }
    ImageMemoryBarrier& setSrcQueueFamilyIndex(uint32_t srcQueueFamilyIndex_) {this->srcQueueFamilyIndex = srcQueueFamilyIndex_; return *this; }
    ImageMemoryBarrier& setDstQueueFamilyIndex(uint32_t dstQueueFamilyIndex_) {this->dstQueueFamilyIndex = dstQueueFamilyIndex_; return *this; }
    ImageMemoryBarrier& setImage(Image image_) {this->image = image_; return *this; }
    ImageMemoryBarrier& setSubresourceRange(ImageSubresourceRange subresourceRange_) {this->subresourceRange = subresourceRange_; return *this; }
};
struct ImageCreateInfo {
    StructureType sType{StructureType::ImageCreateInfo};
    const void* pNext = nullptr;
    ImageCreateFlags flags{};
    ImageType imageType{static_cast<ImageType>(0)};
    Format format{static_cast<Format>(0)};
    Extent3D extent{};
    uint32_t mipLevels{0};
    uint32_t arrayLayers{0};
    SampleCountFlagBits samples{static_cast<SampleCountFlagBits>(0)};
    ImageTiling tiling{static_cast<ImageTiling>(0)};
    ImageUsageFlags usage{};
    SharingMode sharingMode{static_cast<SharingMode>(0)};
    uint32_t queueFamilyIndexCount{0};
    const uint32_t* pQueueFamilyIndices = nullptr;
    ImageLayout initialLayout{static_cast<ImageLayout>(0)};
    ImageCreateInfo& setFlags(ImageCreateFlags flags_) {this->flags = flags_; return *this; }
    ImageCreateInfo& setImageType(ImageType imageType_) {this->imageType = imageType_; return *this; }
    ImageCreateInfo& setFormat(Format format_) {this->format = format_; return *this; }
    ImageCreateInfo& setExtent(Extent3D extent_) {this->extent = extent_; return *this; }
    ImageCreateInfo& setMipLevels(uint32_t mipLevels_) {this->mipLevels = mipLevels_; return *this; }
    ImageCreateInfo& setArrayLayers(uint32_t arrayLayers_) {this->arrayLayers = arrayLayers_; return *this; }
    ImageCreateInfo& setSamples(SampleCountFlagBits samples_) {this->samples = samples_; return *this; }
    ImageCreateInfo& setTiling(ImageTiling tiling_) {this->tiling = tiling_; return *this; }
    ImageCreateInfo& setUsage(ImageUsageFlags usage_) {this->usage = usage_; return *this; }
    ImageCreateInfo& setSharingMode(SharingMode sharingMode_) {this->sharingMode = sharingMode_; return *this; }
    ImageCreateInfo& setQueueFamilyIndexCount(uint32_t queueFamilyIndexCount_) {this->queueFamilyIndexCount = queueFamilyIndexCount_; return *this; }
    ImageCreateInfo& setPQueueFamilyIndices(const uint32_t* pQueueFamilyIndices_) {this->pQueueFamilyIndices = pQueueFamilyIndices_; return *this; }
    ImageCreateInfo& setPQueueFamilyIndices(detail::span<const uint32_t> pQueueFamilyIndices_) {this->queueFamilyIndexCount = pQueueFamilyIndices_.size(); this->pQueueFamilyIndices = pQueueFamilyIndices_.data();  return *this; }
    ImageCreateInfo& setInitialLayout(ImageLayout initialLayout_) {this->initialLayout = initialLayout_; return *this; }
};
struct SubresourceLayout {
    DeviceSize offset{0};
    DeviceSize size{0};
    DeviceSize rowPitch{0};
    DeviceSize arrayPitch{0};
    DeviceSize depthPitch{0};
    constexpr bool operator==(SubresourceLayout const& value) const {
        return offset == value.offset && size == value.size && rowPitch == value.rowPitch && arrayPitch == value.arrayPitch && depthPitch == value.depthPitch 
        ;}
    constexpr bool operator!=(SubresourceLayout const& value) const {return !(*this == value);}
    SubresourceLayout& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    SubresourceLayout& setSize(DeviceSize size_) {this->size = size_; return *this; }
    SubresourceLayout& setRowPitch(DeviceSize rowPitch_) {this->rowPitch = rowPitch_; return *this; }
    SubresourceLayout& setArrayPitch(DeviceSize arrayPitch_) {this->arrayPitch = arrayPitch_; return *this; }
    SubresourceLayout& setDepthPitch(DeviceSize depthPitch_) {this->depthPitch = depthPitch_; return *this; }
};
struct ImageViewCreateInfo {
    StructureType sType{StructureType::ImageViewCreateInfo};
    const void* pNext = nullptr;
    ImageViewCreateFlags flags{};
    Image image{};
    ImageViewType viewType{static_cast<ImageViewType>(0)};
    Format format{static_cast<Format>(0)};
    ComponentMapping components{};
    ImageSubresourceRange subresourceRange{};
    ImageViewCreateInfo& setFlags(ImageViewCreateFlags flags_) {this->flags = flags_; return *this; }
    ImageViewCreateInfo& setImage(Image image_) {this->image = image_; return *this; }
    ImageViewCreateInfo& setViewType(ImageViewType viewType_) {this->viewType = viewType_; return *this; }
    ImageViewCreateInfo& setFormat(Format format_) {this->format = format_; return *this; }
    ImageViewCreateInfo& setComponents(ComponentMapping components_) {this->components = components_; return *this; }
    ImageViewCreateInfo& setSubresourceRange(ImageSubresourceRange subresourceRange_) {this->subresourceRange = subresourceRange_; return *this; }
};
struct BufferCopy {
    DeviceSize srcOffset{0};
    DeviceSize dstOffset{0};
    DeviceSize size{0};
    constexpr bool operator==(BufferCopy const& value) const {
        return srcOffset == value.srcOffset && dstOffset == value.dstOffset && size == value.size ;}
    constexpr bool operator!=(BufferCopy const& value) const {return !(*this == value);}
    BufferCopy& setSrcOffset(DeviceSize srcOffset_) {this->srcOffset = srcOffset_; return *this; }
    BufferCopy& setDstOffset(DeviceSize dstOffset_) {this->dstOffset = dstOffset_; return *this; }
    BufferCopy& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
struct SparseMemoryBind {
    DeviceSize resourceOffset{0};
    DeviceSize size{0};
    DeviceMemory memory{};
    DeviceSize memoryOffset{0};
    SparseMemoryBindFlags flags{};
    SparseMemoryBind& setResourceOffset(DeviceSize resourceOffset_) {this->resourceOffset = resourceOffset_; return *this; }
    SparseMemoryBind& setSize(DeviceSize size_) {this->size = size_; return *this; }
    SparseMemoryBind& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    SparseMemoryBind& setMemoryOffset(DeviceSize memoryOffset_) {this->memoryOffset = memoryOffset_; return *this; }
    SparseMemoryBind& setFlags(SparseMemoryBindFlags flags_) {this->flags = flags_; return *this; }
};
struct SparseImageMemoryBind {
    ImageSubresource subresource{};
    Offset3D offset{};
    Extent3D extent{};
    DeviceMemory memory{};
    DeviceSize memoryOffset{0};
    SparseMemoryBindFlags flags{};
    SparseImageMemoryBind& setSubresource(ImageSubresource subresource_) {this->subresource = subresource_; return *this; }
    SparseImageMemoryBind& setOffset(Offset3D offset_) {this->offset = offset_; return *this; }
    SparseImageMemoryBind& setExtent(Extent3D extent_) {this->extent = extent_; return *this; }
    SparseImageMemoryBind& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    SparseImageMemoryBind& setMemoryOffset(DeviceSize memoryOffset_) {this->memoryOffset = memoryOffset_; return *this; }
    SparseImageMemoryBind& setFlags(SparseMemoryBindFlags flags_) {this->flags = flags_; return *this; }
};
struct SparseBufferMemoryBindInfo {
    Buffer buffer{};
    uint32_t bindCount{0};
    const SparseMemoryBind* pBinds = nullptr;
    SparseBufferMemoryBindInfo& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    SparseBufferMemoryBindInfo& setBindCount(uint32_t bindCount_) {this->bindCount = bindCount_; return *this; }
    SparseBufferMemoryBindInfo& setPBinds(const SparseMemoryBind* pBinds_) {this->pBinds = pBinds_; return *this; }
    SparseBufferMemoryBindInfo& setPBinds(detail::span<const SparseMemoryBind> pBinds_) {this->bindCount = pBinds_.size(); this->pBinds = pBinds_.data();  return *this; }
};
struct SparseImageOpaqueMemoryBindInfo {
    Image image{};
    uint32_t bindCount{0};
    const SparseMemoryBind* pBinds = nullptr;
    SparseImageOpaqueMemoryBindInfo& setImage(Image image_) {this->image = image_; return *this; }
    SparseImageOpaqueMemoryBindInfo& setBindCount(uint32_t bindCount_) {this->bindCount = bindCount_; return *this; }
    SparseImageOpaqueMemoryBindInfo& setPBinds(const SparseMemoryBind* pBinds_) {this->pBinds = pBinds_; return *this; }
    SparseImageOpaqueMemoryBindInfo& setPBinds(detail::span<const SparseMemoryBind> pBinds_) {this->bindCount = pBinds_.size(); this->pBinds = pBinds_.data();  return *this; }
};
struct SparseImageMemoryBindInfo {
    Image image{};
    uint32_t bindCount{0};
    const SparseImageMemoryBind* pBinds = nullptr;
    SparseImageMemoryBindInfo& setImage(Image image_) {this->image = image_; return *this; }
    SparseImageMemoryBindInfo& setBindCount(uint32_t bindCount_) {this->bindCount = bindCount_; return *this; }
    SparseImageMemoryBindInfo& setPBinds(const SparseImageMemoryBind* pBinds_) {this->pBinds = pBinds_; return *this; }
    SparseImageMemoryBindInfo& setPBinds(detail::span<const SparseImageMemoryBind> pBinds_) {this->bindCount = pBinds_.size(); this->pBinds = pBinds_.data();  return *this; }
};
struct BindSparseInfo {
    StructureType sType{StructureType::BindSparseInfo};
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount{0};
    const Semaphore* pWaitSemaphores = nullptr;
    uint32_t bufferBindCount{0};
    const SparseBufferMemoryBindInfo* pBufferBinds = nullptr;
    uint32_t imageOpaqueBindCount{0};
    const SparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds = nullptr;
    uint32_t imageBindCount{0};
    const SparseImageMemoryBindInfo* pImageBinds = nullptr;
    uint32_t signalSemaphoreCount{0};
    const Semaphore* pSignalSemaphores = nullptr;
    BindSparseInfo& setWaitSemaphoreCount(uint32_t waitSemaphoreCount_) {this->waitSemaphoreCount = waitSemaphoreCount_; return *this; }
    BindSparseInfo& setPWaitSemaphores(const Semaphore* pWaitSemaphores_) {this->pWaitSemaphores = pWaitSemaphores_; return *this; }
    BindSparseInfo& setPWaitSemaphores(detail::span<const Semaphore> pWaitSemaphores_) {this->waitSemaphoreCount = pWaitSemaphores_.size(); this->pWaitSemaphores = pWaitSemaphores_.data();  return *this; }
    BindSparseInfo& setBufferBindCount(uint32_t bufferBindCount_) {this->bufferBindCount = bufferBindCount_; return *this; }
    BindSparseInfo& setPBufferBinds(const SparseBufferMemoryBindInfo* pBufferBinds_) {this->pBufferBinds = pBufferBinds_; return *this; }
    BindSparseInfo& setPBufferBinds(detail::span<const SparseBufferMemoryBindInfo> pBufferBinds_) {this->bufferBindCount = pBufferBinds_.size(); this->pBufferBinds = pBufferBinds_.data();  return *this; }
    BindSparseInfo& setImageOpaqueBindCount(uint32_t imageOpaqueBindCount_) {this->imageOpaqueBindCount = imageOpaqueBindCount_; return *this; }
    BindSparseInfo& setPImageOpaqueBinds(const SparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds_) {this->pImageOpaqueBinds = pImageOpaqueBinds_; return *this; }
    BindSparseInfo& setPImageOpaqueBinds(detail::span<const SparseImageOpaqueMemoryBindInfo> pImageOpaqueBinds_) {this->imageOpaqueBindCount = pImageOpaqueBinds_.size(); this->pImageOpaqueBinds = pImageOpaqueBinds_.data();  return *this; }
    BindSparseInfo& setImageBindCount(uint32_t imageBindCount_) {this->imageBindCount = imageBindCount_; return *this; }
    BindSparseInfo& setPImageBinds(const SparseImageMemoryBindInfo* pImageBinds_) {this->pImageBinds = pImageBinds_; return *this; }
    BindSparseInfo& setPImageBinds(detail::span<const SparseImageMemoryBindInfo> pImageBinds_) {this->imageBindCount = pImageBinds_.size(); this->pImageBinds = pImageBinds_.data();  return *this; }
    BindSparseInfo& setSignalSemaphoreCount(uint32_t signalSemaphoreCount_) {this->signalSemaphoreCount = signalSemaphoreCount_; return *this; }
    BindSparseInfo& setPSignalSemaphores(const Semaphore* pSignalSemaphores_) {this->pSignalSemaphores = pSignalSemaphores_; return *this; }
    BindSparseInfo& setPSignalSemaphores(detail::span<const Semaphore> pSignalSemaphores_) {this->signalSemaphoreCount = pSignalSemaphores_.size(); this->pSignalSemaphores = pSignalSemaphores_.data();  return *this; }
};
struct ImageCopy {
    ImageSubresourceLayers srcSubresource{};
    Offset3D srcOffset{};
    ImageSubresourceLayers dstSubresource{};
    Offset3D dstOffset{};
    Extent3D extent{};
    constexpr bool operator==(ImageCopy const& value) const {
        return srcSubresource == value.srcSubresource && srcOffset == value.srcOffset && dstSubresource == value.dstSubresource && dstOffset == value.dstOffset 
        && extent == value.extent ;}
    constexpr bool operator!=(ImageCopy const& value) const {return !(*this == value);}
    ImageCopy& setSrcSubresource(ImageSubresourceLayers srcSubresource_) {this->srcSubresource = srcSubresource_; return *this; }
    ImageCopy& setSrcOffset(Offset3D srcOffset_) {this->srcOffset = srcOffset_; return *this; }
    ImageCopy& setDstSubresource(ImageSubresourceLayers dstSubresource_) {this->dstSubresource = dstSubresource_; return *this; }
    ImageCopy& setDstOffset(Offset3D dstOffset_) {this->dstOffset = dstOffset_; return *this; }
    ImageCopy& setExtent(Extent3D extent_) {this->extent = extent_; return *this; }
};
struct ImageBlit {
    ImageSubresourceLayers srcSubresource{};
    Offset3D srcOffsets[2];
    ImageSubresourceLayers dstSubresource{};
    Offset3D dstOffsets[2];
    constexpr bool operator==(ImageBlit const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 2; i++)
            is_equal &= srcOffsets[i] == value.srcOffsets[i];
        for(uint32_t i = 0; i < 2; i++)
            is_equal &= dstOffsets[i] == value.dstOffsets[i];
        return is_equal && srcSubresource == value.srcSubresource && dstSubresource == value.dstSubresource ;}
    constexpr bool operator!=(ImageBlit const& value) const {return !(*this == value);}
    ImageBlit& setSrcSubresource(ImageSubresourceLayers srcSubresource_) {this->srcSubresource = srcSubresource_; return *this; }
    ImageBlit& setSrcOffsets(Offset3D srcOffsets_[2]) {for(uint32_t i = 0; i < 2; i++) this->srcOffsets[i] = srcOffsets_[i]; return *this; }
    ImageBlit& setDstSubresource(ImageSubresourceLayers dstSubresource_) {this->dstSubresource = dstSubresource_; return *this; }
    ImageBlit& setDstOffsets(Offset3D dstOffsets_[2]) {for(uint32_t i = 0; i < 2; i++) this->dstOffsets[i] = dstOffsets_[i]; return *this; }
};
struct BufferImageCopy {
    DeviceSize bufferOffset{0};
    uint32_t bufferRowLength{0};
    uint32_t bufferImageHeight{0};
    ImageSubresourceLayers imageSubresource{};
    Offset3D imageOffset{};
    Extent3D imageExtent{};
    constexpr bool operator==(BufferImageCopy const& value) const {
        return bufferOffset == value.bufferOffset && bufferRowLength == value.bufferRowLength && bufferImageHeight == value.bufferImageHeight && imageSubresource == value.imageSubresource 
        && imageOffset == value.imageOffset && imageExtent == value.imageExtent ;}
    constexpr bool operator!=(BufferImageCopy const& value) const {return !(*this == value);}
    BufferImageCopy& setBufferOffset(DeviceSize bufferOffset_) {this->bufferOffset = bufferOffset_; return *this; }
    BufferImageCopy& setBufferRowLength(uint32_t bufferRowLength_) {this->bufferRowLength = bufferRowLength_; return *this; }
    BufferImageCopy& setBufferImageHeight(uint32_t bufferImageHeight_) {this->bufferImageHeight = bufferImageHeight_; return *this; }
    BufferImageCopy& setImageSubresource(ImageSubresourceLayers imageSubresource_) {this->imageSubresource = imageSubresource_; return *this; }
    BufferImageCopy& setImageOffset(Offset3D imageOffset_) {this->imageOffset = imageOffset_; return *this; }
    BufferImageCopy& setImageExtent(Extent3D imageExtent_) {this->imageExtent = imageExtent_; return *this; }
};
struct ImageResolve {
    ImageSubresourceLayers srcSubresource{};
    Offset3D srcOffset{};
    ImageSubresourceLayers dstSubresource{};
    Offset3D dstOffset{};
    Extent3D extent{};
    constexpr bool operator==(ImageResolve const& value) const {
        return srcSubresource == value.srcSubresource && srcOffset == value.srcOffset && dstSubresource == value.dstSubresource && dstOffset == value.dstOffset 
        && extent == value.extent ;}
    constexpr bool operator!=(ImageResolve const& value) const {return !(*this == value);}
    ImageResolve& setSrcSubresource(ImageSubresourceLayers srcSubresource_) {this->srcSubresource = srcSubresource_; return *this; }
    ImageResolve& setSrcOffset(Offset3D srcOffset_) {this->srcOffset = srcOffset_; return *this; }
    ImageResolve& setDstSubresource(ImageSubresourceLayers dstSubresource_) {this->dstSubresource = dstSubresource_; return *this; }
    ImageResolve& setDstOffset(Offset3D dstOffset_) {this->dstOffset = dstOffset_; return *this; }
    ImageResolve& setExtent(Extent3D extent_) {this->extent = extent_; return *this; }
};
struct ShaderModuleCreateInfo {
    StructureType sType{StructureType::ShaderModuleCreateInfo};
    const void* pNext = nullptr;
    ShaderModuleCreateFlags flags{};
    size_t codeSize{0};
    const uint32_t* pCode = nullptr;
    ShaderModuleCreateInfo& setFlags(ShaderModuleCreateFlags flags_) {this->flags = flags_; return *this; }
    ShaderModuleCreateInfo& setCodeSize(size_t codeSize_) {this->codeSize = codeSize_; return *this; }
    ShaderModuleCreateInfo& setPCode(const uint32_t* pCode_) {this->pCode = pCode_; return *this; }
};
struct DescriptorSetLayoutBinding {
    uint32_t binding{0};
    DescriptorType descriptorType{static_cast<DescriptorType>(0)};
    uint32_t descriptorCount{0};
    ShaderStageFlags stageFlags{};
    const Sampler* pImmutableSamplers = nullptr;
    DescriptorSetLayoutBinding& setBinding(uint32_t binding_) {this->binding = binding_; return *this; }
    DescriptorSetLayoutBinding& setDescriptorType(DescriptorType descriptorType_) {this->descriptorType = descriptorType_; return *this; }
    DescriptorSetLayoutBinding& setDescriptorCount(uint32_t descriptorCount_) {this->descriptorCount = descriptorCount_; return *this; }
    DescriptorSetLayoutBinding& setStageFlags(ShaderStageFlags stageFlags_) {this->stageFlags = stageFlags_; return *this; }
    DescriptorSetLayoutBinding& setPImmutableSamplers(const Sampler* pImmutableSamplers_) {this->pImmutableSamplers = pImmutableSamplers_; return *this; }
    DescriptorSetLayoutBinding& setPImmutableSamplers(detail::span<const Sampler> pImmutableSamplers_) {this->descriptorCount = pImmutableSamplers_.size(); this->pImmutableSamplers = pImmutableSamplers_.data();  return *this; }
};
struct DescriptorSetLayoutCreateInfo {
    StructureType sType{StructureType::DescriptorSetLayoutCreateInfo};
    const void* pNext = nullptr;
    DescriptorSetLayoutCreateFlags flags{};
    uint32_t bindingCount{0};
    const DescriptorSetLayoutBinding* pBindings = nullptr;
    DescriptorSetLayoutCreateInfo& setFlags(DescriptorSetLayoutCreateFlags flags_) {this->flags = flags_; return *this; }
    DescriptorSetLayoutCreateInfo& setBindingCount(uint32_t bindingCount_) {this->bindingCount = bindingCount_; return *this; }
    DescriptorSetLayoutCreateInfo& setPBindings(const DescriptorSetLayoutBinding* pBindings_) {this->pBindings = pBindings_; return *this; }
    DescriptorSetLayoutCreateInfo& setPBindings(detail::span<const DescriptorSetLayoutBinding> pBindings_) {this->bindingCount = pBindings_.size(); this->pBindings = pBindings_.data();  return *this; }
};
struct DescriptorPoolSize {
    DescriptorType type{static_cast<DescriptorType>(0)};
    uint32_t descriptorCount{0};
    constexpr bool operator==(DescriptorPoolSize const& value) const {
        return type == value.type && descriptorCount == value.descriptorCount ;}
    constexpr bool operator!=(DescriptorPoolSize const& value) const {return !(*this == value);}
    DescriptorPoolSize& setType(DescriptorType type_) {this->type = type_; return *this; }
    DescriptorPoolSize& setDescriptorCount(uint32_t descriptorCount_) {this->descriptorCount = descriptorCount_; return *this; }
};
struct DescriptorPoolCreateInfo {
    StructureType sType{StructureType::DescriptorPoolCreateInfo};
    const void* pNext = nullptr;
    DescriptorPoolCreateFlags flags{};
    uint32_t maxSets{0};
    uint32_t poolSizeCount{0};
    const DescriptorPoolSize* pPoolSizes = nullptr;
    DescriptorPoolCreateInfo& setFlags(DescriptorPoolCreateFlags flags_) {this->flags = flags_; return *this; }
    DescriptorPoolCreateInfo& setMaxSets(uint32_t maxSets_) {this->maxSets = maxSets_; return *this; }
    DescriptorPoolCreateInfo& setPoolSizeCount(uint32_t poolSizeCount_) {this->poolSizeCount = poolSizeCount_; return *this; }
    DescriptorPoolCreateInfo& setPPoolSizes(const DescriptorPoolSize* pPoolSizes_) {this->pPoolSizes = pPoolSizes_; return *this; }
    DescriptorPoolCreateInfo& setPPoolSizes(detail::span<const DescriptorPoolSize> pPoolSizes_) {this->poolSizeCount = pPoolSizes_.size(); this->pPoolSizes = pPoolSizes_.data();  return *this; }
};
struct DescriptorSetAllocateInfo {
    StructureType sType{StructureType::DescriptorSetAllocateInfo};
    const void* pNext = nullptr;
    DescriptorPool descriptorPool{};
    uint32_t descriptorSetCount{0};
    const DescriptorSetLayout* pSetLayouts = nullptr;
    DescriptorSetAllocateInfo& setDescriptorPool(DescriptorPool descriptorPool_) {this->descriptorPool = descriptorPool_; return *this; }
    DescriptorSetAllocateInfo& setDescriptorSetCount(uint32_t descriptorSetCount_) {this->descriptorSetCount = descriptorSetCount_; return *this; }
    DescriptorSetAllocateInfo& setPSetLayouts(const DescriptorSetLayout* pSetLayouts_) {this->pSetLayouts = pSetLayouts_; return *this; }
    DescriptorSetAllocateInfo& setPSetLayouts(detail::span<const DescriptorSetLayout> pSetLayouts_) {this->descriptorSetCount = pSetLayouts_.size(); this->pSetLayouts = pSetLayouts_.data();  return *this; }
};
struct SpecializationMapEntry {
    uint32_t constantID{0};
    uint32_t offset{0};
    size_t size{0};
    constexpr bool operator==(SpecializationMapEntry const& value) const {
        return constantID == value.constantID && offset == value.offset && size == value.size ;}
    constexpr bool operator!=(SpecializationMapEntry const& value) const {return !(*this == value);}
    SpecializationMapEntry& setConstantID(uint32_t constantID_) {this->constantID = constantID_; return *this; }
    SpecializationMapEntry& setOffset(uint32_t offset_) {this->offset = offset_; return *this; }
    SpecializationMapEntry& setSize(size_t size_) {this->size = size_; return *this; }
};
struct SpecializationInfo {
    uint32_t mapEntryCount{0};
    const SpecializationMapEntry* pMapEntries = nullptr;
    size_t dataSize{0};
    const void* pData = nullptr;
    SpecializationInfo& setMapEntryCount(uint32_t mapEntryCount_) {this->mapEntryCount = mapEntryCount_; return *this; }
    SpecializationInfo& setPMapEntries(const SpecializationMapEntry* pMapEntries_) {this->pMapEntries = pMapEntries_; return *this; }
    SpecializationInfo& setPMapEntries(detail::span<const SpecializationMapEntry> pMapEntries_) {this->mapEntryCount = pMapEntries_.size(); this->pMapEntries = pMapEntries_.data();  return *this; }
    SpecializationInfo& setDataSize(size_t dataSize_) {this->dataSize = dataSize_; return *this; }
    SpecializationInfo& setPData(const void* pData_) {this->pData = pData_; return *this; }
    SpecializationInfo& setPData(detail::span<const std::byte> pData_) {this->dataSize = pData_.size(); this->pData = pData_.data();  return *this; }
};
struct PipelineShaderStageCreateInfo {
    StructureType sType{StructureType::PipelineShaderStageCreateInfo};
    const void* pNext = nullptr;
    PipelineShaderStageCreateFlags flags{};
    ShaderStageFlagBits stage{static_cast<ShaderStageFlagBits>(0)};
    ShaderModule module{};
    const char* pName = nullptr;
    const SpecializationInfo* pSpecializationInfo = nullptr;
    PipelineShaderStageCreateInfo& setFlags(PipelineShaderStageCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineShaderStageCreateInfo& setStage(ShaderStageFlagBits stage_) {this->stage = stage_; return *this; }
    PipelineShaderStageCreateInfo& setModule(ShaderModule module_) {this->module = module_; return *this; }
    PipelineShaderStageCreateInfo& setPName(const char* pName_) {this->pName = pName_; return *this; }
    PipelineShaderStageCreateInfo& setPSpecializationInfo(const SpecializationInfo* pSpecializationInfo_) {this->pSpecializationInfo = pSpecializationInfo_; return *this; }
    PipelineShaderStageCreateInfo& setPSpecializationInfo(SpecializationInfo const& pSpecializationInfo_) {this->pSpecializationInfo = &pSpecializationInfo_; return *this; }
};
struct ComputePipelineCreateInfo {
    StructureType sType{StructureType::ComputePipelineCreateInfo};
    const void* pNext = nullptr;
    PipelineCreateFlags flags{};
    PipelineShaderStageCreateInfo stage{};
    PipelineLayout layout{};
    Pipeline basePipelineHandle{};
    int32_t basePipelineIndex{0};
    ComputePipelineCreateInfo& setFlags(PipelineCreateFlags flags_) {this->flags = flags_; return *this; }
    ComputePipelineCreateInfo& setStage(PipelineShaderStageCreateInfo stage_) {this->stage = stage_; return *this; }
    ComputePipelineCreateInfo& setLayout(PipelineLayout layout_) {this->layout = layout_; return *this; }
    ComputePipelineCreateInfo& setBasePipelineHandle(Pipeline basePipelineHandle_) {this->basePipelineHandle = basePipelineHandle_; return *this; }
    ComputePipelineCreateInfo& setBasePipelineIndex(int32_t basePipelineIndex_) {this->basePipelineIndex = basePipelineIndex_; return *this; }
};
struct VertexInputBindingDescription {
    uint32_t binding{0};
    uint32_t stride{0};
    VertexInputRate inputRate{static_cast<VertexInputRate>(0)};
    constexpr bool operator==(VertexInputBindingDescription const& value) const {
        return binding == value.binding && stride == value.stride && inputRate == value.inputRate ;}
    constexpr bool operator!=(VertexInputBindingDescription const& value) const {return !(*this == value);}
    VertexInputBindingDescription& setBinding(uint32_t binding_) {this->binding = binding_; return *this; }
    VertexInputBindingDescription& setStride(uint32_t stride_) {this->stride = stride_; return *this; }
    VertexInputBindingDescription& setInputRate(VertexInputRate inputRate_) {this->inputRate = inputRate_; return *this; }
};
struct VertexInputAttributeDescription {
    uint32_t location{0};
    uint32_t binding{0};
    Format format{static_cast<Format>(0)};
    uint32_t offset{0};
    constexpr bool operator==(VertexInputAttributeDescription const& value) const {
        return location == value.location && binding == value.binding && format == value.format && offset == value.offset ;}
    constexpr bool operator!=(VertexInputAttributeDescription const& value) const {return !(*this == value);}
    VertexInputAttributeDescription& setLocation(uint32_t location_) {this->location = location_; return *this; }
    VertexInputAttributeDescription& setBinding(uint32_t binding_) {this->binding = binding_; return *this; }
    VertexInputAttributeDescription& setFormat(Format format_) {this->format = format_; return *this; }
    VertexInputAttributeDescription& setOffset(uint32_t offset_) {this->offset = offset_; return *this; }
};
struct PipelineVertexInputStateCreateInfo {
    StructureType sType{StructureType::PipelineVertexInputStateCreateInfo};
    const void* pNext = nullptr;
    PipelineVertexInputStateCreateFlags flags{};
    uint32_t vertexBindingDescriptionCount{0};
    const VertexInputBindingDescription* pVertexBindingDescriptions = nullptr;
    uint32_t vertexAttributeDescriptionCount{0};
    const VertexInputAttributeDescription* pVertexAttributeDescriptions = nullptr;
    PipelineVertexInputStateCreateInfo& setFlags(PipelineVertexInputStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineVertexInputStateCreateInfo& setVertexBindingDescriptionCount(uint32_t vertexBindingDescriptionCount_) {this->vertexBindingDescriptionCount = vertexBindingDescriptionCount_; return *this; }
    PipelineVertexInputStateCreateInfo& setPVertexBindingDescriptions(const VertexInputBindingDescription* pVertexBindingDescriptions_) {this->pVertexBindingDescriptions = pVertexBindingDescriptions_; return *this; }
    PipelineVertexInputStateCreateInfo& setPVertexBindingDescriptions(detail::span<const VertexInputBindingDescription> pVertexBindingDescriptions_) {this->vertexBindingDescriptionCount = pVertexBindingDescriptions_.size(); this->pVertexBindingDescriptions = pVertexBindingDescriptions_.data();  return *this; }
    PipelineVertexInputStateCreateInfo& setVertexAttributeDescriptionCount(uint32_t vertexAttributeDescriptionCount_) {this->vertexAttributeDescriptionCount = vertexAttributeDescriptionCount_; return *this; }
    PipelineVertexInputStateCreateInfo& setPVertexAttributeDescriptions(const VertexInputAttributeDescription* pVertexAttributeDescriptions_) {this->pVertexAttributeDescriptions = pVertexAttributeDescriptions_; return *this; }
    PipelineVertexInputStateCreateInfo& setPVertexAttributeDescriptions(detail::span<const VertexInputAttributeDescription> pVertexAttributeDescriptions_) {this->vertexAttributeDescriptionCount = pVertexAttributeDescriptions_.size(); this->pVertexAttributeDescriptions = pVertexAttributeDescriptions_.data();  return *this; }
};
struct PipelineInputAssemblyStateCreateInfo {
    StructureType sType{StructureType::PipelineInputAssemblyStateCreateInfo};
    const void* pNext = nullptr;
    PipelineInputAssemblyStateCreateFlags flags{};
    PrimitiveTopology topology{static_cast<PrimitiveTopology>(0)};
    Bool32 primitiveRestartEnable{0};
    PipelineInputAssemblyStateCreateInfo& setFlags(PipelineInputAssemblyStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineInputAssemblyStateCreateInfo& setTopology(PrimitiveTopology topology_) {this->topology = topology_; return *this; }
    PipelineInputAssemblyStateCreateInfo& setPrimitiveRestartEnable(Bool32 primitiveRestartEnable_) {this->primitiveRestartEnable = primitiveRestartEnable_; return *this; }
};
struct PipelineTessellationStateCreateInfo {
    StructureType sType{StructureType::PipelineTessellationStateCreateInfo};
    const void* pNext = nullptr;
    PipelineTessellationStateCreateFlags flags{};
    uint32_t patchControlPoints{0};
    PipelineTessellationStateCreateInfo& setFlags(PipelineTessellationStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineTessellationStateCreateInfo& setPatchControlPoints(uint32_t patchControlPoints_) {this->patchControlPoints = patchControlPoints_; return *this; }
};
struct PipelineViewportStateCreateInfo {
    StructureType sType{StructureType::PipelineViewportStateCreateInfo};
    const void* pNext = nullptr;
    PipelineViewportStateCreateFlags flags{};
    uint32_t viewportCount{0};
    const Viewport* pViewports = nullptr;
    uint32_t scissorCount{0};
    const Rect2D* pScissors = nullptr;
    PipelineViewportStateCreateInfo& setFlags(PipelineViewportStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineViewportStateCreateInfo& setViewportCount(uint32_t viewportCount_) {this->viewportCount = viewportCount_; return *this; }
    PipelineViewportStateCreateInfo& setPViewports(const Viewport* pViewports_) {this->pViewports = pViewports_; return *this; }
    PipelineViewportStateCreateInfo& setPViewports(detail::span<const Viewport> pViewports_) {this->viewportCount = pViewports_.size(); this->pViewports = pViewports_.data();  return *this; }
    PipelineViewportStateCreateInfo& setScissorCount(uint32_t scissorCount_) {this->scissorCount = scissorCount_; return *this; }
    PipelineViewportStateCreateInfo& setPScissors(const Rect2D* pScissors_) {this->pScissors = pScissors_; return *this; }
    PipelineViewportStateCreateInfo& setPScissors(detail::span<const Rect2D> pScissors_) {this->scissorCount = pScissors_.size(); this->pScissors = pScissors_.data();  return *this; }
};
struct PipelineRasterizationStateCreateInfo {
    StructureType sType{StructureType::PipelineRasterizationStateCreateInfo};
    const void* pNext = nullptr;
    PipelineRasterizationStateCreateFlags flags{};
    Bool32 depthClampEnable{0};
    Bool32 rasterizerDiscardEnable{0};
    PolygonMode polygonMode{static_cast<PolygonMode>(0)};
    CullModeFlags cullMode{};
    FrontFace frontFace{static_cast<FrontFace>(0)};
    Bool32 depthBiasEnable{0};
    float depthBiasConstantFactor{0.f};
    float depthBiasClamp{0.f};
    float depthBiasSlopeFactor{0.f};
    float lineWidth{0.f};
    PipelineRasterizationStateCreateInfo& setFlags(PipelineRasterizationStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineRasterizationStateCreateInfo& setDepthClampEnable(Bool32 depthClampEnable_) {this->depthClampEnable = depthClampEnable_; return *this; }
    PipelineRasterizationStateCreateInfo& setRasterizerDiscardEnable(Bool32 rasterizerDiscardEnable_) {this->rasterizerDiscardEnable = rasterizerDiscardEnable_; return *this; }
    PipelineRasterizationStateCreateInfo& setPolygonMode(PolygonMode polygonMode_) {this->polygonMode = polygonMode_; return *this; }
    PipelineRasterizationStateCreateInfo& setCullMode(CullModeFlags cullMode_) {this->cullMode = cullMode_; return *this; }
    PipelineRasterizationStateCreateInfo& setFrontFace(FrontFace frontFace_) {this->frontFace = frontFace_; return *this; }
    PipelineRasterizationStateCreateInfo& setDepthBiasEnable(Bool32 depthBiasEnable_) {this->depthBiasEnable = depthBiasEnable_; return *this; }
    PipelineRasterizationStateCreateInfo& setDepthBiasConstantFactor(float depthBiasConstantFactor_) {this->depthBiasConstantFactor = depthBiasConstantFactor_; return *this; }
    PipelineRasterizationStateCreateInfo& setDepthBiasClamp(float depthBiasClamp_) {this->depthBiasClamp = depthBiasClamp_; return *this; }
    PipelineRasterizationStateCreateInfo& setDepthBiasSlopeFactor(float depthBiasSlopeFactor_) {this->depthBiasSlopeFactor = depthBiasSlopeFactor_; return *this; }
    PipelineRasterizationStateCreateInfo& setLineWidth(float lineWidth_) {this->lineWidth = lineWidth_; return *this; }
};
struct PipelineMultisampleStateCreateInfo {
    StructureType sType{StructureType::PipelineMultisampleStateCreateInfo};
    const void* pNext = nullptr;
    PipelineMultisampleStateCreateFlags flags{};
    SampleCountFlagBits rasterizationSamples{static_cast<SampleCountFlagBits>(0)};
    Bool32 sampleShadingEnable{0};
    float minSampleShading{0.f};
    const SampleMask* pSampleMask = nullptr;
    Bool32 alphaToCoverageEnable{0};
    Bool32 alphaToOneEnable{0};
    PipelineMultisampleStateCreateInfo& setFlags(PipelineMultisampleStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineMultisampleStateCreateInfo& setRasterizationSamples(SampleCountFlagBits rasterizationSamples_) {this->rasterizationSamples = rasterizationSamples_; return *this; }
    PipelineMultisampleStateCreateInfo& setSampleShadingEnable(Bool32 sampleShadingEnable_) {this->sampleShadingEnable = sampleShadingEnable_; return *this; }
    PipelineMultisampleStateCreateInfo& setMinSampleShading(float minSampleShading_) {this->minSampleShading = minSampleShading_; return *this; }
    PipelineMultisampleStateCreateInfo& setPSampleMask(const SampleMask* pSampleMask_) {this->pSampleMask = pSampleMask_; return *this; }
    PipelineMultisampleStateCreateInfo& setAlphaToCoverageEnable(Bool32 alphaToCoverageEnable_) {this->alphaToCoverageEnable = alphaToCoverageEnable_; return *this; }
    PipelineMultisampleStateCreateInfo& setAlphaToOneEnable(Bool32 alphaToOneEnable_) {this->alphaToOneEnable = alphaToOneEnable_; return *this; }
};
struct PipelineColorBlendAttachmentState {
    Bool32 blendEnable{0};
    BlendFactor srcColorBlendFactor{static_cast<BlendFactor>(0)};
    BlendFactor dstColorBlendFactor{static_cast<BlendFactor>(0)};
    BlendOp colorBlendOp{static_cast<BlendOp>(0)};
    BlendFactor srcAlphaBlendFactor{static_cast<BlendFactor>(0)};
    BlendFactor dstAlphaBlendFactor{static_cast<BlendFactor>(0)};
    BlendOp alphaBlendOp{static_cast<BlendOp>(0)};
    ColorComponentFlags colorWriteMask{};
    constexpr bool operator==(PipelineColorBlendAttachmentState const& value) const {
        return blendEnable == value.blendEnable && srcColorBlendFactor == value.srcColorBlendFactor && dstColorBlendFactor == value.dstColorBlendFactor 
        && colorBlendOp == value.colorBlendOp && srcAlphaBlendFactor == value.srcAlphaBlendFactor && dstAlphaBlendFactor == value.dstAlphaBlendFactor 
        && alphaBlendOp == value.alphaBlendOp && colorWriteMask == value.colorWriteMask ;}
    constexpr bool operator!=(PipelineColorBlendAttachmentState const& value) const {return !(*this == value);}
    PipelineColorBlendAttachmentState& setBlendEnable(Bool32 blendEnable_) {this->blendEnable = blendEnable_; return *this; }
    PipelineColorBlendAttachmentState& setSrcColorBlendFactor(BlendFactor srcColorBlendFactor_) {this->srcColorBlendFactor = srcColorBlendFactor_; return *this; }
    PipelineColorBlendAttachmentState& setDstColorBlendFactor(BlendFactor dstColorBlendFactor_) {this->dstColorBlendFactor = dstColorBlendFactor_; return *this; }
    PipelineColorBlendAttachmentState& setColorBlendOp(BlendOp colorBlendOp_) {this->colorBlendOp = colorBlendOp_; return *this; }
    PipelineColorBlendAttachmentState& setSrcAlphaBlendFactor(BlendFactor srcAlphaBlendFactor_) {this->srcAlphaBlendFactor = srcAlphaBlendFactor_; return *this; }
    PipelineColorBlendAttachmentState& setDstAlphaBlendFactor(BlendFactor dstAlphaBlendFactor_) {this->dstAlphaBlendFactor = dstAlphaBlendFactor_; return *this; }
    PipelineColorBlendAttachmentState& setAlphaBlendOp(BlendOp alphaBlendOp_) {this->alphaBlendOp = alphaBlendOp_; return *this; }
    PipelineColorBlendAttachmentState& setColorWriteMask(ColorComponentFlags colorWriteMask_) {this->colorWriteMask = colorWriteMask_; return *this; }
};
struct PipelineColorBlendStateCreateInfo {
    StructureType sType{StructureType::PipelineColorBlendStateCreateInfo};
    const void* pNext = nullptr;
    PipelineColorBlendStateCreateFlags flags{};
    Bool32 logicOpEnable{0};
    LogicOp logicOp{static_cast<LogicOp>(0)};
    uint32_t attachmentCount{0};
    const PipelineColorBlendAttachmentState* pAttachments = nullptr;
    float blendConstants[4];
    PipelineColorBlendStateCreateInfo& setFlags(PipelineColorBlendStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineColorBlendStateCreateInfo& setLogicOpEnable(Bool32 logicOpEnable_) {this->logicOpEnable = logicOpEnable_; return *this; }
    PipelineColorBlendStateCreateInfo& setLogicOp(LogicOp logicOp_) {this->logicOp = logicOp_; return *this; }
    PipelineColorBlendStateCreateInfo& setAttachmentCount(uint32_t attachmentCount_) {this->attachmentCount = attachmentCount_; return *this; }
    PipelineColorBlendStateCreateInfo& setPAttachments(const PipelineColorBlendAttachmentState* pAttachments_) {this->pAttachments = pAttachments_; return *this; }
    PipelineColorBlendStateCreateInfo& setPAttachments(detail::span<const PipelineColorBlendAttachmentState> pAttachments_) {this->attachmentCount = pAttachments_.size(); this->pAttachments = pAttachments_.data();  return *this; }
    PipelineColorBlendStateCreateInfo& setBlendConstants(float blendConstants_[4]) {for(uint32_t i = 0; i < 4; i++) this->blendConstants[i] = blendConstants_[i]; return *this; }
};
struct PipelineDynamicStateCreateInfo {
    StructureType sType{StructureType::PipelineDynamicStateCreateInfo};
    const void* pNext = nullptr;
    PipelineDynamicStateCreateFlags flags{};
    uint32_t dynamicStateCount{0};
    const DynamicState* pDynamicStates = nullptr;
    PipelineDynamicStateCreateInfo& setFlags(PipelineDynamicStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineDynamicStateCreateInfo& setDynamicStateCount(uint32_t dynamicStateCount_) {this->dynamicStateCount = dynamicStateCount_; return *this; }
    PipelineDynamicStateCreateInfo& setPDynamicStates(const DynamicState* pDynamicStates_) {this->pDynamicStates = pDynamicStates_; return *this; }
    PipelineDynamicStateCreateInfo& setPDynamicStates(detail::span<const DynamicState> pDynamicStates_) {this->dynamicStateCount = pDynamicStates_.size(); this->pDynamicStates = pDynamicStates_.data();  return *this; }
};
struct StencilOpState {
    StencilOp failOp{static_cast<StencilOp>(0)};
    StencilOp passOp{static_cast<StencilOp>(0)};
    StencilOp depthFailOp{static_cast<StencilOp>(0)};
    CompareOp compareOp{static_cast<CompareOp>(0)};
    uint32_t compareMask{0};
    uint32_t writeMask{0};
    uint32_t reference{0};
    constexpr bool operator==(StencilOpState const& value) const {
        return failOp == value.failOp && passOp == value.passOp && depthFailOp == value.depthFailOp && compareOp == value.compareOp && compareMask == value.compareMask 
        && writeMask == value.writeMask && reference == value.reference ;}
    constexpr bool operator!=(StencilOpState const& value) const {return !(*this == value);}
    StencilOpState& setFailOp(StencilOp failOp_) {this->failOp = failOp_; return *this; }
    StencilOpState& setPassOp(StencilOp passOp_) {this->passOp = passOp_; return *this; }
    StencilOpState& setDepthFailOp(StencilOp depthFailOp_) {this->depthFailOp = depthFailOp_; return *this; }
    StencilOpState& setCompareOp(CompareOp compareOp_) {this->compareOp = compareOp_; return *this; }
    StencilOpState& setCompareMask(uint32_t compareMask_) {this->compareMask = compareMask_; return *this; }
    StencilOpState& setWriteMask(uint32_t writeMask_) {this->writeMask = writeMask_; return *this; }
    StencilOpState& setReference(uint32_t reference_) {this->reference = reference_; return *this; }
};
struct PipelineDepthStencilStateCreateInfo {
    StructureType sType{StructureType::PipelineDepthStencilStateCreateInfo};
    const void* pNext = nullptr;
    PipelineDepthStencilStateCreateFlags flags{};
    Bool32 depthTestEnable{0};
    Bool32 depthWriteEnable{0};
    CompareOp depthCompareOp{static_cast<CompareOp>(0)};
    Bool32 depthBoundsTestEnable{0};
    Bool32 stencilTestEnable{0};
    StencilOpState front{};
    StencilOpState back{};
    float minDepthBounds{0.f};
    float maxDepthBounds{0.f};
    PipelineDepthStencilStateCreateInfo& setFlags(PipelineDepthStencilStateCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineDepthStencilStateCreateInfo& setDepthTestEnable(Bool32 depthTestEnable_) {this->depthTestEnable = depthTestEnable_; return *this; }
    PipelineDepthStencilStateCreateInfo& setDepthWriteEnable(Bool32 depthWriteEnable_) {this->depthWriteEnable = depthWriteEnable_; return *this; }
    PipelineDepthStencilStateCreateInfo& setDepthCompareOp(CompareOp depthCompareOp_) {this->depthCompareOp = depthCompareOp_; return *this; }
    PipelineDepthStencilStateCreateInfo& setDepthBoundsTestEnable(Bool32 depthBoundsTestEnable_) {this->depthBoundsTestEnable = depthBoundsTestEnable_; return *this; }
    PipelineDepthStencilStateCreateInfo& setStencilTestEnable(Bool32 stencilTestEnable_) {this->stencilTestEnable = stencilTestEnable_; return *this; }
    PipelineDepthStencilStateCreateInfo& setFront(StencilOpState front_) {this->front = front_; return *this; }
    PipelineDepthStencilStateCreateInfo& setBack(StencilOpState back_) {this->back = back_; return *this; }
    PipelineDepthStencilStateCreateInfo& setMinDepthBounds(float minDepthBounds_) {this->minDepthBounds = minDepthBounds_; return *this; }
    PipelineDepthStencilStateCreateInfo& setMaxDepthBounds(float maxDepthBounds_) {this->maxDepthBounds = maxDepthBounds_; return *this; }
};
struct GraphicsPipelineCreateInfo {
    StructureType sType{StructureType::GraphicsPipelineCreateInfo};
    const void* pNext = nullptr;
    PipelineCreateFlags flags{};
    uint32_t stageCount{0};
    const PipelineShaderStageCreateInfo* pStages = nullptr;
    const PipelineVertexInputStateCreateInfo* pVertexInputState = nullptr;
    const PipelineInputAssemblyStateCreateInfo* pInputAssemblyState = nullptr;
    const PipelineTessellationStateCreateInfo* pTessellationState = nullptr;
    const PipelineViewportStateCreateInfo* pViewportState = nullptr;
    const PipelineRasterizationStateCreateInfo* pRasterizationState = nullptr;
    const PipelineMultisampleStateCreateInfo* pMultisampleState = nullptr;
    const PipelineDepthStencilStateCreateInfo* pDepthStencilState = nullptr;
    const PipelineColorBlendStateCreateInfo* pColorBlendState = nullptr;
    const PipelineDynamicStateCreateInfo* pDynamicState = nullptr;
    PipelineLayout layout{};
    RenderPass renderPass{};
    uint32_t subpass{0};
    Pipeline basePipelineHandle{};
    int32_t basePipelineIndex{0};
    GraphicsPipelineCreateInfo& setFlags(PipelineCreateFlags flags_) {this->flags = flags_; return *this; }
    GraphicsPipelineCreateInfo& setStageCount(uint32_t stageCount_) {this->stageCount = stageCount_; return *this; }
    GraphicsPipelineCreateInfo& setPStages(const PipelineShaderStageCreateInfo* pStages_) {this->pStages = pStages_; return *this; }
    GraphicsPipelineCreateInfo& setPStages(detail::span<const PipelineShaderStageCreateInfo> pStages_) {this->stageCount = pStages_.size(); this->pStages = pStages_.data();  return *this; }
    GraphicsPipelineCreateInfo& setPVertexInputState(const PipelineVertexInputStateCreateInfo* pVertexInputState_) {this->pVertexInputState = pVertexInputState_; return *this; }
    GraphicsPipelineCreateInfo& setPVertexInputState(PipelineVertexInputStateCreateInfo const& pVertexInputState_) {this->pVertexInputState = &pVertexInputState_; return *this; }
    GraphicsPipelineCreateInfo& setPInputAssemblyState(const PipelineInputAssemblyStateCreateInfo* pInputAssemblyState_) {this->pInputAssemblyState = pInputAssemblyState_; return *this; }
    GraphicsPipelineCreateInfo& setPInputAssemblyState(PipelineInputAssemblyStateCreateInfo const& pInputAssemblyState_) {this->pInputAssemblyState = &pInputAssemblyState_; return *this; }
    GraphicsPipelineCreateInfo& setPTessellationState(const PipelineTessellationStateCreateInfo* pTessellationState_) {this->pTessellationState = pTessellationState_; return *this; }
    GraphicsPipelineCreateInfo& setPTessellationState(PipelineTessellationStateCreateInfo const& pTessellationState_) {this->pTessellationState = &pTessellationState_; return *this; }
    GraphicsPipelineCreateInfo& setPViewportState(const PipelineViewportStateCreateInfo* pViewportState_) {this->pViewportState = pViewportState_; return *this; }
    GraphicsPipelineCreateInfo& setPViewportState(PipelineViewportStateCreateInfo const& pViewportState_) {this->pViewportState = &pViewportState_; return *this; }
    GraphicsPipelineCreateInfo& setPRasterizationState(const PipelineRasterizationStateCreateInfo* pRasterizationState_) {this->pRasterizationState = pRasterizationState_; return *this; }
    GraphicsPipelineCreateInfo& setPRasterizationState(PipelineRasterizationStateCreateInfo const& pRasterizationState_) {this->pRasterizationState = &pRasterizationState_; return *this; }
    GraphicsPipelineCreateInfo& setPMultisampleState(const PipelineMultisampleStateCreateInfo* pMultisampleState_) {this->pMultisampleState = pMultisampleState_; return *this; }
    GraphicsPipelineCreateInfo& setPMultisampleState(PipelineMultisampleStateCreateInfo const& pMultisampleState_) {this->pMultisampleState = &pMultisampleState_; return *this; }
    GraphicsPipelineCreateInfo& setPDepthStencilState(const PipelineDepthStencilStateCreateInfo* pDepthStencilState_) {this->pDepthStencilState = pDepthStencilState_; return *this; }
    GraphicsPipelineCreateInfo& setPDepthStencilState(PipelineDepthStencilStateCreateInfo const& pDepthStencilState_) {this->pDepthStencilState = &pDepthStencilState_; return *this; }
    GraphicsPipelineCreateInfo& setPColorBlendState(const PipelineColorBlendStateCreateInfo* pColorBlendState_) {this->pColorBlendState = pColorBlendState_; return *this; }
    GraphicsPipelineCreateInfo& setPColorBlendState(PipelineColorBlendStateCreateInfo const& pColorBlendState_) {this->pColorBlendState = &pColorBlendState_; return *this; }
    GraphicsPipelineCreateInfo& setPDynamicState(const PipelineDynamicStateCreateInfo* pDynamicState_) {this->pDynamicState = pDynamicState_; return *this; }
    GraphicsPipelineCreateInfo& setPDynamicState(PipelineDynamicStateCreateInfo const& pDynamicState_) {this->pDynamicState = &pDynamicState_; return *this; }
    GraphicsPipelineCreateInfo& setLayout(PipelineLayout layout_) {this->layout = layout_; return *this; }
    GraphicsPipelineCreateInfo& setRenderPass(RenderPass renderPass_) {this->renderPass = renderPass_; return *this; }
    GraphicsPipelineCreateInfo& setSubpass(uint32_t subpass_) {this->subpass = subpass_; return *this; }
    GraphicsPipelineCreateInfo& setBasePipelineHandle(Pipeline basePipelineHandle_) {this->basePipelineHandle = basePipelineHandle_; return *this; }
    GraphicsPipelineCreateInfo& setBasePipelineIndex(int32_t basePipelineIndex_) {this->basePipelineIndex = basePipelineIndex_; return *this; }
};
struct PipelineCacheCreateInfo {
    StructureType sType{StructureType::PipelineCacheCreateInfo};
    const void* pNext = nullptr;
    PipelineCacheCreateFlags flags{};
    size_t initialDataSize{0};
    const void* pInitialData = nullptr;
    PipelineCacheCreateInfo& setFlags(PipelineCacheCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineCacheCreateInfo& setInitialDataSize(size_t initialDataSize_) {this->initialDataSize = initialDataSize_; return *this; }
    PipelineCacheCreateInfo& setPInitialData(const void* pInitialData_) {this->pInitialData = pInitialData_; return *this; }
    PipelineCacheCreateInfo& setPInitialData(detail::span<const std::byte> pInitialData_) {this->initialDataSize = pInitialData_.size(); this->pInitialData = pInitialData_.data();  return *this; }
};
struct PushConstantRange {
    ShaderStageFlags stageFlags{};
    uint32_t offset{0};
    uint32_t size{0};
    constexpr bool operator==(PushConstantRange const& value) const {
        return stageFlags == value.stageFlags && offset == value.offset && size == value.size ;}
    constexpr bool operator!=(PushConstantRange const& value) const {return !(*this == value);}
    PushConstantRange& setStageFlags(ShaderStageFlags stageFlags_) {this->stageFlags = stageFlags_; return *this; }
    PushConstantRange& setOffset(uint32_t offset_) {this->offset = offset_; return *this; }
    PushConstantRange& setSize(uint32_t size_) {this->size = size_; return *this; }
};
struct PipelineLayoutCreateInfo {
    StructureType sType{StructureType::PipelineLayoutCreateInfo};
    const void* pNext = nullptr;
    PipelineLayoutCreateFlags flags{};
    uint32_t setLayoutCount{0};
    const DescriptorSetLayout* pSetLayouts = nullptr;
    uint32_t pushConstantRangeCount{0};
    const PushConstantRange* pPushConstantRanges = nullptr;
    PipelineLayoutCreateInfo& setFlags(PipelineLayoutCreateFlags flags_) {this->flags = flags_; return *this; }
    PipelineLayoutCreateInfo& setSetLayoutCount(uint32_t setLayoutCount_) {this->setLayoutCount = setLayoutCount_; return *this; }
    PipelineLayoutCreateInfo& setPSetLayouts(const DescriptorSetLayout* pSetLayouts_) {this->pSetLayouts = pSetLayouts_; return *this; }
    PipelineLayoutCreateInfo& setPSetLayouts(detail::span<const DescriptorSetLayout> pSetLayouts_) {this->setLayoutCount = pSetLayouts_.size(); this->pSetLayouts = pSetLayouts_.data();  return *this; }
    PipelineLayoutCreateInfo& setPushConstantRangeCount(uint32_t pushConstantRangeCount_) {this->pushConstantRangeCount = pushConstantRangeCount_; return *this; }
    PipelineLayoutCreateInfo& setPPushConstantRanges(const PushConstantRange* pPushConstantRanges_) {this->pPushConstantRanges = pPushConstantRanges_; return *this; }
    PipelineLayoutCreateInfo& setPPushConstantRanges(detail::span<const PushConstantRange> pPushConstantRanges_) {this->pushConstantRangeCount = pPushConstantRanges_.size(); this->pPushConstantRanges = pPushConstantRanges_.data();  return *this; }
};
struct SamplerCreateInfo {
    StructureType sType{StructureType::SamplerCreateInfo};
    const void* pNext = nullptr;
    SamplerCreateFlags flags{};
    Filter magFilter{static_cast<Filter>(0)};
    Filter minFilter{static_cast<Filter>(0)};
    SamplerMipmapMode mipmapMode{static_cast<SamplerMipmapMode>(0)};
    SamplerAddressMode addressModeU{static_cast<SamplerAddressMode>(0)};
    SamplerAddressMode addressModeV{static_cast<SamplerAddressMode>(0)};
    SamplerAddressMode addressModeW{static_cast<SamplerAddressMode>(0)};
    float mipLodBias{0.f};
    Bool32 anisotropyEnable{0};
    float maxAnisotropy{0.f};
    Bool32 compareEnable{0};
    CompareOp compareOp{static_cast<CompareOp>(0)};
    float minLod{0.f};
    float maxLod{0.f};
    BorderColor borderColor{static_cast<BorderColor>(0)};
    Bool32 unnormalizedCoordinates{0};
    SamplerCreateInfo& setFlags(SamplerCreateFlags flags_) {this->flags = flags_; return *this; }
    SamplerCreateInfo& setMagFilter(Filter magFilter_) {this->magFilter = magFilter_; return *this; }
    SamplerCreateInfo& setMinFilter(Filter minFilter_) {this->minFilter = minFilter_; return *this; }
    SamplerCreateInfo& setMipmapMode(SamplerMipmapMode mipmapMode_) {this->mipmapMode = mipmapMode_; return *this; }
    SamplerCreateInfo& setAddressModeU(SamplerAddressMode addressModeU_) {this->addressModeU = addressModeU_; return *this; }
    SamplerCreateInfo& setAddressModeV(SamplerAddressMode addressModeV_) {this->addressModeV = addressModeV_; return *this; }
    SamplerCreateInfo& setAddressModeW(SamplerAddressMode addressModeW_) {this->addressModeW = addressModeW_; return *this; }
    SamplerCreateInfo& setMipLodBias(float mipLodBias_) {this->mipLodBias = mipLodBias_; return *this; }
    SamplerCreateInfo& setAnisotropyEnable(Bool32 anisotropyEnable_) {this->anisotropyEnable = anisotropyEnable_; return *this; }
    SamplerCreateInfo& setMaxAnisotropy(float maxAnisotropy_) {this->maxAnisotropy = maxAnisotropy_; return *this; }
    SamplerCreateInfo& setCompareEnable(Bool32 compareEnable_) {this->compareEnable = compareEnable_; return *this; }
    SamplerCreateInfo& setCompareOp(CompareOp compareOp_) {this->compareOp = compareOp_; return *this; }
    SamplerCreateInfo& setMinLod(float minLod_) {this->minLod = minLod_; return *this; }
    SamplerCreateInfo& setMaxLod(float maxLod_) {this->maxLod = maxLod_; return *this; }
    SamplerCreateInfo& setBorderColor(BorderColor borderColor_) {this->borderColor = borderColor_; return *this; }
    SamplerCreateInfo& setUnnormalizedCoordinates(Bool32 unnormalizedCoordinates_) {this->unnormalizedCoordinates = unnormalizedCoordinates_; return *this; }
};
struct CommandPoolCreateInfo {
    StructureType sType{StructureType::CommandPoolCreateInfo};
    const void* pNext = nullptr;
    CommandPoolCreateFlags flags{};
    uint32_t queueFamilyIndex{0};
    CommandPoolCreateInfo& setFlags(CommandPoolCreateFlags flags_) {this->flags = flags_; return *this; }
    CommandPoolCreateInfo& setQueueFamilyIndex(uint32_t queueFamilyIndex_) {this->queueFamilyIndex = queueFamilyIndex_; return *this; }
};
struct CommandBufferAllocateInfo {
    StructureType sType{StructureType::CommandBufferAllocateInfo};
    const void* pNext = nullptr;
    CommandPool commandPool{};
    CommandBufferLevel level{static_cast<CommandBufferLevel>(0)};
    uint32_t commandBufferCount{0};
    CommandBufferAllocateInfo& setCommandPool(CommandPool commandPool_) {this->commandPool = commandPool_; return *this; }
    CommandBufferAllocateInfo& setLevel(CommandBufferLevel level_) {this->level = level_; return *this; }
    CommandBufferAllocateInfo& setCommandBufferCount(uint32_t commandBufferCount_) {this->commandBufferCount = commandBufferCount_; return *this; }
};
struct CommandBufferInheritanceInfo {
    StructureType sType{StructureType::CommandBufferInheritanceInfo};
    const void* pNext = nullptr;
    RenderPass renderPass{};
    uint32_t subpass{0};
    Framebuffer framebuffer{};
    Bool32 occlusionQueryEnable{0};
    QueryControlFlags queryFlags{};
    QueryPipelineStatisticFlags pipelineStatistics{};
    CommandBufferInheritanceInfo& setRenderPass(RenderPass renderPass_) {this->renderPass = renderPass_; return *this; }
    CommandBufferInheritanceInfo& setSubpass(uint32_t subpass_) {this->subpass = subpass_; return *this; }
    CommandBufferInheritanceInfo& setFramebuffer(Framebuffer framebuffer_) {this->framebuffer = framebuffer_; return *this; }
    CommandBufferInheritanceInfo& setOcclusionQueryEnable(Bool32 occlusionQueryEnable_) {this->occlusionQueryEnable = occlusionQueryEnable_; return *this; }
    CommandBufferInheritanceInfo& setQueryFlags(QueryControlFlags queryFlags_) {this->queryFlags = queryFlags_; return *this; }
    CommandBufferInheritanceInfo& setPipelineStatistics(QueryPipelineStatisticFlags pipelineStatistics_) {this->pipelineStatistics = pipelineStatistics_; return *this; }
};
struct CommandBufferBeginInfo {
    StructureType sType{StructureType::CommandBufferBeginInfo};
    const void* pNext = nullptr;
    CommandBufferUsageFlags flags{};
    const CommandBufferInheritanceInfo* pInheritanceInfo = nullptr;
    CommandBufferBeginInfo& setFlags(CommandBufferUsageFlags flags_) {this->flags = flags_; return *this; }
    CommandBufferBeginInfo& setPInheritanceInfo(const CommandBufferInheritanceInfo* pInheritanceInfo_) {this->pInheritanceInfo = pInheritanceInfo_; return *this; }
    CommandBufferBeginInfo& setPInheritanceInfo(CommandBufferInheritanceInfo const& pInheritanceInfo_) {this->pInheritanceInfo = &pInheritanceInfo_; return *this; }
};
struct ClearDepthStencilValue {
    float depth{0.f};
    uint32_t stencil{0};
    constexpr bool operator==(ClearDepthStencilValue const& value) const {
        return depth == value.depth && stencil == value.stencil ;}
    constexpr bool operator!=(ClearDepthStencilValue const& value) const {return !(*this == value);}
    ClearDepthStencilValue& setDepth(float depth_) {this->depth = depth_; return *this; }
    ClearDepthStencilValue& setStencil(uint32_t stencil_) {this->stencil = stencil_; return *this; }
};
union ClearColorValue {
    float float32[4];
    int32_t int32[4];
    uint32_t uint32[4];
    constexpr bool operator==(ClearColorValue const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 4; i++)
            is_equal &= float32[i] == value.float32[i];
        for(uint32_t i = 0; i < 4; i++)
            is_equal &= int32[i] == value.int32[i];
        for(uint32_t i = 0; i < 4; i++)
            is_equal &= uint32[i] == value.uint32[i];
        return is_equal;}
    constexpr bool operator!=(ClearColorValue const& value) const {return !(*this == value);}
    ClearColorValue& setFloat32(float float32_[4]) {for(uint32_t i = 0; i < 4; i++) this->float32[i] = float32_[i]; return *this; }
    ClearColorValue& setInt32(int32_t int32_[4]) {for(uint32_t i = 0; i < 4; i++) this->int32[i] = int32_[i]; return *this; }
    ClearColorValue& setUint32(uint32_t uint32_[4]) {for(uint32_t i = 0; i < 4; i++) this->uint32[i] = uint32_[i]; return *this; }
};
union ClearValue {
    ClearColorValue color;
    ClearDepthStencilValue depthStencil;
    constexpr bool operator==(ClearValue const& value) const {
        return color == value.color && depthStencil == value.depthStencil ;}
    constexpr bool operator!=(ClearValue const& value) const {return !(*this == value);}
    ClearValue& setColor(ClearColorValue color_) {this->color = color_; return *this; }
    ClearValue& setDepthStencil(ClearDepthStencilValue depthStencil_) {this->depthStencil = depthStencil_; return *this; }
};
struct RenderPassBeginInfo {
    StructureType sType{StructureType::RenderPassBeginInfo};
    const void* pNext = nullptr;
    RenderPass renderPass{};
    Framebuffer framebuffer{};
    Rect2D renderArea{};
    uint32_t clearValueCount{0};
    const ClearValue* pClearValues = nullptr;
    RenderPassBeginInfo& setRenderPass(RenderPass renderPass_) {this->renderPass = renderPass_; return *this; }
    RenderPassBeginInfo& setFramebuffer(Framebuffer framebuffer_) {this->framebuffer = framebuffer_; return *this; }
    RenderPassBeginInfo& setRenderArea(Rect2D renderArea_) {this->renderArea = renderArea_; return *this; }
    RenderPassBeginInfo& setClearValueCount(uint32_t clearValueCount_) {this->clearValueCount = clearValueCount_; return *this; }
    RenderPassBeginInfo& setPClearValues(const ClearValue* pClearValues_) {this->pClearValues = pClearValues_; return *this; }
    RenderPassBeginInfo& setPClearValues(detail::span<const ClearValue> pClearValues_) {this->clearValueCount = pClearValues_.size(); this->pClearValues = pClearValues_.data();  return *this; }
};
struct ClearAttachment {
    ImageAspectFlags aspectMask{};
    uint32_t colorAttachment{0};
    ClearValue clearValue{};
    constexpr bool operator==(ClearAttachment const& value) const {
        return aspectMask == value.aspectMask && colorAttachment == value.colorAttachment && clearValue == value.clearValue ;}
    constexpr bool operator!=(ClearAttachment const& value) const {return !(*this == value);}
    ClearAttachment& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
    ClearAttachment& setColorAttachment(uint32_t colorAttachment_) {this->colorAttachment = colorAttachment_; return *this; }
    ClearAttachment& setClearValue(ClearValue clearValue_) {this->clearValue = clearValue_; return *this; }
};
struct AttachmentDescription {
    AttachmentDescriptionFlags flags{};
    Format format{static_cast<Format>(0)};
    SampleCountFlagBits samples{static_cast<SampleCountFlagBits>(0)};
    AttachmentLoadOp loadOp{static_cast<AttachmentLoadOp>(0)};
    AttachmentStoreOp storeOp{static_cast<AttachmentStoreOp>(0)};
    AttachmentLoadOp stencilLoadOp{static_cast<AttachmentLoadOp>(0)};
    AttachmentStoreOp stencilStoreOp{static_cast<AttachmentStoreOp>(0)};
    ImageLayout initialLayout{static_cast<ImageLayout>(0)};
    ImageLayout finalLayout{static_cast<ImageLayout>(0)};
    constexpr bool operator==(AttachmentDescription const& value) const {
        return flags == value.flags && format == value.format && samples == value.samples && loadOp == value.loadOp && storeOp == value.storeOp && stencilLoadOp == value.stencilLoadOp 
        && stencilStoreOp == value.stencilStoreOp && initialLayout == value.initialLayout && finalLayout == value.finalLayout ;}
    constexpr bool operator!=(AttachmentDescription const& value) const {return !(*this == value);}
    AttachmentDescription& setFlags(AttachmentDescriptionFlags flags_) {this->flags = flags_; return *this; }
    AttachmentDescription& setFormat(Format format_) {this->format = format_; return *this; }
    AttachmentDescription& setSamples(SampleCountFlagBits samples_) {this->samples = samples_; return *this; }
    AttachmentDescription& setLoadOp(AttachmentLoadOp loadOp_) {this->loadOp = loadOp_; return *this; }
    AttachmentDescription& setStoreOp(AttachmentStoreOp storeOp_) {this->storeOp = storeOp_; return *this; }
    AttachmentDescription& setStencilLoadOp(AttachmentLoadOp stencilLoadOp_) {this->stencilLoadOp = stencilLoadOp_; return *this; }
    AttachmentDescription& setStencilStoreOp(AttachmentStoreOp stencilStoreOp_) {this->stencilStoreOp = stencilStoreOp_; return *this; }
    AttachmentDescription& setInitialLayout(ImageLayout initialLayout_) {this->initialLayout = initialLayout_; return *this; }
    AttachmentDescription& setFinalLayout(ImageLayout finalLayout_) {this->finalLayout = finalLayout_; return *this; }
};
struct AttachmentReference {
    uint32_t attachment{0};
    ImageLayout layout{static_cast<ImageLayout>(0)};
    constexpr bool operator==(AttachmentReference const& value) const {
        return attachment == value.attachment && layout == value.layout ;}
    constexpr bool operator!=(AttachmentReference const& value) const {return !(*this == value);}
    AttachmentReference& setAttachment(uint32_t attachment_) {this->attachment = attachment_; return *this; }
    AttachmentReference& setLayout(ImageLayout layout_) {this->layout = layout_; return *this; }
};
struct SubpassDescription {
    SubpassDescriptionFlags flags{};
    PipelineBindPoint pipelineBindPoint{static_cast<PipelineBindPoint>(0)};
    uint32_t inputAttachmentCount{0};
    const AttachmentReference* pInputAttachments = nullptr;
    uint32_t colorAttachmentCount{0};
    const AttachmentReference* pColorAttachments = nullptr;
    const AttachmentReference* pResolveAttachments = nullptr;
    const AttachmentReference* pDepthStencilAttachment = nullptr;
    uint32_t preserveAttachmentCount{0};
    const uint32_t* pPreserveAttachments = nullptr;
    SubpassDescription& setFlags(SubpassDescriptionFlags flags_) {this->flags = flags_; return *this; }
    SubpassDescription& setPipelineBindPoint(PipelineBindPoint pipelineBindPoint_) {this->pipelineBindPoint = pipelineBindPoint_; return *this; }
    SubpassDescription& setInputAttachmentCount(uint32_t inputAttachmentCount_) {this->inputAttachmentCount = inputAttachmentCount_; return *this; }
    SubpassDescription& setPInputAttachments(const AttachmentReference* pInputAttachments_) {this->pInputAttachments = pInputAttachments_; return *this; }
    SubpassDescription& setPInputAttachments(detail::span<const AttachmentReference> pInputAttachments_) {this->inputAttachmentCount = pInputAttachments_.size(); this->pInputAttachments = pInputAttachments_.data();  return *this; }
    SubpassDescription& setColorAttachmentCount(uint32_t colorAttachmentCount_) {this->colorAttachmentCount = colorAttachmentCount_; return *this; }
    SubpassDescription& setPColorAttachments(const AttachmentReference* pColorAttachments_) {this->pColorAttachments = pColorAttachments_; return *this; }
    SubpassDescription& setPColorAttachments(detail::span<const AttachmentReference> pColorAttachments_) {this->colorAttachmentCount = pColorAttachments_.size(); this->pColorAttachments = pColorAttachments_.data();  return *this; }
    SubpassDescription& setPResolveAttachments(const AttachmentReference* pResolveAttachments_) {this->pResolveAttachments = pResolveAttachments_; return *this; }
    SubpassDescription& setPResolveAttachments(detail::span<const AttachmentReference> pResolveAttachments_) {this->colorAttachmentCount = pResolveAttachments_.size(); this->pResolveAttachments = pResolveAttachments_.data();  return *this; }
    SubpassDescription& setPDepthStencilAttachment(const AttachmentReference* pDepthStencilAttachment_) {this->pDepthStencilAttachment = pDepthStencilAttachment_; return *this; }
    SubpassDescription& setPDepthStencilAttachment(AttachmentReference const& pDepthStencilAttachment_) {this->pDepthStencilAttachment = &pDepthStencilAttachment_; return *this; }
    SubpassDescription& setPreserveAttachmentCount(uint32_t preserveAttachmentCount_) {this->preserveAttachmentCount = preserveAttachmentCount_; return *this; }
    SubpassDescription& setPPreserveAttachments(const uint32_t* pPreserveAttachments_) {this->pPreserveAttachments = pPreserveAttachments_; return *this; }
    SubpassDescription& setPPreserveAttachments(detail::span<const uint32_t> pPreserveAttachments_) {this->preserveAttachmentCount = pPreserveAttachments_.size(); this->pPreserveAttachments = pPreserveAttachments_.data();  return *this; }
};
struct SubpassDependency {
    uint32_t srcSubpass{0};
    uint32_t dstSubpass{0};
    PipelineStageFlags srcStageMask{};
    PipelineStageFlags dstStageMask{};
    AccessFlags srcAccessMask{};
    AccessFlags dstAccessMask{};
    DependencyFlags dependencyFlags{};
    constexpr bool operator==(SubpassDependency const& value) const {
        return srcSubpass == value.srcSubpass && dstSubpass == value.dstSubpass && srcStageMask == value.srcStageMask && dstStageMask == value.dstStageMask 
        && srcAccessMask == value.srcAccessMask && dstAccessMask == value.dstAccessMask && dependencyFlags == value.dependencyFlags ;}
    constexpr bool operator!=(SubpassDependency const& value) const {return !(*this == value);}
    SubpassDependency& setSrcSubpass(uint32_t srcSubpass_) {this->srcSubpass = srcSubpass_; return *this; }
    SubpassDependency& setDstSubpass(uint32_t dstSubpass_) {this->dstSubpass = dstSubpass_; return *this; }
    SubpassDependency& setSrcStageMask(PipelineStageFlags srcStageMask_) {this->srcStageMask = srcStageMask_; return *this; }
    SubpassDependency& setDstStageMask(PipelineStageFlags dstStageMask_) {this->dstStageMask = dstStageMask_; return *this; }
    SubpassDependency& setSrcAccessMask(AccessFlags srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    SubpassDependency& setDstAccessMask(AccessFlags dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
    SubpassDependency& setDependencyFlags(DependencyFlags dependencyFlags_) {this->dependencyFlags = dependencyFlags_; return *this; }
};
struct RenderPassCreateInfo {
    StructureType sType{StructureType::RenderPassCreateInfo};
    const void* pNext = nullptr;
    RenderPassCreateFlags flags{};
    uint32_t attachmentCount{0};
    const AttachmentDescription* pAttachments = nullptr;
    uint32_t subpassCount{0};
    const SubpassDescription* pSubpasses = nullptr;
    uint32_t dependencyCount{0};
    const SubpassDependency* pDependencies = nullptr;
    RenderPassCreateInfo& setFlags(RenderPassCreateFlags flags_) {this->flags = flags_; return *this; }
    RenderPassCreateInfo& setAttachmentCount(uint32_t attachmentCount_) {this->attachmentCount = attachmentCount_; return *this; }
    RenderPassCreateInfo& setPAttachments(const AttachmentDescription* pAttachments_) {this->pAttachments = pAttachments_; return *this; }
    RenderPassCreateInfo& setPAttachments(detail::span<const AttachmentDescription> pAttachments_) {this->attachmentCount = pAttachments_.size(); this->pAttachments = pAttachments_.data();  return *this; }
    RenderPassCreateInfo& setSubpassCount(uint32_t subpassCount_) {this->subpassCount = subpassCount_; return *this; }
    RenderPassCreateInfo& setPSubpasses(const SubpassDescription* pSubpasses_) {this->pSubpasses = pSubpasses_; return *this; }
    RenderPassCreateInfo& setPSubpasses(detail::span<const SubpassDescription> pSubpasses_) {this->subpassCount = pSubpasses_.size(); this->pSubpasses = pSubpasses_.data();  return *this; }
    RenderPassCreateInfo& setDependencyCount(uint32_t dependencyCount_) {this->dependencyCount = dependencyCount_; return *this; }
    RenderPassCreateInfo& setPDependencies(const SubpassDependency* pDependencies_) {this->pDependencies = pDependencies_; return *this; }
    RenderPassCreateInfo& setPDependencies(detail::span<const SubpassDependency> pDependencies_) {this->dependencyCount = pDependencies_.size(); this->pDependencies = pDependencies_.data();  return *this; }
};
struct EventCreateInfo {
    StructureType sType{StructureType::EventCreateInfo};
    const void* pNext = nullptr;
    EventCreateFlags flags{};
    EventCreateInfo& setFlags(EventCreateFlags flags_) {this->flags = flags_; return *this; }
};
struct FenceCreateInfo {
    StructureType sType{StructureType::FenceCreateInfo};
    const void* pNext = nullptr;
    FenceCreateFlags flags{};
    FenceCreateInfo& setFlags(FenceCreateFlags flags_) {this->flags = flags_; return *this; }
};
struct SemaphoreCreateInfo {
    StructureType sType{StructureType::SemaphoreCreateInfo};
    const void* pNext = nullptr;
    SemaphoreCreateFlags flags{};
    SemaphoreCreateInfo& setFlags(SemaphoreCreateFlags flags_) {this->flags = flags_; return *this; }
};
struct QueryPoolCreateInfo {
    StructureType sType{StructureType::QueryPoolCreateInfo};
    const void* pNext = nullptr;
    QueryPoolCreateFlags flags{};
    QueryType queryType{static_cast<QueryType>(0)};
    uint32_t queryCount{0};
    QueryPipelineStatisticFlags pipelineStatistics{};
    QueryPoolCreateInfo& setFlags(QueryPoolCreateFlags flags_) {this->flags = flags_; return *this; }
    QueryPoolCreateInfo& setQueryType(QueryType queryType_) {this->queryType = queryType_; return *this; }
    QueryPoolCreateInfo& setQueryCount(uint32_t queryCount_) {this->queryCount = queryCount_; return *this; }
    QueryPoolCreateInfo& setPipelineStatistics(QueryPipelineStatisticFlags pipelineStatistics_) {this->pipelineStatistics = pipelineStatistics_; return *this; }
};
struct FramebufferCreateInfo {
    StructureType sType{StructureType::FramebufferCreateInfo};
    const void* pNext = nullptr;
    FramebufferCreateFlags flags{};
    RenderPass renderPass{};
    uint32_t attachmentCount{0};
    const ImageView* pAttachments = nullptr;
    uint32_t width{0};
    uint32_t height{0};
    uint32_t layers{0};
    FramebufferCreateInfo& setFlags(FramebufferCreateFlags flags_) {this->flags = flags_; return *this; }
    FramebufferCreateInfo& setRenderPass(RenderPass renderPass_) {this->renderPass = renderPass_; return *this; }
    FramebufferCreateInfo& setAttachmentCount(uint32_t attachmentCount_) {this->attachmentCount = attachmentCount_; return *this; }
    FramebufferCreateInfo& setPAttachments(const ImageView* pAttachments_) {this->pAttachments = pAttachments_; return *this; }
    FramebufferCreateInfo& setPAttachments(detail::span<const ImageView> pAttachments_) {this->attachmentCount = pAttachments_.size(); this->pAttachments = pAttachments_.data();  return *this; }
    FramebufferCreateInfo& setWidth(uint32_t width_) {this->width = width_; return *this; }
    FramebufferCreateInfo& setHeight(uint32_t height_) {this->height = height_; return *this; }
    FramebufferCreateInfo& setLayers(uint32_t layers_) {this->layers = layers_; return *this; }
};
struct DrawIndirectCommand {
    uint32_t vertexCount{0};
    uint32_t instanceCount{0};
    uint32_t firstVertex{0};
    uint32_t firstInstance{0};
    constexpr bool operator==(DrawIndirectCommand const& value) const {
        return vertexCount == value.vertexCount && instanceCount == value.instanceCount && firstVertex == value.firstVertex && firstInstance == value.firstInstance 
        ;}
    constexpr bool operator!=(DrawIndirectCommand const& value) const {return !(*this == value);}
    DrawIndirectCommand& setVertexCount(uint32_t vertexCount_) {this->vertexCount = vertexCount_; return *this; }
    DrawIndirectCommand& setInstanceCount(uint32_t instanceCount_) {this->instanceCount = instanceCount_; return *this; }
    DrawIndirectCommand& setFirstVertex(uint32_t firstVertex_) {this->firstVertex = firstVertex_; return *this; }
    DrawIndirectCommand& setFirstInstance(uint32_t firstInstance_) {this->firstInstance = firstInstance_; return *this; }
};
struct DrawIndexedIndirectCommand {
    uint32_t indexCount{0};
    uint32_t instanceCount{0};
    uint32_t firstIndex{0};
    int32_t vertexOffset{0};
    uint32_t firstInstance{0};
    constexpr bool operator==(DrawIndexedIndirectCommand const& value) const {
        return indexCount == value.indexCount && instanceCount == value.instanceCount && firstIndex == value.firstIndex && vertexOffset == value.vertexOffset 
        && firstInstance == value.firstInstance ;}
    constexpr bool operator!=(DrawIndexedIndirectCommand const& value) const {return !(*this == value);}
    DrawIndexedIndirectCommand& setIndexCount(uint32_t indexCount_) {this->indexCount = indexCount_; return *this; }
    DrawIndexedIndirectCommand& setInstanceCount(uint32_t instanceCount_) {this->instanceCount = instanceCount_; return *this; }
    DrawIndexedIndirectCommand& setFirstIndex(uint32_t firstIndex_) {this->firstIndex = firstIndex_; return *this; }
    DrawIndexedIndirectCommand& setVertexOffset(int32_t vertexOffset_) {this->vertexOffset = vertexOffset_; return *this; }
    DrawIndexedIndirectCommand& setFirstInstance(uint32_t firstInstance_) {this->firstInstance = firstInstance_; return *this; }
};
struct DispatchIndirectCommand {
    uint32_t x{0};
    uint32_t y{0};
    uint32_t z{0};
    constexpr bool operator==(DispatchIndirectCommand const& value) const {
        return x == value.x && y == value.y && z == value.z ;}
    constexpr bool operator!=(DispatchIndirectCommand const& value) const {return !(*this == value);}
    DispatchIndirectCommand& setX(uint32_t x_) {this->x = x_; return *this; }
    DispatchIndirectCommand& setY(uint32_t y_) {this->y = y_; return *this; }
    DispatchIndirectCommand& setZ(uint32_t z_) {this->z = z_; return *this; }
};
struct SubmitInfo {
    StructureType sType{StructureType::SubmitInfo};
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount{0};
    const Semaphore* pWaitSemaphores = nullptr;
    const PipelineStageFlags* pWaitDstStageMask = nullptr;
    uint32_t commandBufferCount{0};
    const CommandBuffer* pCommandBuffers = nullptr;
    uint32_t signalSemaphoreCount{0};
    const Semaphore* pSignalSemaphores = nullptr;
    SubmitInfo& setWaitSemaphoreCount(uint32_t waitSemaphoreCount_) {this->waitSemaphoreCount = waitSemaphoreCount_; return *this; }
    SubmitInfo& setPWaitSemaphores(const Semaphore* pWaitSemaphores_) {this->pWaitSemaphores = pWaitSemaphores_; return *this; }
    SubmitInfo& setPWaitSemaphores(detail::span<const Semaphore> pWaitSemaphores_) {this->waitSemaphoreCount = pWaitSemaphores_.size(); this->pWaitSemaphores = pWaitSemaphores_.data();  return *this; }
    SubmitInfo& setPWaitDstStageMask(const PipelineStageFlags* pWaitDstStageMask_) {this->pWaitDstStageMask = pWaitDstStageMask_; return *this; }
    SubmitInfo& setPWaitDstStageMask(detail::span<const PipelineStageFlags> pWaitDstStageMask_) {this->waitSemaphoreCount = pWaitDstStageMask_.size(); this->pWaitDstStageMask = pWaitDstStageMask_.data();  return *this; }
    SubmitInfo& setCommandBufferCount(uint32_t commandBufferCount_) {this->commandBufferCount = commandBufferCount_; return *this; }
    SubmitInfo& setPCommandBuffers(const CommandBuffer* pCommandBuffers_) {this->pCommandBuffers = pCommandBuffers_; return *this; }
    SubmitInfo& setPCommandBuffers(detail::span<const CommandBuffer> pCommandBuffers_) {this->commandBufferCount = pCommandBuffers_.size(); this->pCommandBuffers = pCommandBuffers_.data();  return *this; }
    SubmitInfo& setSignalSemaphoreCount(uint32_t signalSemaphoreCount_) {this->signalSemaphoreCount = signalSemaphoreCount_; return *this; }
    SubmitInfo& setPSignalSemaphores(const Semaphore* pSignalSemaphores_) {this->pSignalSemaphores = pSignalSemaphores_; return *this; }
    SubmitInfo& setPSignalSemaphores(detail::span<const Semaphore> pSignalSemaphores_) {this->signalSemaphoreCount = pSignalSemaphores_.size(); this->pSignalSemaphores = pSignalSemaphores_.data();  return *this; }
};
struct DisplayPropertiesKHR {
    DisplayKHR display{};
    const char* displayName = nullptr;
    Extent2D physicalDimensions{};
    Extent2D physicalResolution{};
    SurfaceTransformFlagsKHR supportedTransforms{};
    Bool32 planeReorderPossible{0};
    Bool32 persistentContent{0};
    DisplayPropertiesKHR& setDisplay(DisplayKHR display_) {this->display = display_; return *this; }
    DisplayPropertiesKHR& setDisplayName(const char* displayName_) {this->displayName = displayName_; return *this; }
    DisplayPropertiesKHR& setPhysicalDimensions(Extent2D physicalDimensions_) {this->physicalDimensions = physicalDimensions_; return *this; }
    DisplayPropertiesKHR& setPhysicalResolution(Extent2D physicalResolution_) {this->physicalResolution = physicalResolution_; return *this; }
    DisplayPropertiesKHR& setSupportedTransforms(SurfaceTransformFlagsKHR supportedTransforms_) {this->supportedTransforms = supportedTransforms_; return *this; }
    DisplayPropertiesKHR& setPlaneReorderPossible(Bool32 planeReorderPossible_) {this->planeReorderPossible = planeReorderPossible_; return *this; }
    DisplayPropertiesKHR& setPersistentContent(Bool32 persistentContent_) {this->persistentContent = persistentContent_; return *this; }
};
struct DisplayPlanePropertiesKHR {
    DisplayKHR currentDisplay{};
    uint32_t currentStackIndex{0};
    DisplayPlanePropertiesKHR& setCurrentDisplay(DisplayKHR currentDisplay_) {this->currentDisplay = currentDisplay_; return *this; }
    DisplayPlanePropertiesKHR& setCurrentStackIndex(uint32_t currentStackIndex_) {this->currentStackIndex = currentStackIndex_; return *this; }
};
struct DisplayModeParametersKHR {
    Extent2D visibleRegion{};
    uint32_t refreshRate{0};
    constexpr bool operator==(DisplayModeParametersKHR const& value) const {
        return visibleRegion == value.visibleRegion && refreshRate == value.refreshRate ;}
    constexpr bool operator!=(DisplayModeParametersKHR const& value) const {return !(*this == value);}
    DisplayModeParametersKHR& setVisibleRegion(Extent2D visibleRegion_) {this->visibleRegion = visibleRegion_; return *this; }
    DisplayModeParametersKHR& setRefreshRate(uint32_t refreshRate_) {this->refreshRate = refreshRate_; return *this; }
};
struct DisplayModePropertiesKHR {
    DisplayModeKHR displayMode{};
    DisplayModeParametersKHR parameters{};
    DisplayModePropertiesKHR& setDisplayMode(DisplayModeKHR displayMode_) {this->displayMode = displayMode_; return *this; }
    DisplayModePropertiesKHR& setParameters(DisplayModeParametersKHR parameters_) {this->parameters = parameters_; return *this; }
};
struct DisplayModeCreateInfoKHR {
    StructureType sType{StructureType::DisplayModeCreateInfoKHR};
    const void* pNext = nullptr;
    DisplayModeCreateFlagsKHR flags{};
    DisplayModeParametersKHR parameters{};
    DisplayModeCreateInfoKHR& setFlags(DisplayModeCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    DisplayModeCreateInfoKHR& setParameters(DisplayModeParametersKHR parameters_) {this->parameters = parameters_; return *this; }
};
struct DisplayPlaneCapabilitiesKHR {
    DisplayPlaneAlphaFlagsKHR supportedAlpha{};
    Offset2D minSrcPosition{};
    Offset2D maxSrcPosition{};
    Extent2D minSrcExtent{};
    Extent2D maxSrcExtent{};
    Offset2D minDstPosition{};
    Offset2D maxDstPosition{};
    Extent2D minDstExtent{};
    Extent2D maxDstExtent{};
    constexpr bool operator==(DisplayPlaneCapabilitiesKHR const& value) const {
        return supportedAlpha == value.supportedAlpha && minSrcPosition == value.minSrcPosition && maxSrcPosition == value.maxSrcPosition && minSrcExtent == value.minSrcExtent 
        && maxSrcExtent == value.maxSrcExtent && minDstPosition == value.minDstPosition && maxDstPosition == value.maxDstPosition && minDstExtent == value.minDstExtent 
        && maxDstExtent == value.maxDstExtent ;}
    constexpr bool operator!=(DisplayPlaneCapabilitiesKHR const& value) const {return !(*this == value);}
    DisplayPlaneCapabilitiesKHR& setSupportedAlpha(DisplayPlaneAlphaFlagsKHR supportedAlpha_) {this->supportedAlpha = supportedAlpha_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMinSrcPosition(Offset2D minSrcPosition_) {this->minSrcPosition = minSrcPosition_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMaxSrcPosition(Offset2D maxSrcPosition_) {this->maxSrcPosition = maxSrcPosition_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMinSrcExtent(Extent2D minSrcExtent_) {this->minSrcExtent = minSrcExtent_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMaxSrcExtent(Extent2D maxSrcExtent_) {this->maxSrcExtent = maxSrcExtent_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMinDstPosition(Offset2D minDstPosition_) {this->minDstPosition = minDstPosition_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMaxDstPosition(Offset2D maxDstPosition_) {this->maxDstPosition = maxDstPosition_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMinDstExtent(Extent2D minDstExtent_) {this->minDstExtent = minDstExtent_; return *this; }
    DisplayPlaneCapabilitiesKHR& setMaxDstExtent(Extent2D maxDstExtent_) {this->maxDstExtent = maxDstExtent_; return *this; }
};
struct DisplaySurfaceCreateInfoKHR {
    StructureType sType{StructureType::DisplaySurfaceCreateInfoKHR};
    const void* pNext = nullptr;
    DisplaySurfaceCreateFlagsKHR flags{};
    DisplayModeKHR displayMode{};
    uint32_t planeIndex{0};
    uint32_t planeStackIndex{0};
    SurfaceTransformFlagBitsKHR transform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    float globalAlpha{0.f};
    DisplayPlaneAlphaFlagBitsKHR alphaMode{static_cast<DisplayPlaneAlphaFlagBitsKHR>(0)};
    Extent2D imageExtent{};
    DisplaySurfaceCreateInfoKHR& setFlags(DisplaySurfaceCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    DisplaySurfaceCreateInfoKHR& setDisplayMode(DisplayModeKHR displayMode_) {this->displayMode = displayMode_; return *this; }
    DisplaySurfaceCreateInfoKHR& setPlaneIndex(uint32_t planeIndex_) {this->planeIndex = planeIndex_; return *this; }
    DisplaySurfaceCreateInfoKHR& setPlaneStackIndex(uint32_t planeStackIndex_) {this->planeStackIndex = planeStackIndex_; return *this; }
    DisplaySurfaceCreateInfoKHR& setTransform(SurfaceTransformFlagBitsKHR transform_) {this->transform = transform_; return *this; }
    DisplaySurfaceCreateInfoKHR& setGlobalAlpha(float globalAlpha_) {this->globalAlpha = globalAlpha_; return *this; }
    DisplaySurfaceCreateInfoKHR& setAlphaMode(DisplayPlaneAlphaFlagBitsKHR alphaMode_) {this->alphaMode = alphaMode_; return *this; }
    DisplaySurfaceCreateInfoKHR& setImageExtent(Extent2D imageExtent_) {this->imageExtent = imageExtent_; return *this; }
};
struct DisplayPresentInfoKHR {
    StructureType sType{StructureType::DisplayPresentInfoKHR};
    const void* pNext = nullptr;
    Rect2D srcRect{};
    Rect2D dstRect{};
    Bool32 persistent{0};
    DisplayPresentInfoKHR& setSrcRect(Rect2D srcRect_) {this->srcRect = srcRect_; return *this; }
    DisplayPresentInfoKHR& setDstRect(Rect2D dstRect_) {this->dstRect = dstRect_; return *this; }
    DisplayPresentInfoKHR& setPersistent(Bool32 persistent_) {this->persistent = persistent_; return *this; }
};
struct SurfaceCapabilitiesKHR {
    uint32_t minImageCount{0};
    uint32_t maxImageCount{0};
    Extent2D currentExtent{};
    Extent2D minImageExtent{};
    Extent2D maxImageExtent{};
    uint32_t maxImageArrayLayers{0};
    SurfaceTransformFlagsKHR supportedTransforms{};
    SurfaceTransformFlagBitsKHR currentTransform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    CompositeAlphaFlagsKHR supportedCompositeAlpha{};
    ImageUsageFlags supportedUsageFlags{};
    constexpr bool operator==(SurfaceCapabilitiesKHR const& value) const {
        return minImageCount == value.minImageCount && maxImageCount == value.maxImageCount && currentExtent == value.currentExtent && minImageExtent == value.minImageExtent 
        && maxImageExtent == value.maxImageExtent && maxImageArrayLayers == value.maxImageArrayLayers && supportedTransforms == value.supportedTransforms 
        && currentTransform == value.currentTransform && supportedCompositeAlpha == value.supportedCompositeAlpha && supportedUsageFlags == value.supportedUsageFlags 
        ;}
    constexpr bool operator!=(SurfaceCapabilitiesKHR const& value) const {return !(*this == value);}
    SurfaceCapabilitiesKHR& setMinImageCount(uint32_t minImageCount_) {this->minImageCount = minImageCount_; return *this; }
    SurfaceCapabilitiesKHR& setMaxImageCount(uint32_t maxImageCount_) {this->maxImageCount = maxImageCount_; return *this; }
    SurfaceCapabilitiesKHR& setCurrentExtent(Extent2D currentExtent_) {this->currentExtent = currentExtent_; return *this; }
    SurfaceCapabilitiesKHR& setMinImageExtent(Extent2D minImageExtent_) {this->minImageExtent = minImageExtent_; return *this; }
    SurfaceCapabilitiesKHR& setMaxImageExtent(Extent2D maxImageExtent_) {this->maxImageExtent = maxImageExtent_; return *this; }
    SurfaceCapabilitiesKHR& setMaxImageArrayLayers(uint32_t maxImageArrayLayers_) {this->maxImageArrayLayers = maxImageArrayLayers_; return *this; }
    SurfaceCapabilitiesKHR& setSupportedTransforms(SurfaceTransformFlagsKHR supportedTransforms_) {this->supportedTransforms = supportedTransforms_; return *this; }
    SurfaceCapabilitiesKHR& setCurrentTransform(SurfaceTransformFlagBitsKHR currentTransform_) {this->currentTransform = currentTransform_; return *this; }
    SurfaceCapabilitiesKHR& setSupportedCompositeAlpha(CompositeAlphaFlagsKHR supportedCompositeAlpha_) {this->supportedCompositeAlpha = supportedCompositeAlpha_; return *this; }
    SurfaceCapabilitiesKHR& setSupportedUsageFlags(ImageUsageFlags supportedUsageFlags_) {this->supportedUsageFlags = supportedUsageFlags_; return *this; }
};
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct AndroidSurfaceCreateInfoKHR {
    StructureType sType{StructureType::AndroidSurfaceCreateInfoKHR};
    const void* pNext = nullptr;
    AndroidSurfaceCreateFlagsKHR flags{};
    ANativeWindow* window = nullptr;
    AndroidSurfaceCreateInfoKHR& setFlags(AndroidSurfaceCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    AndroidSurfaceCreateInfoKHR& setWindow(ANativeWindow* window_) {this->window = window_; return *this; }
    AndroidSurfaceCreateInfoKHR& setWindow(ANativeWindow & window_) {this->window = &window_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_VI_NN)
struct ViSurfaceCreateInfoNN {
    StructureType sType{StructureType::ViSurfaceCreateInfoNN};
    const void* pNext = nullptr;
    ViSurfaceCreateFlagsNN flags{};
    void* window = nullptr;
    ViSurfaceCreateInfoNN& setFlags(ViSurfaceCreateFlagsNN flags_) {this->flags = flags_; return *this; }
    ViSurfaceCreateInfoNN& setWindow(void* window_) {this->window = window_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_VI_NN)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
struct WaylandSurfaceCreateInfoKHR {
    StructureType sType{StructureType::WaylandSurfaceCreateInfoKHR};
    const void* pNext = nullptr;
    WaylandSurfaceCreateFlagsKHR flags{};
    wl_display* display = nullptr;
    wl_surface* surface = nullptr;
    WaylandSurfaceCreateInfoKHR& setFlags(WaylandSurfaceCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    WaylandSurfaceCreateInfoKHR& setDisplay(wl_display* display_) {this->display = display_; return *this; }
    WaylandSurfaceCreateInfoKHR& setDisplay(wl_display & display_) {this->display = &display_; return *this; }
    WaylandSurfaceCreateInfoKHR& setSurface(wl_surface* surface_) {this->surface = surface_; return *this; }
    WaylandSurfaceCreateInfoKHR& setSurface(wl_surface & surface_) {this->surface = &surface_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct Win32SurfaceCreateInfoKHR {
    StructureType sType{StructureType::Win32SurfaceCreateInfoKHR};
    const void* pNext = nullptr;
    Win32SurfaceCreateFlagsKHR flags{};
    HINSTANCE hinstance{};
    HWND hwnd{};
    Win32SurfaceCreateInfoKHR& setFlags(Win32SurfaceCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    Win32SurfaceCreateInfoKHR& setHinstance(HINSTANCE hinstance_) {this->hinstance = hinstance_; return *this; }
    Win32SurfaceCreateInfoKHR& setHwnd(HWND hwnd_) {this->hwnd = hwnd_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_XLIB_KHR)
struct XlibSurfaceCreateInfoKHR {
    StructureType sType{StructureType::XlibSurfaceCreateInfoKHR};
    const void* pNext = nullptr;
    XlibSurfaceCreateFlagsKHR flags{};
    Display* dpy = nullptr;
    Window window{};
    XlibSurfaceCreateInfoKHR& setFlags(XlibSurfaceCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    XlibSurfaceCreateInfoKHR& setDpy(Display* dpy_) {this->dpy = dpy_; return *this; }
    XlibSurfaceCreateInfoKHR& setDpy(Display & dpy_) {this->dpy = &dpy_; return *this; }
    XlibSurfaceCreateInfoKHR& setWindow(Window window_) {this->window = window_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
struct XcbSurfaceCreateInfoKHR {
    StructureType sType{StructureType::XcbSurfaceCreateInfoKHR};
    const void* pNext = nullptr;
    XcbSurfaceCreateFlagsKHR flags{};
    xcb_connection_t* connection = nullptr;
    xcb_window_t window{};
    XcbSurfaceCreateInfoKHR& setFlags(XcbSurfaceCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    XcbSurfaceCreateInfoKHR& setConnection(xcb_connection_t* connection_) {this->connection = connection_; return *this; }
    XcbSurfaceCreateInfoKHR& setConnection(xcb_connection_t & connection_) {this->connection = &connection_; return *this; }
    XcbSurfaceCreateInfoKHR& setWindow(xcb_window_t window_) {this->window = window_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
struct DirectFBSurfaceCreateInfoEXT {
    StructureType sType{StructureType::DirectfbSurfaceCreateInfoEXT};
    const void* pNext = nullptr;
    DirectFBSurfaceCreateFlagsEXT flags{};
    IDirectFB* dfb = nullptr;
    IDirectFBSurface* surface = nullptr;
    DirectFBSurfaceCreateInfoEXT& setFlags(DirectFBSurfaceCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    DirectFBSurfaceCreateInfoEXT& setDfb(IDirectFB* dfb_) {this->dfb = dfb_; return *this; }
    DirectFBSurfaceCreateInfoEXT& setDfb(IDirectFB & dfb_) {this->dfb = &dfb_; return *this; }
    DirectFBSurfaceCreateInfoEXT& setSurface(IDirectFBSurface* surface_) {this->surface = surface_; return *this; }
    DirectFBSurfaceCreateInfoEXT& setSurface(IDirectFBSurface & surface_) {this->surface = &surface_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_FUCHSIA)
struct ImagePipeSurfaceCreateInfoFUCHSIA {
    StructureType sType{StructureType::ImagepipeSurfaceCreateInfoFUCHSIA};
    const void* pNext = nullptr;
    ImagePipeSurfaceCreateFlagsFUCHSIA flags{};
    zx_handle_t imagePipeHandle{};
    ImagePipeSurfaceCreateInfoFUCHSIA& setFlags(ImagePipeSurfaceCreateFlagsFUCHSIA flags_) {this->flags = flags_; return *this; }
    ImagePipeSurfaceCreateInfoFUCHSIA& setImagePipeHandle(zx_handle_t imagePipeHandle_) {this->imagePipeHandle = imagePipeHandle_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_GGP)
struct StreamDescriptorSurfaceCreateInfoGGP {
    StructureType sType{StructureType::StreamDescriptorSurfaceCreateInfoGGP};
    const void* pNext = nullptr;
    StreamDescriptorSurfaceCreateFlagsGGP flags{};
    GgpStreamDescriptor streamDescriptor{};
    StreamDescriptorSurfaceCreateInfoGGP& setFlags(StreamDescriptorSurfaceCreateFlagsGGP flags_) {this->flags = flags_; return *this; }
    StreamDescriptorSurfaceCreateInfoGGP& setStreamDescriptor(GgpStreamDescriptor streamDescriptor_) {this->streamDescriptor = streamDescriptor_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_GGP)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
struct ScreenSurfaceCreateInfoQNX {
    StructureType sType{StructureType::ScreenSurfaceCreateInfoQNX};
    const void* pNext = nullptr;
    ScreenSurfaceCreateFlagsQNX flags{};
    _screen_context* context = nullptr;
    _screen_window* window = nullptr;
    ScreenSurfaceCreateInfoQNX& setFlags(ScreenSurfaceCreateFlagsQNX flags_) {this->flags = flags_; return *this; }
    ScreenSurfaceCreateInfoQNX& setContext(_screen_context* context_) {this->context = context_; return *this; }
    ScreenSurfaceCreateInfoQNX& setContext(_screen_context & context_) {this->context = &context_; return *this; }
    ScreenSurfaceCreateInfoQNX& setWindow(_screen_window* window_) {this->window = window_; return *this; }
    ScreenSurfaceCreateInfoQNX& setWindow(_screen_window & window_) {this->window = &window_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
struct SurfaceFormatKHR {
    Format format{static_cast<Format>(0)};
    ColorSpaceKHR colorSpace{static_cast<ColorSpaceKHR>(0)};
    constexpr bool operator==(SurfaceFormatKHR const& value) const {
        return format == value.format && colorSpace == value.colorSpace ;}
    constexpr bool operator!=(SurfaceFormatKHR const& value) const {return !(*this == value);}
    SurfaceFormatKHR& setFormat(Format format_) {this->format = format_; return *this; }
    SurfaceFormatKHR& setColorSpace(ColorSpaceKHR colorSpace_) {this->colorSpace = colorSpace_; return *this; }
};
struct SwapchainCreateInfoKHR {
    StructureType sType{StructureType::SwapchainCreateInfoKHR};
    const void* pNext = nullptr;
    SwapchainCreateFlagsKHR flags{};
    SurfaceKHR surface{};
    uint32_t minImageCount{0};
    Format imageFormat{static_cast<Format>(0)};
    ColorSpaceKHR imageColorSpace{static_cast<ColorSpaceKHR>(0)};
    Extent2D imageExtent{};
    uint32_t imageArrayLayers{0};
    ImageUsageFlags imageUsage{};
    SharingMode imageSharingMode{static_cast<SharingMode>(0)};
    uint32_t queueFamilyIndexCount{0};
    const uint32_t* pQueueFamilyIndices = nullptr;
    SurfaceTransformFlagBitsKHR preTransform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    CompositeAlphaFlagBitsKHR compositeAlpha{static_cast<CompositeAlphaFlagBitsKHR>(0)};
    PresentModeKHR presentMode{static_cast<PresentModeKHR>(0)};
    Bool32 clipped{0};
    SwapchainKHR oldSwapchain{};
    SwapchainCreateInfoKHR& setFlags(SwapchainCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    SwapchainCreateInfoKHR& setSurface(SurfaceKHR surface_) {this->surface = surface_; return *this; }
    SwapchainCreateInfoKHR& setMinImageCount(uint32_t minImageCount_) {this->minImageCount = minImageCount_; return *this; }
    SwapchainCreateInfoKHR& setImageFormat(Format imageFormat_) {this->imageFormat = imageFormat_; return *this; }
    SwapchainCreateInfoKHR& setImageColorSpace(ColorSpaceKHR imageColorSpace_) {this->imageColorSpace = imageColorSpace_; return *this; }
    SwapchainCreateInfoKHR& setImageExtent(Extent2D imageExtent_) {this->imageExtent = imageExtent_; return *this; }
    SwapchainCreateInfoKHR& setImageArrayLayers(uint32_t imageArrayLayers_) {this->imageArrayLayers = imageArrayLayers_; return *this; }
    SwapchainCreateInfoKHR& setImageUsage(ImageUsageFlags imageUsage_) {this->imageUsage = imageUsage_; return *this; }
    SwapchainCreateInfoKHR& setImageSharingMode(SharingMode imageSharingMode_) {this->imageSharingMode = imageSharingMode_; return *this; }
    SwapchainCreateInfoKHR& setQueueFamilyIndexCount(uint32_t queueFamilyIndexCount_) {this->queueFamilyIndexCount = queueFamilyIndexCount_; return *this; }
    SwapchainCreateInfoKHR& setPQueueFamilyIndices(const uint32_t* pQueueFamilyIndices_) {this->pQueueFamilyIndices = pQueueFamilyIndices_; return *this; }
    SwapchainCreateInfoKHR& setPQueueFamilyIndices(detail::span<const uint32_t> pQueueFamilyIndices_) {this->queueFamilyIndexCount = pQueueFamilyIndices_.size(); this->pQueueFamilyIndices = pQueueFamilyIndices_.data();  return *this; }
    SwapchainCreateInfoKHR& setPreTransform(SurfaceTransformFlagBitsKHR preTransform_) {this->preTransform = preTransform_; return *this; }
    SwapchainCreateInfoKHR& setCompositeAlpha(CompositeAlphaFlagBitsKHR compositeAlpha_) {this->compositeAlpha = compositeAlpha_; return *this; }
    SwapchainCreateInfoKHR& setPresentMode(PresentModeKHR presentMode_) {this->presentMode = presentMode_; return *this; }
    SwapchainCreateInfoKHR& setClipped(Bool32 clipped_) {this->clipped = clipped_; return *this; }
    SwapchainCreateInfoKHR& setOldSwapchain(SwapchainKHR oldSwapchain_) {this->oldSwapchain = oldSwapchain_; return *this; }
};
struct PresentInfoKHR {
    StructureType sType{StructureType::PresentInfoKHR};
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount{0};
    const Semaphore* pWaitSemaphores = nullptr;
    uint32_t swapchainCount{0};
    const SwapchainKHR* pSwapchains = nullptr;
    const uint32_t* pImageIndices = nullptr;
    Result* pResults = nullptr;
    PresentInfoKHR& setWaitSemaphoreCount(uint32_t waitSemaphoreCount_) {this->waitSemaphoreCount = waitSemaphoreCount_; return *this; }
    PresentInfoKHR& setPWaitSemaphores(const Semaphore* pWaitSemaphores_) {this->pWaitSemaphores = pWaitSemaphores_; return *this; }
    PresentInfoKHR& setPWaitSemaphores(detail::span<const Semaphore> pWaitSemaphores_) {this->waitSemaphoreCount = pWaitSemaphores_.size(); this->pWaitSemaphores = pWaitSemaphores_.data();  return *this; }
    PresentInfoKHR& setSwapchainCount(uint32_t swapchainCount_) {this->swapchainCount = swapchainCount_; return *this; }
    PresentInfoKHR& setPSwapchains(const SwapchainKHR* pSwapchains_) {this->pSwapchains = pSwapchains_; return *this; }
    PresentInfoKHR& setPSwapchains(detail::span<const SwapchainKHR> pSwapchains_) {this->swapchainCount = pSwapchains_.size(); this->pSwapchains = pSwapchains_.data();  return *this; }
    PresentInfoKHR& setPImageIndices(const uint32_t* pImageIndices_) {this->pImageIndices = pImageIndices_; return *this; }
    PresentInfoKHR& setPImageIndices(detail::span<const uint32_t> pImageIndices_) {this->swapchainCount = pImageIndices_.size(); this->pImageIndices = pImageIndices_.data();  return *this; }
    PresentInfoKHR& setPResults(Result* pResults_) {this->pResults = pResults_; return *this; }
    PresentInfoKHR& setPResults(detail::span<Result> pResults_) {this->swapchainCount = pResults_.size(); this->pResults = pResults_.data();  return *this; }
};
struct DebugReportCallbackCreateInfoEXT {
    StructureType sType{StructureType::DebugReportCallbackCreateInfoEXT};
    const void* pNext = nullptr;
    DebugReportFlagsEXT flags{};
    PFN_DebugReportCallbackEXT pfnCallback{};
    void* pUserData = nullptr;
    DebugReportCallbackCreateInfoEXT& setFlags(DebugReportFlagsEXT flags_) {this->flags = flags_; return *this; }
    DebugReportCallbackCreateInfoEXT& setPfnCallback(PFN_DebugReportCallbackEXT pfnCallback_) {this->pfnCallback = pfnCallback_; return *this; }
    DebugReportCallbackCreateInfoEXT& setPUserData(void* pUserData_) {this->pUserData = pUserData_; return *this; }
};
struct ValidationFlagsEXT {
    StructureType sType{StructureType::ValidationFlagsEXT};
    const void* pNext = nullptr;
    uint32_t disabledValidationCheckCount{0};
    const ValidationCheckEXT* pDisabledValidationChecks = nullptr;
    ValidationFlagsEXT& setDisabledValidationCheckCount(uint32_t disabledValidationCheckCount_) {this->disabledValidationCheckCount = disabledValidationCheckCount_; return *this; }
    ValidationFlagsEXT& setPDisabledValidationChecks(const ValidationCheckEXT* pDisabledValidationChecks_) {this->pDisabledValidationChecks = pDisabledValidationChecks_; return *this; }
    ValidationFlagsEXT& setPDisabledValidationChecks(detail::span<const ValidationCheckEXT> pDisabledValidationChecks_) {this->disabledValidationCheckCount = pDisabledValidationChecks_.size(); this->pDisabledValidationChecks = pDisabledValidationChecks_.data();  return *this; }
};
struct ValidationFeaturesEXT {
    StructureType sType{StructureType::ValidationFeaturesEXT};
    const void* pNext = nullptr;
    uint32_t enabledValidationFeatureCount{0};
    const ValidationFeatureEnableEXT* pEnabledValidationFeatures = nullptr;
    uint32_t disabledValidationFeatureCount{0};
    const ValidationFeatureDisableEXT* pDisabledValidationFeatures = nullptr;
    ValidationFeaturesEXT& setEnabledValidationFeatureCount(uint32_t enabledValidationFeatureCount_) {this->enabledValidationFeatureCount = enabledValidationFeatureCount_; return *this; }
    ValidationFeaturesEXT& setPEnabledValidationFeatures(const ValidationFeatureEnableEXT* pEnabledValidationFeatures_) {this->pEnabledValidationFeatures = pEnabledValidationFeatures_; return *this; }
    ValidationFeaturesEXT& setPEnabledValidationFeatures(detail::span<const ValidationFeatureEnableEXT> pEnabledValidationFeatures_) {this->enabledValidationFeatureCount = pEnabledValidationFeatures_.size(); this->pEnabledValidationFeatures = pEnabledValidationFeatures_.data();  return *this; }
    ValidationFeaturesEXT& setDisabledValidationFeatureCount(uint32_t disabledValidationFeatureCount_) {this->disabledValidationFeatureCount = disabledValidationFeatureCount_; return *this; }
    ValidationFeaturesEXT& setPDisabledValidationFeatures(const ValidationFeatureDisableEXT* pDisabledValidationFeatures_) {this->pDisabledValidationFeatures = pDisabledValidationFeatures_; return *this; }
    ValidationFeaturesEXT& setPDisabledValidationFeatures(detail::span<const ValidationFeatureDisableEXT> pDisabledValidationFeatures_) {this->disabledValidationFeatureCount = pDisabledValidationFeatures_.size(); this->pDisabledValidationFeatures = pDisabledValidationFeatures_.data();  return *this; }
};
struct PipelineRasterizationStateRasterizationOrderAMD {
    StructureType sType{StructureType::PipelineRasterizationStateRasterizationOrderAMD};
    const void* pNext = nullptr;
    RasterizationOrderAMD rasterizationOrder{static_cast<RasterizationOrderAMD>(0)};
    PipelineRasterizationStateRasterizationOrderAMD& setRasterizationOrder(RasterizationOrderAMD rasterizationOrder_) {this->rasterizationOrder = rasterizationOrder_; return *this; }
};
struct DebugMarkerObjectNameInfoEXT {
    StructureType sType{StructureType::DebugMarkerObjectNameInfoEXT};
    const void* pNext = nullptr;
    DebugReportObjectTypeEXT objectType{static_cast<DebugReportObjectTypeEXT>(0)};
    uint64_t object{0};
    const char* pObjectName = nullptr;
    DebugMarkerObjectNameInfoEXT& setObjectType(DebugReportObjectTypeEXT objectType_) {this->objectType = objectType_; return *this; }
    DebugMarkerObjectNameInfoEXT& setObject(uint64_t object_) {this->object = object_; return *this; }
    DebugMarkerObjectNameInfoEXT& setPObjectName(const char* pObjectName_) {this->pObjectName = pObjectName_; return *this; }
};
struct DebugMarkerObjectTagInfoEXT {
    StructureType sType{StructureType::DebugMarkerObjectTagInfoEXT};
    const void* pNext = nullptr;
    DebugReportObjectTypeEXT objectType{static_cast<DebugReportObjectTypeEXT>(0)};
    uint64_t object{0};
    uint64_t tagName{0};
    size_t tagSize{0};
    const void* pTag = nullptr;
    DebugMarkerObjectTagInfoEXT& setObjectType(DebugReportObjectTypeEXT objectType_) {this->objectType = objectType_; return *this; }
    DebugMarkerObjectTagInfoEXT& setObject(uint64_t object_) {this->object = object_; return *this; }
    DebugMarkerObjectTagInfoEXT& setTagName(uint64_t tagName_) {this->tagName = tagName_; return *this; }
    DebugMarkerObjectTagInfoEXT& setTagSize(size_t tagSize_) {this->tagSize = tagSize_; return *this; }
    DebugMarkerObjectTagInfoEXT& setPTag(const void* pTag_) {this->pTag = pTag_; return *this; }
    DebugMarkerObjectTagInfoEXT& setPTag(detail::span<const std::byte> pTag_) {this->tagSize = pTag_.size(); this->pTag = pTag_.data();  return *this; }
};
struct DebugMarkerMarkerInfoEXT {
    StructureType sType{StructureType::DebugMarkerMarkerInfoEXT};
    const void* pNext = nullptr;
    const char* pMarkerName = nullptr;
    float color[4];
    DebugMarkerMarkerInfoEXT& setPMarkerName(const char* pMarkerName_) {this->pMarkerName = pMarkerName_; return *this; }
    DebugMarkerMarkerInfoEXT& setColor(float color_[4]) {for(uint32_t i = 0; i < 4; i++) this->color[i] = color_[i]; return *this; }
};
struct DedicatedAllocationImageCreateInfoNV {
    StructureType sType{StructureType::DedicatedAllocationImageCreateInfoNV};
    const void* pNext = nullptr;
    Bool32 dedicatedAllocation{0};
    DedicatedAllocationImageCreateInfoNV& setDedicatedAllocation(Bool32 dedicatedAllocation_) {this->dedicatedAllocation = dedicatedAllocation_; return *this; }
};
struct DedicatedAllocationBufferCreateInfoNV {
    StructureType sType{StructureType::DedicatedAllocationBufferCreateInfoNV};
    const void* pNext = nullptr;
    Bool32 dedicatedAllocation{0};
    DedicatedAllocationBufferCreateInfoNV& setDedicatedAllocation(Bool32 dedicatedAllocation_) {this->dedicatedAllocation = dedicatedAllocation_; return *this; }
};
struct DedicatedAllocationMemoryAllocateInfoNV {
    StructureType sType{StructureType::DedicatedAllocationMemoryAllocateInfoNV};
    const void* pNext = nullptr;
    Image image{};
    Buffer buffer{};
    DedicatedAllocationMemoryAllocateInfoNV& setImage(Image image_) {this->image = image_; return *this; }
    DedicatedAllocationMemoryAllocateInfoNV& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
};
struct ExternalImageFormatPropertiesNV {
    ImageFormatProperties imageFormatProperties{};
    ExternalMemoryFeatureFlagsNV externalMemoryFeatures{};
    ExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes{};
    ExternalMemoryHandleTypeFlagsNV compatibleHandleTypes{};
    constexpr bool operator==(ExternalImageFormatPropertiesNV const& value) const {
        return imageFormatProperties == value.imageFormatProperties && externalMemoryFeatures == value.externalMemoryFeatures && exportFromImportedHandleTypes == value.exportFromImportedHandleTypes 
        && compatibleHandleTypes == value.compatibleHandleTypes ;}
    constexpr bool operator!=(ExternalImageFormatPropertiesNV const& value) const {return !(*this == value);}
    ExternalImageFormatPropertiesNV& setImageFormatProperties(ImageFormatProperties imageFormatProperties_) {this->imageFormatProperties = imageFormatProperties_; return *this; }
    ExternalImageFormatPropertiesNV& setExternalMemoryFeatures(ExternalMemoryFeatureFlagsNV externalMemoryFeatures_) {this->externalMemoryFeatures = externalMemoryFeatures_; return *this; }
    ExternalImageFormatPropertiesNV& setExportFromImportedHandleTypes(ExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes_) {this->exportFromImportedHandleTypes = exportFromImportedHandleTypes_; return *this; }
    ExternalImageFormatPropertiesNV& setCompatibleHandleTypes(ExternalMemoryHandleTypeFlagsNV compatibleHandleTypes_) {this->compatibleHandleTypes = compatibleHandleTypes_; return *this; }
};
struct ExternalMemoryImageCreateInfoNV {
    StructureType sType{StructureType::ExternalMemoryImageCreateInfoNV};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagsNV handleTypes{};
    ExternalMemoryImageCreateInfoNV& setHandleTypes(ExternalMemoryHandleTypeFlagsNV handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
struct ExportMemoryAllocateInfoNV {
    StructureType sType{StructureType::ExportMemoryAllocateInfoNV};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagsNV handleTypes{};
    ExportMemoryAllocateInfoNV& setHandleTypes(ExternalMemoryHandleTypeFlagsNV handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportMemoryWin32HandleInfoNV {
    StructureType sType{StructureType::ImportMemoryWin32HandleInfoNV};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagsNV handleType{};
    HANDLE handle{};
    ImportMemoryWin32HandleInfoNV& setHandleType(ExternalMemoryHandleTypeFlagsNV handleType_) {this->handleType = handleType_; return *this; }
    ImportMemoryWin32HandleInfoNV& setHandle(HANDLE handle_) {this->handle = handle_; return *this; }
};
struct ExportMemoryWin32HandleInfoNV {
    StructureType sType{StructureType::ExportMemoryWin32HandleInfoNV};
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess{};
    ExportMemoryWin32HandleInfoNV& setPAttributes(const SECURITY_ATTRIBUTES* pAttributes_) {this->pAttributes = pAttributes_; return *this; }
    ExportMemoryWin32HandleInfoNV& setPAttributes(SECURITY_ATTRIBUTES const& pAttributes_) {this->pAttributes = &pAttributes_; return *this; }
    ExportMemoryWin32HandleInfoNV& setDwAccess(DWORD dwAccess_) {this->dwAccess = dwAccess_; return *this; }
};
struct Win32KeyedMutexAcquireReleaseInfoNV {
    StructureType sType{StructureType::Win32KeyedMutexAcquireReleaseInfoNV};
    const void* pNext = nullptr;
    uint32_t acquireCount{0};
    const DeviceMemory* pAcquireSyncs = nullptr;
    const uint64_t* pAcquireKeys = nullptr;
    const uint32_t* pAcquireTimeoutMilliseconds = nullptr;
    uint32_t releaseCount{0};
    const DeviceMemory* pReleaseSyncs = nullptr;
    const uint64_t* pReleaseKeys = nullptr;
    Win32KeyedMutexAcquireReleaseInfoNV& setAcquireCount(uint32_t acquireCount_) {this->acquireCount = acquireCount_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPAcquireSyncs(const DeviceMemory* pAcquireSyncs_) {this->pAcquireSyncs = pAcquireSyncs_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPAcquireSyncs(detail::span<const DeviceMemory> pAcquireSyncs_) {this->acquireCount = pAcquireSyncs_.size(); this->pAcquireSyncs = pAcquireSyncs_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPAcquireKeys(const uint64_t* pAcquireKeys_) {this->pAcquireKeys = pAcquireKeys_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPAcquireKeys(detail::span<const uint64_t> pAcquireKeys_) {this->acquireCount = pAcquireKeys_.size(); this->pAcquireKeys = pAcquireKeys_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPAcquireTimeoutMilliseconds(const uint32_t* pAcquireTimeoutMilliseconds_) {this->pAcquireTimeoutMilliseconds = pAcquireTimeoutMilliseconds_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPAcquireTimeoutMilliseconds(detail::span<const uint32_t> pAcquireTimeoutMilliseconds_) {this->acquireCount = pAcquireTimeoutMilliseconds_.size(); this->pAcquireTimeoutMilliseconds = pAcquireTimeoutMilliseconds_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setReleaseCount(uint32_t releaseCount_) {this->releaseCount = releaseCount_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPReleaseSyncs(const DeviceMemory* pReleaseSyncs_) {this->pReleaseSyncs = pReleaseSyncs_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPReleaseSyncs(detail::span<const DeviceMemory> pReleaseSyncs_) {this->releaseCount = pReleaseSyncs_.size(); this->pReleaseSyncs = pReleaseSyncs_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPReleaseKeys(const uint64_t* pReleaseKeys_) {this->pReleaseKeys = pReleaseKeys_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoNV& setPReleaseKeys(detail::span<const uint64_t> pReleaseKeys_) {this->releaseCount = pReleaseKeys_.size(); this->pReleaseKeys = pReleaseKeys_.data();  return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV};
    void* pNext = nullptr;
    Bool32 deviceGeneratedCommands{0};
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV& setDeviceGeneratedCommands(Bool32 deviceGeneratedCommands_) {this->deviceGeneratedCommands = deviceGeneratedCommands_; return *this; }
};
struct DevicePrivateDataCreateInfoEXT {
    StructureType sType{StructureType::DevicePrivateDataCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t privateDataSlotRequestCount{0};
    DevicePrivateDataCreateInfoEXT& setPrivateDataSlotRequestCount(uint32_t privateDataSlotRequestCount_) {this->privateDataSlotRequestCount = privateDataSlotRequestCount_; return *this; }
};
struct PrivateDataSlotCreateInfoEXT {
    StructureType sType{StructureType::PrivateDataSlotCreateInfoEXT};
    const void* pNext = nullptr;
    PrivateDataSlotCreateFlagsEXT flags{};
    PrivateDataSlotCreateInfoEXT& setFlags(PrivateDataSlotCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
};
struct PhysicalDevicePrivateDataFeaturesEXT {
    StructureType sType{StructureType::PhysicalDevicePrivateDataFeaturesEXT};
    void* pNext = nullptr;
    Bool32 privateData{0};
    PhysicalDevicePrivateDataFeaturesEXT& setPrivateData(Bool32 privateData_) {this->privateData = privateData_; return *this; }
};
struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceDeviceGeneratedCommandsPropertiesNV};
    void* pNext = nullptr;
    uint32_t maxGraphicsShaderGroupCount{0};
    uint32_t maxIndirectSequenceCount{0};
    uint32_t maxIndirectCommandsTokenCount{0};
    uint32_t maxIndirectCommandsStreamCount{0};
    uint32_t maxIndirectCommandsTokenOffset{0};
    uint32_t maxIndirectCommandsStreamStride{0};
    uint32_t minSequencesCountBufferOffsetAlignment{0};
    uint32_t minSequencesIndexBufferOffsetAlignment{0};
    uint32_t minIndirectCommandsBufferOffsetAlignment{0};
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMaxGraphicsShaderGroupCount(uint32_t maxGraphicsShaderGroupCount_) {this->maxGraphicsShaderGroupCount = maxGraphicsShaderGroupCount_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMaxIndirectSequenceCount(uint32_t maxIndirectSequenceCount_) {this->maxIndirectSequenceCount = maxIndirectSequenceCount_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMaxIndirectCommandsTokenCount(uint32_t maxIndirectCommandsTokenCount_) {this->maxIndirectCommandsTokenCount = maxIndirectCommandsTokenCount_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMaxIndirectCommandsStreamCount(uint32_t maxIndirectCommandsStreamCount_) {this->maxIndirectCommandsStreamCount = maxIndirectCommandsStreamCount_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMaxIndirectCommandsTokenOffset(uint32_t maxIndirectCommandsTokenOffset_) {this->maxIndirectCommandsTokenOffset = maxIndirectCommandsTokenOffset_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMaxIndirectCommandsStreamStride(uint32_t maxIndirectCommandsStreamStride_) {this->maxIndirectCommandsStreamStride = maxIndirectCommandsStreamStride_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMinSequencesCountBufferOffsetAlignment(uint32_t minSequencesCountBufferOffsetAlignment_) {this->minSequencesCountBufferOffsetAlignment = minSequencesCountBufferOffsetAlignment_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMinSequencesIndexBufferOffsetAlignment(uint32_t minSequencesIndexBufferOffsetAlignment_) {this->minSequencesIndexBufferOffsetAlignment = minSequencesIndexBufferOffsetAlignment_; return *this; }
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& setMinIndirectCommandsBufferOffsetAlignment(uint32_t minIndirectCommandsBufferOffsetAlignment_) {this->minIndirectCommandsBufferOffsetAlignment = minIndirectCommandsBufferOffsetAlignment_; return *this; }
};
struct GraphicsShaderGroupCreateInfoNV {
    StructureType sType{StructureType::GraphicsShaderGroupCreateInfoNV};
    const void* pNext = nullptr;
    uint32_t stageCount{0};
    const PipelineShaderStageCreateInfo* pStages = nullptr;
    const PipelineVertexInputStateCreateInfo* pVertexInputState = nullptr;
    const PipelineTessellationStateCreateInfo* pTessellationState = nullptr;
    GraphicsShaderGroupCreateInfoNV& setStageCount(uint32_t stageCount_) {this->stageCount = stageCount_; return *this; }
    GraphicsShaderGroupCreateInfoNV& setPStages(const PipelineShaderStageCreateInfo* pStages_) {this->pStages = pStages_; return *this; }
    GraphicsShaderGroupCreateInfoNV& setPStages(detail::span<const PipelineShaderStageCreateInfo> pStages_) {this->stageCount = pStages_.size(); this->pStages = pStages_.data();  return *this; }
    GraphicsShaderGroupCreateInfoNV& setPVertexInputState(const PipelineVertexInputStateCreateInfo* pVertexInputState_) {this->pVertexInputState = pVertexInputState_; return *this; }
    GraphicsShaderGroupCreateInfoNV& setPVertexInputState(PipelineVertexInputStateCreateInfo const& pVertexInputState_) {this->pVertexInputState = &pVertexInputState_; return *this; }
    GraphicsShaderGroupCreateInfoNV& setPTessellationState(const PipelineTessellationStateCreateInfo* pTessellationState_) {this->pTessellationState = pTessellationState_; return *this; }
    GraphicsShaderGroupCreateInfoNV& setPTessellationState(PipelineTessellationStateCreateInfo const& pTessellationState_) {this->pTessellationState = &pTessellationState_; return *this; }
};
struct GraphicsPipelineShaderGroupsCreateInfoNV {
    StructureType sType{StructureType::GraphicsPipelineShaderGroupsCreateInfoNV};
    const void* pNext = nullptr;
    uint32_t groupCount{0};
    const GraphicsShaderGroupCreateInfoNV* pGroups = nullptr;
    uint32_t pipelineCount{0};
    const Pipeline* pPipelines = nullptr;
    GraphicsPipelineShaderGroupsCreateInfoNV& setGroupCount(uint32_t groupCount_) {this->groupCount = groupCount_; return *this; }
    GraphicsPipelineShaderGroupsCreateInfoNV& setPGroups(const GraphicsShaderGroupCreateInfoNV* pGroups_) {this->pGroups = pGroups_; return *this; }
    GraphicsPipelineShaderGroupsCreateInfoNV& setPGroups(detail::span<const GraphicsShaderGroupCreateInfoNV> pGroups_) {this->groupCount = pGroups_.size(); this->pGroups = pGroups_.data();  return *this; }
    GraphicsPipelineShaderGroupsCreateInfoNV& setPipelineCount(uint32_t pipelineCount_) {this->pipelineCount = pipelineCount_; return *this; }
    GraphicsPipelineShaderGroupsCreateInfoNV& setPPipelines(const Pipeline* pPipelines_) {this->pPipelines = pPipelines_; return *this; }
    GraphicsPipelineShaderGroupsCreateInfoNV& setPPipelines(detail::span<const Pipeline> pPipelines_) {this->pipelineCount = pPipelines_.size(); this->pPipelines = pPipelines_.data();  return *this; }
};
struct BindShaderGroupIndirectCommandNV {
    uint32_t groupIndex{0};
    constexpr bool operator==(BindShaderGroupIndirectCommandNV const& value) const {
        return groupIndex == value.groupIndex ;}
    constexpr bool operator!=(BindShaderGroupIndirectCommandNV const& value) const {return !(*this == value);}
    BindShaderGroupIndirectCommandNV& setGroupIndex(uint32_t groupIndex_) {this->groupIndex = groupIndex_; return *this; }
};
struct BindIndexBufferIndirectCommandNV {
    DeviceAddress bufferAddress{0};
    uint32_t size{0};
    IndexType indexType{static_cast<IndexType>(0)};
    constexpr bool operator==(BindIndexBufferIndirectCommandNV const& value) const {
        return bufferAddress == value.bufferAddress && size == value.size && indexType == value.indexType ;}
    constexpr bool operator!=(BindIndexBufferIndirectCommandNV const& value) const {return !(*this == value);}
    BindIndexBufferIndirectCommandNV& setBufferAddress(DeviceAddress bufferAddress_) {this->bufferAddress = bufferAddress_; return *this; }
    BindIndexBufferIndirectCommandNV& setSize(uint32_t size_) {this->size = size_; return *this; }
    BindIndexBufferIndirectCommandNV& setIndexType(IndexType indexType_) {this->indexType = indexType_; return *this; }
};
struct BindVertexBufferIndirectCommandNV {
    DeviceAddress bufferAddress{0};
    uint32_t size{0};
    uint32_t stride{0};
    constexpr bool operator==(BindVertexBufferIndirectCommandNV const& value) const {
        return bufferAddress == value.bufferAddress && size == value.size && stride == value.stride ;}
    constexpr bool operator!=(BindVertexBufferIndirectCommandNV const& value) const {return !(*this == value);}
    BindVertexBufferIndirectCommandNV& setBufferAddress(DeviceAddress bufferAddress_) {this->bufferAddress = bufferAddress_; return *this; }
    BindVertexBufferIndirectCommandNV& setSize(uint32_t size_) {this->size = size_; return *this; }
    BindVertexBufferIndirectCommandNV& setStride(uint32_t stride_) {this->stride = stride_; return *this; }
};
struct SetStateFlagsIndirectCommandNV {
    uint32_t data{0};
    constexpr bool operator==(SetStateFlagsIndirectCommandNV const& value) const {
        return data == value.data ;}
    constexpr bool operator!=(SetStateFlagsIndirectCommandNV const& value) const {return !(*this == value);}
    SetStateFlagsIndirectCommandNV& setData(uint32_t data_) {this->data = data_; return *this; }
};
struct IndirectCommandsStreamNV {
    Buffer buffer{};
    DeviceSize offset{0};
    IndirectCommandsStreamNV& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    IndirectCommandsStreamNV& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
};
struct IndirectCommandsLayoutTokenNV {
    StructureType sType{StructureType::IndirectCommandsLayoutTokenNV};
    const void* pNext = nullptr;
    IndirectCommandsTokenTypeNV tokenType{static_cast<IndirectCommandsTokenTypeNV>(0)};
    uint32_t stream{0};
    uint32_t offset{0};
    uint32_t vertexBindingUnit{0};
    Bool32 vertexDynamicStride{0};
    PipelineLayout pushconstantPipelineLayout{};
    ShaderStageFlags pushconstantShaderStageFlags{};
    uint32_t pushconstantOffset{0};
    uint32_t pushconstantSize{0};
    IndirectStateFlagsNV indirectStateFlags{};
    uint32_t indexTypeCount{0};
    const IndexType* pIndexTypes = nullptr;
    const uint32_t* pIndexTypeValues = nullptr;
    IndirectCommandsLayoutTokenNV& setTokenType(IndirectCommandsTokenTypeNV tokenType_) {this->tokenType = tokenType_; return *this; }
    IndirectCommandsLayoutTokenNV& setStream(uint32_t stream_) {this->stream = stream_; return *this; }
    IndirectCommandsLayoutTokenNV& setOffset(uint32_t offset_) {this->offset = offset_; return *this; }
    IndirectCommandsLayoutTokenNV& setVertexBindingUnit(uint32_t vertexBindingUnit_) {this->vertexBindingUnit = vertexBindingUnit_; return *this; }
    IndirectCommandsLayoutTokenNV& setVertexDynamicStride(Bool32 vertexDynamicStride_) {this->vertexDynamicStride = vertexDynamicStride_; return *this; }
    IndirectCommandsLayoutTokenNV& setPushconstantPipelineLayout(PipelineLayout pushconstantPipelineLayout_) {this->pushconstantPipelineLayout = pushconstantPipelineLayout_; return *this; }
    IndirectCommandsLayoutTokenNV& setPushconstantShaderStageFlags(ShaderStageFlags pushconstantShaderStageFlags_) {this->pushconstantShaderStageFlags = pushconstantShaderStageFlags_; return *this; }
    IndirectCommandsLayoutTokenNV& setPushconstantOffset(uint32_t pushconstantOffset_) {this->pushconstantOffset = pushconstantOffset_; return *this; }
    IndirectCommandsLayoutTokenNV& setPushconstantSize(uint32_t pushconstantSize_) {this->pushconstantSize = pushconstantSize_; return *this; }
    IndirectCommandsLayoutTokenNV& setIndirectStateFlags(IndirectStateFlagsNV indirectStateFlags_) {this->indirectStateFlags = indirectStateFlags_; return *this; }
    IndirectCommandsLayoutTokenNV& setIndexTypeCount(uint32_t indexTypeCount_) {this->indexTypeCount = indexTypeCount_; return *this; }
    IndirectCommandsLayoutTokenNV& setPIndexTypes(const IndexType* pIndexTypes_) {this->pIndexTypes = pIndexTypes_; return *this; }
    IndirectCommandsLayoutTokenNV& setPIndexTypes(detail::span<const IndexType> pIndexTypes_) {this->indexTypeCount = pIndexTypes_.size(); this->pIndexTypes = pIndexTypes_.data();  return *this; }
    IndirectCommandsLayoutTokenNV& setPIndexTypeValues(const uint32_t* pIndexTypeValues_) {this->pIndexTypeValues = pIndexTypeValues_; return *this; }
    IndirectCommandsLayoutTokenNV& setPIndexTypeValues(detail::span<const uint32_t> pIndexTypeValues_) {this->indexTypeCount = pIndexTypeValues_.size(); this->pIndexTypeValues = pIndexTypeValues_.data();  return *this; }
};
struct IndirectCommandsLayoutCreateInfoNV {
    StructureType sType{StructureType::IndirectCommandsLayoutCreateInfoNV};
    const void* pNext = nullptr;
    IndirectCommandsLayoutUsageFlagsNV flags{};
    PipelineBindPoint pipelineBindPoint{static_cast<PipelineBindPoint>(0)};
    uint32_t tokenCount{0};
    const IndirectCommandsLayoutTokenNV* pTokens = nullptr;
    uint32_t streamCount{0};
    const uint32_t* pStreamStrides = nullptr;
    IndirectCommandsLayoutCreateInfoNV& setFlags(IndirectCommandsLayoutUsageFlagsNV flags_) {this->flags = flags_; return *this; }
    IndirectCommandsLayoutCreateInfoNV& setPipelineBindPoint(PipelineBindPoint pipelineBindPoint_) {this->pipelineBindPoint = pipelineBindPoint_; return *this; }
    IndirectCommandsLayoutCreateInfoNV& setTokenCount(uint32_t tokenCount_) {this->tokenCount = tokenCount_; return *this; }
    IndirectCommandsLayoutCreateInfoNV& setPTokens(const IndirectCommandsLayoutTokenNV* pTokens_) {this->pTokens = pTokens_; return *this; }
    IndirectCommandsLayoutCreateInfoNV& setPTokens(detail::span<const IndirectCommandsLayoutTokenNV> pTokens_) {this->tokenCount = pTokens_.size(); this->pTokens = pTokens_.data();  return *this; }
    IndirectCommandsLayoutCreateInfoNV& setStreamCount(uint32_t streamCount_) {this->streamCount = streamCount_; return *this; }
    IndirectCommandsLayoutCreateInfoNV& setPStreamStrides(const uint32_t* pStreamStrides_) {this->pStreamStrides = pStreamStrides_; return *this; }
    IndirectCommandsLayoutCreateInfoNV& setPStreamStrides(detail::span<const uint32_t> pStreamStrides_) {this->streamCount = pStreamStrides_.size(); this->pStreamStrides = pStreamStrides_.data();  return *this; }
};
struct GeneratedCommandsInfoNV {
    StructureType sType{StructureType::GeneratedCommandsInfoNV};
    const void* pNext = nullptr;
    PipelineBindPoint pipelineBindPoint{static_cast<PipelineBindPoint>(0)};
    Pipeline pipeline{};
    IndirectCommandsLayoutNV indirectCommandsLayout{};
    uint32_t streamCount{0};
    const IndirectCommandsStreamNV* pStreams = nullptr;
    uint32_t sequencesCount{0};
    Buffer preprocessBuffer{};
    DeviceSize preprocessOffset{0};
    DeviceSize preprocessSize{0};
    Buffer sequencesCountBuffer{};
    DeviceSize sequencesCountOffset{0};
    Buffer sequencesIndexBuffer{};
    DeviceSize sequencesIndexOffset{0};
    GeneratedCommandsInfoNV& setPipelineBindPoint(PipelineBindPoint pipelineBindPoint_) {this->pipelineBindPoint = pipelineBindPoint_; return *this; }
    GeneratedCommandsInfoNV& setPipeline(Pipeline pipeline_) {this->pipeline = pipeline_; return *this; }
    GeneratedCommandsInfoNV& setIndirectCommandsLayout(IndirectCommandsLayoutNV indirectCommandsLayout_) {this->indirectCommandsLayout = indirectCommandsLayout_; return *this; }
    GeneratedCommandsInfoNV& setStreamCount(uint32_t streamCount_) {this->streamCount = streamCount_; return *this; }
    GeneratedCommandsInfoNV& setPStreams(const IndirectCommandsStreamNV* pStreams_) {this->pStreams = pStreams_; return *this; }
    GeneratedCommandsInfoNV& setPStreams(detail::span<const IndirectCommandsStreamNV> pStreams_) {this->streamCount = pStreams_.size(); this->pStreams = pStreams_.data();  return *this; }
    GeneratedCommandsInfoNV& setSequencesCount(uint32_t sequencesCount_) {this->sequencesCount = sequencesCount_; return *this; }
    GeneratedCommandsInfoNV& setPreprocessBuffer(Buffer preprocessBuffer_) {this->preprocessBuffer = preprocessBuffer_; return *this; }
    GeneratedCommandsInfoNV& setPreprocessOffset(DeviceSize preprocessOffset_) {this->preprocessOffset = preprocessOffset_; return *this; }
    GeneratedCommandsInfoNV& setPreprocessSize(DeviceSize preprocessSize_) {this->preprocessSize = preprocessSize_; return *this; }
    GeneratedCommandsInfoNV& setSequencesCountBuffer(Buffer sequencesCountBuffer_) {this->sequencesCountBuffer = sequencesCountBuffer_; return *this; }
    GeneratedCommandsInfoNV& setSequencesCountOffset(DeviceSize sequencesCountOffset_) {this->sequencesCountOffset = sequencesCountOffset_; return *this; }
    GeneratedCommandsInfoNV& setSequencesIndexBuffer(Buffer sequencesIndexBuffer_) {this->sequencesIndexBuffer = sequencesIndexBuffer_; return *this; }
    GeneratedCommandsInfoNV& setSequencesIndexOffset(DeviceSize sequencesIndexOffset_) {this->sequencesIndexOffset = sequencesIndexOffset_; return *this; }
};
struct GeneratedCommandsMemoryRequirementsInfoNV {
    StructureType sType{StructureType::GeneratedCommandsMemoryRequirementsInfoNV};
    const void* pNext = nullptr;
    PipelineBindPoint pipelineBindPoint{static_cast<PipelineBindPoint>(0)};
    Pipeline pipeline{};
    IndirectCommandsLayoutNV indirectCommandsLayout{};
    uint32_t maxSequencesCount{0};
    GeneratedCommandsMemoryRequirementsInfoNV& setPipelineBindPoint(PipelineBindPoint pipelineBindPoint_) {this->pipelineBindPoint = pipelineBindPoint_; return *this; }
    GeneratedCommandsMemoryRequirementsInfoNV& setPipeline(Pipeline pipeline_) {this->pipeline = pipeline_; return *this; }
    GeneratedCommandsMemoryRequirementsInfoNV& setIndirectCommandsLayout(IndirectCommandsLayoutNV indirectCommandsLayout_) {this->indirectCommandsLayout = indirectCommandsLayout_; return *this; }
    GeneratedCommandsMemoryRequirementsInfoNV& setMaxSequencesCount(uint32_t maxSequencesCount_) {this->maxSequencesCount = maxSequencesCount_; return *this; }
};
struct PhysicalDeviceFeatures2 {
    StructureType sType{StructureType::PhysicalDeviceFeatures2};
    void* pNext = nullptr;
    PhysicalDeviceFeatures features{};
    PhysicalDeviceFeatures2& setFeatures(PhysicalDeviceFeatures features_) {this->features = features_; return *this; }
};
using PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
struct PhysicalDeviceProperties2 {
    StructureType sType{StructureType::PhysicalDeviceProperties2};
    void* pNext = nullptr;
    PhysicalDeviceProperties properties{};
    PhysicalDeviceProperties2& setProperties(PhysicalDeviceProperties properties_) {this->properties = properties_; return *this; }
};
using PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
struct FormatProperties2 {
    StructureType sType{StructureType::FormatProperties2};
    void* pNext = nullptr;
    FormatProperties formatProperties{};
    FormatProperties2& setFormatProperties(FormatProperties formatProperties_) {this->formatProperties = formatProperties_; return *this; }
};
using FormatProperties2KHR = FormatProperties2;
struct ImageFormatProperties2 {
    StructureType sType{StructureType::ImageFormatProperties2};
    void* pNext = nullptr;
    ImageFormatProperties imageFormatProperties{};
    ImageFormatProperties2& setImageFormatProperties(ImageFormatProperties imageFormatProperties_) {this->imageFormatProperties = imageFormatProperties_; return *this; }
};
using ImageFormatProperties2KHR = ImageFormatProperties2;
struct PhysicalDeviceImageFormatInfo2 {
    StructureType sType{StructureType::PhysicalDeviceImageFormatInfo2};
    const void* pNext = nullptr;
    Format format{static_cast<Format>(0)};
    ImageType type{static_cast<ImageType>(0)};
    ImageTiling tiling{static_cast<ImageTiling>(0)};
    ImageUsageFlags usage{};
    ImageCreateFlags flags{};
    PhysicalDeviceImageFormatInfo2& setFormat(Format format_) {this->format = format_; return *this; }
    PhysicalDeviceImageFormatInfo2& setType(ImageType type_) {this->type = type_; return *this; }
    PhysicalDeviceImageFormatInfo2& setTiling(ImageTiling tiling_) {this->tiling = tiling_; return *this; }
    PhysicalDeviceImageFormatInfo2& setUsage(ImageUsageFlags usage_) {this->usage = usage_; return *this; }
    PhysicalDeviceImageFormatInfo2& setFlags(ImageCreateFlags flags_) {this->flags = flags_; return *this; }
};
using PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
struct QueueFamilyProperties2 {
    StructureType sType{StructureType::QueueFamilyProperties2};
    void* pNext = nullptr;
    QueueFamilyProperties queueFamilyProperties{};
    QueueFamilyProperties2& setQueueFamilyProperties(QueueFamilyProperties queueFamilyProperties_) {this->queueFamilyProperties = queueFamilyProperties_; return *this; }
};
using QueueFamilyProperties2KHR = QueueFamilyProperties2;
struct PhysicalDeviceMemoryProperties2 {
    StructureType sType{StructureType::PhysicalDeviceMemoryProperties2};
    void* pNext = nullptr;
    PhysicalDeviceMemoryProperties memoryProperties{};
    PhysicalDeviceMemoryProperties2& setMemoryProperties(PhysicalDeviceMemoryProperties memoryProperties_) {this->memoryProperties = memoryProperties_; return *this; }
};
using PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
struct SparseImageFormatProperties2 {
    StructureType sType{StructureType::SparseImageFormatProperties2};
    void* pNext = nullptr;
    SparseImageFormatProperties properties{};
    SparseImageFormatProperties2& setProperties(SparseImageFormatProperties properties_) {this->properties = properties_; return *this; }
};
using SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
struct PhysicalDeviceSparseImageFormatInfo2 {
    StructureType sType{StructureType::PhysicalDeviceSparseImageFormatInfo2};
    const void* pNext = nullptr;
    Format format{static_cast<Format>(0)};
    ImageType type{static_cast<ImageType>(0)};
    SampleCountFlagBits samples{static_cast<SampleCountFlagBits>(0)};
    ImageUsageFlags usage{};
    ImageTiling tiling{static_cast<ImageTiling>(0)};
    PhysicalDeviceSparseImageFormatInfo2& setFormat(Format format_) {this->format = format_; return *this; }
    PhysicalDeviceSparseImageFormatInfo2& setType(ImageType type_) {this->type = type_; return *this; }
    PhysicalDeviceSparseImageFormatInfo2& setSamples(SampleCountFlagBits samples_) {this->samples = samples_; return *this; }
    PhysicalDeviceSparseImageFormatInfo2& setUsage(ImageUsageFlags usage_) {this->usage = usage_; return *this; }
    PhysicalDeviceSparseImageFormatInfo2& setTiling(ImageTiling tiling_) {this->tiling = tiling_; return *this; }
};
using PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
struct PhysicalDevicePushDescriptorPropertiesKHR {
    StructureType sType{StructureType::PhysicalDevicePushDescriptorPropertiesKHR};
    void* pNext = nullptr;
    uint32_t maxPushDescriptors{0};
    PhysicalDevicePushDescriptorPropertiesKHR& setMaxPushDescriptors(uint32_t maxPushDescriptors_) {this->maxPushDescriptors = maxPushDescriptors_; return *this; }
};
struct ConformanceVersion {
    uint8_t major{0};
    uint8_t minor{0};
    uint8_t subminor{0};
    uint8_t patch{0};
    constexpr bool operator==(ConformanceVersion const& value) const {
        return major == value.major && minor == value.minor && subminor == value.subminor && patch == value.patch ;}
    constexpr bool operator!=(ConformanceVersion const& value) const {return !(*this == value);}
    ConformanceVersion& setMajor(uint8_t major_) {this->major = major_; return *this; }
    ConformanceVersion& setMinor(uint8_t minor_) {this->minor = minor_; return *this; }
    ConformanceVersion& setSubminor(uint8_t subminor_) {this->subminor = subminor_; return *this; }
    ConformanceVersion& setPatch(uint8_t patch_) {this->patch = patch_; return *this; }
};
using ConformanceVersionKHR = ConformanceVersion;
struct PhysicalDeviceDriverProperties {
    StructureType sType{StructureType::PhysicalDeviceDriverProperties};
    void* pNext = nullptr;
    DriverId driverID{static_cast<DriverId>(0)};
    char driverName[MAX_DRIVER_NAME_SIZE];
    char driverInfo[MAX_DRIVER_INFO_SIZE];
    ConformanceVersion conformanceVersion{};
    PhysicalDeviceDriverProperties& setDriverID(DriverId driverID_) {this->driverID = driverID_; return *this; }
    PhysicalDeviceDriverProperties& setDriverName(char driverName_[MAX_DRIVER_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_DRIVER_NAME_SIZE; i++) this->driverName[i] = driverName_[i]; return *this; }
    PhysicalDeviceDriverProperties& setDriverInfo(char driverInfo_[MAX_DRIVER_INFO_SIZE]) {for(uint32_t i = 0; i < MAX_DRIVER_INFO_SIZE; i++) this->driverInfo[i] = driverInfo_[i]; return *this; }
    PhysicalDeviceDriverProperties& setConformanceVersion(ConformanceVersion conformanceVersion_) {this->conformanceVersion = conformanceVersion_; return *this; }
};
using PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
struct RectLayerKHR {
    Offset2D offset{};
    Extent2D extent{};
    uint32_t layer{0};
    constexpr bool operator==(RectLayerKHR const& value) const {
        return offset == value.offset && extent == value.extent && layer == value.layer ;}
    constexpr bool operator!=(RectLayerKHR const& value) const {return !(*this == value);}
    RectLayerKHR& setOffset(Offset2D offset_) {this->offset = offset_; return *this; }
    RectLayerKHR& setExtent(Extent2D extent_) {this->extent = extent_; return *this; }
    RectLayerKHR& setLayer(uint32_t layer_) {this->layer = layer_; return *this; }
};
struct PresentRegionKHR {
    uint32_t rectangleCount{0};
    const RectLayerKHR* pRectangles = nullptr;
    PresentRegionKHR& setRectangleCount(uint32_t rectangleCount_) {this->rectangleCount = rectangleCount_; return *this; }
    PresentRegionKHR& setPRectangles(const RectLayerKHR* pRectangles_) {this->pRectangles = pRectangles_; return *this; }
    PresentRegionKHR& setPRectangles(detail::span<const RectLayerKHR> pRectangles_) {this->rectangleCount = pRectangles_.size(); this->pRectangles = pRectangles_.data();  return *this; }
};
struct PresentRegionsKHR {
    StructureType sType{StructureType::PresentRegionsKHR};
    const void* pNext = nullptr;
    uint32_t swapchainCount{0};
    const PresentRegionKHR* pRegions = nullptr;
    PresentRegionsKHR& setSwapchainCount(uint32_t swapchainCount_) {this->swapchainCount = swapchainCount_; return *this; }
    PresentRegionsKHR& setPRegions(const PresentRegionKHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    PresentRegionsKHR& setPRegions(detail::span<const PresentRegionKHR> pRegions_) {this->swapchainCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
};
struct PhysicalDeviceVariablePointersFeatures {
    StructureType sType{StructureType::PhysicalDeviceVariablePointersFeatures};
    void* pNext = nullptr;
    Bool32 variablePointersStorageBuffer{0};
    Bool32 variablePointers{0};
    PhysicalDeviceVariablePointersFeatures& setVariablePointersStorageBuffer(Bool32 variablePointersStorageBuffer_) {this->variablePointersStorageBuffer = variablePointersStorageBuffer_; return *this; }
    PhysicalDeviceVariablePointersFeatures& setVariablePointers(Bool32 variablePointers_) {this->variablePointers = variablePointers_; return *this; }
};
using PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
using PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
using PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;
struct ExternalMemoryProperties {
    ExternalMemoryFeatureFlags externalMemoryFeatures{};
    ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes{};
    ExternalMemoryHandleTypeFlags compatibleHandleTypes{};
    constexpr bool operator==(ExternalMemoryProperties const& value) const {
        return externalMemoryFeatures == value.externalMemoryFeatures && exportFromImportedHandleTypes == value.exportFromImportedHandleTypes 
        && compatibleHandleTypes == value.compatibleHandleTypes ;}
    constexpr bool operator!=(ExternalMemoryProperties const& value) const {return !(*this == value);}
    ExternalMemoryProperties& setExternalMemoryFeatures(ExternalMemoryFeatureFlags externalMemoryFeatures_) {this->externalMemoryFeatures = externalMemoryFeatures_; return *this; }
    ExternalMemoryProperties& setExportFromImportedHandleTypes(ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes_) {this->exportFromImportedHandleTypes = exportFromImportedHandleTypes_; return *this; }
    ExternalMemoryProperties& setCompatibleHandleTypes(ExternalMemoryHandleTypeFlags compatibleHandleTypes_) {this->compatibleHandleTypes = compatibleHandleTypes_; return *this; }
};
using ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
struct PhysicalDeviceExternalImageFormatInfo {
    StructureType sType{StructureType::PhysicalDeviceExternalImageFormatInfo};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    PhysicalDeviceExternalImageFormatInfo& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
using PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
struct ExternalImageFormatProperties {
    StructureType sType{StructureType::ExternalImageFormatProperties};
    void* pNext = nullptr;
    ExternalMemoryProperties externalMemoryProperties{};
    ExternalImageFormatProperties& setExternalMemoryProperties(ExternalMemoryProperties externalMemoryProperties_) {this->externalMemoryProperties = externalMemoryProperties_; return *this; }
};
using ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
struct PhysicalDeviceExternalBufferInfo {
    StructureType sType{StructureType::PhysicalDeviceExternalBufferInfo};
    const void* pNext = nullptr;
    BufferCreateFlags flags{};
    BufferUsageFlags usage{};
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    PhysicalDeviceExternalBufferInfo& setFlags(BufferCreateFlags flags_) {this->flags = flags_; return *this; }
    PhysicalDeviceExternalBufferInfo& setUsage(BufferUsageFlags usage_) {this->usage = usage_; return *this; }
    PhysicalDeviceExternalBufferInfo& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
using PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
struct ExternalBufferProperties {
    StructureType sType{StructureType::ExternalBufferProperties};
    void* pNext = nullptr;
    ExternalMemoryProperties externalMemoryProperties{};
    ExternalBufferProperties& setExternalMemoryProperties(ExternalMemoryProperties externalMemoryProperties_) {this->externalMemoryProperties = externalMemoryProperties_; return *this; }
};
using ExternalBufferPropertiesKHR = ExternalBufferProperties;
struct PhysicalDeviceIDProperties {
    StructureType sType{StructureType::PhysicalDeviceIdProperties};
    void* pNext = nullptr;
    uint8_t deviceUUID[UUID_SIZE];
    uint8_t driverUUID[UUID_SIZE];
    uint8_t deviceLUID[LUID_SIZE];
    uint32_t deviceNodeMask{0};
    Bool32 deviceLUIDValid{0};
    PhysicalDeviceIDProperties& setDeviceUUID(uint8_t deviceUUID_[UUID_SIZE]) {for(uint32_t i = 0; i < UUID_SIZE; i++) this->deviceUUID[i] = deviceUUID_[i]; return *this; }
    PhysicalDeviceIDProperties& setDriverUUID(uint8_t driverUUID_[UUID_SIZE]) {for(uint32_t i = 0; i < UUID_SIZE; i++) this->driverUUID[i] = driverUUID_[i]; return *this; }
    PhysicalDeviceIDProperties& setDeviceLUID(uint8_t deviceLUID_[LUID_SIZE]) {for(uint32_t i = 0; i < LUID_SIZE; i++) this->deviceLUID[i] = deviceLUID_[i]; return *this; }
    PhysicalDeviceIDProperties& setDeviceNodeMask(uint32_t deviceNodeMask_) {this->deviceNodeMask = deviceNodeMask_; return *this; }
    PhysicalDeviceIDProperties& setDeviceLUIDValid(Bool32 deviceLUIDValid_) {this->deviceLUIDValid = deviceLUIDValid_; return *this; }
};
using PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
struct ExternalMemoryImageCreateInfo {
    StructureType sType{StructureType::ExternalMemoryImageCreateInfo};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlags handleTypes{};
    ExternalMemoryImageCreateInfo& setHandleTypes(ExternalMemoryHandleTypeFlags handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
using ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
struct ExternalMemoryBufferCreateInfo {
    StructureType sType{StructureType::ExternalMemoryBufferCreateInfo};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlags handleTypes{};
    ExternalMemoryBufferCreateInfo& setHandleTypes(ExternalMemoryHandleTypeFlags handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
using ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
struct ExportMemoryAllocateInfo {
    StructureType sType{StructureType::ExportMemoryAllocateInfo};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlags handleTypes{};
    ExportMemoryAllocateInfo& setHandleTypes(ExternalMemoryHandleTypeFlags handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
using ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportMemoryWin32HandleInfoKHR {
    StructureType sType{StructureType::ImportMemoryWin32HandleInfoKHR};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    HANDLE handle{};
    LPCWSTR name{};
    ImportMemoryWin32HandleInfoKHR& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportMemoryWin32HandleInfoKHR& setHandle(HANDLE handle_) {this->handle = handle_; return *this; }
    ImportMemoryWin32HandleInfoKHR& setName(LPCWSTR name_) {this->name = name_; return *this; }
};
struct ExportMemoryWin32HandleInfoKHR {
    StructureType sType{StructureType::ExportMemoryWin32HandleInfoKHR};
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess{};
    LPCWSTR name{};
    ExportMemoryWin32HandleInfoKHR& setPAttributes(const SECURITY_ATTRIBUTES* pAttributes_) {this->pAttributes = pAttributes_; return *this; }
    ExportMemoryWin32HandleInfoKHR& setPAttributes(SECURITY_ATTRIBUTES const& pAttributes_) {this->pAttributes = &pAttributes_; return *this; }
    ExportMemoryWin32HandleInfoKHR& setDwAccess(DWORD dwAccess_) {this->dwAccess = dwAccess_; return *this; }
    ExportMemoryWin32HandleInfoKHR& setName(LPCWSTR name_) {this->name = name_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_FUCHSIA)
struct ImportMemoryZirconHandleInfoFUCHSIA {
    StructureType sType{StructureType::ImportMemoryZirconHandleInfoFUCHSIA};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    zx_handle_t handle{};
    ImportMemoryZirconHandleInfoFUCHSIA& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportMemoryZirconHandleInfoFUCHSIA& setHandle(zx_handle_t handle_) {this->handle = handle_; return *this; }
};
struct MemoryZirconHandlePropertiesFUCHSIA {
    StructureType sType{StructureType::MemoryZirconHandlePropertiesFUCHSIA};
    void* pNext = nullptr;
    uint32_t memoryTypeBits{0};
    MemoryZirconHandlePropertiesFUCHSIA& setMemoryTypeBits(uint32_t memoryTypeBits_) {this->memoryTypeBits = memoryTypeBits_; return *this; }
};
struct MemoryGetZirconHandleInfoFUCHSIA {
    StructureType sType{StructureType::MemoryGetZirconHandleInfoFUCHSIA};
    const void* pNext = nullptr;
    DeviceMemory memory{};
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    MemoryGetZirconHandleInfoFUCHSIA& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    MemoryGetZirconHandleInfoFUCHSIA& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct MemoryWin32HandlePropertiesKHR {
    StructureType sType{StructureType::MemoryWin32HandlePropertiesKHR};
    void* pNext = nullptr;
    uint32_t memoryTypeBits{0};
    MemoryWin32HandlePropertiesKHR& setMemoryTypeBits(uint32_t memoryTypeBits_) {this->memoryTypeBits = memoryTypeBits_; return *this; }
};
struct MemoryGetWin32HandleInfoKHR {
    StructureType sType{StructureType::MemoryGetWin32HandleInfoKHR};
    const void* pNext = nullptr;
    DeviceMemory memory{};
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    MemoryGetWin32HandleInfoKHR& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    MemoryGetWin32HandleInfoKHR& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportMemoryFdInfoKHR {
    StructureType sType{StructureType::ImportMemoryFdInfoKHR};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    int fd{0};
    ImportMemoryFdInfoKHR& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportMemoryFdInfoKHR& setFd(int fd_) {this->fd = fd_; return *this; }
};
struct MemoryFdPropertiesKHR {
    StructureType sType{StructureType::MemoryFdPropertiesKHR};
    void* pNext = nullptr;
    uint32_t memoryTypeBits{0};
    MemoryFdPropertiesKHR& setMemoryTypeBits(uint32_t memoryTypeBits_) {this->memoryTypeBits = memoryTypeBits_; return *this; }
};
struct MemoryGetFdInfoKHR {
    StructureType sType{StructureType::MemoryGetFdInfoKHR};
    const void* pNext = nullptr;
    DeviceMemory memory{};
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    MemoryGetFdInfoKHR& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    MemoryGetFdInfoKHR& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct Win32KeyedMutexAcquireReleaseInfoKHR {
    StructureType sType{StructureType::Win32KeyedMutexAcquireReleaseInfoKHR};
    const void* pNext = nullptr;
    uint32_t acquireCount{0};
    const DeviceMemory* pAcquireSyncs = nullptr;
    const uint64_t* pAcquireKeys = nullptr;
    const uint32_t* pAcquireTimeouts = nullptr;
    uint32_t releaseCount{0};
    const DeviceMemory* pReleaseSyncs = nullptr;
    const uint64_t* pReleaseKeys = nullptr;
    Win32KeyedMutexAcquireReleaseInfoKHR& setAcquireCount(uint32_t acquireCount_) {this->acquireCount = acquireCount_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPAcquireSyncs(const DeviceMemory* pAcquireSyncs_) {this->pAcquireSyncs = pAcquireSyncs_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPAcquireSyncs(detail::span<const DeviceMemory> pAcquireSyncs_) {this->acquireCount = pAcquireSyncs_.size(); this->pAcquireSyncs = pAcquireSyncs_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPAcquireKeys(const uint64_t* pAcquireKeys_) {this->pAcquireKeys = pAcquireKeys_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPAcquireKeys(detail::span<const uint64_t> pAcquireKeys_) {this->acquireCount = pAcquireKeys_.size(); this->pAcquireKeys = pAcquireKeys_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPAcquireTimeouts(const uint32_t* pAcquireTimeouts_) {this->pAcquireTimeouts = pAcquireTimeouts_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPAcquireTimeouts(detail::span<const uint32_t> pAcquireTimeouts_) {this->acquireCount = pAcquireTimeouts_.size(); this->pAcquireTimeouts = pAcquireTimeouts_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setReleaseCount(uint32_t releaseCount_) {this->releaseCount = releaseCount_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPReleaseSyncs(const DeviceMemory* pReleaseSyncs_) {this->pReleaseSyncs = pReleaseSyncs_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPReleaseSyncs(detail::span<const DeviceMemory> pReleaseSyncs_) {this->releaseCount = pReleaseSyncs_.size(); this->pReleaseSyncs = pReleaseSyncs_.data();  return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPReleaseKeys(const uint64_t* pReleaseKeys_) {this->pReleaseKeys = pReleaseKeys_; return *this; }
    Win32KeyedMutexAcquireReleaseInfoKHR& setPReleaseKeys(detail::span<const uint64_t> pReleaseKeys_) {this->releaseCount = pReleaseKeys_.size(); this->pReleaseKeys = pReleaseKeys_.data();  return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
struct PhysicalDeviceExternalSemaphoreInfo {
    StructureType sType{StructureType::PhysicalDeviceExternalSemaphoreInfo};
    const void* pNext = nullptr;
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    PhysicalDeviceExternalSemaphoreInfo& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
using PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
struct ExternalSemaphoreProperties {
    StructureType sType{StructureType::ExternalSemaphoreProperties};
    void* pNext = nullptr;
    ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes{};
    ExternalSemaphoreHandleTypeFlags compatibleHandleTypes{};
    ExternalSemaphoreFeatureFlags externalSemaphoreFeatures{};
    ExternalSemaphoreProperties& setExportFromImportedHandleTypes(ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes_) {this->exportFromImportedHandleTypes = exportFromImportedHandleTypes_; return *this; }
    ExternalSemaphoreProperties& setCompatibleHandleTypes(ExternalSemaphoreHandleTypeFlags compatibleHandleTypes_) {this->compatibleHandleTypes = compatibleHandleTypes_; return *this; }
    ExternalSemaphoreProperties& setExternalSemaphoreFeatures(ExternalSemaphoreFeatureFlags externalSemaphoreFeatures_) {this->externalSemaphoreFeatures = externalSemaphoreFeatures_; return *this; }
};
using ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
struct ExportSemaphoreCreateInfo {
    StructureType sType{StructureType::ExportSemaphoreCreateInfo};
    const void* pNext = nullptr;
    ExternalSemaphoreHandleTypeFlags handleTypes{};
    ExportSemaphoreCreateInfo& setHandleTypes(ExternalSemaphoreHandleTypeFlags handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
using ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportSemaphoreWin32HandleInfoKHR {
    StructureType sType{StructureType::ImportSemaphoreWin32HandleInfoKHR};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    SemaphoreImportFlags flags{};
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    HANDLE handle{};
    LPCWSTR name{};
    ImportSemaphoreWin32HandleInfoKHR& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    ImportSemaphoreWin32HandleInfoKHR& setFlags(SemaphoreImportFlags flags_) {this->flags = flags_; return *this; }
    ImportSemaphoreWin32HandleInfoKHR& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportSemaphoreWin32HandleInfoKHR& setHandle(HANDLE handle_) {this->handle = handle_; return *this; }
    ImportSemaphoreWin32HandleInfoKHR& setName(LPCWSTR name_) {this->name = name_; return *this; }
};
struct ExportSemaphoreWin32HandleInfoKHR {
    StructureType sType{StructureType::ExportSemaphoreWin32HandleInfoKHR};
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess{};
    LPCWSTR name{};
    ExportSemaphoreWin32HandleInfoKHR& setPAttributes(const SECURITY_ATTRIBUTES* pAttributes_) {this->pAttributes = pAttributes_; return *this; }
    ExportSemaphoreWin32HandleInfoKHR& setPAttributes(SECURITY_ATTRIBUTES const& pAttributes_) {this->pAttributes = &pAttributes_; return *this; }
    ExportSemaphoreWin32HandleInfoKHR& setDwAccess(DWORD dwAccess_) {this->dwAccess = dwAccess_; return *this; }
    ExportSemaphoreWin32HandleInfoKHR& setName(LPCWSTR name_) {this->name = name_; return *this; }
};
struct D3D12FenceSubmitInfoKHR {
    StructureType sType{StructureType::D3D12FenceSubmitInfoKHR};
    const void* pNext = nullptr;
    uint32_t waitSemaphoreValuesCount{0};
    const uint64_t* pWaitSemaphoreValues = nullptr;
    uint32_t signalSemaphoreValuesCount{0};
    const uint64_t* pSignalSemaphoreValues = nullptr;
    D3D12FenceSubmitInfoKHR& setWaitSemaphoreValuesCount(uint32_t waitSemaphoreValuesCount_) {this->waitSemaphoreValuesCount = waitSemaphoreValuesCount_; return *this; }
    D3D12FenceSubmitInfoKHR& setPWaitSemaphoreValues(const uint64_t* pWaitSemaphoreValues_) {this->pWaitSemaphoreValues = pWaitSemaphoreValues_; return *this; }
    D3D12FenceSubmitInfoKHR& setPWaitSemaphoreValues(detail::span<const uint64_t> pWaitSemaphoreValues_) {this->waitSemaphoreValuesCount = pWaitSemaphoreValues_.size(); this->pWaitSemaphoreValues = pWaitSemaphoreValues_.data();  return *this; }
    D3D12FenceSubmitInfoKHR& setSignalSemaphoreValuesCount(uint32_t signalSemaphoreValuesCount_) {this->signalSemaphoreValuesCount = signalSemaphoreValuesCount_; return *this; }
    D3D12FenceSubmitInfoKHR& setPSignalSemaphoreValues(const uint64_t* pSignalSemaphoreValues_) {this->pSignalSemaphoreValues = pSignalSemaphoreValues_; return *this; }
    D3D12FenceSubmitInfoKHR& setPSignalSemaphoreValues(detail::span<const uint64_t> pSignalSemaphoreValues_) {this->signalSemaphoreValuesCount = pSignalSemaphoreValues_.size(); this->pSignalSemaphoreValues = pSignalSemaphoreValues_.data();  return *this; }
};
struct SemaphoreGetWin32HandleInfoKHR {
    StructureType sType{StructureType::SemaphoreGetWin32HandleInfoKHR};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    SemaphoreGetWin32HandleInfoKHR& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    SemaphoreGetWin32HandleInfoKHR& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportSemaphoreFdInfoKHR {
    StructureType sType{StructureType::ImportSemaphoreFdInfoKHR};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    SemaphoreImportFlags flags{};
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    int fd{0};
    ImportSemaphoreFdInfoKHR& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    ImportSemaphoreFdInfoKHR& setFlags(SemaphoreImportFlags flags_) {this->flags = flags_; return *this; }
    ImportSemaphoreFdInfoKHR& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportSemaphoreFdInfoKHR& setFd(int fd_) {this->fd = fd_; return *this; }
};
struct SemaphoreGetFdInfoKHR {
    StructureType sType{StructureType::SemaphoreGetFdInfoKHR};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    SemaphoreGetFdInfoKHR& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    SemaphoreGetFdInfoKHR& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#if defined(VK_USE_PLATFORM_FUCHSIA)
struct ImportSemaphoreZirconHandleInfoFUCHSIA {
    StructureType sType{StructureType::ImportSemaphoreZirconHandleInfoFUCHSIA};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    SemaphoreImportFlags flags{};
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    zx_handle_t zirconHandle{};
    ImportSemaphoreZirconHandleInfoFUCHSIA& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    ImportSemaphoreZirconHandleInfoFUCHSIA& setFlags(SemaphoreImportFlags flags_) {this->flags = flags_; return *this; }
    ImportSemaphoreZirconHandleInfoFUCHSIA& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportSemaphoreZirconHandleInfoFUCHSIA& setZirconHandle(zx_handle_t zirconHandle_) {this->zirconHandle = zirconHandle_; return *this; }
};
struct SemaphoreGetZirconHandleInfoFUCHSIA {
    StructureType sType{StructureType::SemaphoreGetZirconHandleInfoFUCHSIA};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    ExternalSemaphoreHandleTypeFlagBits handleType{static_cast<ExternalSemaphoreHandleTypeFlagBits>(0)};
    SemaphoreGetZirconHandleInfoFUCHSIA& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    SemaphoreGetZirconHandleInfoFUCHSIA& setHandleType(ExternalSemaphoreHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
struct PhysicalDeviceExternalFenceInfo {
    StructureType sType{StructureType::PhysicalDeviceExternalFenceInfo};
    const void* pNext = nullptr;
    ExternalFenceHandleTypeFlagBits handleType{static_cast<ExternalFenceHandleTypeFlagBits>(0)};
    PhysicalDeviceExternalFenceInfo& setHandleType(ExternalFenceHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
using PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
struct ExternalFenceProperties {
    StructureType sType{StructureType::ExternalFenceProperties};
    void* pNext = nullptr;
    ExternalFenceHandleTypeFlags exportFromImportedHandleTypes{};
    ExternalFenceHandleTypeFlags compatibleHandleTypes{};
    ExternalFenceFeatureFlags externalFenceFeatures{};
    ExternalFenceProperties& setExportFromImportedHandleTypes(ExternalFenceHandleTypeFlags exportFromImportedHandleTypes_) {this->exportFromImportedHandleTypes = exportFromImportedHandleTypes_; return *this; }
    ExternalFenceProperties& setCompatibleHandleTypes(ExternalFenceHandleTypeFlags compatibleHandleTypes_) {this->compatibleHandleTypes = compatibleHandleTypes_; return *this; }
    ExternalFenceProperties& setExternalFenceFeatures(ExternalFenceFeatureFlags externalFenceFeatures_) {this->externalFenceFeatures = externalFenceFeatures_; return *this; }
};
using ExternalFencePropertiesKHR = ExternalFenceProperties;
struct ExportFenceCreateInfo {
    StructureType sType{StructureType::ExportFenceCreateInfo};
    const void* pNext = nullptr;
    ExternalFenceHandleTypeFlags handleTypes{};
    ExportFenceCreateInfo& setHandleTypes(ExternalFenceHandleTypeFlags handleTypes_) {this->handleTypes = handleTypes_; return *this; }
};
using ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportFenceWin32HandleInfoKHR {
    StructureType sType{StructureType::ImportFenceWin32HandleInfoKHR};
    const void* pNext = nullptr;
    Fence fence{};
    FenceImportFlags flags{};
    ExternalFenceHandleTypeFlagBits handleType{static_cast<ExternalFenceHandleTypeFlagBits>(0)};
    HANDLE handle{};
    LPCWSTR name{};
    ImportFenceWin32HandleInfoKHR& setFence(Fence fence_) {this->fence = fence_; return *this; }
    ImportFenceWin32HandleInfoKHR& setFlags(FenceImportFlags flags_) {this->flags = flags_; return *this; }
    ImportFenceWin32HandleInfoKHR& setHandleType(ExternalFenceHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportFenceWin32HandleInfoKHR& setHandle(HANDLE handle_) {this->handle = handle_; return *this; }
    ImportFenceWin32HandleInfoKHR& setName(LPCWSTR name_) {this->name = name_; return *this; }
};
struct ExportFenceWin32HandleInfoKHR {
    StructureType sType{StructureType::ExportFenceWin32HandleInfoKHR};
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess{};
    LPCWSTR name{};
    ExportFenceWin32HandleInfoKHR& setPAttributes(const SECURITY_ATTRIBUTES* pAttributes_) {this->pAttributes = pAttributes_; return *this; }
    ExportFenceWin32HandleInfoKHR& setPAttributes(SECURITY_ATTRIBUTES const& pAttributes_) {this->pAttributes = &pAttributes_; return *this; }
    ExportFenceWin32HandleInfoKHR& setDwAccess(DWORD dwAccess_) {this->dwAccess = dwAccess_; return *this; }
    ExportFenceWin32HandleInfoKHR& setName(LPCWSTR name_) {this->name = name_; return *this; }
};
struct FenceGetWin32HandleInfoKHR {
    StructureType sType{StructureType::FenceGetWin32HandleInfoKHR};
    const void* pNext = nullptr;
    Fence fence{};
    ExternalFenceHandleTypeFlagBits handleType{static_cast<ExternalFenceHandleTypeFlagBits>(0)};
    FenceGetWin32HandleInfoKHR& setFence(Fence fence_) {this->fence = fence_; return *this; }
    FenceGetWin32HandleInfoKHR& setHandleType(ExternalFenceHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
struct ImportFenceFdInfoKHR {
    StructureType sType{StructureType::ImportFenceFdInfoKHR};
    const void* pNext = nullptr;
    Fence fence{};
    FenceImportFlags flags{};
    ExternalFenceHandleTypeFlagBits handleType{static_cast<ExternalFenceHandleTypeFlagBits>(0)};
    int fd{0};
    ImportFenceFdInfoKHR& setFence(Fence fence_) {this->fence = fence_; return *this; }
    ImportFenceFdInfoKHR& setFlags(FenceImportFlags flags_) {this->flags = flags_; return *this; }
    ImportFenceFdInfoKHR& setHandleType(ExternalFenceHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportFenceFdInfoKHR& setFd(int fd_) {this->fd = fd_; return *this; }
};
struct FenceGetFdInfoKHR {
    StructureType sType{StructureType::FenceGetFdInfoKHR};
    const void* pNext = nullptr;
    Fence fence{};
    ExternalFenceHandleTypeFlagBits handleType{static_cast<ExternalFenceHandleTypeFlagBits>(0)};
    FenceGetFdInfoKHR& setFence(Fence fence_) {this->fence = fence_; return *this; }
    FenceGetFdInfoKHR& setHandleType(ExternalFenceHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
};
struct PhysicalDeviceMultiviewFeatures {
    StructureType sType{StructureType::PhysicalDeviceMultiviewFeatures};
    void* pNext = nullptr;
    Bool32 multiview{0};
    Bool32 multiviewGeometryShader{0};
    Bool32 multiviewTessellationShader{0};
    PhysicalDeviceMultiviewFeatures& setMultiview(Bool32 multiview_) {this->multiview = multiview_; return *this; }
    PhysicalDeviceMultiviewFeatures& setMultiviewGeometryShader(Bool32 multiviewGeometryShader_) {this->multiviewGeometryShader = multiviewGeometryShader_; return *this; }
    PhysicalDeviceMultiviewFeatures& setMultiviewTessellationShader(Bool32 multiviewTessellationShader_) {this->multiviewTessellationShader = multiviewTessellationShader_; return *this; }
};
using PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
struct PhysicalDeviceMultiviewProperties {
    StructureType sType{StructureType::PhysicalDeviceMultiviewProperties};
    void* pNext = nullptr;
    uint32_t maxMultiviewViewCount{0};
    uint32_t maxMultiviewInstanceIndex{0};
    PhysicalDeviceMultiviewProperties& setMaxMultiviewViewCount(uint32_t maxMultiviewViewCount_) {this->maxMultiviewViewCount = maxMultiviewViewCount_; return *this; }
    PhysicalDeviceMultiviewProperties& setMaxMultiviewInstanceIndex(uint32_t maxMultiviewInstanceIndex_) {this->maxMultiviewInstanceIndex = maxMultiviewInstanceIndex_; return *this; }
};
using PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
struct RenderPassMultiviewCreateInfo {
    StructureType sType{StructureType::RenderPassMultiviewCreateInfo};
    const void* pNext = nullptr;
    uint32_t subpassCount{0};
    const uint32_t* pViewMasks = nullptr;
    uint32_t dependencyCount{0};
    const int32_t* pViewOffsets = nullptr;
    uint32_t correlationMaskCount{0};
    const uint32_t* pCorrelationMasks = nullptr;
    RenderPassMultiviewCreateInfo& setSubpassCount(uint32_t subpassCount_) {this->subpassCount = subpassCount_; return *this; }
    RenderPassMultiviewCreateInfo& setPViewMasks(const uint32_t* pViewMasks_) {this->pViewMasks = pViewMasks_; return *this; }
    RenderPassMultiviewCreateInfo& setPViewMasks(detail::span<const uint32_t> pViewMasks_) {this->subpassCount = pViewMasks_.size(); this->pViewMasks = pViewMasks_.data();  return *this; }
    RenderPassMultiviewCreateInfo& setDependencyCount(uint32_t dependencyCount_) {this->dependencyCount = dependencyCount_; return *this; }
    RenderPassMultiviewCreateInfo& setPViewOffsets(const int32_t* pViewOffsets_) {this->pViewOffsets = pViewOffsets_; return *this; }
    RenderPassMultiviewCreateInfo& setPViewOffsets(detail::span<const int32_t> pViewOffsets_) {this->dependencyCount = pViewOffsets_.size(); this->pViewOffsets = pViewOffsets_.data();  return *this; }
    RenderPassMultiviewCreateInfo& setCorrelationMaskCount(uint32_t correlationMaskCount_) {this->correlationMaskCount = correlationMaskCount_; return *this; }
    RenderPassMultiviewCreateInfo& setPCorrelationMasks(const uint32_t* pCorrelationMasks_) {this->pCorrelationMasks = pCorrelationMasks_; return *this; }
    RenderPassMultiviewCreateInfo& setPCorrelationMasks(detail::span<const uint32_t> pCorrelationMasks_) {this->correlationMaskCount = pCorrelationMasks_.size(); this->pCorrelationMasks = pCorrelationMasks_.data();  return *this; }
};
using RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
struct SurfaceCapabilities2EXT {
    StructureType sType{StructureType::SurfaceCapabilities2EXT};
    void* pNext = nullptr;
    uint32_t minImageCount{0};
    uint32_t maxImageCount{0};
    Extent2D currentExtent{};
    Extent2D minImageExtent{};
    Extent2D maxImageExtent{};
    uint32_t maxImageArrayLayers{0};
    SurfaceTransformFlagsKHR supportedTransforms{};
    SurfaceTransformFlagBitsKHR currentTransform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    CompositeAlphaFlagsKHR supportedCompositeAlpha{};
    ImageUsageFlags supportedUsageFlags{};
    SurfaceCounterFlagsEXT supportedSurfaceCounters{};
    SurfaceCapabilities2EXT& setMinImageCount(uint32_t minImageCount_) {this->minImageCount = minImageCount_; return *this; }
    SurfaceCapabilities2EXT& setMaxImageCount(uint32_t maxImageCount_) {this->maxImageCount = maxImageCount_; return *this; }
    SurfaceCapabilities2EXT& setCurrentExtent(Extent2D currentExtent_) {this->currentExtent = currentExtent_; return *this; }
    SurfaceCapabilities2EXT& setMinImageExtent(Extent2D minImageExtent_) {this->minImageExtent = minImageExtent_; return *this; }
    SurfaceCapabilities2EXT& setMaxImageExtent(Extent2D maxImageExtent_) {this->maxImageExtent = maxImageExtent_; return *this; }
    SurfaceCapabilities2EXT& setMaxImageArrayLayers(uint32_t maxImageArrayLayers_) {this->maxImageArrayLayers = maxImageArrayLayers_; return *this; }
    SurfaceCapabilities2EXT& setSupportedTransforms(SurfaceTransformFlagsKHR supportedTransforms_) {this->supportedTransforms = supportedTransforms_; return *this; }
    SurfaceCapabilities2EXT& setCurrentTransform(SurfaceTransformFlagBitsKHR currentTransform_) {this->currentTransform = currentTransform_; return *this; }
    SurfaceCapabilities2EXT& setSupportedCompositeAlpha(CompositeAlphaFlagsKHR supportedCompositeAlpha_) {this->supportedCompositeAlpha = supportedCompositeAlpha_; return *this; }
    SurfaceCapabilities2EXT& setSupportedUsageFlags(ImageUsageFlags supportedUsageFlags_) {this->supportedUsageFlags = supportedUsageFlags_; return *this; }
    SurfaceCapabilities2EXT& setSupportedSurfaceCounters(SurfaceCounterFlagsEXT supportedSurfaceCounters_) {this->supportedSurfaceCounters = supportedSurfaceCounters_; return *this; }
};
struct DisplayPowerInfoEXT {
    StructureType sType{StructureType::DisplayPowerInfoEXT};
    const void* pNext = nullptr;
    DisplayPowerStateEXT powerState{static_cast<DisplayPowerStateEXT>(0)};
    DisplayPowerInfoEXT& setPowerState(DisplayPowerStateEXT powerState_) {this->powerState = powerState_; return *this; }
};
struct DeviceEventInfoEXT {
    StructureType sType{StructureType::DeviceEventInfoEXT};
    const void* pNext = nullptr;
    DeviceEventTypeEXT deviceEvent{static_cast<DeviceEventTypeEXT>(0)};
    DeviceEventInfoEXT& setDeviceEvent(DeviceEventTypeEXT deviceEvent_) {this->deviceEvent = deviceEvent_; return *this; }
};
struct DisplayEventInfoEXT {
    StructureType sType{StructureType::DisplayEventInfoEXT};
    const void* pNext = nullptr;
    DisplayEventTypeEXT displayEvent{static_cast<DisplayEventTypeEXT>(0)};
    DisplayEventInfoEXT& setDisplayEvent(DisplayEventTypeEXT displayEvent_) {this->displayEvent = displayEvent_; return *this; }
};
struct SwapchainCounterCreateInfoEXT {
    StructureType sType{StructureType::SwapchainCounterCreateInfoEXT};
    const void* pNext = nullptr;
    SurfaceCounterFlagsEXT surfaceCounters{};
    SwapchainCounterCreateInfoEXT& setSurfaceCounters(SurfaceCounterFlagsEXT surfaceCounters_) {this->surfaceCounters = surfaceCounters_; return *this; }
};
struct PhysicalDeviceGroupProperties {
    StructureType sType{StructureType::PhysicalDeviceGroupProperties};
    void* pNext = nullptr;
    uint32_t physicalDeviceCount{0};
    PhysicalDevice physicalDevices[MAX_DEVICE_GROUP_SIZE];
    Bool32 subsetAllocation{0};
    PhysicalDeviceGroupProperties& setPhysicalDeviceCount(uint32_t physicalDeviceCount_) {this->physicalDeviceCount = physicalDeviceCount_; return *this; }
    PhysicalDeviceGroupProperties& setPhysicalDevices(PhysicalDevice physicalDevices_[MAX_DEVICE_GROUP_SIZE]) {for(uint32_t i = 0; i < MAX_DEVICE_GROUP_SIZE; i++) this->physicalDevices[i] = physicalDevices_[i]; return *this; }
    PhysicalDeviceGroupProperties& setSubsetAllocation(Bool32 subsetAllocation_) {this->subsetAllocation = subsetAllocation_; return *this; }
};
using PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
struct MemoryAllocateFlagsInfo {
    StructureType sType{StructureType::MemoryAllocateFlagsInfo};
    const void* pNext = nullptr;
    MemoryAllocateFlags flags{};
    uint32_t deviceMask{0};
    MemoryAllocateFlagsInfo& setFlags(MemoryAllocateFlags flags_) {this->flags = flags_; return *this; }
    MemoryAllocateFlagsInfo& setDeviceMask(uint32_t deviceMask_) {this->deviceMask = deviceMask_; return *this; }
};
using MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
struct BindBufferMemoryInfo {
    StructureType sType{StructureType::BindBufferMemoryInfo};
    const void* pNext = nullptr;
    Buffer buffer{};
    DeviceMemory memory{};
    DeviceSize memoryOffset{0};
    BindBufferMemoryInfo& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    BindBufferMemoryInfo& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    BindBufferMemoryInfo& setMemoryOffset(DeviceSize memoryOffset_) {this->memoryOffset = memoryOffset_; return *this; }
};
using BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
struct BindBufferMemoryDeviceGroupInfo {
    StructureType sType{StructureType::BindBufferMemoryDeviceGroupInfo};
    const void* pNext = nullptr;
    uint32_t deviceIndexCount{0};
    const uint32_t* pDeviceIndices = nullptr;
    BindBufferMemoryDeviceGroupInfo& setDeviceIndexCount(uint32_t deviceIndexCount_) {this->deviceIndexCount = deviceIndexCount_; return *this; }
    BindBufferMemoryDeviceGroupInfo& setPDeviceIndices(const uint32_t* pDeviceIndices_) {this->pDeviceIndices = pDeviceIndices_; return *this; }
    BindBufferMemoryDeviceGroupInfo& setPDeviceIndices(detail::span<const uint32_t> pDeviceIndices_) {this->deviceIndexCount = pDeviceIndices_.size(); this->pDeviceIndices = pDeviceIndices_.data();  return *this; }
};
using BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
struct BindImageMemoryInfo {
    StructureType sType{StructureType::BindImageMemoryInfo};
    const void* pNext = nullptr;
    Image image{};
    DeviceMemory memory{};
    DeviceSize memoryOffset{0};
    BindImageMemoryInfo& setImage(Image image_) {this->image = image_; return *this; }
    BindImageMemoryInfo& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    BindImageMemoryInfo& setMemoryOffset(DeviceSize memoryOffset_) {this->memoryOffset = memoryOffset_; return *this; }
};
using BindImageMemoryInfoKHR = BindImageMemoryInfo;
struct BindImageMemoryDeviceGroupInfo {
    StructureType sType{StructureType::BindImageMemoryDeviceGroupInfo};
    const void* pNext = nullptr;
    uint32_t deviceIndexCount{0};
    const uint32_t* pDeviceIndices = nullptr;
    uint32_t splitInstanceBindRegionCount{0};
    const Rect2D* pSplitInstanceBindRegions = nullptr;
    BindImageMemoryDeviceGroupInfo& setDeviceIndexCount(uint32_t deviceIndexCount_) {this->deviceIndexCount = deviceIndexCount_; return *this; }
    BindImageMemoryDeviceGroupInfo& setPDeviceIndices(const uint32_t* pDeviceIndices_) {this->pDeviceIndices = pDeviceIndices_; return *this; }
    BindImageMemoryDeviceGroupInfo& setPDeviceIndices(detail::span<const uint32_t> pDeviceIndices_) {this->deviceIndexCount = pDeviceIndices_.size(); this->pDeviceIndices = pDeviceIndices_.data();  return *this; }
    BindImageMemoryDeviceGroupInfo& setSplitInstanceBindRegionCount(uint32_t splitInstanceBindRegionCount_) {this->splitInstanceBindRegionCount = splitInstanceBindRegionCount_; return *this; }
    BindImageMemoryDeviceGroupInfo& setPSplitInstanceBindRegions(const Rect2D* pSplitInstanceBindRegions_) {this->pSplitInstanceBindRegions = pSplitInstanceBindRegions_; return *this; }
    BindImageMemoryDeviceGroupInfo& setPSplitInstanceBindRegions(detail::span<const Rect2D> pSplitInstanceBindRegions_) {this->splitInstanceBindRegionCount = pSplitInstanceBindRegions_.size(); this->pSplitInstanceBindRegions = pSplitInstanceBindRegions_.data();  return *this; }
};
using BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;
struct DeviceGroupRenderPassBeginInfo {
    StructureType sType{StructureType::DeviceGroupRenderPassBeginInfo};
    const void* pNext = nullptr;
    uint32_t deviceMask{0};
    uint32_t deviceRenderAreaCount{0};
    const Rect2D* pDeviceRenderAreas = nullptr;
    DeviceGroupRenderPassBeginInfo& setDeviceMask(uint32_t deviceMask_) {this->deviceMask = deviceMask_; return *this; }
    DeviceGroupRenderPassBeginInfo& setDeviceRenderAreaCount(uint32_t deviceRenderAreaCount_) {this->deviceRenderAreaCount = deviceRenderAreaCount_; return *this; }
    DeviceGroupRenderPassBeginInfo& setPDeviceRenderAreas(const Rect2D* pDeviceRenderAreas_) {this->pDeviceRenderAreas = pDeviceRenderAreas_; return *this; }
    DeviceGroupRenderPassBeginInfo& setPDeviceRenderAreas(detail::span<const Rect2D> pDeviceRenderAreas_) {this->deviceRenderAreaCount = pDeviceRenderAreas_.size(); this->pDeviceRenderAreas = pDeviceRenderAreas_.data();  return *this; }
};
using DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
struct DeviceGroupCommandBufferBeginInfo {
    StructureType sType{StructureType::DeviceGroupCommandBufferBeginInfo};
    const void* pNext = nullptr;
    uint32_t deviceMask{0};
    DeviceGroupCommandBufferBeginInfo& setDeviceMask(uint32_t deviceMask_) {this->deviceMask = deviceMask_; return *this; }
};
using DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
struct DeviceGroupSubmitInfo {
    StructureType sType{StructureType::DeviceGroupSubmitInfo};
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount{0};
    const uint32_t* pWaitSemaphoreDeviceIndices = nullptr;
    uint32_t commandBufferCount{0};
    const uint32_t* pCommandBufferDeviceMasks = nullptr;
    uint32_t signalSemaphoreCount{0};
    const uint32_t* pSignalSemaphoreDeviceIndices = nullptr;
    DeviceGroupSubmitInfo& setWaitSemaphoreCount(uint32_t waitSemaphoreCount_) {this->waitSemaphoreCount = waitSemaphoreCount_; return *this; }
    DeviceGroupSubmitInfo& setPWaitSemaphoreDeviceIndices(const uint32_t* pWaitSemaphoreDeviceIndices_) {this->pWaitSemaphoreDeviceIndices = pWaitSemaphoreDeviceIndices_; return *this; }
    DeviceGroupSubmitInfo& setPWaitSemaphoreDeviceIndices(detail::span<const uint32_t> pWaitSemaphoreDeviceIndices_) {this->waitSemaphoreCount = pWaitSemaphoreDeviceIndices_.size(); this->pWaitSemaphoreDeviceIndices = pWaitSemaphoreDeviceIndices_.data();  return *this; }
    DeviceGroupSubmitInfo& setCommandBufferCount(uint32_t commandBufferCount_) {this->commandBufferCount = commandBufferCount_; return *this; }
    DeviceGroupSubmitInfo& setPCommandBufferDeviceMasks(const uint32_t* pCommandBufferDeviceMasks_) {this->pCommandBufferDeviceMasks = pCommandBufferDeviceMasks_; return *this; }
    DeviceGroupSubmitInfo& setPCommandBufferDeviceMasks(detail::span<const uint32_t> pCommandBufferDeviceMasks_) {this->commandBufferCount = pCommandBufferDeviceMasks_.size(); this->pCommandBufferDeviceMasks = pCommandBufferDeviceMasks_.data();  return *this; }
    DeviceGroupSubmitInfo& setSignalSemaphoreCount(uint32_t signalSemaphoreCount_) {this->signalSemaphoreCount = signalSemaphoreCount_; return *this; }
    DeviceGroupSubmitInfo& setPSignalSemaphoreDeviceIndices(const uint32_t* pSignalSemaphoreDeviceIndices_) {this->pSignalSemaphoreDeviceIndices = pSignalSemaphoreDeviceIndices_; return *this; }
    DeviceGroupSubmitInfo& setPSignalSemaphoreDeviceIndices(detail::span<const uint32_t> pSignalSemaphoreDeviceIndices_) {this->signalSemaphoreCount = pSignalSemaphoreDeviceIndices_.size(); this->pSignalSemaphoreDeviceIndices = pSignalSemaphoreDeviceIndices_.data();  return *this; }
};
using DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
struct DeviceGroupBindSparseInfo {
    StructureType sType{StructureType::DeviceGroupBindSparseInfo};
    const void* pNext = nullptr;
    uint32_t resourceDeviceIndex{0};
    uint32_t memoryDeviceIndex{0};
    DeviceGroupBindSparseInfo& setResourceDeviceIndex(uint32_t resourceDeviceIndex_) {this->resourceDeviceIndex = resourceDeviceIndex_; return *this; }
    DeviceGroupBindSparseInfo& setMemoryDeviceIndex(uint32_t memoryDeviceIndex_) {this->memoryDeviceIndex = memoryDeviceIndex_; return *this; }
};
using DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
struct DeviceGroupPresentCapabilitiesKHR {
    StructureType sType{StructureType::DeviceGroupPresentCapabilitiesKHR};
    const void* pNext = nullptr;
    uint32_t presentMask[MAX_DEVICE_GROUP_SIZE];
    DeviceGroupPresentModeFlagsKHR modes{};
    DeviceGroupPresentCapabilitiesKHR& setPresentMask(uint32_t presentMask_[MAX_DEVICE_GROUP_SIZE]) {for(uint32_t i = 0; i < MAX_DEVICE_GROUP_SIZE; i++) this->presentMask[i] = presentMask_[i]; return *this; }
    DeviceGroupPresentCapabilitiesKHR& setModes(DeviceGroupPresentModeFlagsKHR modes_) {this->modes = modes_; return *this; }
};
struct ImageSwapchainCreateInfoKHR {
    StructureType sType{StructureType::ImageSwapchainCreateInfoKHR};
    const void* pNext = nullptr;
    SwapchainKHR swapchain{};
    ImageSwapchainCreateInfoKHR& setSwapchain(SwapchainKHR swapchain_) {this->swapchain = swapchain_; return *this; }
};
struct BindImageMemorySwapchainInfoKHR {
    StructureType sType{StructureType::BindImageMemorySwapchainInfoKHR};
    const void* pNext = nullptr;
    SwapchainKHR swapchain{};
    uint32_t imageIndex{0};
    BindImageMemorySwapchainInfoKHR& setSwapchain(SwapchainKHR swapchain_) {this->swapchain = swapchain_; return *this; }
    BindImageMemorySwapchainInfoKHR& setImageIndex(uint32_t imageIndex_) {this->imageIndex = imageIndex_; return *this; }
};
struct AcquireNextImageInfoKHR {
    StructureType sType{StructureType::AcquireNextImageInfoKHR};
    const void* pNext = nullptr;
    SwapchainKHR swapchain{};
    uint64_t timeout{0};
    Semaphore semaphore{};
    Fence fence{};
    uint32_t deviceMask{0};
    AcquireNextImageInfoKHR& setSwapchain(SwapchainKHR swapchain_) {this->swapchain = swapchain_; return *this; }
    AcquireNextImageInfoKHR& setTimeout(uint64_t timeout_) {this->timeout = timeout_; return *this; }
    AcquireNextImageInfoKHR& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    AcquireNextImageInfoKHR& setFence(Fence fence_) {this->fence = fence_; return *this; }
    AcquireNextImageInfoKHR& setDeviceMask(uint32_t deviceMask_) {this->deviceMask = deviceMask_; return *this; }
};
struct DeviceGroupPresentInfoKHR {
    StructureType sType{StructureType::DeviceGroupPresentInfoKHR};
    const void* pNext = nullptr;
    uint32_t swapchainCount{0};
    const uint32_t* pDeviceMasks = nullptr;
    DeviceGroupPresentModeFlagBitsKHR mode{static_cast<DeviceGroupPresentModeFlagBitsKHR>(0)};
    DeviceGroupPresentInfoKHR& setSwapchainCount(uint32_t swapchainCount_) {this->swapchainCount = swapchainCount_; return *this; }
    DeviceGroupPresentInfoKHR& setPDeviceMasks(const uint32_t* pDeviceMasks_) {this->pDeviceMasks = pDeviceMasks_; return *this; }
    DeviceGroupPresentInfoKHR& setPDeviceMasks(detail::span<const uint32_t> pDeviceMasks_) {this->swapchainCount = pDeviceMasks_.size(); this->pDeviceMasks = pDeviceMasks_.data();  return *this; }
    DeviceGroupPresentInfoKHR& setMode(DeviceGroupPresentModeFlagBitsKHR mode_) {this->mode = mode_; return *this; }
};
struct DeviceGroupDeviceCreateInfo {
    StructureType sType{StructureType::DeviceGroupDeviceCreateInfo};
    const void* pNext = nullptr;
    uint32_t physicalDeviceCount{0};
    const PhysicalDevice* pPhysicalDevices = nullptr;
    DeviceGroupDeviceCreateInfo& setPhysicalDeviceCount(uint32_t physicalDeviceCount_) {this->physicalDeviceCount = physicalDeviceCount_; return *this; }
    DeviceGroupDeviceCreateInfo& setPPhysicalDevices(const PhysicalDevice* pPhysicalDevices_) {this->pPhysicalDevices = pPhysicalDevices_; return *this; }
    DeviceGroupDeviceCreateInfo& setPPhysicalDevices(detail::span<const PhysicalDevice> pPhysicalDevices_) {this->physicalDeviceCount = pPhysicalDevices_.size(); this->pPhysicalDevices = pPhysicalDevices_.data();  return *this; }
};
using DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
struct DeviceGroupSwapchainCreateInfoKHR {
    StructureType sType{StructureType::DeviceGroupSwapchainCreateInfoKHR};
    const void* pNext = nullptr;
    DeviceGroupPresentModeFlagsKHR modes{};
    DeviceGroupSwapchainCreateInfoKHR& setModes(DeviceGroupPresentModeFlagsKHR modes_) {this->modes = modes_; return *this; }
};
struct DescriptorUpdateTemplateEntry {
    uint32_t dstBinding{0};
    uint32_t dstArrayElement{0};
    uint32_t descriptorCount{0};
    DescriptorType descriptorType{static_cast<DescriptorType>(0)};
    size_t offset{0};
    size_t stride{0};
    constexpr bool operator==(DescriptorUpdateTemplateEntry const& value) const {
        return dstBinding == value.dstBinding && dstArrayElement == value.dstArrayElement && descriptorCount == value.descriptorCount && descriptorType == value.descriptorType 
        && offset == value.offset && stride == value.stride ;}
    constexpr bool operator!=(DescriptorUpdateTemplateEntry const& value) const {return !(*this == value);}
    DescriptorUpdateTemplateEntry& setDstBinding(uint32_t dstBinding_) {this->dstBinding = dstBinding_; return *this; }
    DescriptorUpdateTemplateEntry& setDstArrayElement(uint32_t dstArrayElement_) {this->dstArrayElement = dstArrayElement_; return *this; }
    DescriptorUpdateTemplateEntry& setDescriptorCount(uint32_t descriptorCount_) {this->descriptorCount = descriptorCount_; return *this; }
    DescriptorUpdateTemplateEntry& setDescriptorType(DescriptorType descriptorType_) {this->descriptorType = descriptorType_; return *this; }
    DescriptorUpdateTemplateEntry& setOffset(size_t offset_) {this->offset = offset_; return *this; }
    DescriptorUpdateTemplateEntry& setStride(size_t stride_) {this->stride = stride_; return *this; }
};
using DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
struct DescriptorUpdateTemplateCreateInfo {
    StructureType sType{StructureType::DescriptorUpdateTemplateCreateInfo};
    const void* pNext = nullptr;
    DescriptorUpdateTemplateCreateFlags flags{};
    uint32_t descriptorUpdateEntryCount{0};
    const DescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = nullptr;
    DescriptorUpdateTemplateType templateType{static_cast<DescriptorUpdateTemplateType>(0)};
    DescriptorSetLayout descriptorSetLayout{};
    PipelineBindPoint pipelineBindPoint{static_cast<PipelineBindPoint>(0)};
    PipelineLayout pipelineLayout{};
    uint32_t set{0};
    DescriptorUpdateTemplateCreateInfo& setFlags(DescriptorUpdateTemplateCreateFlags flags_) {this->flags = flags_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setDescriptorUpdateEntryCount(uint32_t descriptorUpdateEntryCount_) {this->descriptorUpdateEntryCount = descriptorUpdateEntryCount_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setPDescriptorUpdateEntries(const DescriptorUpdateTemplateEntry* pDescriptorUpdateEntries_) {this->pDescriptorUpdateEntries = pDescriptorUpdateEntries_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setPDescriptorUpdateEntries(detail::span<const DescriptorUpdateTemplateEntry> pDescriptorUpdateEntries_) {this->descriptorUpdateEntryCount = pDescriptorUpdateEntries_.size(); this->pDescriptorUpdateEntries = pDescriptorUpdateEntries_.data();  return *this; }
    DescriptorUpdateTemplateCreateInfo& setTemplateType(DescriptorUpdateTemplateType templateType_) {this->templateType = templateType_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setDescriptorSetLayout(DescriptorSetLayout descriptorSetLayout_) {this->descriptorSetLayout = descriptorSetLayout_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setPipelineBindPoint(PipelineBindPoint pipelineBindPoint_) {this->pipelineBindPoint = pipelineBindPoint_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setPipelineLayout(PipelineLayout pipelineLayout_) {this->pipelineLayout = pipelineLayout_; return *this; }
    DescriptorUpdateTemplateCreateInfo& setSet(uint32_t set_) {this->set = set_; return *this; }
};
using DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
struct XYColorEXT {
    float x{0.f};
    float y{0.f};
    constexpr bool operator==(XYColorEXT const& value) const {
        return x == value.x && y == value.y ;}
    constexpr bool operator!=(XYColorEXT const& value) const {return !(*this == value);}
    XYColorEXT& setX(float x_) {this->x = x_; return *this; }
    XYColorEXT& setY(float y_) {this->y = y_; return *this; }
};
struct HdrMetadataEXT {
    StructureType sType{StructureType::HdrMetadataEXT};
    const void* pNext = nullptr;
    XYColorEXT displayPrimaryRed{};
    XYColorEXT displayPrimaryGreen{};
    XYColorEXT displayPrimaryBlue{};
    XYColorEXT whitePoint{};
    float maxLuminance{0.f};
    float minLuminance{0.f};
    float maxContentLightLevel{0.f};
    float maxFrameAverageLightLevel{0.f};
    HdrMetadataEXT& setDisplayPrimaryRed(XYColorEXT displayPrimaryRed_) {this->displayPrimaryRed = displayPrimaryRed_; return *this; }
    HdrMetadataEXT& setDisplayPrimaryGreen(XYColorEXT displayPrimaryGreen_) {this->displayPrimaryGreen = displayPrimaryGreen_; return *this; }
    HdrMetadataEXT& setDisplayPrimaryBlue(XYColorEXT displayPrimaryBlue_) {this->displayPrimaryBlue = displayPrimaryBlue_; return *this; }
    HdrMetadataEXT& setWhitePoint(XYColorEXT whitePoint_) {this->whitePoint = whitePoint_; return *this; }
    HdrMetadataEXT& setMaxLuminance(float maxLuminance_) {this->maxLuminance = maxLuminance_; return *this; }
    HdrMetadataEXT& setMinLuminance(float minLuminance_) {this->minLuminance = minLuminance_; return *this; }
    HdrMetadataEXT& setMaxContentLightLevel(float maxContentLightLevel_) {this->maxContentLightLevel = maxContentLightLevel_; return *this; }
    HdrMetadataEXT& setMaxFrameAverageLightLevel(float maxFrameAverageLightLevel_) {this->maxFrameAverageLightLevel = maxFrameAverageLightLevel_; return *this; }
};
struct DisplayNativeHdrSurfaceCapabilitiesAMD {
    StructureType sType{StructureType::DisplayNativeHdrSurfaceCapabilitiesAMD};
    void* pNext = nullptr;
    Bool32 localDimmingSupport{0};
    DisplayNativeHdrSurfaceCapabilitiesAMD& setLocalDimmingSupport(Bool32 localDimmingSupport_) {this->localDimmingSupport = localDimmingSupport_; return *this; }
};
struct SwapchainDisplayNativeHdrCreateInfoAMD {
    StructureType sType{StructureType::SwapchainDisplayNativeHdrCreateInfoAMD};
    const void* pNext = nullptr;
    Bool32 localDimmingEnable{0};
    SwapchainDisplayNativeHdrCreateInfoAMD& setLocalDimmingEnable(Bool32 localDimmingEnable_) {this->localDimmingEnable = localDimmingEnable_; return *this; }
};
struct RefreshCycleDurationGOOGLE {
    uint64_t refreshDuration{0};
    constexpr bool operator==(RefreshCycleDurationGOOGLE const& value) const {
        return refreshDuration == value.refreshDuration ;}
    constexpr bool operator!=(RefreshCycleDurationGOOGLE const& value) const {return !(*this == value);}
    RefreshCycleDurationGOOGLE& setRefreshDuration(uint64_t refreshDuration_) {this->refreshDuration = refreshDuration_; return *this; }
};
struct PastPresentationTimingGOOGLE {
    uint32_t presentID{0};
    uint64_t desiredPresentTime{0};
    uint64_t actualPresentTime{0};
    uint64_t earliestPresentTime{0};
    uint64_t presentMargin{0};
    constexpr bool operator==(PastPresentationTimingGOOGLE const& value) const {
        return presentID == value.presentID && desiredPresentTime == value.desiredPresentTime && actualPresentTime == value.actualPresentTime && earliestPresentTime == value.earliestPresentTime 
        && presentMargin == value.presentMargin ;}
    constexpr bool operator!=(PastPresentationTimingGOOGLE const& value) const {return !(*this == value);}
    PastPresentationTimingGOOGLE& setPresentID(uint32_t presentID_) {this->presentID = presentID_; return *this; }
    PastPresentationTimingGOOGLE& setDesiredPresentTime(uint64_t desiredPresentTime_) {this->desiredPresentTime = desiredPresentTime_; return *this; }
    PastPresentationTimingGOOGLE& setActualPresentTime(uint64_t actualPresentTime_) {this->actualPresentTime = actualPresentTime_; return *this; }
    PastPresentationTimingGOOGLE& setEarliestPresentTime(uint64_t earliestPresentTime_) {this->earliestPresentTime = earliestPresentTime_; return *this; }
    PastPresentationTimingGOOGLE& setPresentMargin(uint64_t presentMargin_) {this->presentMargin = presentMargin_; return *this; }
};
struct PresentTimeGOOGLE {
    uint32_t presentID{0};
    uint64_t desiredPresentTime{0};
    constexpr bool operator==(PresentTimeGOOGLE const& value) const {
        return presentID == value.presentID && desiredPresentTime == value.desiredPresentTime ;}
    constexpr bool operator!=(PresentTimeGOOGLE const& value) const {return !(*this == value);}
    PresentTimeGOOGLE& setPresentID(uint32_t presentID_) {this->presentID = presentID_; return *this; }
    PresentTimeGOOGLE& setDesiredPresentTime(uint64_t desiredPresentTime_) {this->desiredPresentTime = desiredPresentTime_; return *this; }
};
struct PresentTimesInfoGOOGLE {
    StructureType sType{StructureType::PresentTimesInfoGOOGLE};
    const void* pNext = nullptr;
    uint32_t swapchainCount{0};
    const PresentTimeGOOGLE* pTimes = nullptr;
    PresentTimesInfoGOOGLE& setSwapchainCount(uint32_t swapchainCount_) {this->swapchainCount = swapchainCount_; return *this; }
    PresentTimesInfoGOOGLE& setPTimes(const PresentTimeGOOGLE* pTimes_) {this->pTimes = pTimes_; return *this; }
    PresentTimesInfoGOOGLE& setPTimes(detail::span<const PresentTimeGOOGLE> pTimes_) {this->swapchainCount = pTimes_.size(); this->pTimes = pTimes_.data();  return *this; }
};
#if defined(VK_USE_PLATFORM_IOS_MVK)
struct IOSSurfaceCreateInfoMVK {
    StructureType sType{StructureType::IosSurfaceCreateInfoMVK};
    const void* pNext = nullptr;
    IOSSurfaceCreateFlagsMVK flags{};
    const void* pView = nullptr;
    IOSSurfaceCreateInfoMVK& setFlags(IOSSurfaceCreateFlagsMVK flags_) {this->flags = flags_; return *this; }
    IOSSurfaceCreateInfoMVK& setPView(const void* pView_) {this->pView = pView_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
struct MacOSSurfaceCreateInfoMVK {
    StructureType sType{StructureType::MacosSurfaceCreateInfoMVK};
    const void* pNext = nullptr;
    MacOSSurfaceCreateFlagsMVK flags{};
    const void* pView = nullptr;
    MacOSSurfaceCreateInfoMVK& setFlags(MacOSSurfaceCreateFlagsMVK flags_) {this->flags = flags_; return *this; }
    MacOSSurfaceCreateInfoMVK& setPView(const void* pView_) {this->pView = pView_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
#if defined(VK_USE_PLATFORM_METAL_EXT)
struct MetalSurfaceCreateInfoEXT {
    StructureType sType{StructureType::MetalSurfaceCreateInfoEXT};
    const void* pNext = nullptr;
    MetalSurfaceCreateFlagsEXT flags{};
    const CAMetalLayer* pLayer = nullptr;
    MetalSurfaceCreateInfoEXT& setFlags(MetalSurfaceCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    MetalSurfaceCreateInfoEXT& setPLayer(const CAMetalLayer* pLayer_) {this->pLayer = pLayer_; return *this; }
    MetalSurfaceCreateInfoEXT& setPLayer(CAMetalLayer const& pLayer_) {this->pLayer = &pLayer_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
struct ViewportWScalingNV {
    float xcoeff{0.f};
    float ycoeff{0.f};
    constexpr bool operator==(ViewportWScalingNV const& value) const {
        return xcoeff == value.xcoeff && ycoeff == value.ycoeff ;}
    constexpr bool operator!=(ViewportWScalingNV const& value) const {return !(*this == value);}
    ViewportWScalingNV& setXcoeff(float xcoeff_) {this->xcoeff = xcoeff_; return *this; }
    ViewportWScalingNV& setYcoeff(float ycoeff_) {this->ycoeff = ycoeff_; return *this; }
};
struct PipelineViewportWScalingStateCreateInfoNV {
    StructureType sType{StructureType::PipelineViewportWScalingStateCreateInfoNV};
    const void* pNext = nullptr;
    Bool32 viewportWScalingEnable{0};
    uint32_t viewportCount{0};
    const ViewportWScalingNV* pViewportWScalings = nullptr;
    PipelineViewportWScalingStateCreateInfoNV& setViewportWScalingEnable(Bool32 viewportWScalingEnable_) {this->viewportWScalingEnable = viewportWScalingEnable_; return *this; }
    PipelineViewportWScalingStateCreateInfoNV& setViewportCount(uint32_t viewportCount_) {this->viewportCount = viewportCount_; return *this; }
    PipelineViewportWScalingStateCreateInfoNV& setPViewportWScalings(const ViewportWScalingNV* pViewportWScalings_) {this->pViewportWScalings = pViewportWScalings_; return *this; }
    PipelineViewportWScalingStateCreateInfoNV& setPViewportWScalings(detail::span<const ViewportWScalingNV> pViewportWScalings_) {this->viewportCount = pViewportWScalings_.size(); this->pViewportWScalings = pViewportWScalings_.data();  return *this; }
};
struct ViewportSwizzleNV {
    ViewportCoordinateSwizzleNV x{static_cast<ViewportCoordinateSwizzleNV>(0)};
    ViewportCoordinateSwizzleNV y{static_cast<ViewportCoordinateSwizzleNV>(0)};
    ViewportCoordinateSwizzleNV z{static_cast<ViewportCoordinateSwizzleNV>(0)};
    ViewportCoordinateSwizzleNV w{static_cast<ViewportCoordinateSwizzleNV>(0)};
    constexpr bool operator==(ViewportSwizzleNV const& value) const {
        return x == value.x && y == value.y && z == value.z && w == value.w ;}
    constexpr bool operator!=(ViewportSwizzleNV const& value) const {return !(*this == value);}
    ViewportSwizzleNV& setX(ViewportCoordinateSwizzleNV x_) {this->x = x_; return *this; }
    ViewportSwizzleNV& setY(ViewportCoordinateSwizzleNV y_) {this->y = y_; return *this; }
    ViewportSwizzleNV& setZ(ViewportCoordinateSwizzleNV z_) {this->z = z_; return *this; }
    ViewportSwizzleNV& setW(ViewportCoordinateSwizzleNV w_) {this->w = w_; return *this; }
};
struct PipelineViewportSwizzleStateCreateInfoNV {
    StructureType sType{StructureType::PipelineViewportSwizzleStateCreateInfoNV};
    const void* pNext = nullptr;
    PipelineViewportSwizzleStateCreateFlagsNV flags{};
    uint32_t viewportCount{0};
    const ViewportSwizzleNV* pViewportSwizzles = nullptr;
    PipelineViewportSwizzleStateCreateInfoNV& setFlags(PipelineViewportSwizzleStateCreateFlagsNV flags_) {this->flags = flags_; return *this; }
    PipelineViewportSwizzleStateCreateInfoNV& setViewportCount(uint32_t viewportCount_) {this->viewportCount = viewportCount_; return *this; }
    PipelineViewportSwizzleStateCreateInfoNV& setPViewportSwizzles(const ViewportSwizzleNV* pViewportSwizzles_) {this->pViewportSwizzles = pViewportSwizzles_; return *this; }
    PipelineViewportSwizzleStateCreateInfoNV& setPViewportSwizzles(detail::span<const ViewportSwizzleNV> pViewportSwizzles_) {this->viewportCount = pViewportSwizzles_.size(); this->pViewportSwizzles = pViewportSwizzles_.data();  return *this; }
};
struct PhysicalDeviceDiscardRectanglePropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceDiscardRectanglePropertiesEXT};
    void* pNext = nullptr;
    uint32_t maxDiscardRectangles{0};
    PhysicalDeviceDiscardRectanglePropertiesEXT& setMaxDiscardRectangles(uint32_t maxDiscardRectangles_) {this->maxDiscardRectangles = maxDiscardRectangles_; return *this; }
};
struct PipelineDiscardRectangleStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineDiscardRectangleStateCreateInfoEXT};
    const void* pNext = nullptr;
    PipelineDiscardRectangleStateCreateFlagsEXT flags{};
    DiscardRectangleModeEXT discardRectangleMode{static_cast<DiscardRectangleModeEXT>(0)};
    uint32_t discardRectangleCount{0};
    const Rect2D* pDiscardRectangles = nullptr;
    PipelineDiscardRectangleStateCreateInfoEXT& setFlags(PipelineDiscardRectangleStateCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    PipelineDiscardRectangleStateCreateInfoEXT& setDiscardRectangleMode(DiscardRectangleModeEXT discardRectangleMode_) {this->discardRectangleMode = discardRectangleMode_; return *this; }
    PipelineDiscardRectangleStateCreateInfoEXT& setDiscardRectangleCount(uint32_t discardRectangleCount_) {this->discardRectangleCount = discardRectangleCount_; return *this; }
    PipelineDiscardRectangleStateCreateInfoEXT& setPDiscardRectangles(const Rect2D* pDiscardRectangles_) {this->pDiscardRectangles = pDiscardRectangles_; return *this; }
    PipelineDiscardRectangleStateCreateInfoEXT& setPDiscardRectangles(detail::span<const Rect2D> pDiscardRectangles_) {this->discardRectangleCount = pDiscardRectangles_.size(); this->pDiscardRectangles = pDiscardRectangles_.data();  return *this; }
};
struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    StructureType sType{StructureType::PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX};
    void* pNext = nullptr;
    Bool32 perViewPositionAllComponents{0};
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& setPerViewPositionAllComponents(Bool32 perViewPositionAllComponents_) {this->perViewPositionAllComponents = perViewPositionAllComponents_; return *this; }
};
struct InputAttachmentAspectReference {
    uint32_t subpass{0};
    uint32_t inputAttachmentIndex{0};
    ImageAspectFlags aspectMask{};
    constexpr bool operator==(InputAttachmentAspectReference const& value) const {
        return subpass == value.subpass && inputAttachmentIndex == value.inputAttachmentIndex && aspectMask == value.aspectMask ;}
    constexpr bool operator!=(InputAttachmentAspectReference const& value) const {return !(*this == value);}
    InputAttachmentAspectReference& setSubpass(uint32_t subpass_) {this->subpass = subpass_; return *this; }
    InputAttachmentAspectReference& setInputAttachmentIndex(uint32_t inputAttachmentIndex_) {this->inputAttachmentIndex = inputAttachmentIndex_; return *this; }
    InputAttachmentAspectReference& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
};
using InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
struct RenderPassInputAttachmentAspectCreateInfo {
    StructureType sType{StructureType::RenderPassInputAttachmentAspectCreateInfo};
    const void* pNext = nullptr;
    uint32_t aspectReferenceCount{0};
    const InputAttachmentAspectReference* pAspectReferences = nullptr;
    RenderPassInputAttachmentAspectCreateInfo& setAspectReferenceCount(uint32_t aspectReferenceCount_) {this->aspectReferenceCount = aspectReferenceCount_; return *this; }
    RenderPassInputAttachmentAspectCreateInfo& setPAspectReferences(const InputAttachmentAspectReference* pAspectReferences_) {this->pAspectReferences = pAspectReferences_; return *this; }
    RenderPassInputAttachmentAspectCreateInfo& setPAspectReferences(detail::span<const InputAttachmentAspectReference> pAspectReferences_) {this->aspectReferenceCount = pAspectReferences_.size(); this->pAspectReferences = pAspectReferences_.data();  return *this; }
};
using RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
struct PhysicalDeviceSurfaceInfo2KHR {
    StructureType sType{StructureType::PhysicalDeviceSurfaceInfo2KHR};
    const void* pNext = nullptr;
    SurfaceKHR surface{};
    PhysicalDeviceSurfaceInfo2KHR& setSurface(SurfaceKHR surface_) {this->surface = surface_; return *this; }
};
struct SurfaceCapabilities2KHR {
    StructureType sType{StructureType::SurfaceCapabilities2KHR};
    void* pNext = nullptr;
    SurfaceCapabilitiesKHR surfaceCapabilities{};
    SurfaceCapabilities2KHR& setSurfaceCapabilities(SurfaceCapabilitiesKHR surfaceCapabilities_) {this->surfaceCapabilities = surfaceCapabilities_; return *this; }
};
struct SurfaceFormat2KHR {
    StructureType sType{StructureType::SurfaceFormat2KHR};
    void* pNext = nullptr;
    SurfaceFormatKHR surfaceFormat{};
    SurfaceFormat2KHR& setSurfaceFormat(SurfaceFormatKHR surfaceFormat_) {this->surfaceFormat = surfaceFormat_; return *this; }
};
struct DisplayProperties2KHR {
    StructureType sType{StructureType::DisplayProperties2KHR};
    void* pNext = nullptr;
    DisplayPropertiesKHR displayProperties{};
    DisplayProperties2KHR& setDisplayProperties(DisplayPropertiesKHR displayProperties_) {this->displayProperties = displayProperties_; return *this; }
};
struct DisplayPlaneProperties2KHR {
    StructureType sType{StructureType::DisplayPlaneProperties2KHR};
    void* pNext = nullptr;
    DisplayPlanePropertiesKHR displayPlaneProperties{};
    DisplayPlaneProperties2KHR& setDisplayPlaneProperties(DisplayPlanePropertiesKHR displayPlaneProperties_) {this->displayPlaneProperties = displayPlaneProperties_; return *this; }
};
struct DisplayModeProperties2KHR {
    StructureType sType{StructureType::DisplayModeProperties2KHR};
    void* pNext = nullptr;
    DisplayModePropertiesKHR displayModeProperties{};
    DisplayModeProperties2KHR& setDisplayModeProperties(DisplayModePropertiesKHR displayModeProperties_) {this->displayModeProperties = displayModeProperties_; return *this; }
};
struct DisplayPlaneInfo2KHR {
    StructureType sType{StructureType::DisplayPlaneInfo2KHR};
    const void* pNext = nullptr;
    DisplayModeKHR mode{};
    uint32_t planeIndex{0};
    DisplayPlaneInfo2KHR& setMode(DisplayModeKHR mode_) {this->mode = mode_; return *this; }
    DisplayPlaneInfo2KHR& setPlaneIndex(uint32_t planeIndex_) {this->planeIndex = planeIndex_; return *this; }
};
struct DisplayPlaneCapabilities2KHR {
    StructureType sType{StructureType::DisplayPlaneCapabilities2KHR};
    void* pNext = nullptr;
    DisplayPlaneCapabilitiesKHR capabilities{};
    DisplayPlaneCapabilities2KHR& setCapabilities(DisplayPlaneCapabilitiesKHR capabilities_) {this->capabilities = capabilities_; return *this; }
};
struct SharedPresentSurfaceCapabilitiesKHR {
    StructureType sType{StructureType::SharedPresentSurfaceCapabilitiesKHR};
    void* pNext = nullptr;
    ImageUsageFlags sharedPresentSupportedUsageFlags{};
    SharedPresentSurfaceCapabilitiesKHR& setSharedPresentSupportedUsageFlags(ImageUsageFlags sharedPresentSupportedUsageFlags_) {this->sharedPresentSupportedUsageFlags = sharedPresentSupportedUsageFlags_; return *this; }
};
struct PhysicalDevice16BitStorageFeatures {
    StructureType sType{StructureType::PhysicalDevice16BitStorageFeatures};
    void* pNext = nullptr;
    Bool32 storageBuffer16BitAccess{0};
    Bool32 uniformAndStorageBuffer16BitAccess{0};
    Bool32 storagePushConstant16{0};
    Bool32 storageInputOutput16{0};
    PhysicalDevice16BitStorageFeatures& setStorageBuffer16BitAccess(Bool32 storageBuffer16BitAccess_) {this->storageBuffer16BitAccess = storageBuffer16BitAccess_; return *this; }
    PhysicalDevice16BitStorageFeatures& setUniformAndStorageBuffer16BitAccess(Bool32 uniformAndStorageBuffer16BitAccess_) {this->uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess_; return *this; }
    PhysicalDevice16BitStorageFeatures& setStoragePushConstant16(Bool32 storagePushConstant16_) {this->storagePushConstant16 = storagePushConstant16_; return *this; }
    PhysicalDevice16BitStorageFeatures& setStorageInputOutput16(Bool32 storageInputOutput16_) {this->storageInputOutput16 = storageInputOutput16_; return *this; }
};
using PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
struct PhysicalDeviceSubgroupProperties {
    StructureType sType{StructureType::PhysicalDeviceSubgroupProperties};
    void* pNext = nullptr;
    uint32_t subgroupSize{0};
    ShaderStageFlags supportedStages{};
    SubgroupFeatureFlags supportedOperations{};
    Bool32 quadOperationsInAllStages{0};
    PhysicalDeviceSubgroupProperties& setSubgroupSize(uint32_t subgroupSize_) {this->subgroupSize = subgroupSize_; return *this; }
    PhysicalDeviceSubgroupProperties& setSupportedStages(ShaderStageFlags supportedStages_) {this->supportedStages = supportedStages_; return *this; }
    PhysicalDeviceSubgroupProperties& setSupportedOperations(SubgroupFeatureFlags supportedOperations_) {this->supportedOperations = supportedOperations_; return *this; }
    PhysicalDeviceSubgroupProperties& setQuadOperationsInAllStages(Bool32 quadOperationsInAllStages_) {this->quadOperationsInAllStages = quadOperationsInAllStages_; return *this; }
};
struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    StructureType sType{StructureType::PhysicalDeviceShaderSubgroupExtendedTypesFeatures};
    void* pNext = nullptr;
    Bool32 shaderSubgroupExtendedTypes{0};
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures& setShaderSubgroupExtendedTypes(Bool32 shaderSubgroupExtendedTypes_) {this->shaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes_; return *this; }
};
using PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
struct BufferMemoryRequirementsInfo2 {
    StructureType sType{StructureType::BufferMemoryRequirementsInfo2};
    const void* pNext = nullptr;
    Buffer buffer{};
    BufferMemoryRequirementsInfo2& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
};
using BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
struct ImageMemoryRequirementsInfo2 {
    StructureType sType{StructureType::ImageMemoryRequirementsInfo2};
    const void* pNext = nullptr;
    Image image{};
    ImageMemoryRequirementsInfo2& setImage(Image image_) {this->image = image_; return *this; }
};
using ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
struct ImageSparseMemoryRequirementsInfo2 {
    StructureType sType{StructureType::ImageSparseMemoryRequirementsInfo2};
    const void* pNext = nullptr;
    Image image{};
    ImageSparseMemoryRequirementsInfo2& setImage(Image image_) {this->image = image_; return *this; }
};
using ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
struct MemoryRequirements2 {
    StructureType sType{StructureType::MemoryRequirements2};
    void* pNext = nullptr;
    MemoryRequirements memoryRequirements{};
    MemoryRequirements2& setMemoryRequirements(MemoryRequirements memoryRequirements_) {this->memoryRequirements = memoryRequirements_; return *this; }
};
using MemoryRequirements2KHR = MemoryRequirements2;
struct SparseImageMemoryRequirements2 {
    StructureType sType{StructureType::SparseImageMemoryRequirements2};
    void* pNext = nullptr;
    SparseImageMemoryRequirements memoryRequirements{};
    SparseImageMemoryRequirements2& setMemoryRequirements(SparseImageMemoryRequirements memoryRequirements_) {this->memoryRequirements = memoryRequirements_; return *this; }
};
using SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
struct PhysicalDevicePointClippingProperties {
    StructureType sType{StructureType::PhysicalDevicePointClippingProperties};
    void* pNext = nullptr;
    PointClippingBehavior pointClippingBehavior{static_cast<PointClippingBehavior>(0)};
    PhysicalDevicePointClippingProperties& setPointClippingBehavior(PointClippingBehavior pointClippingBehavior_) {this->pointClippingBehavior = pointClippingBehavior_; return *this; }
};
using PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
struct MemoryDedicatedRequirements {
    StructureType sType{StructureType::MemoryDedicatedRequirements};
    void* pNext = nullptr;
    Bool32 prefersDedicatedAllocation{0};
    Bool32 requiresDedicatedAllocation{0};
    MemoryDedicatedRequirements& setPrefersDedicatedAllocation(Bool32 prefersDedicatedAllocation_) {this->prefersDedicatedAllocation = prefersDedicatedAllocation_; return *this; }
    MemoryDedicatedRequirements& setRequiresDedicatedAllocation(Bool32 requiresDedicatedAllocation_) {this->requiresDedicatedAllocation = requiresDedicatedAllocation_; return *this; }
};
using MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
struct MemoryDedicatedAllocateInfo {
    StructureType sType{StructureType::MemoryDedicatedAllocateInfo};
    const void* pNext = nullptr;
    Image image{};
    Buffer buffer{};
    MemoryDedicatedAllocateInfo& setImage(Image image_) {this->image = image_; return *this; }
    MemoryDedicatedAllocateInfo& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
};
using MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
struct ImageViewUsageCreateInfo {
    StructureType sType{StructureType::ImageViewUsageCreateInfo};
    const void* pNext = nullptr;
    ImageUsageFlags usage{};
    ImageViewUsageCreateInfo& setUsage(ImageUsageFlags usage_) {this->usage = usage_; return *this; }
};
using ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
struct PipelineTessellationDomainOriginStateCreateInfo {
    StructureType sType{StructureType::PipelineTessellationDomainOriginStateCreateInfo};
    const void* pNext = nullptr;
    TessellationDomainOrigin domainOrigin{static_cast<TessellationDomainOrigin>(0)};
    PipelineTessellationDomainOriginStateCreateInfo& setDomainOrigin(TessellationDomainOrigin domainOrigin_) {this->domainOrigin = domainOrigin_; return *this; }
};
using PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
struct SamplerYcbcrConversionInfo {
    StructureType sType{StructureType::SamplerYcbcrConversionInfo};
    const void* pNext = nullptr;
    SamplerYcbcrConversion conversion{};
    SamplerYcbcrConversionInfo& setConversion(SamplerYcbcrConversion conversion_) {this->conversion = conversion_; return *this; }
};
using SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
struct SamplerYcbcrConversionCreateInfo {
    StructureType sType{StructureType::SamplerYcbcrConversionCreateInfo};
    const void* pNext = nullptr;
    Format format{static_cast<Format>(0)};
    SamplerYcbcrModelConversion ycbcrModel{static_cast<SamplerYcbcrModelConversion>(0)};
    SamplerYcbcrRange ycbcrRange{static_cast<SamplerYcbcrRange>(0)};
    ComponentMapping components{};
    ChromaLocation xChromaOffset{static_cast<ChromaLocation>(0)};
    ChromaLocation yChromaOffset{static_cast<ChromaLocation>(0)};
    Filter chromaFilter{static_cast<Filter>(0)};
    Bool32 forceExplicitReconstruction{0};
    SamplerYcbcrConversionCreateInfo& setFormat(Format format_) {this->format = format_; return *this; }
    SamplerYcbcrConversionCreateInfo& setYcbcrModel(SamplerYcbcrModelConversion ycbcrModel_) {this->ycbcrModel = ycbcrModel_; return *this; }
    SamplerYcbcrConversionCreateInfo& setYcbcrRange(SamplerYcbcrRange ycbcrRange_) {this->ycbcrRange = ycbcrRange_; return *this; }
    SamplerYcbcrConversionCreateInfo& setComponents(ComponentMapping components_) {this->components = components_; return *this; }
    SamplerYcbcrConversionCreateInfo& setXChromaOffset(ChromaLocation xChromaOffset_) {this->xChromaOffset = xChromaOffset_; return *this; }
    SamplerYcbcrConversionCreateInfo& setYChromaOffset(ChromaLocation yChromaOffset_) {this->yChromaOffset = yChromaOffset_; return *this; }
    SamplerYcbcrConversionCreateInfo& setChromaFilter(Filter chromaFilter_) {this->chromaFilter = chromaFilter_; return *this; }
    SamplerYcbcrConversionCreateInfo& setForceExplicitReconstruction(Bool32 forceExplicitReconstruction_) {this->forceExplicitReconstruction = forceExplicitReconstruction_; return *this; }
};
using SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
struct BindImagePlaneMemoryInfo {
    StructureType sType{StructureType::BindImagePlaneMemoryInfo};
    const void* pNext = nullptr;
    ImageAspectFlagBits planeAspect{static_cast<ImageAspectFlagBits>(0)};
    BindImagePlaneMemoryInfo& setPlaneAspect(ImageAspectFlagBits planeAspect_) {this->planeAspect = planeAspect_; return *this; }
};
using BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
struct ImagePlaneMemoryRequirementsInfo {
    StructureType sType{StructureType::ImagePlaneMemoryRequirementsInfo};
    const void* pNext = nullptr;
    ImageAspectFlagBits planeAspect{static_cast<ImageAspectFlagBits>(0)};
    ImagePlaneMemoryRequirementsInfo& setPlaneAspect(ImageAspectFlagBits planeAspect_) {this->planeAspect = planeAspect_; return *this; }
};
using ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    StructureType sType{StructureType::PhysicalDeviceSamplerYcbcrConversionFeatures};
    void* pNext = nullptr;
    Bool32 samplerYcbcrConversion{0};
    PhysicalDeviceSamplerYcbcrConversionFeatures& setSamplerYcbcrConversion(Bool32 samplerYcbcrConversion_) {this->samplerYcbcrConversion = samplerYcbcrConversion_; return *this; }
};
using PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
struct SamplerYcbcrConversionImageFormatProperties {
    StructureType sType{StructureType::SamplerYcbcrConversionImageFormatProperties};
    void* pNext = nullptr;
    uint32_t combinedImageSamplerDescriptorCount{0};
    SamplerYcbcrConversionImageFormatProperties& setCombinedImageSamplerDescriptorCount(uint32_t combinedImageSamplerDescriptorCount_) {this->combinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount_; return *this; }
};
using SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
struct TextureLODGatherFormatPropertiesAMD {
    StructureType sType{StructureType::TextureLodGatherFormatPropertiesAMD};
    void* pNext = nullptr;
    Bool32 supportsTextureGatherLODBiasAMD{0};
    TextureLODGatherFormatPropertiesAMD& setSupportsTextureGatherLODBiasAMD(Bool32 supportsTextureGatherLODBiasAMD_) {this->supportsTextureGatherLODBiasAMD = supportsTextureGatherLODBiasAMD_; return *this; }
};
struct ConditionalRenderingBeginInfoEXT {
    StructureType sType{StructureType::ConditionalRenderingBeginInfoEXT};
    const void* pNext = nullptr;
    Buffer buffer{};
    DeviceSize offset{0};
    ConditionalRenderingFlagsEXT flags{};
    ConditionalRenderingBeginInfoEXT& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    ConditionalRenderingBeginInfoEXT& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    ConditionalRenderingBeginInfoEXT& setFlags(ConditionalRenderingFlagsEXT flags_) {this->flags = flags_; return *this; }
};
struct ProtectedSubmitInfo {
    StructureType sType{StructureType::ProtectedSubmitInfo};
    const void* pNext = nullptr;
    Bool32 protectedSubmit{0};
    ProtectedSubmitInfo& setProtectedSubmit(Bool32 protectedSubmit_) {this->protectedSubmit = protectedSubmit_; return *this; }
};
struct PhysicalDeviceProtectedMemoryFeatures {
    StructureType sType{StructureType::PhysicalDeviceProtectedMemoryFeatures};
    void* pNext = nullptr;
    Bool32 protectedMemory{0};
    PhysicalDeviceProtectedMemoryFeatures& setProtectedMemory(Bool32 protectedMemory_) {this->protectedMemory = protectedMemory_; return *this; }
};
struct PhysicalDeviceProtectedMemoryProperties {
    StructureType sType{StructureType::PhysicalDeviceProtectedMemoryProperties};
    void* pNext = nullptr;
    Bool32 protectedNoFault{0};
    PhysicalDeviceProtectedMemoryProperties& setProtectedNoFault(Bool32 protectedNoFault_) {this->protectedNoFault = protectedNoFault_; return *this; }
};
struct DeviceQueueInfo2 {
    StructureType sType{StructureType::DeviceQueueInfo2};
    const void* pNext = nullptr;
    DeviceQueueCreateFlags flags{};
    uint32_t queueFamilyIndex{0};
    uint32_t queueIndex{0};
    DeviceQueueInfo2& setFlags(DeviceQueueCreateFlags flags_) {this->flags = flags_; return *this; }
    DeviceQueueInfo2& setQueueFamilyIndex(uint32_t queueFamilyIndex_) {this->queueFamilyIndex = queueFamilyIndex_; return *this; }
    DeviceQueueInfo2& setQueueIndex(uint32_t queueIndex_) {this->queueIndex = queueIndex_; return *this; }
};
struct PipelineCoverageToColorStateCreateInfoNV {
    StructureType sType{StructureType::PipelineCoverageToColorStateCreateInfoNV};
    const void* pNext = nullptr;
    PipelineCoverageToColorStateCreateFlagsNV flags{};
    Bool32 coverageToColorEnable{0};
    uint32_t coverageToColorLocation{0};
    PipelineCoverageToColorStateCreateInfoNV& setFlags(PipelineCoverageToColorStateCreateFlagsNV flags_) {this->flags = flags_; return *this; }
    PipelineCoverageToColorStateCreateInfoNV& setCoverageToColorEnable(Bool32 coverageToColorEnable_) {this->coverageToColorEnable = coverageToColorEnable_; return *this; }
    PipelineCoverageToColorStateCreateInfoNV& setCoverageToColorLocation(uint32_t coverageToColorLocation_) {this->coverageToColorLocation = coverageToColorLocation_; return *this; }
};
struct PhysicalDeviceSamplerFilterMinmaxProperties {
    StructureType sType{StructureType::PhysicalDeviceSamplerFilterMinmaxProperties};
    void* pNext = nullptr;
    Bool32 filterMinmaxSingleComponentFormats{0};
    Bool32 filterMinmaxImageComponentMapping{0};
    PhysicalDeviceSamplerFilterMinmaxProperties& setFilterMinmaxSingleComponentFormats(Bool32 filterMinmaxSingleComponentFormats_) {this->filterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats_; return *this; }
    PhysicalDeviceSamplerFilterMinmaxProperties& setFilterMinmaxImageComponentMapping(Bool32 filterMinmaxImageComponentMapping_) {this->filterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping_; return *this; }
};
using PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
struct SampleLocationEXT {
    float x{0.f};
    float y{0.f};
    constexpr bool operator==(SampleLocationEXT const& value) const {
        return x == value.x && y == value.y ;}
    constexpr bool operator!=(SampleLocationEXT const& value) const {return !(*this == value);}
    SampleLocationEXT& setX(float x_) {this->x = x_; return *this; }
    SampleLocationEXT& setY(float y_) {this->y = y_; return *this; }
};
struct SampleLocationsInfoEXT {
    StructureType sType{StructureType::SampleLocationsInfoEXT};
    const void* pNext = nullptr;
    SampleCountFlagBits sampleLocationsPerPixel{static_cast<SampleCountFlagBits>(0)};
    Extent2D sampleLocationGridSize{};
    uint32_t sampleLocationsCount{0};
    const SampleLocationEXT* pSampleLocations = nullptr;
    SampleLocationsInfoEXT& setSampleLocationsPerPixel(SampleCountFlagBits sampleLocationsPerPixel_) {this->sampleLocationsPerPixel = sampleLocationsPerPixel_; return *this; }
    SampleLocationsInfoEXT& setSampleLocationGridSize(Extent2D sampleLocationGridSize_) {this->sampleLocationGridSize = sampleLocationGridSize_; return *this; }
    SampleLocationsInfoEXT& setSampleLocationsCount(uint32_t sampleLocationsCount_) {this->sampleLocationsCount = sampleLocationsCount_; return *this; }
    SampleLocationsInfoEXT& setPSampleLocations(const SampleLocationEXT* pSampleLocations_) {this->pSampleLocations = pSampleLocations_; return *this; }
    SampleLocationsInfoEXT& setPSampleLocations(detail::span<const SampleLocationEXT> pSampleLocations_) {this->sampleLocationsCount = pSampleLocations_.size(); this->pSampleLocations = pSampleLocations_.data();  return *this; }
};
struct AttachmentSampleLocationsEXT {
    uint32_t attachmentIndex{0};
    SampleLocationsInfoEXT sampleLocationsInfo{};
    AttachmentSampleLocationsEXT& setAttachmentIndex(uint32_t attachmentIndex_) {this->attachmentIndex = attachmentIndex_; return *this; }
    AttachmentSampleLocationsEXT& setSampleLocationsInfo(SampleLocationsInfoEXT sampleLocationsInfo_) {this->sampleLocationsInfo = sampleLocationsInfo_; return *this; }
};
struct SubpassSampleLocationsEXT {
    uint32_t subpassIndex{0};
    SampleLocationsInfoEXT sampleLocationsInfo{};
    SubpassSampleLocationsEXT& setSubpassIndex(uint32_t subpassIndex_) {this->subpassIndex = subpassIndex_; return *this; }
    SubpassSampleLocationsEXT& setSampleLocationsInfo(SampleLocationsInfoEXT sampleLocationsInfo_) {this->sampleLocationsInfo = sampleLocationsInfo_; return *this; }
};
struct RenderPassSampleLocationsBeginInfoEXT {
    StructureType sType{StructureType::RenderPassSampleLocationsBeginInfoEXT};
    const void* pNext = nullptr;
    uint32_t attachmentInitialSampleLocationsCount{0};
    const AttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations = nullptr;
    uint32_t postSubpassSampleLocationsCount{0};
    const SubpassSampleLocationsEXT* pPostSubpassSampleLocations = nullptr;
    RenderPassSampleLocationsBeginInfoEXT& setAttachmentInitialSampleLocationsCount(uint32_t attachmentInitialSampleLocationsCount_) {this->attachmentInitialSampleLocationsCount = attachmentInitialSampleLocationsCount_; return *this; }
    RenderPassSampleLocationsBeginInfoEXT& setPAttachmentInitialSampleLocations(const AttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations_) {this->pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations_; return *this; }
    RenderPassSampleLocationsBeginInfoEXT& setPAttachmentInitialSampleLocations(detail::span<const AttachmentSampleLocationsEXT> pAttachmentInitialSampleLocations_) {this->attachmentInitialSampleLocationsCount = pAttachmentInitialSampleLocations_.size(); this->pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations_.data();  return *this; }
    RenderPassSampleLocationsBeginInfoEXT& setPostSubpassSampleLocationsCount(uint32_t postSubpassSampleLocationsCount_) {this->postSubpassSampleLocationsCount = postSubpassSampleLocationsCount_; return *this; }
    RenderPassSampleLocationsBeginInfoEXT& setPPostSubpassSampleLocations(const SubpassSampleLocationsEXT* pPostSubpassSampleLocations_) {this->pPostSubpassSampleLocations = pPostSubpassSampleLocations_; return *this; }
    RenderPassSampleLocationsBeginInfoEXT& setPPostSubpassSampleLocations(detail::span<const SubpassSampleLocationsEXT> pPostSubpassSampleLocations_) {this->postSubpassSampleLocationsCount = pPostSubpassSampleLocations_.size(); this->pPostSubpassSampleLocations = pPostSubpassSampleLocations_.data();  return *this; }
};
struct PipelineSampleLocationsStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineSampleLocationsStateCreateInfoEXT};
    const void* pNext = nullptr;
    Bool32 sampleLocationsEnable{0};
    SampleLocationsInfoEXT sampleLocationsInfo{};
    PipelineSampleLocationsStateCreateInfoEXT& setSampleLocationsEnable(Bool32 sampleLocationsEnable_) {this->sampleLocationsEnable = sampleLocationsEnable_; return *this; }
    PipelineSampleLocationsStateCreateInfoEXT& setSampleLocationsInfo(SampleLocationsInfoEXT sampleLocationsInfo_) {this->sampleLocationsInfo = sampleLocationsInfo_; return *this; }
};
struct PhysicalDeviceSampleLocationsPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceSampleLocationsPropertiesEXT};
    void* pNext = nullptr;
    SampleCountFlags sampleLocationSampleCounts{};
    Extent2D maxSampleLocationGridSize{};
    float sampleLocationCoordinateRange[2];
    uint32_t sampleLocationSubPixelBits{0};
    Bool32 variableSampleLocations{0};
    PhysicalDeviceSampleLocationsPropertiesEXT& setSampleLocationSampleCounts(SampleCountFlags sampleLocationSampleCounts_) {this->sampleLocationSampleCounts = sampleLocationSampleCounts_; return *this; }
    PhysicalDeviceSampleLocationsPropertiesEXT& setMaxSampleLocationGridSize(Extent2D maxSampleLocationGridSize_) {this->maxSampleLocationGridSize = maxSampleLocationGridSize_; return *this; }
    PhysicalDeviceSampleLocationsPropertiesEXT& setSampleLocationCoordinateRange(float sampleLocationCoordinateRange_[2]) {for(uint32_t i = 0; i < 2; i++) this->sampleLocationCoordinateRange[i] = sampleLocationCoordinateRange_[i]; return *this; }
    PhysicalDeviceSampleLocationsPropertiesEXT& setSampleLocationSubPixelBits(uint32_t sampleLocationSubPixelBits_) {this->sampleLocationSubPixelBits = sampleLocationSubPixelBits_; return *this; }
    PhysicalDeviceSampleLocationsPropertiesEXT& setVariableSampleLocations(Bool32 variableSampleLocations_) {this->variableSampleLocations = variableSampleLocations_; return *this; }
};
struct MultisamplePropertiesEXT {
    StructureType sType{StructureType::MultisamplePropertiesEXT};
    void* pNext = nullptr;
    Extent2D maxSampleLocationGridSize{};
    MultisamplePropertiesEXT& setMaxSampleLocationGridSize(Extent2D maxSampleLocationGridSize_) {this->maxSampleLocationGridSize = maxSampleLocationGridSize_; return *this; }
};
struct SamplerReductionModeCreateInfo {
    StructureType sType{StructureType::SamplerReductionModeCreateInfo};
    const void* pNext = nullptr;
    SamplerReductionMode reductionMode{static_cast<SamplerReductionMode>(0)};
    SamplerReductionModeCreateInfo& setReductionMode(SamplerReductionMode reductionMode_) {this->reductionMode = reductionMode_; return *this; }
};
using SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceBlendOperationAdvancedFeaturesEXT};
    void* pNext = nullptr;
    Bool32 advancedBlendCoherentOperations{0};
    PhysicalDeviceBlendOperationAdvancedFeaturesEXT& setAdvancedBlendCoherentOperations(Bool32 advancedBlendCoherentOperations_) {this->advancedBlendCoherentOperations = advancedBlendCoherentOperations_; return *this; }
};
struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceBlendOperationAdvancedPropertiesEXT};
    void* pNext = nullptr;
    uint32_t advancedBlendMaxColorAttachments{0};
    Bool32 advancedBlendIndependentBlend{0};
    Bool32 advancedBlendNonPremultipliedSrcColor{0};
    Bool32 advancedBlendNonPremultipliedDstColor{0};
    Bool32 advancedBlendCorrelatedOverlap{0};
    Bool32 advancedBlendAllOperations{0};
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT& setAdvancedBlendMaxColorAttachments(uint32_t advancedBlendMaxColorAttachments_) {this->advancedBlendMaxColorAttachments = advancedBlendMaxColorAttachments_; return *this; }
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT& setAdvancedBlendIndependentBlend(Bool32 advancedBlendIndependentBlend_) {this->advancedBlendIndependentBlend = advancedBlendIndependentBlend_; return *this; }
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT& setAdvancedBlendNonPremultipliedSrcColor(Bool32 advancedBlendNonPremultipliedSrcColor_) {this->advancedBlendNonPremultipliedSrcColor = advancedBlendNonPremultipliedSrcColor_; return *this; }
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT& setAdvancedBlendNonPremultipliedDstColor(Bool32 advancedBlendNonPremultipliedDstColor_) {this->advancedBlendNonPremultipliedDstColor = advancedBlendNonPremultipliedDstColor_; return *this; }
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT& setAdvancedBlendCorrelatedOverlap(Bool32 advancedBlendCorrelatedOverlap_) {this->advancedBlendCorrelatedOverlap = advancedBlendCorrelatedOverlap_; return *this; }
    PhysicalDeviceBlendOperationAdvancedPropertiesEXT& setAdvancedBlendAllOperations(Bool32 advancedBlendAllOperations_) {this->advancedBlendAllOperations = advancedBlendAllOperations_; return *this; }
};
struct PipelineColorBlendAdvancedStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineColorBlendAdvancedStateCreateInfoEXT};
    const void* pNext = nullptr;
    Bool32 srcPremultiplied{0};
    Bool32 dstPremultiplied{0};
    BlendOverlapEXT blendOverlap{static_cast<BlendOverlapEXT>(0)};
    PipelineColorBlendAdvancedStateCreateInfoEXT& setSrcPremultiplied(Bool32 srcPremultiplied_) {this->srcPremultiplied = srcPremultiplied_; return *this; }
    PipelineColorBlendAdvancedStateCreateInfoEXT& setDstPremultiplied(Bool32 dstPremultiplied_) {this->dstPremultiplied = dstPremultiplied_; return *this; }
    PipelineColorBlendAdvancedStateCreateInfoEXT& setBlendOverlap(BlendOverlapEXT blendOverlap_) {this->blendOverlap = blendOverlap_; return *this; }
};
struct PhysicalDeviceInlineUniformBlockFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceInlineUniformBlockFeaturesEXT};
    void* pNext = nullptr;
    Bool32 inlineUniformBlock{0};
    Bool32 descriptorBindingInlineUniformBlockUpdateAfterBind{0};
    PhysicalDeviceInlineUniformBlockFeaturesEXT& setInlineUniformBlock(Bool32 inlineUniformBlock_) {this->inlineUniformBlock = inlineUniformBlock_; return *this; }
    PhysicalDeviceInlineUniformBlockFeaturesEXT& setDescriptorBindingInlineUniformBlockUpdateAfterBind(Bool32 descriptorBindingInlineUniformBlockUpdateAfterBind_) {this->descriptorBindingInlineUniformBlockUpdateAfterBind = descriptorBindingInlineUniformBlockUpdateAfterBind_; return *this; }
};
struct PhysicalDeviceInlineUniformBlockPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceInlineUniformBlockPropertiesEXT};
    void* pNext = nullptr;
    uint32_t maxInlineUniformBlockSize{0};
    uint32_t maxPerStageDescriptorInlineUniformBlocks{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks{0};
    uint32_t maxDescriptorSetInlineUniformBlocks{0};
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks{0};
    PhysicalDeviceInlineUniformBlockPropertiesEXT& setMaxInlineUniformBlockSize(uint32_t maxInlineUniformBlockSize_) {this->maxInlineUniformBlockSize = maxInlineUniformBlockSize_; return *this; }
    PhysicalDeviceInlineUniformBlockPropertiesEXT& setMaxPerStageDescriptorInlineUniformBlocks(uint32_t maxPerStageDescriptorInlineUniformBlocks_) {this->maxPerStageDescriptorInlineUniformBlocks = maxPerStageDescriptorInlineUniformBlocks_; return *this; }
    PhysicalDeviceInlineUniformBlockPropertiesEXT& setMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks(uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_) {this->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_; return *this; }
    PhysicalDeviceInlineUniformBlockPropertiesEXT& setMaxDescriptorSetInlineUniformBlocks(uint32_t maxDescriptorSetInlineUniformBlocks_) {this->maxDescriptorSetInlineUniformBlocks = maxDescriptorSetInlineUniformBlocks_; return *this; }
    PhysicalDeviceInlineUniformBlockPropertiesEXT& setMaxDescriptorSetUpdateAfterBindInlineUniformBlocks(uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks_) {this->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = maxDescriptorSetUpdateAfterBindInlineUniformBlocks_; return *this; }
};
struct WriteDescriptorSetInlineUniformBlockEXT {
    StructureType sType{StructureType::WriteDescriptorSetInlineUniformBlockEXT};
    const void* pNext = nullptr;
    uint32_t dataSize{0};
    const void* pData = nullptr;
    WriteDescriptorSetInlineUniformBlockEXT& setDataSize(uint32_t dataSize_) {this->dataSize = dataSize_; return *this; }
    WriteDescriptorSetInlineUniformBlockEXT& setPData(const void* pData_) {this->pData = pData_; return *this; }
    WriteDescriptorSetInlineUniformBlockEXT& setPData(detail::span<const std::byte> pData_) {this->dataSize = pData_.size(); this->pData = pData_.data();  return *this; }
};
struct DescriptorPoolInlineUniformBlockCreateInfoEXT {
    StructureType sType{StructureType::DescriptorPoolInlineUniformBlockCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t maxInlineUniformBlockBindings{0};
    DescriptorPoolInlineUniformBlockCreateInfoEXT& setMaxInlineUniformBlockBindings(uint32_t maxInlineUniformBlockBindings_) {this->maxInlineUniformBlockBindings = maxInlineUniformBlockBindings_; return *this; }
};
struct PipelineCoverageModulationStateCreateInfoNV {
    StructureType sType{StructureType::PipelineCoverageModulationStateCreateInfoNV};
    const void* pNext = nullptr;
    PipelineCoverageModulationStateCreateFlagsNV flags{};
    CoverageModulationModeNV coverageModulationMode{static_cast<CoverageModulationModeNV>(0)};
    Bool32 coverageModulationTableEnable{0};
    uint32_t coverageModulationTableCount{0};
    const float* pCoverageModulationTable = nullptr;
    PipelineCoverageModulationStateCreateInfoNV& setFlags(PipelineCoverageModulationStateCreateFlagsNV flags_) {this->flags = flags_; return *this; }
    PipelineCoverageModulationStateCreateInfoNV& setCoverageModulationMode(CoverageModulationModeNV coverageModulationMode_) {this->coverageModulationMode = coverageModulationMode_; return *this; }
    PipelineCoverageModulationStateCreateInfoNV& setCoverageModulationTableEnable(Bool32 coverageModulationTableEnable_) {this->coverageModulationTableEnable = coverageModulationTableEnable_; return *this; }
    PipelineCoverageModulationStateCreateInfoNV& setCoverageModulationTableCount(uint32_t coverageModulationTableCount_) {this->coverageModulationTableCount = coverageModulationTableCount_; return *this; }
    PipelineCoverageModulationStateCreateInfoNV& setPCoverageModulationTable(const float* pCoverageModulationTable_) {this->pCoverageModulationTable = pCoverageModulationTable_; return *this; }
    PipelineCoverageModulationStateCreateInfoNV& setPCoverageModulationTable(detail::span<const float> pCoverageModulationTable_) {this->coverageModulationTableCount = pCoverageModulationTable_.size(); this->pCoverageModulationTable = pCoverageModulationTable_.data();  return *this; }
};
struct ImageFormatListCreateInfo {
    StructureType sType{StructureType::ImageFormatListCreateInfo};
    const void* pNext = nullptr;
    uint32_t viewFormatCount{0};
    const Format* pViewFormats = nullptr;
    ImageFormatListCreateInfo& setViewFormatCount(uint32_t viewFormatCount_) {this->viewFormatCount = viewFormatCount_; return *this; }
    ImageFormatListCreateInfo& setPViewFormats(const Format* pViewFormats_) {this->pViewFormats = pViewFormats_; return *this; }
    ImageFormatListCreateInfo& setPViewFormats(detail::span<const Format> pViewFormats_) {this->viewFormatCount = pViewFormats_.size(); this->pViewFormats = pViewFormats_.data();  return *this; }
};
using ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
struct ValidationCacheCreateInfoEXT {
    StructureType sType{StructureType::ValidationCacheCreateInfoEXT};
    const void* pNext = nullptr;
    ValidationCacheCreateFlagsEXT flags{};
    size_t initialDataSize{0};
    const void* pInitialData = nullptr;
    ValidationCacheCreateInfoEXT& setFlags(ValidationCacheCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    ValidationCacheCreateInfoEXT& setInitialDataSize(size_t initialDataSize_) {this->initialDataSize = initialDataSize_; return *this; }
    ValidationCacheCreateInfoEXT& setPInitialData(const void* pInitialData_) {this->pInitialData = pInitialData_; return *this; }
    ValidationCacheCreateInfoEXT& setPInitialData(detail::span<const std::byte> pInitialData_) {this->initialDataSize = pInitialData_.size(); this->pInitialData = pInitialData_.data();  return *this; }
};
struct ShaderModuleValidationCacheCreateInfoEXT {
    StructureType sType{StructureType::ShaderModuleValidationCacheCreateInfoEXT};
    const void* pNext = nullptr;
    ValidationCacheEXT validationCache{};
    ShaderModuleValidationCacheCreateInfoEXT& setValidationCache(ValidationCacheEXT validationCache_) {this->validationCache = validationCache_; return *this; }
};
struct PhysicalDeviceMaintenance3Properties {
    StructureType sType{StructureType::PhysicalDeviceMaintenance3Properties};
    void* pNext = nullptr;
    uint32_t maxPerSetDescriptors{0};
    DeviceSize maxMemoryAllocationSize{0};
    PhysicalDeviceMaintenance3Properties& setMaxPerSetDescriptors(uint32_t maxPerSetDescriptors_) {this->maxPerSetDescriptors = maxPerSetDescriptors_; return *this; }
    PhysicalDeviceMaintenance3Properties& setMaxMemoryAllocationSize(DeviceSize maxMemoryAllocationSize_) {this->maxMemoryAllocationSize = maxMemoryAllocationSize_; return *this; }
};
using PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
struct DescriptorSetLayoutSupport {
    StructureType sType{StructureType::DescriptorSetLayoutSupport};
    void* pNext = nullptr;
    Bool32 supported{0};
    DescriptorSetLayoutSupport& setSupported(Bool32 supported_) {this->supported = supported_; return *this; }
};
using DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
struct PhysicalDeviceShaderDrawParametersFeatures {
    StructureType sType{StructureType::PhysicalDeviceShaderDrawParametersFeatures};
    void* pNext = nullptr;
    Bool32 shaderDrawParameters{0};
    PhysicalDeviceShaderDrawParametersFeatures& setShaderDrawParameters(Bool32 shaderDrawParameters_) {this->shaderDrawParameters = shaderDrawParameters_; return *this; }
};
using PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;
struct PhysicalDeviceShaderFloat16Int8Features {
    StructureType sType{StructureType::PhysicalDeviceShaderFloat16Int8Features};
    void* pNext = nullptr;
    Bool32 shaderFloat16{0};
    Bool32 shaderInt8{0};
    PhysicalDeviceShaderFloat16Int8Features& setShaderFloat16(Bool32 shaderFloat16_) {this->shaderFloat16 = shaderFloat16_; return *this; }
    PhysicalDeviceShaderFloat16Int8Features& setShaderInt8(Bool32 shaderInt8_) {this->shaderInt8 = shaderInt8_; return *this; }
};
using PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
using PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
struct PhysicalDeviceFloatControlsProperties {
    StructureType sType{StructureType::PhysicalDeviceFloatControlsProperties};
    void* pNext = nullptr;
    ShaderFloatControlsIndependence denormBehaviorIndependence{static_cast<ShaderFloatControlsIndependence>(0)};
    ShaderFloatControlsIndependence roundingModeIndependence{static_cast<ShaderFloatControlsIndependence>(0)};
    Bool32 shaderSignedZeroInfNanPreserveFloat16{0};
    Bool32 shaderSignedZeroInfNanPreserveFloat32{0};
    Bool32 shaderSignedZeroInfNanPreserveFloat64{0};
    Bool32 shaderDenormPreserveFloat16{0};
    Bool32 shaderDenormPreserveFloat32{0};
    Bool32 shaderDenormPreserveFloat64{0};
    Bool32 shaderDenormFlushToZeroFloat16{0};
    Bool32 shaderDenormFlushToZeroFloat32{0};
    Bool32 shaderDenormFlushToZeroFloat64{0};
    Bool32 shaderRoundingModeRTEFloat16{0};
    Bool32 shaderRoundingModeRTEFloat32{0};
    Bool32 shaderRoundingModeRTEFloat64{0};
    Bool32 shaderRoundingModeRTZFloat16{0};
    Bool32 shaderRoundingModeRTZFloat32{0};
    Bool32 shaderRoundingModeRTZFloat64{0};
    PhysicalDeviceFloatControlsProperties& setDenormBehaviorIndependence(ShaderFloatControlsIndependence denormBehaviorIndependence_) {this->denormBehaviorIndependence = denormBehaviorIndependence_; return *this; }
    PhysicalDeviceFloatControlsProperties& setRoundingModeIndependence(ShaderFloatControlsIndependence roundingModeIndependence_) {this->roundingModeIndependence = roundingModeIndependence_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderSignedZeroInfNanPreserveFloat16(Bool32 shaderSignedZeroInfNanPreserveFloat16_) {this->shaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderSignedZeroInfNanPreserveFloat32(Bool32 shaderSignedZeroInfNanPreserveFloat32_) {this->shaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderSignedZeroInfNanPreserveFloat64(Bool32 shaderSignedZeroInfNanPreserveFloat64_) {this->shaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderDenormPreserveFloat16(Bool32 shaderDenormPreserveFloat16_) {this->shaderDenormPreserveFloat16 = shaderDenormPreserveFloat16_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderDenormPreserveFloat32(Bool32 shaderDenormPreserveFloat32_) {this->shaderDenormPreserveFloat32 = shaderDenormPreserveFloat32_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderDenormPreserveFloat64(Bool32 shaderDenormPreserveFloat64_) {this->shaderDenormPreserveFloat64 = shaderDenormPreserveFloat64_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderDenormFlushToZeroFloat16(Bool32 shaderDenormFlushToZeroFloat16_) {this->shaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderDenormFlushToZeroFloat32(Bool32 shaderDenormFlushToZeroFloat32_) {this->shaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderDenormFlushToZeroFloat64(Bool32 shaderDenormFlushToZeroFloat64_) {this->shaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderRoundingModeRTEFloat16(Bool32 shaderRoundingModeRTEFloat16_) {this->shaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderRoundingModeRTEFloat32(Bool32 shaderRoundingModeRTEFloat32_) {this->shaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderRoundingModeRTEFloat64(Bool32 shaderRoundingModeRTEFloat64_) {this->shaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderRoundingModeRTZFloat16(Bool32 shaderRoundingModeRTZFloat16_) {this->shaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderRoundingModeRTZFloat32(Bool32 shaderRoundingModeRTZFloat32_) {this->shaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32_; return *this; }
    PhysicalDeviceFloatControlsProperties& setShaderRoundingModeRTZFloat64(Bool32 shaderRoundingModeRTZFloat64_) {this->shaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64_; return *this; }
};
using PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
struct PhysicalDeviceHostQueryResetFeatures {
    StructureType sType{StructureType::PhysicalDeviceHostQueryResetFeatures};
    void* pNext = nullptr;
    Bool32 hostQueryReset{0};
    PhysicalDeviceHostQueryResetFeatures& setHostQueryReset(Bool32 hostQueryReset_) {this->hostQueryReset = hostQueryReset_; return *this; }
};
using PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
struct ShaderResourceUsageAMD {
    uint32_t numUsedVgprs{0};
    uint32_t numUsedSgprs{0};
    uint32_t ldsSizePerLocalWorkGroup{0};
    size_t ldsUsageSizeInBytes{0};
    size_t scratchMemUsageInBytes{0};
    constexpr bool operator==(ShaderResourceUsageAMD const& value) const {
        return numUsedVgprs == value.numUsedVgprs && numUsedSgprs == value.numUsedSgprs && ldsSizePerLocalWorkGroup == value.ldsSizePerLocalWorkGroup 
        && ldsUsageSizeInBytes == value.ldsUsageSizeInBytes && scratchMemUsageInBytes == value.scratchMemUsageInBytes ;}
    constexpr bool operator!=(ShaderResourceUsageAMD const& value) const {return !(*this == value);}
    ShaderResourceUsageAMD& setNumUsedVgprs(uint32_t numUsedVgprs_) {this->numUsedVgprs = numUsedVgprs_; return *this; }
    ShaderResourceUsageAMD& setNumUsedSgprs(uint32_t numUsedSgprs_) {this->numUsedSgprs = numUsedSgprs_; return *this; }
    ShaderResourceUsageAMD& setLdsSizePerLocalWorkGroup(uint32_t ldsSizePerLocalWorkGroup_) {this->ldsSizePerLocalWorkGroup = ldsSizePerLocalWorkGroup_; return *this; }
    ShaderResourceUsageAMD& setLdsUsageSizeInBytes(size_t ldsUsageSizeInBytes_) {this->ldsUsageSizeInBytes = ldsUsageSizeInBytes_; return *this; }
    ShaderResourceUsageAMD& setScratchMemUsageInBytes(size_t scratchMemUsageInBytes_) {this->scratchMemUsageInBytes = scratchMemUsageInBytes_; return *this; }
};
struct ShaderStatisticsInfoAMD {
    ShaderStageFlags shaderStageMask{};
    ShaderResourceUsageAMD resourceUsage{};
    uint32_t numPhysicalVgprs{0};
    uint32_t numPhysicalSgprs{0};
    uint32_t numAvailableVgprs{0};
    uint32_t numAvailableSgprs{0};
    uint32_t computeWorkGroupSize[3];
    constexpr bool operator==(ShaderStatisticsInfoAMD const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 3; i++)
            is_equal &= computeWorkGroupSize[i] == value.computeWorkGroupSize[i];
        return is_equal && shaderStageMask == value.shaderStageMask && resourceUsage == value.resourceUsage && numPhysicalVgprs == value.numPhysicalVgprs && numPhysicalSgprs == value.numPhysicalSgprs 
        && numAvailableVgprs == value.numAvailableVgprs && numAvailableSgprs == value.numAvailableSgprs ;}
    constexpr bool operator!=(ShaderStatisticsInfoAMD const& value) const {return !(*this == value);}
    ShaderStatisticsInfoAMD& setShaderStageMask(ShaderStageFlags shaderStageMask_) {this->shaderStageMask = shaderStageMask_; return *this; }
    ShaderStatisticsInfoAMD& setResourceUsage(ShaderResourceUsageAMD resourceUsage_) {this->resourceUsage = resourceUsage_; return *this; }
    ShaderStatisticsInfoAMD& setNumPhysicalVgprs(uint32_t numPhysicalVgprs_) {this->numPhysicalVgprs = numPhysicalVgprs_; return *this; }
    ShaderStatisticsInfoAMD& setNumPhysicalSgprs(uint32_t numPhysicalSgprs_) {this->numPhysicalSgprs = numPhysicalSgprs_; return *this; }
    ShaderStatisticsInfoAMD& setNumAvailableVgprs(uint32_t numAvailableVgprs_) {this->numAvailableVgprs = numAvailableVgprs_; return *this; }
    ShaderStatisticsInfoAMD& setNumAvailableSgprs(uint32_t numAvailableSgprs_) {this->numAvailableSgprs = numAvailableSgprs_; return *this; }
    ShaderStatisticsInfoAMD& setComputeWorkGroupSize(uint32_t computeWorkGroupSize_[3]) {for(uint32_t i = 0; i < 3; i++) this->computeWorkGroupSize[i] = computeWorkGroupSize_[i]; return *this; }
};
struct DeviceQueueGlobalPriorityCreateInfoEXT {
    StructureType sType{StructureType::DeviceQueueGlobalPriorityCreateInfoEXT};
    const void* pNext = nullptr;
    QueueGlobalPriorityEXT globalPriority{static_cast<QueueGlobalPriorityEXT>(0)};
    DeviceQueueGlobalPriorityCreateInfoEXT& setGlobalPriority(QueueGlobalPriorityEXT globalPriority_) {this->globalPriority = globalPriority_; return *this; }
};
struct DebugUtilsObjectNameInfoEXT {
    StructureType sType{StructureType::DebugUtilsObjectNameInfoEXT};
    const void* pNext = nullptr;
    ObjectType objectType{static_cast<ObjectType>(0)};
    uint64_t objectHandle{0};
    const char* pObjectName = nullptr;
    DebugUtilsObjectNameInfoEXT& setObjectType(ObjectType objectType_) {this->objectType = objectType_; return *this; }
    DebugUtilsObjectNameInfoEXT& setObjectHandle(uint64_t objectHandle_) {this->objectHandle = objectHandle_; return *this; }
    DebugUtilsObjectNameInfoEXT& setPObjectName(const char* pObjectName_) {this->pObjectName = pObjectName_; return *this; }
};
struct DebugUtilsObjectTagInfoEXT {
    StructureType sType{StructureType::DebugUtilsObjectTagInfoEXT};
    const void* pNext = nullptr;
    ObjectType objectType{static_cast<ObjectType>(0)};
    uint64_t objectHandle{0};
    uint64_t tagName{0};
    size_t tagSize{0};
    const void* pTag = nullptr;
    DebugUtilsObjectTagInfoEXT& setObjectType(ObjectType objectType_) {this->objectType = objectType_; return *this; }
    DebugUtilsObjectTagInfoEXT& setObjectHandle(uint64_t objectHandle_) {this->objectHandle = objectHandle_; return *this; }
    DebugUtilsObjectTagInfoEXT& setTagName(uint64_t tagName_) {this->tagName = tagName_; return *this; }
    DebugUtilsObjectTagInfoEXT& setTagSize(size_t tagSize_) {this->tagSize = tagSize_; return *this; }
    DebugUtilsObjectTagInfoEXT& setPTag(const void* pTag_) {this->pTag = pTag_; return *this; }
    DebugUtilsObjectTagInfoEXT& setPTag(detail::span<const std::byte> pTag_) {this->tagSize = pTag_.size(); this->pTag = pTag_.data();  return *this; }
};
struct DebugUtilsLabelEXT {
    StructureType sType{StructureType::DebugUtilsLabelEXT};
    const void* pNext = nullptr;
    const char* pLabelName = nullptr;
    float color[4];
    DebugUtilsLabelEXT& setPLabelName(const char* pLabelName_) {this->pLabelName = pLabelName_; return *this; }
    DebugUtilsLabelEXT& setColor(float color_[4]) {for(uint32_t i = 0; i < 4; i++) this->color[i] = color_[i]; return *this; }
};
struct DebugUtilsMessengerCreateInfoEXT {
    StructureType sType{StructureType::DebugUtilsMessengerCreateInfoEXT};
    const void* pNext = nullptr;
    DebugUtilsMessengerCreateFlagsEXT flags{};
    DebugUtilsMessageSeverityFlagsEXT messageSeverity{};
    DebugUtilsMessageTypeFlagsEXT messageType{};
    PFN_DebugUtilsMessengerCallbackEXT pfnUserCallback{};
    void* pUserData = nullptr;
    DebugUtilsMessengerCreateInfoEXT& setFlags(DebugUtilsMessengerCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    DebugUtilsMessengerCreateInfoEXT& setMessageSeverity(DebugUtilsMessageSeverityFlagsEXT messageSeverity_) {this->messageSeverity = messageSeverity_; return *this; }
    DebugUtilsMessengerCreateInfoEXT& setMessageType(DebugUtilsMessageTypeFlagsEXT messageType_) {this->messageType = messageType_; return *this; }
    DebugUtilsMessengerCreateInfoEXT& setPfnUserCallback(PFN_DebugUtilsMessengerCallbackEXT pfnUserCallback_) {this->pfnUserCallback = pfnUserCallback_; return *this; }
    DebugUtilsMessengerCreateInfoEXT& setPUserData(void* pUserData_) {this->pUserData = pUserData_; return *this; }
};
struct DebugUtilsMessengerCallbackDataEXT {
    StructureType sType{StructureType::DebugUtilsMessengerCallbackDataEXT};
    const void* pNext = nullptr;
    DebugUtilsMessengerCallbackDataFlagsEXT flags{};
    const char* pMessageIdName = nullptr;
    int32_t messageIdNumber{0};
    const char* pMessage = nullptr;
    uint32_t queueLabelCount{0};
    const DebugUtilsLabelEXT* pQueueLabels = nullptr;
    uint32_t cmdBufLabelCount{0};
    const DebugUtilsLabelEXT* pCmdBufLabels = nullptr;
    uint32_t objectCount{0};
    const DebugUtilsObjectNameInfoEXT* pObjects = nullptr;
    DebugUtilsMessengerCallbackDataEXT& setFlags(DebugUtilsMessengerCallbackDataFlagsEXT flags_) {this->flags = flags_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPMessageIdName(const char* pMessageIdName_) {this->pMessageIdName = pMessageIdName_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setMessageIdNumber(int32_t messageIdNumber_) {this->messageIdNumber = messageIdNumber_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPMessage(const char* pMessage_) {this->pMessage = pMessage_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setQueueLabelCount(uint32_t queueLabelCount_) {this->queueLabelCount = queueLabelCount_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPQueueLabels(const DebugUtilsLabelEXT* pQueueLabels_) {this->pQueueLabels = pQueueLabels_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPQueueLabels(detail::span<const DebugUtilsLabelEXT> pQueueLabels_) {this->queueLabelCount = pQueueLabels_.size(); this->pQueueLabels = pQueueLabels_.data();  return *this; }
    DebugUtilsMessengerCallbackDataEXT& setCmdBufLabelCount(uint32_t cmdBufLabelCount_) {this->cmdBufLabelCount = cmdBufLabelCount_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPCmdBufLabels(const DebugUtilsLabelEXT* pCmdBufLabels_) {this->pCmdBufLabels = pCmdBufLabels_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPCmdBufLabels(detail::span<const DebugUtilsLabelEXT> pCmdBufLabels_) {this->cmdBufLabelCount = pCmdBufLabels_.size(); this->pCmdBufLabels = pCmdBufLabels_.data();  return *this; }
    DebugUtilsMessengerCallbackDataEXT& setObjectCount(uint32_t objectCount_) {this->objectCount = objectCount_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPObjects(const DebugUtilsObjectNameInfoEXT* pObjects_) {this->pObjects = pObjects_; return *this; }
    DebugUtilsMessengerCallbackDataEXT& setPObjects(detail::span<const DebugUtilsObjectNameInfoEXT> pObjects_) {this->objectCount = pObjects_.size(); this->pObjects = pObjects_.data();  return *this; }
};
struct PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceDeviceMemoryReportFeaturesEXT};
    void* pNext = nullptr;
    Bool32 deviceMemoryReport{0};
    PhysicalDeviceDeviceMemoryReportFeaturesEXT& setDeviceMemoryReport(Bool32 deviceMemoryReport_) {this->deviceMemoryReport = deviceMemoryReport_; return *this; }
};
struct DeviceDeviceMemoryReportCreateInfoEXT {
    StructureType sType{StructureType::DeviceDeviceMemoryReportCreateInfoEXT};
    const void* pNext = nullptr;
    DeviceMemoryReportFlagsEXT flags{};
    PFN_DeviceMemoryReportCallbackEXT pfnUserCallback{};
    void* pUserData = nullptr;
    DeviceDeviceMemoryReportCreateInfoEXT& setFlags(DeviceMemoryReportFlagsEXT flags_) {this->flags = flags_; return *this; }
    DeviceDeviceMemoryReportCreateInfoEXT& setPfnUserCallback(PFN_DeviceMemoryReportCallbackEXT pfnUserCallback_) {this->pfnUserCallback = pfnUserCallback_; return *this; }
    DeviceDeviceMemoryReportCreateInfoEXT& setPUserData(void* pUserData_) {this->pUserData = pUserData_; return *this; }
};
struct DeviceMemoryReportCallbackDataEXT {
    StructureType sType{StructureType::DeviceMemoryReportCallbackDataEXT};
    const void* pNext = nullptr;
    DeviceMemoryReportFlagsEXT flags{};
    DeviceMemoryReportEventTypeEXT type{static_cast<DeviceMemoryReportEventTypeEXT>(0)};
    uint64_t memoryObjectId{0};
    DeviceSize size{0};
    ObjectType objectType{static_cast<ObjectType>(0)};
    uint64_t objectHandle{0};
    uint32_t heapIndex{0};
    DeviceMemoryReportCallbackDataEXT& setFlags(DeviceMemoryReportFlagsEXT flags_) {this->flags = flags_; return *this; }
    DeviceMemoryReportCallbackDataEXT& setType(DeviceMemoryReportEventTypeEXT type_) {this->type = type_; return *this; }
    DeviceMemoryReportCallbackDataEXT& setMemoryObjectId(uint64_t memoryObjectId_) {this->memoryObjectId = memoryObjectId_; return *this; }
    DeviceMemoryReportCallbackDataEXT& setSize(DeviceSize size_) {this->size = size_; return *this; }
    DeviceMemoryReportCallbackDataEXT& setObjectType(ObjectType objectType_) {this->objectType = objectType_; return *this; }
    DeviceMemoryReportCallbackDataEXT& setObjectHandle(uint64_t objectHandle_) {this->objectHandle = objectHandle_; return *this; }
    DeviceMemoryReportCallbackDataEXT& setHeapIndex(uint32_t heapIndex_) {this->heapIndex = heapIndex_; return *this; }
};
struct ImportMemoryHostPointerInfoEXT {
    StructureType sType{StructureType::ImportMemoryHostPointerInfoEXT};
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType{static_cast<ExternalMemoryHandleTypeFlagBits>(0)};
    void* pHostPointer = nullptr;
    ImportMemoryHostPointerInfoEXT& setHandleType(ExternalMemoryHandleTypeFlagBits handleType_) {this->handleType = handleType_; return *this; }
    ImportMemoryHostPointerInfoEXT& setPHostPointer(void* pHostPointer_) {this->pHostPointer = pHostPointer_; return *this; }
};
struct MemoryHostPointerPropertiesEXT {
    StructureType sType{StructureType::MemoryHostPointerPropertiesEXT};
    void* pNext = nullptr;
    uint32_t memoryTypeBits{0};
    MemoryHostPointerPropertiesEXT& setMemoryTypeBits(uint32_t memoryTypeBits_) {this->memoryTypeBits = memoryTypeBits_; return *this; }
};
struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceExternalMemoryHostPropertiesEXT};
    void* pNext = nullptr;
    DeviceSize minImportedHostPointerAlignment{0};
    PhysicalDeviceExternalMemoryHostPropertiesEXT& setMinImportedHostPointerAlignment(DeviceSize minImportedHostPointerAlignment_) {this->minImportedHostPointerAlignment = minImportedHostPointerAlignment_; return *this; }
};
struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceConservativeRasterizationPropertiesEXT};
    void* pNext = nullptr;
    float primitiveOverestimationSize{0.f};
    float maxExtraPrimitiveOverestimationSize{0.f};
    float extraPrimitiveOverestimationSizeGranularity{0.f};
    Bool32 primitiveUnderestimation{0};
    Bool32 conservativePointAndLineRasterization{0};
    Bool32 degenerateTrianglesRasterized{0};
    Bool32 degenerateLinesRasterized{0};
    Bool32 fullyCoveredFragmentShaderInputVariable{0};
    Bool32 conservativeRasterizationPostDepthCoverage{0};
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setPrimitiveOverestimationSize(float primitiveOverestimationSize_) {this->primitiveOverestimationSize = primitiveOverestimationSize_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setMaxExtraPrimitiveOverestimationSize(float maxExtraPrimitiveOverestimationSize_) {this->maxExtraPrimitiveOverestimationSize = maxExtraPrimitiveOverestimationSize_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setExtraPrimitiveOverestimationSizeGranularity(float extraPrimitiveOverestimationSizeGranularity_) {this->extraPrimitiveOverestimationSizeGranularity = extraPrimitiveOverestimationSizeGranularity_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setPrimitiveUnderestimation(Bool32 primitiveUnderestimation_) {this->primitiveUnderestimation = primitiveUnderestimation_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setConservativePointAndLineRasterization(Bool32 conservativePointAndLineRasterization_) {this->conservativePointAndLineRasterization = conservativePointAndLineRasterization_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setDegenerateTrianglesRasterized(Bool32 degenerateTrianglesRasterized_) {this->degenerateTrianglesRasterized = degenerateTrianglesRasterized_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setDegenerateLinesRasterized(Bool32 degenerateLinesRasterized_) {this->degenerateLinesRasterized = degenerateLinesRasterized_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setFullyCoveredFragmentShaderInputVariable(Bool32 fullyCoveredFragmentShaderInputVariable_) {this->fullyCoveredFragmentShaderInputVariable = fullyCoveredFragmentShaderInputVariable_; return *this; }
    PhysicalDeviceConservativeRasterizationPropertiesEXT& setConservativeRasterizationPostDepthCoverage(Bool32 conservativeRasterizationPostDepthCoverage_) {this->conservativeRasterizationPostDepthCoverage = conservativeRasterizationPostDepthCoverage_; return *this; }
};
struct CalibratedTimestampInfoEXT {
    StructureType sType{StructureType::CalibratedTimestampInfoEXT};
    const void* pNext = nullptr;
    TimeDomainEXT timeDomain{static_cast<TimeDomainEXT>(0)};
    CalibratedTimestampInfoEXT& setTimeDomain(TimeDomainEXT timeDomain_) {this->timeDomain = timeDomain_; return *this; }
};
struct PhysicalDeviceShaderCorePropertiesAMD {
    StructureType sType{StructureType::PhysicalDeviceShaderCorePropertiesAMD};
    void* pNext = nullptr;
    uint32_t shaderEngineCount{0};
    uint32_t shaderArraysPerEngineCount{0};
    uint32_t computeUnitsPerShaderArray{0};
    uint32_t simdPerComputeUnit{0};
    uint32_t wavefrontsPerSimd{0};
    uint32_t wavefrontSize{0};
    uint32_t sgprsPerSimd{0};
    uint32_t minSgprAllocation{0};
    uint32_t maxSgprAllocation{0};
    uint32_t sgprAllocationGranularity{0};
    uint32_t vgprsPerSimd{0};
    uint32_t minVgprAllocation{0};
    uint32_t maxVgprAllocation{0};
    uint32_t vgprAllocationGranularity{0};
    PhysicalDeviceShaderCorePropertiesAMD& setShaderEngineCount(uint32_t shaderEngineCount_) {this->shaderEngineCount = shaderEngineCount_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setShaderArraysPerEngineCount(uint32_t shaderArraysPerEngineCount_) {this->shaderArraysPerEngineCount = shaderArraysPerEngineCount_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setComputeUnitsPerShaderArray(uint32_t computeUnitsPerShaderArray_) {this->computeUnitsPerShaderArray = computeUnitsPerShaderArray_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setSimdPerComputeUnit(uint32_t simdPerComputeUnit_) {this->simdPerComputeUnit = simdPerComputeUnit_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setWavefrontsPerSimd(uint32_t wavefrontsPerSimd_) {this->wavefrontsPerSimd = wavefrontsPerSimd_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setWavefrontSize(uint32_t wavefrontSize_) {this->wavefrontSize = wavefrontSize_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setSgprsPerSimd(uint32_t sgprsPerSimd_) {this->sgprsPerSimd = sgprsPerSimd_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setMinSgprAllocation(uint32_t minSgprAllocation_) {this->minSgprAllocation = minSgprAllocation_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setMaxSgprAllocation(uint32_t maxSgprAllocation_) {this->maxSgprAllocation = maxSgprAllocation_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setSgprAllocationGranularity(uint32_t sgprAllocationGranularity_) {this->sgprAllocationGranularity = sgprAllocationGranularity_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setVgprsPerSimd(uint32_t vgprsPerSimd_) {this->vgprsPerSimd = vgprsPerSimd_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setMinVgprAllocation(uint32_t minVgprAllocation_) {this->minVgprAllocation = minVgprAllocation_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setMaxVgprAllocation(uint32_t maxVgprAllocation_) {this->maxVgprAllocation = maxVgprAllocation_; return *this; }
    PhysicalDeviceShaderCorePropertiesAMD& setVgprAllocationGranularity(uint32_t vgprAllocationGranularity_) {this->vgprAllocationGranularity = vgprAllocationGranularity_; return *this; }
};
struct PhysicalDeviceShaderCoreProperties2AMD {
    StructureType sType{StructureType::PhysicalDeviceShaderCoreProperties2AMD};
    void* pNext = nullptr;
    ShaderCorePropertiesFlagsAMD shaderCoreFeatures{};
    uint32_t activeComputeUnitCount{0};
    PhysicalDeviceShaderCoreProperties2AMD& setShaderCoreFeatures(ShaderCorePropertiesFlagsAMD shaderCoreFeatures_) {this->shaderCoreFeatures = shaderCoreFeatures_; return *this; }
    PhysicalDeviceShaderCoreProperties2AMD& setActiveComputeUnitCount(uint32_t activeComputeUnitCount_) {this->activeComputeUnitCount = activeComputeUnitCount_; return *this; }
};
struct PipelineRasterizationConservativeStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineRasterizationConservativeStateCreateInfoEXT};
    const void* pNext = nullptr;
    PipelineRasterizationConservativeStateCreateFlagsEXT flags{};
    ConservativeRasterizationModeEXT conservativeRasterizationMode{static_cast<ConservativeRasterizationModeEXT>(0)};
    float extraPrimitiveOverestimationSize{0.f};
    PipelineRasterizationConservativeStateCreateInfoEXT& setFlags(PipelineRasterizationConservativeStateCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    PipelineRasterizationConservativeStateCreateInfoEXT& setConservativeRasterizationMode(ConservativeRasterizationModeEXT conservativeRasterizationMode_) {this->conservativeRasterizationMode = conservativeRasterizationMode_; return *this; }
    PipelineRasterizationConservativeStateCreateInfoEXT& setExtraPrimitiveOverestimationSize(float extraPrimitiveOverestimationSize_) {this->extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSize_; return *this; }
};
struct PhysicalDeviceDescriptorIndexingFeatures {
    StructureType sType{StructureType::PhysicalDeviceDescriptorIndexingFeatures};
    void* pNext = nullptr;
    Bool32 shaderInputAttachmentArrayDynamicIndexing{0};
    Bool32 shaderUniformTexelBufferArrayDynamicIndexing{0};
    Bool32 shaderStorageTexelBufferArrayDynamicIndexing{0};
    Bool32 shaderUniformBufferArrayNonUniformIndexing{0};
    Bool32 shaderSampledImageArrayNonUniformIndexing{0};
    Bool32 shaderStorageBufferArrayNonUniformIndexing{0};
    Bool32 shaderStorageImageArrayNonUniformIndexing{0};
    Bool32 shaderInputAttachmentArrayNonUniformIndexing{0};
    Bool32 shaderUniformTexelBufferArrayNonUniformIndexing{0};
    Bool32 shaderStorageTexelBufferArrayNonUniformIndexing{0};
    Bool32 descriptorBindingUniformBufferUpdateAfterBind{0};
    Bool32 descriptorBindingSampledImageUpdateAfterBind{0};
    Bool32 descriptorBindingStorageImageUpdateAfterBind{0};
    Bool32 descriptorBindingStorageBufferUpdateAfterBind{0};
    Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind{0};
    Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind{0};
    Bool32 descriptorBindingUpdateUnusedWhilePending{0};
    Bool32 descriptorBindingPartiallyBound{0};
    Bool32 descriptorBindingVariableDescriptorCount{0};
    Bool32 runtimeDescriptorArray{0};
    PhysicalDeviceDescriptorIndexingFeatures& setShaderInputAttachmentArrayDynamicIndexing(Bool32 shaderInputAttachmentArrayDynamicIndexing_) {this->shaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderUniformTexelBufferArrayDynamicIndexing(Bool32 shaderUniformTexelBufferArrayDynamicIndexing_) {this->shaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderStorageTexelBufferArrayDynamicIndexing(Bool32 shaderStorageTexelBufferArrayDynamicIndexing_) {this->shaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderUniformBufferArrayNonUniformIndexing(Bool32 shaderUniformBufferArrayNonUniformIndexing_) {this->shaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderSampledImageArrayNonUniformIndexing(Bool32 shaderSampledImageArrayNonUniformIndexing_) {this->shaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderStorageBufferArrayNonUniformIndexing(Bool32 shaderStorageBufferArrayNonUniformIndexing_) {this->shaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderStorageImageArrayNonUniformIndexing(Bool32 shaderStorageImageArrayNonUniformIndexing_) {this->shaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderInputAttachmentArrayNonUniformIndexing(Bool32 shaderInputAttachmentArrayNonUniformIndexing_) {this->shaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderUniformTexelBufferArrayNonUniformIndexing(Bool32 shaderUniformTexelBufferArrayNonUniformIndexing_) {this->shaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setShaderStorageTexelBufferArrayNonUniformIndexing(Bool32 shaderStorageTexelBufferArrayNonUniformIndexing_) {this->shaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingUniformBufferUpdateAfterBind(Bool32 descriptorBindingUniformBufferUpdateAfterBind_) {this->descriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingSampledImageUpdateAfterBind(Bool32 descriptorBindingSampledImageUpdateAfterBind_) {this->descriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingStorageImageUpdateAfterBind(Bool32 descriptorBindingStorageImageUpdateAfterBind_) {this->descriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingStorageBufferUpdateAfterBind(Bool32 descriptorBindingStorageBufferUpdateAfterBind_) {this->descriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingUniformTexelBufferUpdateAfterBind(Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind_) {this->descriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingStorageTexelBufferUpdateAfterBind(Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind_) {this->descriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingUpdateUnusedWhilePending(Bool32 descriptorBindingUpdateUnusedWhilePending_) {this->descriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingPartiallyBound(Bool32 descriptorBindingPartiallyBound_) {this->descriptorBindingPartiallyBound = descriptorBindingPartiallyBound_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setDescriptorBindingVariableDescriptorCount(Bool32 descriptorBindingVariableDescriptorCount_) {this->descriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount_; return *this; }
    PhysicalDeviceDescriptorIndexingFeatures& setRuntimeDescriptorArray(Bool32 runtimeDescriptorArray_) {this->runtimeDescriptorArray = runtimeDescriptorArray_; return *this; }
};
using PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
struct PhysicalDeviceDescriptorIndexingProperties {
    StructureType sType{StructureType::PhysicalDeviceDescriptorIndexingProperties};
    void* pNext = nullptr;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools{0};
    Bool32 shaderUniformBufferArrayNonUniformIndexingNative{0};
    Bool32 shaderSampledImageArrayNonUniformIndexingNative{0};
    Bool32 shaderStorageBufferArrayNonUniformIndexingNative{0};
    Bool32 shaderStorageImageArrayNonUniformIndexingNative{0};
    Bool32 shaderInputAttachmentArrayNonUniformIndexingNative{0};
    Bool32 robustBufferAccessUpdateAfterBind{0};
    Bool32 quadDivergentImplicitLod{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments{0};
    uint32_t maxPerStageUpdateAfterBindResources{0};
    uint32_t maxDescriptorSetUpdateAfterBindSamplers{0};
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers{0};
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic{0};
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers{0};
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic{0};
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages{0};
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages{0};
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments{0};
    PhysicalDeviceDescriptorIndexingProperties& setMaxUpdateAfterBindDescriptorsInAllPools(uint32_t maxUpdateAfterBindDescriptorsInAllPools_) {this->maxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setShaderUniformBufferArrayNonUniformIndexingNative(Bool32 shaderUniformBufferArrayNonUniformIndexingNative_) {this->shaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setShaderSampledImageArrayNonUniformIndexingNative(Bool32 shaderSampledImageArrayNonUniformIndexingNative_) {this->shaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setShaderStorageBufferArrayNonUniformIndexingNative(Bool32 shaderStorageBufferArrayNonUniformIndexingNative_) {this->shaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setShaderStorageImageArrayNonUniformIndexingNative(Bool32 shaderStorageImageArrayNonUniformIndexingNative_) {this->shaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setShaderInputAttachmentArrayNonUniformIndexingNative(Bool32 shaderInputAttachmentArrayNonUniformIndexingNative_) {this->shaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setRobustBufferAccessUpdateAfterBind(Bool32 robustBufferAccessUpdateAfterBind_) {this->robustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setQuadDivergentImplicitLod(Bool32 quadDivergentImplicitLod_) {this->quadDivergentImplicitLod = quadDivergentImplicitLod_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageDescriptorUpdateAfterBindSamplers(uint32_t maxPerStageDescriptorUpdateAfterBindSamplers_) {this->maxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageDescriptorUpdateAfterBindUniformBuffers(uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers_) {this->maxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageDescriptorUpdateAfterBindStorageBuffers(uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers_) {this->maxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageDescriptorUpdateAfterBindSampledImages(uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages_) {this->maxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageDescriptorUpdateAfterBindStorageImages(uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages_) {this->maxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageDescriptorUpdateAfterBindInputAttachments(uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments_) {this->maxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxPerStageUpdateAfterBindResources(uint32_t maxPerStageUpdateAfterBindResources_) {this->maxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindSamplers(uint32_t maxDescriptorSetUpdateAfterBindSamplers_) {this->maxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindUniformBuffers(uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers_) {this->maxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic(uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_) {this->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindStorageBuffers(uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers_) {this->maxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic(uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_) {this->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindSampledImages(uint32_t maxDescriptorSetUpdateAfterBindSampledImages_) {this->maxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindStorageImages(uint32_t maxDescriptorSetUpdateAfterBindStorageImages_) {this->maxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages_; return *this; }
    PhysicalDeviceDescriptorIndexingProperties& setMaxDescriptorSetUpdateAfterBindInputAttachments(uint32_t maxDescriptorSetUpdateAfterBindInputAttachments_) {this->maxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments_; return *this; }
};
using PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
struct DescriptorSetLayoutBindingFlagsCreateInfo {
    StructureType sType{StructureType::DescriptorSetLayoutBindingFlagsCreateInfo};
    const void* pNext = nullptr;
    uint32_t bindingCount{0};
    const DescriptorBindingFlags* pBindingFlags = nullptr;
    DescriptorSetLayoutBindingFlagsCreateInfo& setBindingCount(uint32_t bindingCount_) {this->bindingCount = bindingCount_; return *this; }
    DescriptorSetLayoutBindingFlagsCreateInfo& setPBindingFlags(const DescriptorBindingFlags* pBindingFlags_) {this->pBindingFlags = pBindingFlags_; return *this; }
    DescriptorSetLayoutBindingFlagsCreateInfo& setPBindingFlags(detail::span<const DescriptorBindingFlags> pBindingFlags_) {this->bindingCount = pBindingFlags_.size(); this->pBindingFlags = pBindingFlags_.data();  return *this; }
};
using DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
struct DescriptorSetVariableDescriptorCountAllocateInfo {
    StructureType sType{StructureType::DescriptorSetVariableDescriptorCountAllocateInfo};
    const void* pNext = nullptr;
    uint32_t descriptorSetCount{0};
    const uint32_t* pDescriptorCounts = nullptr;
    DescriptorSetVariableDescriptorCountAllocateInfo& setDescriptorSetCount(uint32_t descriptorSetCount_) {this->descriptorSetCount = descriptorSetCount_; return *this; }
    DescriptorSetVariableDescriptorCountAllocateInfo& setPDescriptorCounts(const uint32_t* pDescriptorCounts_) {this->pDescriptorCounts = pDescriptorCounts_; return *this; }
    DescriptorSetVariableDescriptorCountAllocateInfo& setPDescriptorCounts(detail::span<const uint32_t> pDescriptorCounts_) {this->descriptorSetCount = pDescriptorCounts_.size(); this->pDescriptorCounts = pDescriptorCounts_.data();  return *this; }
};
using DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
struct DescriptorSetVariableDescriptorCountLayoutSupport {
    StructureType sType{StructureType::DescriptorSetVariableDescriptorCountLayoutSupport};
    void* pNext = nullptr;
    uint32_t maxVariableDescriptorCount{0};
    DescriptorSetVariableDescriptorCountLayoutSupport& setMaxVariableDescriptorCount(uint32_t maxVariableDescriptorCount_) {this->maxVariableDescriptorCount = maxVariableDescriptorCount_; return *this; }
};
using DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
struct AttachmentDescription2 {
    StructureType sType{StructureType::AttachmentDescription2};
    const void* pNext = nullptr;
    AttachmentDescriptionFlags flags{};
    Format format{static_cast<Format>(0)};
    SampleCountFlagBits samples{static_cast<SampleCountFlagBits>(0)};
    AttachmentLoadOp loadOp{static_cast<AttachmentLoadOp>(0)};
    AttachmentStoreOp storeOp{static_cast<AttachmentStoreOp>(0)};
    AttachmentLoadOp stencilLoadOp{static_cast<AttachmentLoadOp>(0)};
    AttachmentStoreOp stencilStoreOp{static_cast<AttachmentStoreOp>(0)};
    ImageLayout initialLayout{static_cast<ImageLayout>(0)};
    ImageLayout finalLayout{static_cast<ImageLayout>(0)};
    AttachmentDescription2& setFlags(AttachmentDescriptionFlags flags_) {this->flags = flags_; return *this; }
    AttachmentDescription2& setFormat(Format format_) {this->format = format_; return *this; }
    AttachmentDescription2& setSamples(SampleCountFlagBits samples_) {this->samples = samples_; return *this; }
    AttachmentDescription2& setLoadOp(AttachmentLoadOp loadOp_) {this->loadOp = loadOp_; return *this; }
    AttachmentDescription2& setStoreOp(AttachmentStoreOp storeOp_) {this->storeOp = storeOp_; return *this; }
    AttachmentDescription2& setStencilLoadOp(AttachmentLoadOp stencilLoadOp_) {this->stencilLoadOp = stencilLoadOp_; return *this; }
    AttachmentDescription2& setStencilStoreOp(AttachmentStoreOp stencilStoreOp_) {this->stencilStoreOp = stencilStoreOp_; return *this; }
    AttachmentDescription2& setInitialLayout(ImageLayout initialLayout_) {this->initialLayout = initialLayout_; return *this; }
    AttachmentDescription2& setFinalLayout(ImageLayout finalLayout_) {this->finalLayout = finalLayout_; return *this; }
};
using AttachmentDescription2KHR = AttachmentDescription2;
struct AttachmentReference2 {
    StructureType sType{StructureType::AttachmentReference2};
    const void* pNext = nullptr;
    uint32_t attachment{0};
    ImageLayout layout{static_cast<ImageLayout>(0)};
    ImageAspectFlags aspectMask{};
    AttachmentReference2& setAttachment(uint32_t attachment_) {this->attachment = attachment_; return *this; }
    AttachmentReference2& setLayout(ImageLayout layout_) {this->layout = layout_; return *this; }
    AttachmentReference2& setAspectMask(ImageAspectFlags aspectMask_) {this->aspectMask = aspectMask_; return *this; }
};
using AttachmentReference2KHR = AttachmentReference2;
struct SubpassDescription2 {
    StructureType sType{StructureType::SubpassDescription2};
    const void* pNext = nullptr;
    SubpassDescriptionFlags flags{};
    PipelineBindPoint pipelineBindPoint{static_cast<PipelineBindPoint>(0)};
    uint32_t viewMask{0};
    uint32_t inputAttachmentCount{0};
    const AttachmentReference2* pInputAttachments = nullptr;
    uint32_t colorAttachmentCount{0};
    const AttachmentReference2* pColorAttachments = nullptr;
    const AttachmentReference2* pResolveAttachments = nullptr;
    const AttachmentReference2* pDepthStencilAttachment = nullptr;
    uint32_t preserveAttachmentCount{0};
    const uint32_t* pPreserveAttachments = nullptr;
    SubpassDescription2& setFlags(SubpassDescriptionFlags flags_) {this->flags = flags_; return *this; }
    SubpassDescription2& setPipelineBindPoint(PipelineBindPoint pipelineBindPoint_) {this->pipelineBindPoint = pipelineBindPoint_; return *this; }
    SubpassDescription2& setViewMask(uint32_t viewMask_) {this->viewMask = viewMask_; return *this; }
    SubpassDescription2& setInputAttachmentCount(uint32_t inputAttachmentCount_) {this->inputAttachmentCount = inputAttachmentCount_; return *this; }
    SubpassDescription2& setPInputAttachments(const AttachmentReference2* pInputAttachments_) {this->pInputAttachments = pInputAttachments_; return *this; }
    SubpassDescription2& setPInputAttachments(detail::span<const AttachmentReference2> pInputAttachments_) {this->inputAttachmentCount = pInputAttachments_.size(); this->pInputAttachments = pInputAttachments_.data();  return *this; }
    SubpassDescription2& setColorAttachmentCount(uint32_t colorAttachmentCount_) {this->colorAttachmentCount = colorAttachmentCount_; return *this; }
    SubpassDescription2& setPColorAttachments(const AttachmentReference2* pColorAttachments_) {this->pColorAttachments = pColorAttachments_; return *this; }
    SubpassDescription2& setPColorAttachments(detail::span<const AttachmentReference2> pColorAttachments_) {this->colorAttachmentCount = pColorAttachments_.size(); this->pColorAttachments = pColorAttachments_.data();  return *this; }
    SubpassDescription2& setPResolveAttachments(const AttachmentReference2* pResolveAttachments_) {this->pResolveAttachments = pResolveAttachments_; return *this; }
    SubpassDescription2& setPResolveAttachments(detail::span<const AttachmentReference2> pResolveAttachments_) {this->colorAttachmentCount = pResolveAttachments_.size(); this->pResolveAttachments = pResolveAttachments_.data();  return *this; }
    SubpassDescription2& setPDepthStencilAttachment(const AttachmentReference2* pDepthStencilAttachment_) {this->pDepthStencilAttachment = pDepthStencilAttachment_; return *this; }
    SubpassDescription2& setPDepthStencilAttachment(AttachmentReference2 const& pDepthStencilAttachment_) {this->pDepthStencilAttachment = &pDepthStencilAttachment_; return *this; }
    SubpassDescription2& setPreserveAttachmentCount(uint32_t preserveAttachmentCount_) {this->preserveAttachmentCount = preserveAttachmentCount_; return *this; }
    SubpassDescription2& setPPreserveAttachments(const uint32_t* pPreserveAttachments_) {this->pPreserveAttachments = pPreserveAttachments_; return *this; }
    SubpassDescription2& setPPreserveAttachments(detail::span<const uint32_t> pPreserveAttachments_) {this->preserveAttachmentCount = pPreserveAttachments_.size(); this->pPreserveAttachments = pPreserveAttachments_.data();  return *this; }
};
using SubpassDescription2KHR = SubpassDescription2;
struct SubpassDependency2 {
    StructureType sType{StructureType::SubpassDependency2};
    const void* pNext = nullptr;
    uint32_t srcSubpass{0};
    uint32_t dstSubpass{0};
    PipelineStageFlags srcStageMask{};
    PipelineStageFlags dstStageMask{};
    AccessFlags srcAccessMask{};
    AccessFlags dstAccessMask{};
    DependencyFlags dependencyFlags{};
    int32_t viewOffset{0};
    SubpassDependency2& setSrcSubpass(uint32_t srcSubpass_) {this->srcSubpass = srcSubpass_; return *this; }
    SubpassDependency2& setDstSubpass(uint32_t dstSubpass_) {this->dstSubpass = dstSubpass_; return *this; }
    SubpassDependency2& setSrcStageMask(PipelineStageFlags srcStageMask_) {this->srcStageMask = srcStageMask_; return *this; }
    SubpassDependency2& setDstStageMask(PipelineStageFlags dstStageMask_) {this->dstStageMask = dstStageMask_; return *this; }
    SubpassDependency2& setSrcAccessMask(AccessFlags srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    SubpassDependency2& setDstAccessMask(AccessFlags dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
    SubpassDependency2& setDependencyFlags(DependencyFlags dependencyFlags_) {this->dependencyFlags = dependencyFlags_; return *this; }
    SubpassDependency2& setViewOffset(int32_t viewOffset_) {this->viewOffset = viewOffset_; return *this; }
};
using SubpassDependency2KHR = SubpassDependency2;
struct RenderPassCreateInfo2 {
    StructureType sType{StructureType::RenderPassCreateInfo2};
    const void* pNext = nullptr;
    RenderPassCreateFlags flags{};
    uint32_t attachmentCount{0};
    const AttachmentDescription2* pAttachments = nullptr;
    uint32_t subpassCount{0};
    const SubpassDescription2* pSubpasses = nullptr;
    uint32_t dependencyCount{0};
    const SubpassDependency2* pDependencies = nullptr;
    uint32_t correlatedViewMaskCount{0};
    const uint32_t* pCorrelatedViewMasks = nullptr;
    RenderPassCreateInfo2& setFlags(RenderPassCreateFlags flags_) {this->flags = flags_; return *this; }
    RenderPassCreateInfo2& setAttachmentCount(uint32_t attachmentCount_) {this->attachmentCount = attachmentCount_; return *this; }
    RenderPassCreateInfo2& setPAttachments(const AttachmentDescription2* pAttachments_) {this->pAttachments = pAttachments_; return *this; }
    RenderPassCreateInfo2& setPAttachments(detail::span<const AttachmentDescription2> pAttachments_) {this->attachmentCount = pAttachments_.size(); this->pAttachments = pAttachments_.data();  return *this; }
    RenderPassCreateInfo2& setSubpassCount(uint32_t subpassCount_) {this->subpassCount = subpassCount_; return *this; }
    RenderPassCreateInfo2& setPSubpasses(const SubpassDescription2* pSubpasses_) {this->pSubpasses = pSubpasses_; return *this; }
    RenderPassCreateInfo2& setPSubpasses(detail::span<const SubpassDescription2> pSubpasses_) {this->subpassCount = pSubpasses_.size(); this->pSubpasses = pSubpasses_.data();  return *this; }
    RenderPassCreateInfo2& setDependencyCount(uint32_t dependencyCount_) {this->dependencyCount = dependencyCount_; return *this; }
    RenderPassCreateInfo2& setPDependencies(const SubpassDependency2* pDependencies_) {this->pDependencies = pDependencies_; return *this; }
    RenderPassCreateInfo2& setPDependencies(detail::span<const SubpassDependency2> pDependencies_) {this->dependencyCount = pDependencies_.size(); this->pDependencies = pDependencies_.data();  return *this; }
    RenderPassCreateInfo2& setCorrelatedViewMaskCount(uint32_t correlatedViewMaskCount_) {this->correlatedViewMaskCount = correlatedViewMaskCount_; return *this; }
    RenderPassCreateInfo2& setPCorrelatedViewMasks(const uint32_t* pCorrelatedViewMasks_) {this->pCorrelatedViewMasks = pCorrelatedViewMasks_; return *this; }
    RenderPassCreateInfo2& setPCorrelatedViewMasks(detail::span<const uint32_t> pCorrelatedViewMasks_) {this->correlatedViewMaskCount = pCorrelatedViewMasks_.size(); this->pCorrelatedViewMasks = pCorrelatedViewMasks_.data();  return *this; }
};
using RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
struct SubpassBeginInfo {
    StructureType sType{StructureType::SubpassBeginInfo};
    const void* pNext = nullptr;
    SubpassContents contents{static_cast<SubpassContents>(0)};
    SubpassBeginInfo& setContents(SubpassContents contents_) {this->contents = contents_; return *this; }
};
using SubpassBeginInfoKHR = SubpassBeginInfo;
struct SubpassEndInfo {
    StructureType sType{StructureType::SubpassEndInfo};
    const void* pNext = nullptr;
};
using SubpassEndInfoKHR = SubpassEndInfo;
struct PhysicalDeviceTimelineSemaphoreFeatures {
    StructureType sType{StructureType::PhysicalDeviceTimelineSemaphoreFeatures};
    void* pNext = nullptr;
    Bool32 timelineSemaphore{0};
    PhysicalDeviceTimelineSemaphoreFeatures& setTimelineSemaphore(Bool32 timelineSemaphore_) {this->timelineSemaphore = timelineSemaphore_; return *this; }
};
using PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
struct PhysicalDeviceTimelineSemaphoreProperties {
    StructureType sType{StructureType::PhysicalDeviceTimelineSemaphoreProperties};
    void* pNext = nullptr;
    uint64_t maxTimelineSemaphoreValueDifference{0};
    PhysicalDeviceTimelineSemaphoreProperties& setMaxTimelineSemaphoreValueDifference(uint64_t maxTimelineSemaphoreValueDifference_) {this->maxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference_; return *this; }
};
using PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
struct SemaphoreTypeCreateInfo {
    StructureType sType{StructureType::SemaphoreTypeCreateInfo};
    const void* pNext = nullptr;
    SemaphoreType semaphoreType{static_cast<SemaphoreType>(0)};
    uint64_t initialValue{0};
    SemaphoreTypeCreateInfo& setSemaphoreType(SemaphoreType semaphoreType_) {this->semaphoreType = semaphoreType_; return *this; }
    SemaphoreTypeCreateInfo& setInitialValue(uint64_t initialValue_) {this->initialValue = initialValue_; return *this; }
};
using SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
struct TimelineSemaphoreSubmitInfo {
    StructureType sType{StructureType::TimelineSemaphoreSubmitInfo};
    const void* pNext = nullptr;
    uint32_t waitSemaphoreValueCount{0};
    const uint64_t* pWaitSemaphoreValues = nullptr;
    uint32_t signalSemaphoreValueCount{0};
    const uint64_t* pSignalSemaphoreValues = nullptr;
    TimelineSemaphoreSubmitInfo& setWaitSemaphoreValueCount(uint32_t waitSemaphoreValueCount_) {this->waitSemaphoreValueCount = waitSemaphoreValueCount_; return *this; }
    TimelineSemaphoreSubmitInfo& setPWaitSemaphoreValues(const uint64_t* pWaitSemaphoreValues_) {this->pWaitSemaphoreValues = pWaitSemaphoreValues_; return *this; }
    TimelineSemaphoreSubmitInfo& setPWaitSemaphoreValues(detail::span<const uint64_t> pWaitSemaphoreValues_) {this->waitSemaphoreValueCount = pWaitSemaphoreValues_.size(); this->pWaitSemaphoreValues = pWaitSemaphoreValues_.data();  return *this; }
    TimelineSemaphoreSubmitInfo& setSignalSemaphoreValueCount(uint32_t signalSemaphoreValueCount_) {this->signalSemaphoreValueCount = signalSemaphoreValueCount_; return *this; }
    TimelineSemaphoreSubmitInfo& setPSignalSemaphoreValues(const uint64_t* pSignalSemaphoreValues_) {this->pSignalSemaphoreValues = pSignalSemaphoreValues_; return *this; }
    TimelineSemaphoreSubmitInfo& setPSignalSemaphoreValues(detail::span<const uint64_t> pSignalSemaphoreValues_) {this->signalSemaphoreValueCount = pSignalSemaphoreValues_.size(); this->pSignalSemaphoreValues = pSignalSemaphoreValues_.data();  return *this; }
};
using TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
struct SemaphoreWaitInfo {
    StructureType sType{StructureType::SemaphoreWaitInfo};
    const void* pNext = nullptr;
    SemaphoreWaitFlags flags{};
    uint32_t semaphoreCount{0};
    const Semaphore* pSemaphores = nullptr;
    const uint64_t* pValues = nullptr;
    SemaphoreWaitInfo& setFlags(SemaphoreWaitFlags flags_) {this->flags = flags_; return *this; }
    SemaphoreWaitInfo& setSemaphoreCount(uint32_t semaphoreCount_) {this->semaphoreCount = semaphoreCount_; return *this; }
    SemaphoreWaitInfo& setPSemaphores(const Semaphore* pSemaphores_) {this->pSemaphores = pSemaphores_; return *this; }
    SemaphoreWaitInfo& setPSemaphores(detail::span<const Semaphore> pSemaphores_) {this->semaphoreCount = pSemaphores_.size(); this->pSemaphores = pSemaphores_.data();  return *this; }
    SemaphoreWaitInfo& setPValues(const uint64_t* pValues_) {this->pValues = pValues_; return *this; }
    SemaphoreWaitInfo& setPValues(detail::span<const uint64_t> pValues_) {this->semaphoreCount = pValues_.size(); this->pValues = pValues_.data();  return *this; }
};
using SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
struct SemaphoreSignalInfo {
    StructureType sType{StructureType::SemaphoreSignalInfo};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    uint64_t value{0};
    SemaphoreSignalInfo& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    SemaphoreSignalInfo& setValue(uint64_t value_) {this->value = value_; return *this; }
};
using SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
struct VertexInputBindingDivisorDescriptionEXT {
    uint32_t binding{0};
    uint32_t divisor{0};
    constexpr bool operator==(VertexInputBindingDivisorDescriptionEXT const& value) const {
        return binding == value.binding && divisor == value.divisor ;}
    constexpr bool operator!=(VertexInputBindingDivisorDescriptionEXT const& value) const {return !(*this == value);}
    VertexInputBindingDivisorDescriptionEXT& setBinding(uint32_t binding_) {this->binding = binding_; return *this; }
    VertexInputBindingDivisorDescriptionEXT& setDivisor(uint32_t divisor_) {this->divisor = divisor_; return *this; }
};
struct PipelineVertexInputDivisorStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineVertexInputDivisorStateCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t vertexBindingDivisorCount{0};
    const VertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors = nullptr;
    PipelineVertexInputDivisorStateCreateInfoEXT& setVertexBindingDivisorCount(uint32_t vertexBindingDivisorCount_) {this->vertexBindingDivisorCount = vertexBindingDivisorCount_; return *this; }
    PipelineVertexInputDivisorStateCreateInfoEXT& setPVertexBindingDivisors(const VertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors_) {this->pVertexBindingDivisors = pVertexBindingDivisors_; return *this; }
    PipelineVertexInputDivisorStateCreateInfoEXT& setPVertexBindingDivisors(detail::span<const VertexInputBindingDivisorDescriptionEXT> pVertexBindingDivisors_) {this->vertexBindingDivisorCount = pVertexBindingDivisors_.size(); this->pVertexBindingDivisors = pVertexBindingDivisors_.data();  return *this; }
};
struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceVertexAttributeDivisorPropertiesEXT};
    void* pNext = nullptr;
    uint32_t maxVertexAttribDivisor{0};
    PhysicalDeviceVertexAttributeDivisorPropertiesEXT& setMaxVertexAttribDivisor(uint32_t maxVertexAttribDivisor_) {this->maxVertexAttribDivisor = maxVertexAttribDivisor_; return *this; }
};
struct PhysicalDevicePCIBusInfoPropertiesEXT {
    StructureType sType{StructureType::PhysicalDevicePciBusInfoPropertiesEXT};
    void* pNext = nullptr;
    uint32_t pciDomain{0};
    uint32_t pciBus{0};
    uint32_t pciDevice{0};
    uint32_t pciFunction{0};
    PhysicalDevicePCIBusInfoPropertiesEXT& setPciDomain(uint32_t pciDomain_) {this->pciDomain = pciDomain_; return *this; }
    PhysicalDevicePCIBusInfoPropertiesEXT& setPciBus(uint32_t pciBus_) {this->pciBus = pciBus_; return *this; }
    PhysicalDevicePCIBusInfoPropertiesEXT& setPciDevice(uint32_t pciDevice_) {this->pciDevice = pciDevice_; return *this; }
    PhysicalDevicePCIBusInfoPropertiesEXT& setPciFunction(uint32_t pciFunction_) {this->pciFunction = pciFunction_; return *this; }
};
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct ImportAndroidHardwareBufferInfoANDROID {
    StructureType sType{StructureType::ImportAndroidHardwareBufferInfoANDROID};
    const void* pNext = nullptr;
    AHardwareBuffer* buffer = nullptr;
    ImportAndroidHardwareBufferInfoANDROID& setBuffer(AHardwareBuffer* buffer_) {this->buffer = buffer_; return *this; }
    ImportAndroidHardwareBufferInfoANDROID& setBuffer(AHardwareBuffer & buffer_) {this->buffer = &buffer_; return *this; }
};
struct AndroidHardwareBufferUsageANDROID {
    StructureType sType{StructureType::AndroidHardwareBufferUsageANDROID};
    void* pNext = nullptr;
    uint64_t androidHardwareBufferUsage{0};
    AndroidHardwareBufferUsageANDROID& setAndroidHardwareBufferUsage(uint64_t androidHardwareBufferUsage_) {this->androidHardwareBufferUsage = androidHardwareBufferUsage_; return *this; }
};
struct AndroidHardwareBufferPropertiesANDROID {
    StructureType sType{StructureType::AndroidHardwareBufferPropertiesANDROID};
    void* pNext = nullptr;
    DeviceSize allocationSize{0};
    uint32_t memoryTypeBits{0};
    AndroidHardwareBufferPropertiesANDROID& setAllocationSize(DeviceSize allocationSize_) {this->allocationSize = allocationSize_; return *this; }
    AndroidHardwareBufferPropertiesANDROID& setMemoryTypeBits(uint32_t memoryTypeBits_) {this->memoryTypeBits = memoryTypeBits_; return *this; }
};
struct MemoryGetAndroidHardwareBufferInfoANDROID {
    StructureType sType{StructureType::MemoryGetAndroidHardwareBufferInfoANDROID};
    const void* pNext = nullptr;
    DeviceMemory memory{};
    MemoryGetAndroidHardwareBufferInfoANDROID& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
};
struct AndroidHardwareBufferFormatPropertiesANDROID {
    StructureType sType{StructureType::AndroidHardwareBufferFormatPropertiesANDROID};
    void* pNext = nullptr;
    Format format{static_cast<Format>(0)};
    uint64_t externalFormat{0};
    FormatFeatureFlags formatFeatures{};
    ComponentMapping samplerYcbcrConversionComponents{};
    SamplerYcbcrModelConversion suggestedYcbcrModel{static_cast<SamplerYcbcrModelConversion>(0)};
    SamplerYcbcrRange suggestedYcbcrRange{static_cast<SamplerYcbcrRange>(0)};
    ChromaLocation suggestedXChromaOffset{static_cast<ChromaLocation>(0)};
    ChromaLocation suggestedYChromaOffset{static_cast<ChromaLocation>(0)};
    AndroidHardwareBufferFormatPropertiesANDROID& setFormat(Format format_) {this->format = format_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setExternalFormat(uint64_t externalFormat_) {this->externalFormat = externalFormat_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setFormatFeatures(FormatFeatureFlags formatFeatures_) {this->formatFeatures = formatFeatures_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setSamplerYcbcrConversionComponents(ComponentMapping samplerYcbcrConversionComponents_) {this->samplerYcbcrConversionComponents = samplerYcbcrConversionComponents_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setSuggestedYcbcrModel(SamplerYcbcrModelConversion suggestedYcbcrModel_) {this->suggestedYcbcrModel = suggestedYcbcrModel_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setSuggestedYcbcrRange(SamplerYcbcrRange suggestedYcbcrRange_) {this->suggestedYcbcrRange = suggestedYcbcrRange_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setSuggestedXChromaOffset(ChromaLocation suggestedXChromaOffset_) {this->suggestedXChromaOffset = suggestedXChromaOffset_; return *this; }
    AndroidHardwareBufferFormatPropertiesANDROID& setSuggestedYChromaOffset(ChromaLocation suggestedYChromaOffset_) {this->suggestedYChromaOffset = suggestedYChromaOffset_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
struct CommandBufferInheritanceConditionalRenderingInfoEXT {
    StructureType sType{StructureType::CommandBufferInheritanceConditionalRenderingInfoEXT};
    const void* pNext = nullptr;
    Bool32 conditionalRenderingEnable{0};
    CommandBufferInheritanceConditionalRenderingInfoEXT& setConditionalRenderingEnable(Bool32 conditionalRenderingEnable_) {this->conditionalRenderingEnable = conditionalRenderingEnable_; return *this; }
};
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct ExternalFormatANDROID {
    StructureType sType{StructureType::ExternalFormatANDROID};
    void* pNext = nullptr;
    uint64_t externalFormat{0};
    ExternalFormatANDROID& setExternalFormat(uint64_t externalFormat_) {this->externalFormat = externalFormat_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
struct PhysicalDevice8BitStorageFeatures {
    StructureType sType{StructureType::PhysicalDevice8BitStorageFeatures};
    void* pNext = nullptr;
    Bool32 storageBuffer8BitAccess{0};
    Bool32 uniformAndStorageBuffer8BitAccess{0};
    Bool32 storagePushConstant8{0};
    PhysicalDevice8BitStorageFeatures& setStorageBuffer8BitAccess(Bool32 storageBuffer8BitAccess_) {this->storageBuffer8BitAccess = storageBuffer8BitAccess_; return *this; }
    PhysicalDevice8BitStorageFeatures& setUniformAndStorageBuffer8BitAccess(Bool32 uniformAndStorageBuffer8BitAccess_) {this->uniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess_; return *this; }
    PhysicalDevice8BitStorageFeatures& setStoragePushConstant8(Bool32 storagePushConstant8_) {this->storagePushConstant8 = storagePushConstant8_; return *this; }
};
using PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
struct PhysicalDeviceConditionalRenderingFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceConditionalRenderingFeaturesEXT};
    void* pNext = nullptr;
    Bool32 conditionalRendering{0};
    Bool32 inheritedConditionalRendering{0};
    PhysicalDeviceConditionalRenderingFeaturesEXT& setConditionalRendering(Bool32 conditionalRendering_) {this->conditionalRendering = conditionalRendering_; return *this; }
    PhysicalDeviceConditionalRenderingFeaturesEXT& setInheritedConditionalRendering(Bool32 inheritedConditionalRendering_) {this->inheritedConditionalRendering = inheritedConditionalRendering_; return *this; }
};
struct PhysicalDeviceVulkanMemoryModelFeatures {
    StructureType sType{StructureType::PhysicalDeviceVulkanMemoryModelFeatures};
    void* pNext = nullptr;
    Bool32 vulkanMemoryModel{0};
    Bool32 vulkanMemoryModelDeviceScope{0};
    Bool32 vulkanMemoryModelAvailabilityVisibilityChains{0};
    PhysicalDeviceVulkanMemoryModelFeatures& setVulkanMemoryModel(Bool32 vulkanMemoryModel_) {this->vulkanMemoryModel = vulkanMemoryModel_; return *this; }
    PhysicalDeviceVulkanMemoryModelFeatures& setVulkanMemoryModelDeviceScope(Bool32 vulkanMemoryModelDeviceScope_) {this->vulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope_; return *this; }
    PhysicalDeviceVulkanMemoryModelFeatures& setVulkanMemoryModelAvailabilityVisibilityChains(Bool32 vulkanMemoryModelAvailabilityVisibilityChains_) {this->vulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains_; return *this; }
};
using PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
struct PhysicalDeviceShaderAtomicInt64Features {
    StructureType sType{StructureType::PhysicalDeviceShaderAtomicInt64Features};
    void* pNext = nullptr;
    Bool32 shaderBufferInt64Atomics{0};
    Bool32 shaderSharedInt64Atomics{0};
    PhysicalDeviceShaderAtomicInt64Features& setShaderBufferInt64Atomics(Bool32 shaderBufferInt64Atomics_) {this->shaderBufferInt64Atomics = shaderBufferInt64Atomics_; return *this; }
    PhysicalDeviceShaderAtomicInt64Features& setShaderSharedInt64Atomics(Bool32 shaderSharedInt64Atomics_) {this->shaderSharedInt64Atomics = shaderSharedInt64Atomics_; return *this; }
};
using PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceShaderAtomicFloatFeaturesEXT};
    void* pNext = nullptr;
    Bool32 shaderBufferFloat32Atomics{0};
    Bool32 shaderBufferFloat32AtomicAdd{0};
    Bool32 shaderBufferFloat64Atomics{0};
    Bool32 shaderBufferFloat64AtomicAdd{0};
    Bool32 shaderSharedFloat32Atomics{0};
    Bool32 shaderSharedFloat32AtomicAdd{0};
    Bool32 shaderSharedFloat64Atomics{0};
    Bool32 shaderSharedFloat64AtomicAdd{0};
    Bool32 shaderImageFloat32Atomics{0};
    Bool32 shaderImageFloat32AtomicAdd{0};
    Bool32 sparseImageFloat32Atomics{0};
    Bool32 sparseImageFloat32AtomicAdd{0};
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderBufferFloat32Atomics(Bool32 shaderBufferFloat32Atomics_) {this->shaderBufferFloat32Atomics = shaderBufferFloat32Atomics_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderBufferFloat32AtomicAdd(Bool32 shaderBufferFloat32AtomicAdd_) {this->shaderBufferFloat32AtomicAdd = shaderBufferFloat32AtomicAdd_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderBufferFloat64Atomics(Bool32 shaderBufferFloat64Atomics_) {this->shaderBufferFloat64Atomics = shaderBufferFloat64Atomics_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderBufferFloat64AtomicAdd(Bool32 shaderBufferFloat64AtomicAdd_) {this->shaderBufferFloat64AtomicAdd = shaderBufferFloat64AtomicAdd_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderSharedFloat32Atomics(Bool32 shaderSharedFloat32Atomics_) {this->shaderSharedFloat32Atomics = shaderSharedFloat32Atomics_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderSharedFloat32AtomicAdd(Bool32 shaderSharedFloat32AtomicAdd_) {this->shaderSharedFloat32AtomicAdd = shaderSharedFloat32AtomicAdd_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderSharedFloat64Atomics(Bool32 shaderSharedFloat64Atomics_) {this->shaderSharedFloat64Atomics = shaderSharedFloat64Atomics_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderSharedFloat64AtomicAdd(Bool32 shaderSharedFloat64AtomicAdd_) {this->shaderSharedFloat64AtomicAdd = shaderSharedFloat64AtomicAdd_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderImageFloat32Atomics(Bool32 shaderImageFloat32Atomics_) {this->shaderImageFloat32Atomics = shaderImageFloat32Atomics_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setShaderImageFloat32AtomicAdd(Bool32 shaderImageFloat32AtomicAdd_) {this->shaderImageFloat32AtomicAdd = shaderImageFloat32AtomicAdd_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setSparseImageFloat32Atomics(Bool32 sparseImageFloat32Atomics_) {this->sparseImageFloat32Atomics = sparseImageFloat32Atomics_; return *this; }
    PhysicalDeviceShaderAtomicFloatFeaturesEXT& setSparseImageFloat32AtomicAdd(Bool32 sparseImageFloat32AtomicAdd_) {this->sparseImageFloat32AtomicAdd = sparseImageFloat32AtomicAdd_; return *this; }
};
struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceVertexAttributeDivisorFeaturesEXT};
    void* pNext = nullptr;
    Bool32 vertexAttributeInstanceRateDivisor{0};
    Bool32 vertexAttributeInstanceRateZeroDivisor{0};
    PhysicalDeviceVertexAttributeDivisorFeaturesEXT& setVertexAttributeInstanceRateDivisor(Bool32 vertexAttributeInstanceRateDivisor_) {this->vertexAttributeInstanceRateDivisor = vertexAttributeInstanceRateDivisor_; return *this; }
    PhysicalDeviceVertexAttributeDivisorFeaturesEXT& setVertexAttributeInstanceRateZeroDivisor(Bool32 vertexAttributeInstanceRateZeroDivisor_) {this->vertexAttributeInstanceRateZeroDivisor = vertexAttributeInstanceRateZeroDivisor_; return *this; }
};
struct QueueFamilyCheckpointPropertiesNV {
    StructureType sType{StructureType::QueueFamilyCheckpointPropertiesNV};
    void* pNext = nullptr;
    PipelineStageFlags checkpointExecutionStageMask{};
    QueueFamilyCheckpointPropertiesNV& setCheckpointExecutionStageMask(PipelineStageFlags checkpointExecutionStageMask_) {this->checkpointExecutionStageMask = checkpointExecutionStageMask_; return *this; }
};
struct CheckpointDataNV {
    StructureType sType{StructureType::CheckpointDataNV};
    void* pNext = nullptr;
    PipelineStageFlagBits stage{static_cast<PipelineStageFlagBits>(0)};
    void* pCheckpointMarker = nullptr;
    CheckpointDataNV& setStage(PipelineStageFlagBits stage_) {this->stage = stage_; return *this; }
    CheckpointDataNV& setPCheckpointMarker(void* pCheckpointMarker_) {this->pCheckpointMarker = pCheckpointMarker_; return *this; }
};
struct PhysicalDeviceDepthStencilResolveProperties {
    StructureType sType{StructureType::PhysicalDeviceDepthStencilResolveProperties};
    void* pNext = nullptr;
    ResolveModeFlags supportedDepthResolveModes{};
    ResolveModeFlags supportedStencilResolveModes{};
    Bool32 independentResolveNone{0};
    Bool32 independentResolve{0};
    PhysicalDeviceDepthStencilResolveProperties& setSupportedDepthResolveModes(ResolveModeFlags supportedDepthResolveModes_) {this->supportedDepthResolveModes = supportedDepthResolveModes_; return *this; }
    PhysicalDeviceDepthStencilResolveProperties& setSupportedStencilResolveModes(ResolveModeFlags supportedStencilResolveModes_) {this->supportedStencilResolveModes = supportedStencilResolveModes_; return *this; }
    PhysicalDeviceDepthStencilResolveProperties& setIndependentResolveNone(Bool32 independentResolveNone_) {this->independentResolveNone = independentResolveNone_; return *this; }
    PhysicalDeviceDepthStencilResolveProperties& setIndependentResolve(Bool32 independentResolve_) {this->independentResolve = independentResolve_; return *this; }
};
using PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
struct SubpassDescriptionDepthStencilResolve {
    StructureType sType{StructureType::SubpassDescriptionDepthStencilResolve};
    const void* pNext = nullptr;
    ResolveModeFlagBits depthResolveMode{static_cast<ResolveModeFlagBits>(0)};
    ResolveModeFlagBits stencilResolveMode{static_cast<ResolveModeFlagBits>(0)};
    const AttachmentReference2* pDepthStencilResolveAttachment = nullptr;
    SubpassDescriptionDepthStencilResolve& setDepthResolveMode(ResolveModeFlagBits depthResolveMode_) {this->depthResolveMode = depthResolveMode_; return *this; }
    SubpassDescriptionDepthStencilResolve& setStencilResolveMode(ResolveModeFlagBits stencilResolveMode_) {this->stencilResolveMode = stencilResolveMode_; return *this; }
    SubpassDescriptionDepthStencilResolve& setPDepthStencilResolveAttachment(const AttachmentReference2* pDepthStencilResolveAttachment_) {this->pDepthStencilResolveAttachment = pDepthStencilResolveAttachment_; return *this; }
    SubpassDescriptionDepthStencilResolve& setPDepthStencilResolveAttachment(AttachmentReference2 const& pDepthStencilResolveAttachment_) {this->pDepthStencilResolveAttachment = &pDepthStencilResolveAttachment_; return *this; }
};
using SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
struct ImageViewASTCDecodeModeEXT {
    StructureType sType{StructureType::ImageViewAstcDecodeModeEXT};
    const void* pNext = nullptr;
    Format decodeMode{static_cast<Format>(0)};
    ImageViewASTCDecodeModeEXT& setDecodeMode(Format decodeMode_) {this->decodeMode = decodeMode_; return *this; }
};
struct PhysicalDeviceASTCDecodeFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceAstcDecodeFeaturesEXT};
    void* pNext = nullptr;
    Bool32 decodeModeSharedExponent{0};
    PhysicalDeviceASTCDecodeFeaturesEXT& setDecodeModeSharedExponent(Bool32 decodeModeSharedExponent_) {this->decodeModeSharedExponent = decodeModeSharedExponent_; return *this; }
};
struct PhysicalDeviceTransformFeedbackFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceTransformFeedbackFeaturesEXT};
    void* pNext = nullptr;
    Bool32 transformFeedback{0};
    Bool32 geometryStreams{0};
    PhysicalDeviceTransformFeedbackFeaturesEXT& setTransformFeedback(Bool32 transformFeedback_) {this->transformFeedback = transformFeedback_; return *this; }
    PhysicalDeviceTransformFeedbackFeaturesEXT& setGeometryStreams(Bool32 geometryStreams_) {this->geometryStreams = geometryStreams_; return *this; }
};
struct PhysicalDeviceTransformFeedbackPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceTransformFeedbackPropertiesEXT};
    void* pNext = nullptr;
    uint32_t maxTransformFeedbackStreams{0};
    uint32_t maxTransformFeedbackBuffers{0};
    DeviceSize maxTransformFeedbackBufferSize{0};
    uint32_t maxTransformFeedbackStreamDataSize{0};
    uint32_t maxTransformFeedbackBufferDataSize{0};
    uint32_t maxTransformFeedbackBufferDataStride{0};
    Bool32 transformFeedbackQueries{0};
    Bool32 transformFeedbackStreamsLinesTriangles{0};
    Bool32 transformFeedbackRasterizationStreamSelect{0};
    Bool32 transformFeedbackDraw{0};
    PhysicalDeviceTransformFeedbackPropertiesEXT& setMaxTransformFeedbackStreams(uint32_t maxTransformFeedbackStreams_) {this->maxTransformFeedbackStreams = maxTransformFeedbackStreams_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setMaxTransformFeedbackBuffers(uint32_t maxTransformFeedbackBuffers_) {this->maxTransformFeedbackBuffers = maxTransformFeedbackBuffers_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setMaxTransformFeedbackBufferSize(DeviceSize maxTransformFeedbackBufferSize_) {this->maxTransformFeedbackBufferSize = maxTransformFeedbackBufferSize_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setMaxTransformFeedbackStreamDataSize(uint32_t maxTransformFeedbackStreamDataSize_) {this->maxTransformFeedbackStreamDataSize = maxTransformFeedbackStreamDataSize_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setMaxTransformFeedbackBufferDataSize(uint32_t maxTransformFeedbackBufferDataSize_) {this->maxTransformFeedbackBufferDataSize = maxTransformFeedbackBufferDataSize_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setMaxTransformFeedbackBufferDataStride(uint32_t maxTransformFeedbackBufferDataStride_) {this->maxTransformFeedbackBufferDataStride = maxTransformFeedbackBufferDataStride_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setTransformFeedbackQueries(Bool32 transformFeedbackQueries_) {this->transformFeedbackQueries = transformFeedbackQueries_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setTransformFeedbackStreamsLinesTriangles(Bool32 transformFeedbackStreamsLinesTriangles_) {this->transformFeedbackStreamsLinesTriangles = transformFeedbackStreamsLinesTriangles_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setTransformFeedbackRasterizationStreamSelect(Bool32 transformFeedbackRasterizationStreamSelect_) {this->transformFeedbackRasterizationStreamSelect = transformFeedbackRasterizationStreamSelect_; return *this; }
    PhysicalDeviceTransformFeedbackPropertiesEXT& setTransformFeedbackDraw(Bool32 transformFeedbackDraw_) {this->transformFeedbackDraw = transformFeedbackDraw_; return *this; }
};
struct PipelineRasterizationStateStreamCreateInfoEXT {
    StructureType sType{StructureType::PipelineRasterizationStateStreamCreateInfoEXT};
    const void* pNext = nullptr;
    PipelineRasterizationStateStreamCreateFlagsEXT flags{};
    uint32_t rasterizationStream{0};
    PipelineRasterizationStateStreamCreateInfoEXT& setFlags(PipelineRasterizationStateStreamCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    PipelineRasterizationStateStreamCreateInfoEXT& setRasterizationStream(uint32_t rasterizationStream_) {this->rasterizationStream = rasterizationStream_; return *this; }
};
struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceRepresentativeFragmentTestFeaturesNV};
    void* pNext = nullptr;
    Bool32 representativeFragmentTest{0};
    PhysicalDeviceRepresentativeFragmentTestFeaturesNV& setRepresentativeFragmentTest(Bool32 representativeFragmentTest_) {this->representativeFragmentTest = representativeFragmentTest_; return *this; }
};
struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
    StructureType sType{StructureType::PipelineRepresentativeFragmentTestStateCreateInfoNV};
    const void* pNext = nullptr;
    Bool32 representativeFragmentTestEnable{0};
    PipelineRepresentativeFragmentTestStateCreateInfoNV& setRepresentativeFragmentTestEnable(Bool32 representativeFragmentTestEnable_) {this->representativeFragmentTestEnable = representativeFragmentTestEnable_; return *this; }
};
struct PhysicalDeviceExclusiveScissorFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceExclusiveScissorFeaturesNV};
    void* pNext = nullptr;
    Bool32 exclusiveScissor{0};
    PhysicalDeviceExclusiveScissorFeaturesNV& setExclusiveScissor(Bool32 exclusiveScissor_) {this->exclusiveScissor = exclusiveScissor_; return *this; }
};
struct PipelineViewportExclusiveScissorStateCreateInfoNV {
    StructureType sType{StructureType::PipelineViewportExclusiveScissorStateCreateInfoNV};
    const void* pNext = nullptr;
    uint32_t exclusiveScissorCount{0};
    const Rect2D* pExclusiveScissors = nullptr;
    PipelineViewportExclusiveScissorStateCreateInfoNV& setExclusiveScissorCount(uint32_t exclusiveScissorCount_) {this->exclusiveScissorCount = exclusiveScissorCount_; return *this; }
    PipelineViewportExclusiveScissorStateCreateInfoNV& setPExclusiveScissors(const Rect2D* pExclusiveScissors_) {this->pExclusiveScissors = pExclusiveScissors_; return *this; }
    PipelineViewportExclusiveScissorStateCreateInfoNV& setPExclusiveScissors(detail::span<const Rect2D> pExclusiveScissors_) {this->exclusiveScissorCount = pExclusiveScissors_.size(); this->pExclusiveScissors = pExclusiveScissors_.data();  return *this; }
};
struct PhysicalDeviceCornerSampledImageFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceCornerSampledImageFeaturesNV};
    void* pNext = nullptr;
    Bool32 cornerSampledImage{0};
    PhysicalDeviceCornerSampledImageFeaturesNV& setCornerSampledImage(Bool32 cornerSampledImage_) {this->cornerSampledImage = cornerSampledImage_; return *this; }
};
struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceComputeShaderDerivativesFeaturesNV};
    void* pNext = nullptr;
    Bool32 computeDerivativeGroupQuads{0};
    Bool32 computeDerivativeGroupLinear{0};
    PhysicalDeviceComputeShaderDerivativesFeaturesNV& setComputeDerivativeGroupQuads(Bool32 computeDerivativeGroupQuads_) {this->computeDerivativeGroupQuads = computeDerivativeGroupQuads_; return *this; }
    PhysicalDeviceComputeShaderDerivativesFeaturesNV& setComputeDerivativeGroupLinear(Bool32 computeDerivativeGroupLinear_) {this->computeDerivativeGroupLinear = computeDerivativeGroupLinear_; return *this; }
};
struct PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceFragmentShaderBarycentricFeaturesNV};
    void* pNext = nullptr;
    Bool32 fragmentShaderBarycentric{0};
    PhysicalDeviceFragmentShaderBarycentricFeaturesNV& setFragmentShaderBarycentric(Bool32 fragmentShaderBarycentric_) {this->fragmentShaderBarycentric = fragmentShaderBarycentric_; return *this; }
};
struct PhysicalDeviceShaderImageFootprintFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceShaderImageFootprintFeaturesNV};
    void* pNext = nullptr;
    Bool32 imageFootprint{0};
    PhysicalDeviceShaderImageFootprintFeaturesNV& setImageFootprint(Bool32 imageFootprint_) {this->imageFootprint = imageFootprint_; return *this; }
};
struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV};
    void* pNext = nullptr;
    Bool32 dedicatedAllocationImageAliasing{0};
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& setDedicatedAllocationImageAliasing(Bool32 dedicatedAllocationImageAliasing_) {this->dedicatedAllocationImageAliasing = dedicatedAllocationImageAliasing_; return *this; }
};
struct ShadingRatePaletteNV {
    uint32_t shadingRatePaletteEntryCount{0};
    const ShadingRatePaletteEntryNV* pShadingRatePaletteEntries = nullptr;
    ShadingRatePaletteNV& setShadingRatePaletteEntryCount(uint32_t shadingRatePaletteEntryCount_) {this->shadingRatePaletteEntryCount = shadingRatePaletteEntryCount_; return *this; }
    ShadingRatePaletteNV& setPShadingRatePaletteEntries(const ShadingRatePaletteEntryNV* pShadingRatePaletteEntries_) {this->pShadingRatePaletteEntries = pShadingRatePaletteEntries_; return *this; }
    ShadingRatePaletteNV& setPShadingRatePaletteEntries(detail::span<const ShadingRatePaletteEntryNV> pShadingRatePaletteEntries_) {this->shadingRatePaletteEntryCount = pShadingRatePaletteEntries_.size(); this->pShadingRatePaletteEntries = pShadingRatePaletteEntries_.data();  return *this; }
};
struct PipelineViewportShadingRateImageStateCreateInfoNV {
    StructureType sType{StructureType::PipelineViewportShadingRateImageStateCreateInfoNV};
    const void* pNext = nullptr;
    Bool32 shadingRateImageEnable{0};
    uint32_t viewportCount{0};
    const ShadingRatePaletteNV* pShadingRatePalettes = nullptr;
    PipelineViewportShadingRateImageStateCreateInfoNV& setShadingRateImageEnable(Bool32 shadingRateImageEnable_) {this->shadingRateImageEnable = shadingRateImageEnable_; return *this; }
    PipelineViewportShadingRateImageStateCreateInfoNV& setViewportCount(uint32_t viewportCount_) {this->viewportCount = viewportCount_; return *this; }
    PipelineViewportShadingRateImageStateCreateInfoNV& setPShadingRatePalettes(const ShadingRatePaletteNV* pShadingRatePalettes_) {this->pShadingRatePalettes = pShadingRatePalettes_; return *this; }
    PipelineViewportShadingRateImageStateCreateInfoNV& setPShadingRatePalettes(detail::span<const ShadingRatePaletteNV> pShadingRatePalettes_) {this->viewportCount = pShadingRatePalettes_.size(); this->pShadingRatePalettes = pShadingRatePalettes_.data();  return *this; }
};
struct PhysicalDeviceShadingRateImageFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceShadingRateImageFeaturesNV};
    void* pNext = nullptr;
    Bool32 shadingRateImage{0};
    Bool32 shadingRateCoarseSampleOrder{0};
    PhysicalDeviceShadingRateImageFeaturesNV& setShadingRateImage(Bool32 shadingRateImage_) {this->shadingRateImage = shadingRateImage_; return *this; }
    PhysicalDeviceShadingRateImageFeaturesNV& setShadingRateCoarseSampleOrder(Bool32 shadingRateCoarseSampleOrder_) {this->shadingRateCoarseSampleOrder = shadingRateCoarseSampleOrder_; return *this; }
};
struct PhysicalDeviceShadingRateImagePropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceShadingRateImagePropertiesNV};
    void* pNext = nullptr;
    Extent2D shadingRateTexelSize{};
    uint32_t shadingRatePaletteSize{0};
    uint32_t shadingRateMaxCoarseSamples{0};
    PhysicalDeviceShadingRateImagePropertiesNV& setShadingRateTexelSize(Extent2D shadingRateTexelSize_) {this->shadingRateTexelSize = shadingRateTexelSize_; return *this; }
    PhysicalDeviceShadingRateImagePropertiesNV& setShadingRatePaletteSize(uint32_t shadingRatePaletteSize_) {this->shadingRatePaletteSize = shadingRatePaletteSize_; return *this; }
    PhysicalDeviceShadingRateImagePropertiesNV& setShadingRateMaxCoarseSamples(uint32_t shadingRateMaxCoarseSamples_) {this->shadingRateMaxCoarseSamples = shadingRateMaxCoarseSamples_; return *this; }
};
struct CoarseSampleLocationNV {
    uint32_t pixelX{0};
    uint32_t pixelY{0};
    uint32_t sample{0};
    constexpr bool operator==(CoarseSampleLocationNV const& value) const {
        return pixelX == value.pixelX && pixelY == value.pixelY && sample == value.sample ;}
    constexpr bool operator!=(CoarseSampleLocationNV const& value) const {return !(*this == value);}
    CoarseSampleLocationNV& setPixelX(uint32_t pixelX_) {this->pixelX = pixelX_; return *this; }
    CoarseSampleLocationNV& setPixelY(uint32_t pixelY_) {this->pixelY = pixelY_; return *this; }
    CoarseSampleLocationNV& setSample(uint32_t sample_) {this->sample = sample_; return *this; }
};
struct CoarseSampleOrderCustomNV {
    ShadingRatePaletteEntryNV shadingRate{static_cast<ShadingRatePaletteEntryNV>(0)};
    uint32_t sampleCount{0};
    uint32_t sampleLocationCount{0};
    const CoarseSampleLocationNV* pSampleLocations = nullptr;
    CoarseSampleOrderCustomNV& setShadingRate(ShadingRatePaletteEntryNV shadingRate_) {this->shadingRate = shadingRate_; return *this; }
    CoarseSampleOrderCustomNV& setSampleCount(uint32_t sampleCount_) {this->sampleCount = sampleCount_; return *this; }
    CoarseSampleOrderCustomNV& setSampleLocationCount(uint32_t sampleLocationCount_) {this->sampleLocationCount = sampleLocationCount_; return *this; }
    CoarseSampleOrderCustomNV& setPSampleLocations(const CoarseSampleLocationNV* pSampleLocations_) {this->pSampleLocations = pSampleLocations_; return *this; }
    CoarseSampleOrderCustomNV& setPSampleLocations(detail::span<const CoarseSampleLocationNV> pSampleLocations_) {this->sampleLocationCount = pSampleLocations_.size(); this->pSampleLocations = pSampleLocations_.data();  return *this; }
};
struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    StructureType sType{StructureType::PipelineViewportCoarseSampleOrderStateCreateInfoNV};
    const void* pNext = nullptr;
    CoarseSampleOrderTypeNV sampleOrderType{static_cast<CoarseSampleOrderTypeNV>(0)};
    uint32_t customSampleOrderCount{0};
    const CoarseSampleOrderCustomNV* pCustomSampleOrders = nullptr;
    PipelineViewportCoarseSampleOrderStateCreateInfoNV& setSampleOrderType(CoarseSampleOrderTypeNV sampleOrderType_) {this->sampleOrderType = sampleOrderType_; return *this; }
    PipelineViewportCoarseSampleOrderStateCreateInfoNV& setCustomSampleOrderCount(uint32_t customSampleOrderCount_) {this->customSampleOrderCount = customSampleOrderCount_; return *this; }
    PipelineViewportCoarseSampleOrderStateCreateInfoNV& setPCustomSampleOrders(const CoarseSampleOrderCustomNV* pCustomSampleOrders_) {this->pCustomSampleOrders = pCustomSampleOrders_; return *this; }
    PipelineViewportCoarseSampleOrderStateCreateInfoNV& setPCustomSampleOrders(detail::span<const CoarseSampleOrderCustomNV> pCustomSampleOrders_) {this->customSampleOrderCount = pCustomSampleOrders_.size(); this->pCustomSampleOrders = pCustomSampleOrders_.data();  return *this; }
};
struct PhysicalDeviceMeshShaderFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceMeshShaderFeaturesNV};
    void* pNext = nullptr;
    Bool32 taskShader{0};
    Bool32 meshShader{0};
    PhysicalDeviceMeshShaderFeaturesNV& setTaskShader(Bool32 taskShader_) {this->taskShader = taskShader_; return *this; }
    PhysicalDeviceMeshShaderFeaturesNV& setMeshShader(Bool32 meshShader_) {this->meshShader = meshShader_; return *this; }
};
struct PhysicalDeviceMeshShaderPropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceMeshShaderPropertiesNV};
    void* pNext = nullptr;
    uint32_t maxDrawMeshTasksCount{0};
    uint32_t maxTaskWorkGroupInvocations{0};
    uint32_t maxTaskWorkGroupSize[3];
    uint32_t maxTaskTotalMemorySize{0};
    uint32_t maxTaskOutputCount{0};
    uint32_t maxMeshWorkGroupInvocations{0};
    uint32_t maxMeshWorkGroupSize[3];
    uint32_t maxMeshTotalMemorySize{0};
    uint32_t maxMeshOutputVertices{0};
    uint32_t maxMeshOutputPrimitives{0};
    uint32_t maxMeshMultiviewViewCount{0};
    uint32_t meshOutputPerVertexGranularity{0};
    uint32_t meshOutputPerPrimitiveGranularity{0};
    PhysicalDeviceMeshShaderPropertiesNV& setMaxDrawMeshTasksCount(uint32_t maxDrawMeshTasksCount_) {this->maxDrawMeshTasksCount = maxDrawMeshTasksCount_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxTaskWorkGroupInvocations(uint32_t maxTaskWorkGroupInvocations_) {this->maxTaskWorkGroupInvocations = maxTaskWorkGroupInvocations_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxTaskWorkGroupSize(uint32_t maxTaskWorkGroupSize_[3]) {for(uint32_t i = 0; i < 3; i++) this->maxTaskWorkGroupSize[i] = maxTaskWorkGroupSize_[i]; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxTaskTotalMemorySize(uint32_t maxTaskTotalMemorySize_) {this->maxTaskTotalMemorySize = maxTaskTotalMemorySize_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxTaskOutputCount(uint32_t maxTaskOutputCount_) {this->maxTaskOutputCount = maxTaskOutputCount_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxMeshWorkGroupInvocations(uint32_t maxMeshWorkGroupInvocations_) {this->maxMeshWorkGroupInvocations = maxMeshWorkGroupInvocations_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxMeshWorkGroupSize(uint32_t maxMeshWorkGroupSize_[3]) {for(uint32_t i = 0; i < 3; i++) this->maxMeshWorkGroupSize[i] = maxMeshWorkGroupSize_[i]; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxMeshTotalMemorySize(uint32_t maxMeshTotalMemorySize_) {this->maxMeshTotalMemorySize = maxMeshTotalMemorySize_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxMeshOutputVertices(uint32_t maxMeshOutputVertices_) {this->maxMeshOutputVertices = maxMeshOutputVertices_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxMeshOutputPrimitives(uint32_t maxMeshOutputPrimitives_) {this->maxMeshOutputPrimitives = maxMeshOutputPrimitives_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMaxMeshMultiviewViewCount(uint32_t maxMeshMultiviewViewCount_) {this->maxMeshMultiviewViewCount = maxMeshMultiviewViewCount_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMeshOutputPerVertexGranularity(uint32_t meshOutputPerVertexGranularity_) {this->meshOutputPerVertexGranularity = meshOutputPerVertexGranularity_; return *this; }
    PhysicalDeviceMeshShaderPropertiesNV& setMeshOutputPerPrimitiveGranularity(uint32_t meshOutputPerPrimitiveGranularity_) {this->meshOutputPerPrimitiveGranularity = meshOutputPerPrimitiveGranularity_; return *this; }
};
struct DrawMeshTasksIndirectCommandNV {
    uint32_t taskCount{0};
    uint32_t firstTask{0};
    constexpr bool operator==(DrawMeshTasksIndirectCommandNV const& value) const {
        return taskCount == value.taskCount && firstTask == value.firstTask ;}
    constexpr bool operator!=(DrawMeshTasksIndirectCommandNV const& value) const {return !(*this == value);}
    DrawMeshTasksIndirectCommandNV& setTaskCount(uint32_t taskCount_) {this->taskCount = taskCount_; return *this; }
    DrawMeshTasksIndirectCommandNV& setFirstTask(uint32_t firstTask_) {this->firstTask = firstTask_; return *this; }
};
struct RayTracingShaderGroupCreateInfoNV {
    StructureType sType{StructureType::RayTracingShaderGroupCreateInfoNV};
    const void* pNext = nullptr;
    RayTracingShaderGroupTypeKHR type{static_cast<RayTracingShaderGroupTypeKHR>(0)};
    uint32_t generalShader{0};
    uint32_t closestHitShader{0};
    uint32_t anyHitShader{0};
    uint32_t intersectionShader{0};
    RayTracingShaderGroupCreateInfoNV& setType(RayTracingShaderGroupTypeKHR type_) {this->type = type_; return *this; }
    RayTracingShaderGroupCreateInfoNV& setGeneralShader(uint32_t generalShader_) {this->generalShader = generalShader_; return *this; }
    RayTracingShaderGroupCreateInfoNV& setClosestHitShader(uint32_t closestHitShader_) {this->closestHitShader = closestHitShader_; return *this; }
    RayTracingShaderGroupCreateInfoNV& setAnyHitShader(uint32_t anyHitShader_) {this->anyHitShader = anyHitShader_; return *this; }
    RayTracingShaderGroupCreateInfoNV& setIntersectionShader(uint32_t intersectionShader_) {this->intersectionShader = intersectionShader_; return *this; }
};
struct RayTracingShaderGroupCreateInfoKHR {
    StructureType sType{StructureType::RayTracingShaderGroupCreateInfoKHR};
    const void* pNext = nullptr;
    RayTracingShaderGroupTypeKHR type{static_cast<RayTracingShaderGroupTypeKHR>(0)};
    uint32_t generalShader{0};
    uint32_t closestHitShader{0};
    uint32_t anyHitShader{0};
    uint32_t intersectionShader{0};
    const void* pShaderGroupCaptureReplayHandle = nullptr;
    RayTracingShaderGroupCreateInfoKHR& setType(RayTracingShaderGroupTypeKHR type_) {this->type = type_; return *this; }
    RayTracingShaderGroupCreateInfoKHR& setGeneralShader(uint32_t generalShader_) {this->generalShader = generalShader_; return *this; }
    RayTracingShaderGroupCreateInfoKHR& setClosestHitShader(uint32_t closestHitShader_) {this->closestHitShader = closestHitShader_; return *this; }
    RayTracingShaderGroupCreateInfoKHR& setAnyHitShader(uint32_t anyHitShader_) {this->anyHitShader = anyHitShader_; return *this; }
    RayTracingShaderGroupCreateInfoKHR& setIntersectionShader(uint32_t intersectionShader_) {this->intersectionShader = intersectionShader_; return *this; }
    RayTracingShaderGroupCreateInfoKHR& setPShaderGroupCaptureReplayHandle(const void* pShaderGroupCaptureReplayHandle_) {this->pShaderGroupCaptureReplayHandle = pShaderGroupCaptureReplayHandle_; return *this; }
};
struct RayTracingPipelineCreateInfoNV {
    StructureType sType{StructureType::RayTracingPipelineCreateInfoNV};
    const void* pNext = nullptr;
    PipelineCreateFlags flags{};
    uint32_t stageCount{0};
    const PipelineShaderStageCreateInfo* pStages = nullptr;
    uint32_t groupCount{0};
    const RayTracingShaderGroupCreateInfoNV* pGroups = nullptr;
    uint32_t maxRecursionDepth{0};
    PipelineLayout layout{};
    Pipeline basePipelineHandle{};
    int32_t basePipelineIndex{0};
    RayTracingPipelineCreateInfoNV& setFlags(PipelineCreateFlags flags_) {this->flags = flags_; return *this; }
    RayTracingPipelineCreateInfoNV& setStageCount(uint32_t stageCount_) {this->stageCount = stageCount_; return *this; }
    RayTracingPipelineCreateInfoNV& setPStages(const PipelineShaderStageCreateInfo* pStages_) {this->pStages = pStages_; return *this; }
    RayTracingPipelineCreateInfoNV& setPStages(detail::span<const PipelineShaderStageCreateInfo> pStages_) {this->stageCount = pStages_.size(); this->pStages = pStages_.data();  return *this; }
    RayTracingPipelineCreateInfoNV& setGroupCount(uint32_t groupCount_) {this->groupCount = groupCount_; return *this; }
    RayTracingPipelineCreateInfoNV& setPGroups(const RayTracingShaderGroupCreateInfoNV* pGroups_) {this->pGroups = pGroups_; return *this; }
    RayTracingPipelineCreateInfoNV& setPGroups(detail::span<const RayTracingShaderGroupCreateInfoNV> pGroups_) {this->groupCount = pGroups_.size(); this->pGroups = pGroups_.data();  return *this; }
    RayTracingPipelineCreateInfoNV& setMaxRecursionDepth(uint32_t maxRecursionDepth_) {this->maxRecursionDepth = maxRecursionDepth_; return *this; }
    RayTracingPipelineCreateInfoNV& setLayout(PipelineLayout layout_) {this->layout = layout_; return *this; }
    RayTracingPipelineCreateInfoNV& setBasePipelineHandle(Pipeline basePipelineHandle_) {this->basePipelineHandle = basePipelineHandle_; return *this; }
    RayTracingPipelineCreateInfoNV& setBasePipelineIndex(int32_t basePipelineIndex_) {this->basePipelineIndex = basePipelineIndex_; return *this; }
};
struct RayTracingPipelineInterfaceCreateInfoKHR {
    StructureType sType{StructureType::RayTracingPipelineInterfaceCreateInfoKHR};
    const void* pNext = nullptr;
    uint32_t maxPipelineRayPayloadSize{0};
    uint32_t maxPipelineRayHitAttributeSize{0};
    RayTracingPipelineInterfaceCreateInfoKHR& setMaxPipelineRayPayloadSize(uint32_t maxPipelineRayPayloadSize_) {this->maxPipelineRayPayloadSize = maxPipelineRayPayloadSize_; return *this; }
    RayTracingPipelineInterfaceCreateInfoKHR& setMaxPipelineRayHitAttributeSize(uint32_t maxPipelineRayHitAttributeSize_) {this->maxPipelineRayHitAttributeSize = maxPipelineRayHitAttributeSize_; return *this; }
};
struct PipelineLibraryCreateInfoKHR {
    StructureType sType{StructureType::PipelineLibraryCreateInfoKHR};
    const void* pNext = nullptr;
    uint32_t libraryCount{0};
    const Pipeline* pLibraries = nullptr;
    PipelineLibraryCreateInfoKHR& setLibraryCount(uint32_t libraryCount_) {this->libraryCount = libraryCount_; return *this; }
    PipelineLibraryCreateInfoKHR& setPLibraries(const Pipeline* pLibraries_) {this->pLibraries = pLibraries_; return *this; }
    PipelineLibraryCreateInfoKHR& setPLibraries(detail::span<const Pipeline> pLibraries_) {this->libraryCount = pLibraries_.size(); this->pLibraries = pLibraries_.data();  return *this; }
};
struct RayTracingPipelineCreateInfoKHR {
    StructureType sType{StructureType::RayTracingPipelineCreateInfoKHR};
    const void* pNext = nullptr;
    PipelineCreateFlags flags{};
    uint32_t stageCount{0};
    const PipelineShaderStageCreateInfo* pStages = nullptr;
    uint32_t groupCount{0};
    const RayTracingShaderGroupCreateInfoKHR* pGroups = nullptr;
    uint32_t maxPipelineRayRecursionDepth{0};
    const PipelineLibraryCreateInfoKHR* pLibraryInfo = nullptr;
    const RayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface = nullptr;
    const PipelineDynamicStateCreateInfo* pDynamicState = nullptr;
    PipelineLayout layout{};
    Pipeline basePipelineHandle{};
    int32_t basePipelineIndex{0};
    RayTracingPipelineCreateInfoKHR& setFlags(PipelineCreateFlags flags_) {this->flags = flags_; return *this; }
    RayTracingPipelineCreateInfoKHR& setStageCount(uint32_t stageCount_) {this->stageCount = stageCount_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPStages(const PipelineShaderStageCreateInfo* pStages_) {this->pStages = pStages_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPStages(detail::span<const PipelineShaderStageCreateInfo> pStages_) {this->stageCount = pStages_.size(); this->pStages = pStages_.data();  return *this; }
    RayTracingPipelineCreateInfoKHR& setGroupCount(uint32_t groupCount_) {this->groupCount = groupCount_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPGroups(const RayTracingShaderGroupCreateInfoKHR* pGroups_) {this->pGroups = pGroups_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPGroups(detail::span<const RayTracingShaderGroupCreateInfoKHR> pGroups_) {this->groupCount = pGroups_.size(); this->pGroups = pGroups_.data();  return *this; }
    RayTracingPipelineCreateInfoKHR& setMaxPipelineRayRecursionDepth(uint32_t maxPipelineRayRecursionDepth_) {this->maxPipelineRayRecursionDepth = maxPipelineRayRecursionDepth_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPLibraryInfo(const PipelineLibraryCreateInfoKHR* pLibraryInfo_) {this->pLibraryInfo = pLibraryInfo_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPLibraryInfo(PipelineLibraryCreateInfoKHR const& pLibraryInfo_) {this->pLibraryInfo = &pLibraryInfo_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPLibraryInterface(const RayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface_) {this->pLibraryInterface = pLibraryInterface_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPLibraryInterface(RayTracingPipelineInterfaceCreateInfoKHR const& pLibraryInterface_) {this->pLibraryInterface = &pLibraryInterface_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPDynamicState(const PipelineDynamicStateCreateInfo* pDynamicState_) {this->pDynamicState = pDynamicState_; return *this; }
    RayTracingPipelineCreateInfoKHR& setPDynamicState(PipelineDynamicStateCreateInfo const& pDynamicState_) {this->pDynamicState = &pDynamicState_; return *this; }
    RayTracingPipelineCreateInfoKHR& setLayout(PipelineLayout layout_) {this->layout = layout_; return *this; }
    RayTracingPipelineCreateInfoKHR& setBasePipelineHandle(Pipeline basePipelineHandle_) {this->basePipelineHandle = basePipelineHandle_; return *this; }
    RayTracingPipelineCreateInfoKHR& setBasePipelineIndex(int32_t basePipelineIndex_) {this->basePipelineIndex = basePipelineIndex_; return *this; }
};
struct GeometryTrianglesNV {
    StructureType sType{StructureType::GeometryTrianglesNV};
    const void* pNext = nullptr;
    Buffer vertexData{};
    DeviceSize vertexOffset{0};
    uint32_t vertexCount{0};
    DeviceSize vertexStride{0};
    Format vertexFormat{static_cast<Format>(0)};
    Buffer indexData{};
    DeviceSize indexOffset{0};
    uint32_t indexCount{0};
    IndexType indexType{static_cast<IndexType>(0)};
    Buffer transformData{};
    DeviceSize transformOffset{0};
    GeometryTrianglesNV& setVertexData(Buffer vertexData_) {this->vertexData = vertexData_; return *this; }
    GeometryTrianglesNV& setVertexOffset(DeviceSize vertexOffset_) {this->vertexOffset = vertexOffset_; return *this; }
    GeometryTrianglesNV& setVertexCount(uint32_t vertexCount_) {this->vertexCount = vertexCount_; return *this; }
    GeometryTrianglesNV& setVertexStride(DeviceSize vertexStride_) {this->vertexStride = vertexStride_; return *this; }
    GeometryTrianglesNV& setVertexFormat(Format vertexFormat_) {this->vertexFormat = vertexFormat_; return *this; }
    GeometryTrianglesNV& setIndexData(Buffer indexData_) {this->indexData = indexData_; return *this; }
    GeometryTrianglesNV& setIndexOffset(DeviceSize indexOffset_) {this->indexOffset = indexOffset_; return *this; }
    GeometryTrianglesNV& setIndexCount(uint32_t indexCount_) {this->indexCount = indexCount_; return *this; }
    GeometryTrianglesNV& setIndexType(IndexType indexType_) {this->indexType = indexType_; return *this; }
    GeometryTrianglesNV& setTransformData(Buffer transformData_) {this->transformData = transformData_; return *this; }
    GeometryTrianglesNV& setTransformOffset(DeviceSize transformOffset_) {this->transformOffset = transformOffset_; return *this; }
};
struct GeometryAABBNV {
    StructureType sType{StructureType::GeometryAabbNV};
    const void* pNext = nullptr;
    Buffer aabbData{};
    uint32_t numAABBs{0};
    uint32_t stride{0};
    DeviceSize offset{0};
    GeometryAABBNV& setAabbData(Buffer aabbData_) {this->aabbData = aabbData_; return *this; }
    GeometryAABBNV& setNumAABBs(uint32_t numAABBs_) {this->numAABBs = numAABBs_; return *this; }
    GeometryAABBNV& setStride(uint32_t stride_) {this->stride = stride_; return *this; }
    GeometryAABBNV& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
};
struct GeometryDataNV {
    GeometryTrianglesNV triangles{};
    GeometryAABBNV aabbs{};
    GeometryDataNV& setTriangles(GeometryTrianglesNV triangles_) {this->triangles = triangles_; return *this; }
    GeometryDataNV& setAabbs(GeometryAABBNV aabbs_) {this->aabbs = aabbs_; return *this; }
};
struct GeometryNV {
    StructureType sType{StructureType::GeometryNV};
    const void* pNext = nullptr;
    GeometryTypeKHR geometryType{static_cast<GeometryTypeKHR>(0)};
    GeometryDataNV geometry{};
    GeometryFlagsKHR flags{};
    GeometryNV& setGeometryType(GeometryTypeKHR geometryType_) {this->geometryType = geometryType_; return *this; }
    GeometryNV& setGeometry(GeometryDataNV geometry_) {this->geometry = geometry_; return *this; }
    GeometryNV& setFlags(GeometryFlagsKHR flags_) {this->flags = flags_; return *this; }
};
struct AccelerationStructureInfoNV {
    StructureType sType{StructureType::AccelerationStructureInfoNV};
    const void* pNext = nullptr;
    AccelerationStructureTypeNV type{static_cast<AccelerationStructureTypeNV>(0)};
    BuildAccelerationStructureFlagsNV flags{};
    uint32_t instanceCount{0};
    uint32_t geometryCount{0};
    const GeometryNV* pGeometries = nullptr;
    AccelerationStructureInfoNV& setType(AccelerationStructureTypeNV type_) {this->type = type_; return *this; }
    AccelerationStructureInfoNV& setFlags(BuildAccelerationStructureFlagsNV flags_) {this->flags = flags_; return *this; }
    AccelerationStructureInfoNV& setInstanceCount(uint32_t instanceCount_) {this->instanceCount = instanceCount_; return *this; }
    AccelerationStructureInfoNV& setGeometryCount(uint32_t geometryCount_) {this->geometryCount = geometryCount_; return *this; }
    AccelerationStructureInfoNV& setPGeometries(const GeometryNV* pGeometries_) {this->pGeometries = pGeometries_; return *this; }
    AccelerationStructureInfoNV& setPGeometries(detail::span<const GeometryNV> pGeometries_) {this->geometryCount = pGeometries_.size(); this->pGeometries = pGeometries_.data();  return *this; }
};
struct AccelerationStructureCreateInfoNV {
    StructureType sType{StructureType::AccelerationStructureCreateInfoNV};
    const void* pNext = nullptr;
    DeviceSize compactedSize{0};
    AccelerationStructureInfoNV info{};
    AccelerationStructureCreateInfoNV& setCompactedSize(DeviceSize compactedSize_) {this->compactedSize = compactedSize_; return *this; }
    AccelerationStructureCreateInfoNV& setInfo(AccelerationStructureInfoNV info_) {this->info = info_; return *this; }
};
struct BindAccelerationStructureMemoryInfoNV {
    StructureType sType{StructureType::BindAccelerationStructureMemoryInfoNV};
    const void* pNext = nullptr;
    AccelerationStructureNV accelerationStructure{};
    DeviceMemory memory{};
    DeviceSize memoryOffset{0};
    uint32_t deviceIndexCount{0};
    const uint32_t* pDeviceIndices = nullptr;
    BindAccelerationStructureMemoryInfoNV& setAccelerationStructure(AccelerationStructureNV accelerationStructure_) {this->accelerationStructure = accelerationStructure_; return *this; }
    BindAccelerationStructureMemoryInfoNV& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    BindAccelerationStructureMemoryInfoNV& setMemoryOffset(DeviceSize memoryOffset_) {this->memoryOffset = memoryOffset_; return *this; }
    BindAccelerationStructureMemoryInfoNV& setDeviceIndexCount(uint32_t deviceIndexCount_) {this->deviceIndexCount = deviceIndexCount_; return *this; }
    BindAccelerationStructureMemoryInfoNV& setPDeviceIndices(const uint32_t* pDeviceIndices_) {this->pDeviceIndices = pDeviceIndices_; return *this; }
    BindAccelerationStructureMemoryInfoNV& setPDeviceIndices(detail::span<const uint32_t> pDeviceIndices_) {this->deviceIndexCount = pDeviceIndices_.size(); this->pDeviceIndices = pDeviceIndices_.data();  return *this; }
};
struct WriteDescriptorSetAccelerationStructureKHR {
    StructureType sType{StructureType::WriteDescriptorSetAccelerationStructureKHR};
    const void* pNext = nullptr;
    uint32_t accelerationStructureCount{0};
    const AccelerationStructureKHR* pAccelerationStructures = nullptr;
    WriteDescriptorSetAccelerationStructureKHR& setAccelerationStructureCount(uint32_t accelerationStructureCount_) {this->accelerationStructureCount = accelerationStructureCount_; return *this; }
    WriteDescriptorSetAccelerationStructureKHR& setPAccelerationStructures(const AccelerationStructureKHR* pAccelerationStructures_) {this->pAccelerationStructures = pAccelerationStructures_; return *this; }
    WriteDescriptorSetAccelerationStructureKHR& setPAccelerationStructures(detail::span<const AccelerationStructureKHR> pAccelerationStructures_) {this->accelerationStructureCount = pAccelerationStructures_.size(); this->pAccelerationStructures = pAccelerationStructures_.data();  return *this; }
};
struct WriteDescriptorSetAccelerationStructureNV {
    StructureType sType{StructureType::WriteDescriptorSetAccelerationStructureNV};
    const void* pNext = nullptr;
    uint32_t accelerationStructureCount{0};
    const AccelerationStructureNV* pAccelerationStructures = nullptr;
    WriteDescriptorSetAccelerationStructureNV& setAccelerationStructureCount(uint32_t accelerationStructureCount_) {this->accelerationStructureCount = accelerationStructureCount_; return *this; }
    WriteDescriptorSetAccelerationStructureNV& setPAccelerationStructures(const AccelerationStructureNV* pAccelerationStructures_) {this->pAccelerationStructures = pAccelerationStructures_; return *this; }
    WriteDescriptorSetAccelerationStructureNV& setPAccelerationStructures(detail::span<const AccelerationStructureNV> pAccelerationStructures_) {this->accelerationStructureCount = pAccelerationStructures_.size(); this->pAccelerationStructures = pAccelerationStructures_.data();  return *this; }
};
struct AccelerationStructureMemoryRequirementsInfoNV {
    StructureType sType{StructureType::AccelerationStructureMemoryRequirementsInfoNV};
    const void* pNext = nullptr;
    AccelerationStructureMemoryRequirementsTypeNV type{static_cast<AccelerationStructureMemoryRequirementsTypeNV>(0)};
    AccelerationStructureNV accelerationStructure{};
    AccelerationStructureMemoryRequirementsInfoNV& setType(AccelerationStructureMemoryRequirementsTypeNV type_) {this->type = type_; return *this; }
    AccelerationStructureMemoryRequirementsInfoNV& setAccelerationStructure(AccelerationStructureNV accelerationStructure_) {this->accelerationStructure = accelerationStructure_; return *this; }
};
struct PhysicalDeviceAccelerationStructureFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceAccelerationStructureFeaturesKHR};
    void* pNext = nullptr;
    Bool32 accelerationStructure{0};
    Bool32 accelerationStructureCaptureReplay{0};
    Bool32 accelerationStructureIndirectBuild{0};
    Bool32 accelerationStructureHostCommands{0};
    Bool32 descriptorBindingAccelerationStructureUpdateAfterBind{0};
    PhysicalDeviceAccelerationStructureFeaturesKHR& setAccelerationStructure(Bool32 accelerationStructure_) {this->accelerationStructure = accelerationStructure_; return *this; }
    PhysicalDeviceAccelerationStructureFeaturesKHR& setAccelerationStructureCaptureReplay(Bool32 accelerationStructureCaptureReplay_) {this->accelerationStructureCaptureReplay = accelerationStructureCaptureReplay_; return *this; }
    PhysicalDeviceAccelerationStructureFeaturesKHR& setAccelerationStructureIndirectBuild(Bool32 accelerationStructureIndirectBuild_) {this->accelerationStructureIndirectBuild = accelerationStructureIndirectBuild_; return *this; }
    PhysicalDeviceAccelerationStructureFeaturesKHR& setAccelerationStructureHostCommands(Bool32 accelerationStructureHostCommands_) {this->accelerationStructureHostCommands = accelerationStructureHostCommands_; return *this; }
    PhysicalDeviceAccelerationStructureFeaturesKHR& setDescriptorBindingAccelerationStructureUpdateAfterBind(Bool32 descriptorBindingAccelerationStructureUpdateAfterBind_) {this->descriptorBindingAccelerationStructureUpdateAfterBind = descriptorBindingAccelerationStructureUpdateAfterBind_; return *this; }
};
struct PhysicalDeviceRayTracingPipelineFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceRayTracingPipelineFeaturesKHR};
    void* pNext = nullptr;
    Bool32 rayTracingPipeline{0};
    Bool32 rayTracingPipelineShaderGroupHandleCaptureReplay{0};
    Bool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed{0};
    Bool32 rayTracingPipelineTraceRaysIndirect{0};
    Bool32 rayTraversalPrimitiveCulling{0};
    PhysicalDeviceRayTracingPipelineFeaturesKHR& setRayTracingPipeline(Bool32 rayTracingPipeline_) {this->rayTracingPipeline = rayTracingPipeline_; return *this; }
    PhysicalDeviceRayTracingPipelineFeaturesKHR& setRayTracingPipelineShaderGroupHandleCaptureReplay(Bool32 rayTracingPipelineShaderGroupHandleCaptureReplay_) {this->rayTracingPipelineShaderGroupHandleCaptureReplay = rayTracingPipelineShaderGroupHandleCaptureReplay_; return *this; }
    PhysicalDeviceRayTracingPipelineFeaturesKHR& setRayTracingPipelineShaderGroupHandleCaptureReplayMixed(Bool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed_) {this->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = rayTracingPipelineShaderGroupHandleCaptureReplayMixed_; return *this; }
    PhysicalDeviceRayTracingPipelineFeaturesKHR& setRayTracingPipelineTraceRaysIndirect(Bool32 rayTracingPipelineTraceRaysIndirect_) {this->rayTracingPipelineTraceRaysIndirect = rayTracingPipelineTraceRaysIndirect_; return *this; }
    PhysicalDeviceRayTracingPipelineFeaturesKHR& setRayTraversalPrimitiveCulling(Bool32 rayTraversalPrimitiveCulling_) {this->rayTraversalPrimitiveCulling = rayTraversalPrimitiveCulling_; return *this; }
};
struct PhysicalDeviceRayQueryFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceRayQueryFeaturesKHR};
    void* pNext = nullptr;
    Bool32 rayQuery{0};
    PhysicalDeviceRayQueryFeaturesKHR& setRayQuery(Bool32 rayQuery_) {this->rayQuery = rayQuery_; return *this; }
};
struct PhysicalDeviceAccelerationStructurePropertiesKHR {
    StructureType sType{StructureType::PhysicalDeviceAccelerationStructurePropertiesKHR};
    void* pNext = nullptr;
    uint64_t maxGeometryCount{0};
    uint64_t maxInstanceCount{0};
    uint64_t maxPrimitiveCount{0};
    uint32_t maxPerStageDescriptorAccelerationStructures{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures{0};
    uint32_t maxDescriptorSetAccelerationStructures{0};
    uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures{0};
    uint32_t minAccelerationStructureScratchOffsetAlignment{0};
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxGeometryCount(uint64_t maxGeometryCount_) {this->maxGeometryCount = maxGeometryCount_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxInstanceCount(uint64_t maxInstanceCount_) {this->maxInstanceCount = maxInstanceCount_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxPrimitiveCount(uint64_t maxPrimitiveCount_) {this->maxPrimitiveCount = maxPrimitiveCount_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxPerStageDescriptorAccelerationStructures(uint32_t maxPerStageDescriptorAccelerationStructures_) {this->maxPerStageDescriptorAccelerationStructures = maxPerStageDescriptorAccelerationStructures_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxPerStageDescriptorUpdateAfterBindAccelerationStructures(uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures_) {this->maxPerStageDescriptorUpdateAfterBindAccelerationStructures = maxPerStageDescriptorUpdateAfterBindAccelerationStructures_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxDescriptorSetAccelerationStructures(uint32_t maxDescriptorSetAccelerationStructures_) {this->maxDescriptorSetAccelerationStructures = maxDescriptorSetAccelerationStructures_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMaxDescriptorSetUpdateAfterBindAccelerationStructures(uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures_) {this->maxDescriptorSetUpdateAfterBindAccelerationStructures = maxDescriptorSetUpdateAfterBindAccelerationStructures_; return *this; }
    PhysicalDeviceAccelerationStructurePropertiesKHR& setMinAccelerationStructureScratchOffsetAlignment(uint32_t minAccelerationStructureScratchOffsetAlignment_) {this->minAccelerationStructureScratchOffsetAlignment = minAccelerationStructureScratchOffsetAlignment_; return *this; }
};
struct PhysicalDeviceRayTracingPipelinePropertiesKHR {
    StructureType sType{StructureType::PhysicalDeviceRayTracingPipelinePropertiesKHR};
    void* pNext = nullptr;
    uint32_t shaderGroupHandleSize{0};
    uint32_t maxRayRecursionDepth{0};
    uint32_t maxShaderGroupStride{0};
    uint32_t shaderGroupBaseAlignment{0};
    uint32_t shaderGroupHandleCaptureReplaySize{0};
    uint32_t maxRayDispatchInvocationCount{0};
    uint32_t shaderGroupHandleAlignment{0};
    uint32_t maxRayHitAttributeSize{0};
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setShaderGroupHandleSize(uint32_t shaderGroupHandleSize_) {this->shaderGroupHandleSize = shaderGroupHandleSize_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setMaxRayRecursionDepth(uint32_t maxRayRecursionDepth_) {this->maxRayRecursionDepth = maxRayRecursionDepth_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setMaxShaderGroupStride(uint32_t maxShaderGroupStride_) {this->maxShaderGroupStride = maxShaderGroupStride_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setShaderGroupBaseAlignment(uint32_t shaderGroupBaseAlignment_) {this->shaderGroupBaseAlignment = shaderGroupBaseAlignment_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setShaderGroupHandleCaptureReplaySize(uint32_t shaderGroupHandleCaptureReplaySize_) {this->shaderGroupHandleCaptureReplaySize = shaderGroupHandleCaptureReplaySize_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setMaxRayDispatchInvocationCount(uint32_t maxRayDispatchInvocationCount_) {this->maxRayDispatchInvocationCount = maxRayDispatchInvocationCount_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setShaderGroupHandleAlignment(uint32_t shaderGroupHandleAlignment_) {this->shaderGroupHandleAlignment = shaderGroupHandleAlignment_; return *this; }
    PhysicalDeviceRayTracingPipelinePropertiesKHR& setMaxRayHitAttributeSize(uint32_t maxRayHitAttributeSize_) {this->maxRayHitAttributeSize = maxRayHitAttributeSize_; return *this; }
};
struct PhysicalDeviceRayTracingPropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceRayTracingPropertiesNV};
    void* pNext = nullptr;
    uint32_t shaderGroupHandleSize{0};
    uint32_t maxRecursionDepth{0};
    uint32_t maxShaderGroupStride{0};
    uint32_t shaderGroupBaseAlignment{0};
    uint64_t maxGeometryCount{0};
    uint64_t maxInstanceCount{0};
    uint64_t maxTriangleCount{0};
    uint32_t maxDescriptorSetAccelerationStructures{0};
    PhysicalDeviceRayTracingPropertiesNV& setShaderGroupHandleSize(uint32_t shaderGroupHandleSize_) {this->shaderGroupHandleSize = shaderGroupHandleSize_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setMaxRecursionDepth(uint32_t maxRecursionDepth_) {this->maxRecursionDepth = maxRecursionDepth_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setMaxShaderGroupStride(uint32_t maxShaderGroupStride_) {this->maxShaderGroupStride = maxShaderGroupStride_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setShaderGroupBaseAlignment(uint32_t shaderGroupBaseAlignment_) {this->shaderGroupBaseAlignment = shaderGroupBaseAlignment_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setMaxGeometryCount(uint64_t maxGeometryCount_) {this->maxGeometryCount = maxGeometryCount_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setMaxInstanceCount(uint64_t maxInstanceCount_) {this->maxInstanceCount = maxInstanceCount_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setMaxTriangleCount(uint64_t maxTriangleCount_) {this->maxTriangleCount = maxTriangleCount_; return *this; }
    PhysicalDeviceRayTracingPropertiesNV& setMaxDescriptorSetAccelerationStructures(uint32_t maxDescriptorSetAccelerationStructures_) {this->maxDescriptorSetAccelerationStructures = maxDescriptorSetAccelerationStructures_; return *this; }
};
struct StridedDeviceAddressRegionKHR {
    DeviceAddress deviceAddress{0};
    DeviceSize stride{0};
    DeviceSize size{0};
    constexpr bool operator==(StridedDeviceAddressRegionKHR const& value) const {
        return deviceAddress == value.deviceAddress && stride == value.stride && size == value.size ;}
    constexpr bool operator!=(StridedDeviceAddressRegionKHR const& value) const {return !(*this == value);}
    StridedDeviceAddressRegionKHR& setDeviceAddress(DeviceAddress deviceAddress_) {this->deviceAddress = deviceAddress_; return *this; }
    StridedDeviceAddressRegionKHR& setStride(DeviceSize stride_) {this->stride = stride_; return *this; }
    StridedDeviceAddressRegionKHR& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
struct TraceRaysIndirectCommandKHR {
    uint32_t width{0};
    uint32_t height{0};
    uint32_t depth{0};
    constexpr bool operator==(TraceRaysIndirectCommandKHR const& value) const {
        return width == value.width && height == value.height && depth == value.depth ;}
    constexpr bool operator!=(TraceRaysIndirectCommandKHR const& value) const {return !(*this == value);}
    TraceRaysIndirectCommandKHR& setWidth(uint32_t width_) {this->width = width_; return *this; }
    TraceRaysIndirectCommandKHR& setHeight(uint32_t height_) {this->height = height_; return *this; }
    TraceRaysIndirectCommandKHR& setDepth(uint32_t depth_) {this->depth = depth_; return *this; }
};
struct DrmFormatModifierPropertiesEXT {
    uint64_t drmFormatModifier{0};
    uint32_t drmFormatModifierPlaneCount{0};
    FormatFeatureFlags drmFormatModifierTilingFeatures{};
    constexpr bool operator==(DrmFormatModifierPropertiesEXT const& value) const {
        return drmFormatModifier == value.drmFormatModifier && drmFormatModifierPlaneCount == value.drmFormatModifierPlaneCount && drmFormatModifierTilingFeatures == value.drmFormatModifierTilingFeatures 
        ;}
    constexpr bool operator!=(DrmFormatModifierPropertiesEXT const& value) const {return !(*this == value);}
    DrmFormatModifierPropertiesEXT& setDrmFormatModifier(uint64_t drmFormatModifier_) {this->drmFormatModifier = drmFormatModifier_; return *this; }
    DrmFormatModifierPropertiesEXT& setDrmFormatModifierPlaneCount(uint32_t drmFormatModifierPlaneCount_) {this->drmFormatModifierPlaneCount = drmFormatModifierPlaneCount_; return *this; }
    DrmFormatModifierPropertiesEXT& setDrmFormatModifierTilingFeatures(FormatFeatureFlags drmFormatModifierTilingFeatures_) {this->drmFormatModifierTilingFeatures = drmFormatModifierTilingFeatures_; return *this; }
};
struct DrmFormatModifierPropertiesListEXT {
    StructureType sType{StructureType::DrmFormatModifierPropertiesListEXT};
    void* pNext = nullptr;
    uint32_t drmFormatModifierCount{0};
    DrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties = nullptr;
    DrmFormatModifierPropertiesListEXT& setDrmFormatModifierCount(uint32_t drmFormatModifierCount_) {this->drmFormatModifierCount = drmFormatModifierCount_; return *this; }
    DrmFormatModifierPropertiesListEXT& setPDrmFormatModifierProperties(DrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties_) {this->pDrmFormatModifierProperties = pDrmFormatModifierProperties_; return *this; }
    DrmFormatModifierPropertiesListEXT& setPDrmFormatModifierProperties(detail::span<DrmFormatModifierPropertiesEXT> pDrmFormatModifierProperties_) {this->drmFormatModifierCount = pDrmFormatModifierProperties_.size(); this->pDrmFormatModifierProperties = pDrmFormatModifierProperties_.data();  return *this; }
};
struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
    StructureType sType{StructureType::PhysicalDeviceImageDrmFormatModifierInfoEXT};
    const void* pNext = nullptr;
    uint64_t drmFormatModifier{0};
    SharingMode sharingMode{static_cast<SharingMode>(0)};
    uint32_t queueFamilyIndexCount{0};
    const uint32_t* pQueueFamilyIndices = nullptr;
    PhysicalDeviceImageDrmFormatModifierInfoEXT& setDrmFormatModifier(uint64_t drmFormatModifier_) {this->drmFormatModifier = drmFormatModifier_; return *this; }
    PhysicalDeviceImageDrmFormatModifierInfoEXT& setSharingMode(SharingMode sharingMode_) {this->sharingMode = sharingMode_; return *this; }
    PhysicalDeviceImageDrmFormatModifierInfoEXT& setQueueFamilyIndexCount(uint32_t queueFamilyIndexCount_) {this->queueFamilyIndexCount = queueFamilyIndexCount_; return *this; }
    PhysicalDeviceImageDrmFormatModifierInfoEXT& setPQueueFamilyIndices(const uint32_t* pQueueFamilyIndices_) {this->pQueueFamilyIndices = pQueueFamilyIndices_; return *this; }
    PhysicalDeviceImageDrmFormatModifierInfoEXT& setPQueueFamilyIndices(detail::span<const uint32_t> pQueueFamilyIndices_) {this->queueFamilyIndexCount = pQueueFamilyIndices_.size(); this->pQueueFamilyIndices = pQueueFamilyIndices_.data();  return *this; }
};
struct ImageDrmFormatModifierListCreateInfoEXT {
    StructureType sType{StructureType::ImageDrmFormatModifierListCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t drmFormatModifierCount{0};
    const uint64_t* pDrmFormatModifiers = nullptr;
    ImageDrmFormatModifierListCreateInfoEXT& setDrmFormatModifierCount(uint32_t drmFormatModifierCount_) {this->drmFormatModifierCount = drmFormatModifierCount_; return *this; }
    ImageDrmFormatModifierListCreateInfoEXT& setPDrmFormatModifiers(const uint64_t* pDrmFormatModifiers_) {this->pDrmFormatModifiers = pDrmFormatModifiers_; return *this; }
    ImageDrmFormatModifierListCreateInfoEXT& setPDrmFormatModifiers(detail::span<const uint64_t> pDrmFormatModifiers_) {this->drmFormatModifierCount = pDrmFormatModifiers_.size(); this->pDrmFormatModifiers = pDrmFormatModifiers_.data();  return *this; }
};
struct ImageDrmFormatModifierExplicitCreateInfoEXT {
    StructureType sType{StructureType::ImageDrmFormatModifierExplicitCreateInfoEXT};
    const void* pNext = nullptr;
    uint64_t drmFormatModifier{0};
    uint32_t drmFormatModifierPlaneCount{0};
    const SubresourceLayout* pPlaneLayouts = nullptr;
    ImageDrmFormatModifierExplicitCreateInfoEXT& setDrmFormatModifier(uint64_t drmFormatModifier_) {this->drmFormatModifier = drmFormatModifier_; return *this; }
    ImageDrmFormatModifierExplicitCreateInfoEXT& setDrmFormatModifierPlaneCount(uint32_t drmFormatModifierPlaneCount_) {this->drmFormatModifierPlaneCount = drmFormatModifierPlaneCount_; return *this; }
    ImageDrmFormatModifierExplicitCreateInfoEXT& setPPlaneLayouts(const SubresourceLayout* pPlaneLayouts_) {this->pPlaneLayouts = pPlaneLayouts_; return *this; }
    ImageDrmFormatModifierExplicitCreateInfoEXT& setPPlaneLayouts(detail::span<const SubresourceLayout> pPlaneLayouts_) {this->drmFormatModifierPlaneCount = pPlaneLayouts_.size(); this->pPlaneLayouts = pPlaneLayouts_.data();  return *this; }
};
struct ImageDrmFormatModifierPropertiesEXT {
    StructureType sType{StructureType::ImageDrmFormatModifierPropertiesEXT};
    void* pNext = nullptr;
    uint64_t drmFormatModifier{0};
    ImageDrmFormatModifierPropertiesEXT& setDrmFormatModifier(uint64_t drmFormatModifier_) {this->drmFormatModifier = drmFormatModifier_; return *this; }
};
struct ImageStencilUsageCreateInfo {
    StructureType sType{StructureType::ImageStencilUsageCreateInfo};
    const void* pNext = nullptr;
    ImageUsageFlags stencilUsage{};
    ImageStencilUsageCreateInfo& setStencilUsage(ImageUsageFlags stencilUsage_) {this->stencilUsage = stencilUsage_; return *this; }
};
using ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
struct DeviceMemoryOverallocationCreateInfoAMD {
    StructureType sType{StructureType::DeviceMemoryOverallocationCreateInfoAMD};
    const void* pNext = nullptr;
    MemoryOverallocationBehaviorAMD overallocationBehavior{static_cast<MemoryOverallocationBehaviorAMD>(0)};
    DeviceMemoryOverallocationCreateInfoAMD& setOverallocationBehavior(MemoryOverallocationBehaviorAMD overallocationBehavior_) {this->overallocationBehavior = overallocationBehavior_; return *this; }
};
struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceFragmentDensityMapFeaturesEXT};
    void* pNext = nullptr;
    Bool32 fragmentDensityMap{0};
    Bool32 fragmentDensityMapDynamic{0};
    Bool32 fragmentDensityMapNonSubsampledImages{0};
    PhysicalDeviceFragmentDensityMapFeaturesEXT& setFragmentDensityMap(Bool32 fragmentDensityMap_) {this->fragmentDensityMap = fragmentDensityMap_; return *this; }
    PhysicalDeviceFragmentDensityMapFeaturesEXT& setFragmentDensityMapDynamic(Bool32 fragmentDensityMapDynamic_) {this->fragmentDensityMapDynamic = fragmentDensityMapDynamic_; return *this; }
    PhysicalDeviceFragmentDensityMapFeaturesEXT& setFragmentDensityMapNonSubsampledImages(Bool32 fragmentDensityMapNonSubsampledImages_) {this->fragmentDensityMapNonSubsampledImages = fragmentDensityMapNonSubsampledImages_; return *this; }
};
struct PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceFragmentDensityMap2FeaturesEXT};
    void* pNext = nullptr;
    Bool32 fragmentDensityMapDeferred{0};
    PhysicalDeviceFragmentDensityMap2FeaturesEXT& setFragmentDensityMapDeferred(Bool32 fragmentDensityMapDeferred_) {this->fragmentDensityMapDeferred = fragmentDensityMapDeferred_; return *this; }
};
struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceFragmentDensityMapPropertiesEXT};
    void* pNext = nullptr;
    Extent2D minFragmentDensityTexelSize{};
    Extent2D maxFragmentDensityTexelSize{};
    Bool32 fragmentDensityInvocations{0};
    PhysicalDeviceFragmentDensityMapPropertiesEXT& setMinFragmentDensityTexelSize(Extent2D minFragmentDensityTexelSize_) {this->minFragmentDensityTexelSize = minFragmentDensityTexelSize_; return *this; }
    PhysicalDeviceFragmentDensityMapPropertiesEXT& setMaxFragmentDensityTexelSize(Extent2D maxFragmentDensityTexelSize_) {this->maxFragmentDensityTexelSize = maxFragmentDensityTexelSize_; return *this; }
    PhysicalDeviceFragmentDensityMapPropertiesEXT& setFragmentDensityInvocations(Bool32 fragmentDensityInvocations_) {this->fragmentDensityInvocations = fragmentDensityInvocations_; return *this; }
};
struct PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceFragmentDensityMap2PropertiesEXT};
    void* pNext = nullptr;
    Bool32 subsampledLoads{0};
    Bool32 subsampledCoarseReconstructionEarlyAccess{0};
    uint32_t maxSubsampledArrayLayers{0};
    uint32_t maxDescriptorSetSubsampledSamplers{0};
    PhysicalDeviceFragmentDensityMap2PropertiesEXT& setSubsampledLoads(Bool32 subsampledLoads_) {this->subsampledLoads = subsampledLoads_; return *this; }
    PhysicalDeviceFragmentDensityMap2PropertiesEXT& setSubsampledCoarseReconstructionEarlyAccess(Bool32 subsampledCoarseReconstructionEarlyAccess_) {this->subsampledCoarseReconstructionEarlyAccess = subsampledCoarseReconstructionEarlyAccess_; return *this; }
    PhysicalDeviceFragmentDensityMap2PropertiesEXT& setMaxSubsampledArrayLayers(uint32_t maxSubsampledArrayLayers_) {this->maxSubsampledArrayLayers = maxSubsampledArrayLayers_; return *this; }
    PhysicalDeviceFragmentDensityMap2PropertiesEXT& setMaxDescriptorSetSubsampledSamplers(uint32_t maxDescriptorSetSubsampledSamplers_) {this->maxDescriptorSetSubsampledSamplers = maxDescriptorSetSubsampledSamplers_; return *this; }
};
struct RenderPassFragmentDensityMapCreateInfoEXT {
    StructureType sType{StructureType::RenderPassFragmentDensityMapCreateInfoEXT};
    const void* pNext = nullptr;
    AttachmentReference fragmentDensityMapAttachment{};
    RenderPassFragmentDensityMapCreateInfoEXT& setFragmentDensityMapAttachment(AttachmentReference fragmentDensityMapAttachment_) {this->fragmentDensityMapAttachment = fragmentDensityMapAttachment_; return *this; }
};
struct PhysicalDeviceScalarBlockLayoutFeatures {
    StructureType sType{StructureType::PhysicalDeviceScalarBlockLayoutFeatures};
    void* pNext = nullptr;
    Bool32 scalarBlockLayout{0};
    PhysicalDeviceScalarBlockLayoutFeatures& setScalarBlockLayout(Bool32 scalarBlockLayout_) {this->scalarBlockLayout = scalarBlockLayout_; return *this; }
};
using PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
struct SurfaceProtectedCapabilitiesKHR {
    StructureType sType{StructureType::SurfaceProtectedCapabilitiesKHR};
    const void* pNext = nullptr;
    Bool32 supportsProtected{0};
    SurfaceProtectedCapabilitiesKHR& setSupportsProtected(Bool32 supportsProtected_) {this->supportsProtected = supportsProtected_; return *this; }
};
struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    StructureType sType{StructureType::PhysicalDeviceUniformBufferStandardLayoutFeatures};
    void* pNext = nullptr;
    Bool32 uniformBufferStandardLayout{0};
    PhysicalDeviceUniformBufferStandardLayoutFeatures& setUniformBufferStandardLayout(Bool32 uniformBufferStandardLayout_) {this->uniformBufferStandardLayout = uniformBufferStandardLayout_; return *this; }
};
using PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
struct PhysicalDeviceDepthClipEnableFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceDepthClipEnableFeaturesEXT};
    void* pNext = nullptr;
    Bool32 depthClipEnable{0};
    PhysicalDeviceDepthClipEnableFeaturesEXT& setDepthClipEnable(Bool32 depthClipEnable_) {this->depthClipEnable = depthClipEnable_; return *this; }
};
struct PipelineRasterizationDepthClipStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineRasterizationDepthClipStateCreateInfoEXT};
    const void* pNext = nullptr;
    PipelineRasterizationDepthClipStateCreateFlagsEXT flags{};
    Bool32 depthClipEnable{0};
    PipelineRasterizationDepthClipStateCreateInfoEXT& setFlags(PipelineRasterizationDepthClipStateCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    PipelineRasterizationDepthClipStateCreateInfoEXT& setDepthClipEnable(Bool32 depthClipEnable_) {this->depthClipEnable = depthClipEnable_; return *this; }
};
struct PhysicalDeviceMemoryBudgetPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceMemoryBudgetPropertiesEXT};
    void* pNext = nullptr;
    DeviceSize heapBudget[MAX_MEMORY_HEAPS];
    DeviceSize heapUsage[MAX_MEMORY_HEAPS];
    PhysicalDeviceMemoryBudgetPropertiesEXT& setHeapBudget(DeviceSize heapBudget_[MAX_MEMORY_HEAPS]) {for(uint32_t i = 0; i < MAX_MEMORY_HEAPS; i++) this->heapBudget[i] = heapBudget_[i]; return *this; }
    PhysicalDeviceMemoryBudgetPropertiesEXT& setHeapUsage(DeviceSize heapUsage_[MAX_MEMORY_HEAPS]) {for(uint32_t i = 0; i < MAX_MEMORY_HEAPS; i++) this->heapUsage[i] = heapUsage_[i]; return *this; }
};
struct PhysicalDeviceMemoryPriorityFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceMemoryPriorityFeaturesEXT};
    void* pNext = nullptr;
    Bool32 memoryPriority{0};
    PhysicalDeviceMemoryPriorityFeaturesEXT& setMemoryPriority(Bool32 memoryPriority_) {this->memoryPriority = memoryPriority_; return *this; }
};
struct MemoryPriorityAllocateInfoEXT {
    StructureType sType{StructureType::MemoryPriorityAllocateInfoEXT};
    const void* pNext = nullptr;
    float priority{0.f};
    MemoryPriorityAllocateInfoEXT& setPriority(float priority_) {this->priority = priority_; return *this; }
};
struct PhysicalDeviceBufferDeviceAddressFeatures {
    StructureType sType{StructureType::PhysicalDeviceBufferDeviceAddressFeatures};
    void* pNext = nullptr;
    Bool32 bufferDeviceAddress{0};
    Bool32 bufferDeviceAddressCaptureReplay{0};
    Bool32 bufferDeviceAddressMultiDevice{0};
    PhysicalDeviceBufferDeviceAddressFeatures& setBufferDeviceAddress(Bool32 bufferDeviceAddress_) {this->bufferDeviceAddress = bufferDeviceAddress_; return *this; }
    PhysicalDeviceBufferDeviceAddressFeatures& setBufferDeviceAddressCaptureReplay(Bool32 bufferDeviceAddressCaptureReplay_) {this->bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay_; return *this; }
    PhysicalDeviceBufferDeviceAddressFeatures& setBufferDeviceAddressMultiDevice(Bool32 bufferDeviceAddressMultiDevice_) {this->bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice_; return *this; }
};
using PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
struct PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceBufferDeviceAddressFeaturesEXT};
    void* pNext = nullptr;
    Bool32 bufferDeviceAddress{0};
    Bool32 bufferDeviceAddressCaptureReplay{0};
    Bool32 bufferDeviceAddressMultiDevice{0};
    PhysicalDeviceBufferDeviceAddressFeaturesEXT& setBufferDeviceAddress(Bool32 bufferDeviceAddress_) {this->bufferDeviceAddress = bufferDeviceAddress_; return *this; }
    PhysicalDeviceBufferDeviceAddressFeaturesEXT& setBufferDeviceAddressCaptureReplay(Bool32 bufferDeviceAddressCaptureReplay_) {this->bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay_; return *this; }
    PhysicalDeviceBufferDeviceAddressFeaturesEXT& setBufferDeviceAddressMultiDevice(Bool32 bufferDeviceAddressMultiDevice_) {this->bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice_; return *this; }
};
using PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
struct BufferDeviceAddressInfo {
    StructureType sType{StructureType::BufferDeviceAddressInfo};
    const void* pNext = nullptr;
    Buffer buffer{};
    BufferDeviceAddressInfo& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
};
using BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
using BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
struct BufferOpaqueCaptureAddressCreateInfo {
    StructureType sType{StructureType::BufferOpaqueCaptureAddressCreateInfo};
    const void* pNext = nullptr;
    uint64_t opaqueCaptureAddress{0};
    BufferOpaqueCaptureAddressCreateInfo& setOpaqueCaptureAddress(uint64_t opaqueCaptureAddress_) {this->opaqueCaptureAddress = opaqueCaptureAddress_; return *this; }
};
using BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
struct BufferDeviceAddressCreateInfoEXT {
    StructureType sType{StructureType::BufferDeviceAddressCreateInfoEXT};
    const void* pNext = nullptr;
    DeviceAddress deviceAddress{0};
    BufferDeviceAddressCreateInfoEXT& setDeviceAddress(DeviceAddress deviceAddress_) {this->deviceAddress = deviceAddress_; return *this; }
};
struct PhysicalDeviceImageViewImageFormatInfoEXT {
    StructureType sType{StructureType::PhysicalDeviceImageViewImageFormatInfoEXT};
    void* pNext = nullptr;
    ImageViewType imageViewType{static_cast<ImageViewType>(0)};
    PhysicalDeviceImageViewImageFormatInfoEXT& setImageViewType(ImageViewType imageViewType_) {this->imageViewType = imageViewType_; return *this; }
};
struct FilterCubicImageViewImageFormatPropertiesEXT {
    StructureType sType{StructureType::FilterCubicImageViewImageFormatPropertiesEXT};
    void* pNext = nullptr;
    Bool32 filterCubic{0};
    Bool32 filterCubicMinmax{0};
    FilterCubicImageViewImageFormatPropertiesEXT& setFilterCubic(Bool32 filterCubic_) {this->filterCubic = filterCubic_; return *this; }
    FilterCubicImageViewImageFormatPropertiesEXT& setFilterCubicMinmax(Bool32 filterCubicMinmax_) {this->filterCubicMinmax = filterCubicMinmax_; return *this; }
};
struct PhysicalDeviceImagelessFramebufferFeatures {
    StructureType sType{StructureType::PhysicalDeviceImagelessFramebufferFeatures};
    void* pNext = nullptr;
    Bool32 imagelessFramebuffer{0};
    PhysicalDeviceImagelessFramebufferFeatures& setImagelessFramebuffer(Bool32 imagelessFramebuffer_) {this->imagelessFramebuffer = imagelessFramebuffer_; return *this; }
};
using PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
struct FramebufferAttachmentImageInfo {
    StructureType sType{StructureType::FramebufferAttachmentImageInfo};
    const void* pNext = nullptr;
    ImageCreateFlags flags{};
    ImageUsageFlags usage{};
    uint32_t width{0};
    uint32_t height{0};
    uint32_t layerCount{0};
    uint32_t viewFormatCount{0};
    const Format* pViewFormats = nullptr;
    FramebufferAttachmentImageInfo& setFlags(ImageCreateFlags flags_) {this->flags = flags_; return *this; }
    FramebufferAttachmentImageInfo& setUsage(ImageUsageFlags usage_) {this->usage = usage_; return *this; }
    FramebufferAttachmentImageInfo& setWidth(uint32_t width_) {this->width = width_; return *this; }
    FramebufferAttachmentImageInfo& setHeight(uint32_t height_) {this->height = height_; return *this; }
    FramebufferAttachmentImageInfo& setLayerCount(uint32_t layerCount_) {this->layerCount = layerCount_; return *this; }
    FramebufferAttachmentImageInfo& setViewFormatCount(uint32_t viewFormatCount_) {this->viewFormatCount = viewFormatCount_; return *this; }
    FramebufferAttachmentImageInfo& setPViewFormats(const Format* pViewFormats_) {this->pViewFormats = pViewFormats_; return *this; }
    FramebufferAttachmentImageInfo& setPViewFormats(detail::span<const Format> pViewFormats_) {this->viewFormatCount = pViewFormats_.size(); this->pViewFormats = pViewFormats_.data();  return *this; }
};
struct FramebufferAttachmentsCreateInfo {
    StructureType sType{StructureType::FramebufferAttachmentsCreateInfo};
    const void* pNext = nullptr;
    uint32_t attachmentImageInfoCount{0};
    const FramebufferAttachmentImageInfo* pAttachmentImageInfos = nullptr;
    FramebufferAttachmentsCreateInfo& setAttachmentImageInfoCount(uint32_t attachmentImageInfoCount_) {this->attachmentImageInfoCount = attachmentImageInfoCount_; return *this; }
    FramebufferAttachmentsCreateInfo& setPAttachmentImageInfos(const FramebufferAttachmentImageInfo* pAttachmentImageInfos_) {this->pAttachmentImageInfos = pAttachmentImageInfos_; return *this; }
    FramebufferAttachmentsCreateInfo& setPAttachmentImageInfos(detail::span<const FramebufferAttachmentImageInfo> pAttachmentImageInfos_) {this->attachmentImageInfoCount = pAttachmentImageInfos_.size(); this->pAttachmentImageInfos = pAttachmentImageInfos_.data();  return *this; }
};
using FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
using FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
struct RenderPassAttachmentBeginInfo {
    StructureType sType{StructureType::RenderPassAttachmentBeginInfo};
    const void* pNext = nullptr;
    uint32_t attachmentCount{0};
    const ImageView* pAttachments = nullptr;
    RenderPassAttachmentBeginInfo& setAttachmentCount(uint32_t attachmentCount_) {this->attachmentCount = attachmentCount_; return *this; }
    RenderPassAttachmentBeginInfo& setPAttachments(const ImageView* pAttachments_) {this->pAttachments = pAttachments_; return *this; }
    RenderPassAttachmentBeginInfo& setPAttachments(detail::span<const ImageView> pAttachments_) {this->attachmentCount = pAttachments_.size(); this->pAttachments = pAttachments_.data();  return *this; }
};
using RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
struct PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceTextureCompressionAstcHdrFeaturesEXT};
    void* pNext = nullptr;
    Bool32 textureCompressionASTC_HDR{0};
    PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT& setTextureCompressionASTC_HDR(Bool32 textureCompressionASTC_HDR_) {this->textureCompressionASTC_HDR = textureCompressionASTC_HDR_; return *this; }
};
struct PhysicalDeviceCooperativeMatrixFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceCooperativeMatrixFeaturesNV};
    void* pNext = nullptr;
    Bool32 cooperativeMatrix{0};
    Bool32 cooperativeMatrixRobustBufferAccess{0};
    PhysicalDeviceCooperativeMatrixFeaturesNV& setCooperativeMatrix(Bool32 cooperativeMatrix_) {this->cooperativeMatrix = cooperativeMatrix_; return *this; }
    PhysicalDeviceCooperativeMatrixFeaturesNV& setCooperativeMatrixRobustBufferAccess(Bool32 cooperativeMatrixRobustBufferAccess_) {this->cooperativeMatrixRobustBufferAccess = cooperativeMatrixRobustBufferAccess_; return *this; }
};
struct PhysicalDeviceCooperativeMatrixPropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceCooperativeMatrixPropertiesNV};
    void* pNext = nullptr;
    ShaderStageFlags cooperativeMatrixSupportedStages{};
    PhysicalDeviceCooperativeMatrixPropertiesNV& setCooperativeMatrixSupportedStages(ShaderStageFlags cooperativeMatrixSupportedStages_) {this->cooperativeMatrixSupportedStages = cooperativeMatrixSupportedStages_; return *this; }
};
struct CooperativeMatrixPropertiesNV {
    StructureType sType{StructureType::CooperativeMatrixPropertiesNV};
    void* pNext = nullptr;
    uint32_t MSize{0};
    uint32_t NSize{0};
    uint32_t KSize{0};
    ComponentTypeNV AType{static_cast<ComponentTypeNV>(0)};
    ComponentTypeNV BType{static_cast<ComponentTypeNV>(0)};
    ComponentTypeNV CType{static_cast<ComponentTypeNV>(0)};
    ComponentTypeNV DType{static_cast<ComponentTypeNV>(0)};
    ScopeNV scope{static_cast<ScopeNV>(0)};
    CooperativeMatrixPropertiesNV& setMSize(uint32_t MSize_) {this->MSize = MSize_; return *this; }
    CooperativeMatrixPropertiesNV& setNSize(uint32_t NSize_) {this->NSize = NSize_; return *this; }
    CooperativeMatrixPropertiesNV& setKSize(uint32_t KSize_) {this->KSize = KSize_; return *this; }
    CooperativeMatrixPropertiesNV& setAType(ComponentTypeNV AType_) {this->AType = AType_; return *this; }
    CooperativeMatrixPropertiesNV& setBType(ComponentTypeNV BType_) {this->BType = BType_; return *this; }
    CooperativeMatrixPropertiesNV& setCType(ComponentTypeNV CType_) {this->CType = CType_; return *this; }
    CooperativeMatrixPropertiesNV& setDType(ComponentTypeNV DType_) {this->DType = DType_; return *this; }
    CooperativeMatrixPropertiesNV& setScope(ScopeNV scope_) {this->scope = scope_; return *this; }
};
struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceYcbcrImageArraysFeaturesEXT};
    void* pNext = nullptr;
    Bool32 ycbcrImageArrays{0};
    PhysicalDeviceYcbcrImageArraysFeaturesEXT& setYcbcrImageArrays(Bool32 ycbcrImageArrays_) {this->ycbcrImageArrays = ycbcrImageArrays_; return *this; }
};
struct ImageViewHandleInfoNVX {
    StructureType sType{StructureType::ImageViewHandleInfoNVX};
    const void* pNext = nullptr;
    ImageView imageView{};
    DescriptorType descriptorType{static_cast<DescriptorType>(0)};
    Sampler sampler{};
    ImageViewHandleInfoNVX& setImageView(ImageView imageView_) {this->imageView = imageView_; return *this; }
    ImageViewHandleInfoNVX& setDescriptorType(DescriptorType descriptorType_) {this->descriptorType = descriptorType_; return *this; }
    ImageViewHandleInfoNVX& setSampler(Sampler sampler_) {this->sampler = sampler_; return *this; }
};
struct ImageViewAddressPropertiesNVX {
    StructureType sType{StructureType::ImageViewAddressPropertiesNVX};
    void* pNext = nullptr;
    DeviceAddress deviceAddress{0};
    DeviceSize size{0};
    ImageViewAddressPropertiesNVX& setDeviceAddress(DeviceAddress deviceAddress_) {this->deviceAddress = deviceAddress_; return *this; }
    ImageViewAddressPropertiesNVX& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
#if defined(VK_USE_PLATFORM_GGP)
struct PresentFrameTokenGGP {
    StructureType sType{StructureType::PresentFrameTokenGGP};
    const void* pNext = nullptr;
    GgpFrameToken frameToken{};
    PresentFrameTokenGGP& setFrameToken(GgpFrameToken frameToken_) {this->frameToken = frameToken_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_GGP)
struct PipelineCreationFeedbackEXT {
    PipelineCreationFeedbackFlagsEXT flags{};
    uint64_t duration{0};
    constexpr bool operator==(PipelineCreationFeedbackEXT const& value) const {
        return flags == value.flags && duration == value.duration ;}
    constexpr bool operator!=(PipelineCreationFeedbackEXT const& value) const {return !(*this == value);}
    PipelineCreationFeedbackEXT& setFlags(PipelineCreationFeedbackFlagsEXT flags_) {this->flags = flags_; return *this; }
    PipelineCreationFeedbackEXT& setDuration(uint64_t duration_) {this->duration = duration_; return *this; }
};
struct PipelineCreationFeedbackCreateInfoEXT {
    StructureType sType{StructureType::PipelineCreationFeedbackCreateInfoEXT};
    const void* pNext = nullptr;
    PipelineCreationFeedbackEXT* pPipelineCreationFeedback = nullptr;
    uint32_t pipelineStageCreationFeedbackCount{0};
    PipelineCreationFeedbackEXT* pPipelineStageCreationFeedbacks = nullptr;
    PipelineCreationFeedbackCreateInfoEXT& setPPipelineCreationFeedback(PipelineCreationFeedbackEXT* pPipelineCreationFeedback_) {this->pPipelineCreationFeedback = pPipelineCreationFeedback_; return *this; }
    PipelineCreationFeedbackCreateInfoEXT& setPPipelineCreationFeedback(PipelineCreationFeedbackEXT & pPipelineCreationFeedback_) {this->pPipelineCreationFeedback = &pPipelineCreationFeedback_; return *this; }
    PipelineCreationFeedbackCreateInfoEXT& setPipelineStageCreationFeedbackCount(uint32_t pipelineStageCreationFeedbackCount_) {this->pipelineStageCreationFeedbackCount = pipelineStageCreationFeedbackCount_; return *this; }
    PipelineCreationFeedbackCreateInfoEXT& setPPipelineStageCreationFeedbacks(PipelineCreationFeedbackEXT* pPipelineStageCreationFeedbacks_) {this->pPipelineStageCreationFeedbacks = pPipelineStageCreationFeedbacks_; return *this; }
    PipelineCreationFeedbackCreateInfoEXT& setPPipelineStageCreationFeedbacks(detail::span<PipelineCreationFeedbackEXT> pPipelineStageCreationFeedbacks_) {this->pipelineStageCreationFeedbackCount = pPipelineStageCreationFeedbacks_.size(); this->pPipelineStageCreationFeedbacks = pPipelineStageCreationFeedbacks_.data();  return *this; }
};
#if defined(VK_USE_PLATFORM_WIN32_KHR)
struct SurfaceFullScreenExclusiveInfoEXT {
    StructureType sType{StructureType::SurfaceFullScreenExclusiveInfoEXT};
    void* pNext = nullptr;
    FullScreenExclusiveEXT fullScreenExclusive{static_cast<FullScreenExclusiveEXT>(0)};
    SurfaceFullScreenExclusiveInfoEXT& setFullScreenExclusive(FullScreenExclusiveEXT fullScreenExclusive_) {this->fullScreenExclusive = fullScreenExclusive_; return *this; }
};
struct SurfaceFullScreenExclusiveWin32InfoEXT {
    StructureType sType{StructureType::SurfaceFullScreenExclusiveWin32InfoEXT};
    const void* pNext = nullptr;
    HMONITOR hmonitor{};
    SurfaceFullScreenExclusiveWin32InfoEXT& setHmonitor(HMONITOR hmonitor_) {this->hmonitor = hmonitor_; return *this; }
};
struct SurfaceCapabilitiesFullScreenExclusiveEXT {
    StructureType sType{StructureType::SurfaceCapabilitiesFullScreenExclusiveEXT};
    void* pNext = nullptr;
    Bool32 fullScreenExclusiveSupported{0};
    SurfaceCapabilitiesFullScreenExclusiveEXT& setFullScreenExclusiveSupported(Bool32 fullScreenExclusiveSupported_) {this->fullScreenExclusiveSupported = fullScreenExclusiveSupported_; return *this; }
};
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
struct PhysicalDevicePerformanceQueryFeaturesKHR {
    StructureType sType{StructureType::PhysicalDevicePerformanceQueryFeaturesKHR};
    void* pNext = nullptr;
    Bool32 performanceCounterQueryPools{0};
    Bool32 performanceCounterMultipleQueryPools{0};
    PhysicalDevicePerformanceQueryFeaturesKHR& setPerformanceCounterQueryPools(Bool32 performanceCounterQueryPools_) {this->performanceCounterQueryPools = performanceCounterQueryPools_; return *this; }
    PhysicalDevicePerformanceQueryFeaturesKHR& setPerformanceCounterMultipleQueryPools(Bool32 performanceCounterMultipleQueryPools_) {this->performanceCounterMultipleQueryPools = performanceCounterMultipleQueryPools_; return *this; }
};
struct PhysicalDevicePerformanceQueryPropertiesKHR {
    StructureType sType{StructureType::PhysicalDevicePerformanceQueryPropertiesKHR};
    void* pNext = nullptr;
    Bool32 allowCommandBufferQueryCopies{0};
    PhysicalDevicePerformanceQueryPropertiesKHR& setAllowCommandBufferQueryCopies(Bool32 allowCommandBufferQueryCopies_) {this->allowCommandBufferQueryCopies = allowCommandBufferQueryCopies_; return *this; }
};
struct PerformanceCounterKHR {
    StructureType sType{StructureType::PerformanceCounterKHR};
    const void* pNext = nullptr;
    PerformanceCounterUnitKHR unit{static_cast<PerformanceCounterUnitKHR>(0)};
    PerformanceCounterScopeKHR scope{static_cast<PerformanceCounterScopeKHR>(0)};
    PerformanceCounterStorageKHR storage{static_cast<PerformanceCounterStorageKHR>(0)};
    uint8_t uuid[UUID_SIZE];
    PerformanceCounterKHR& setUnit(PerformanceCounterUnitKHR unit_) {this->unit = unit_; return *this; }
    PerformanceCounterKHR& setScope(PerformanceCounterScopeKHR scope_) {this->scope = scope_; return *this; }
    PerformanceCounterKHR& setStorage(PerformanceCounterStorageKHR storage_) {this->storage = storage_; return *this; }
    PerformanceCounterKHR& setUuid(uint8_t uuid_[UUID_SIZE]) {for(uint32_t i = 0; i < UUID_SIZE; i++) this->uuid[i] = uuid_[i]; return *this; }
};
struct PerformanceCounterDescriptionKHR {
    StructureType sType{StructureType::PerformanceCounterDescriptionKHR};
    const void* pNext = nullptr;
    PerformanceCounterDescriptionFlagsKHR flags{};
    char name[MAX_DESCRIPTION_SIZE];
    char category[MAX_DESCRIPTION_SIZE];
    char description[MAX_DESCRIPTION_SIZE];
    PerformanceCounterDescriptionKHR& setFlags(PerformanceCounterDescriptionFlagsKHR flags_) {this->flags = flags_; return *this; }
    PerformanceCounterDescriptionKHR& setName(char name_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->name[i] = name_[i]; return *this; }
    PerformanceCounterDescriptionKHR& setCategory(char category_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->category[i] = category_[i]; return *this; }
    PerformanceCounterDescriptionKHR& setDescription(char description_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->description[i] = description_[i]; return *this; }
};
struct QueryPoolPerformanceCreateInfoKHR {
    StructureType sType{StructureType::QueryPoolPerformanceCreateInfoKHR};
    const void* pNext = nullptr;
    uint32_t queueFamilyIndex{0};
    uint32_t counterIndexCount{0};
    const uint32_t* pCounterIndices = nullptr;
    QueryPoolPerformanceCreateInfoKHR& setQueueFamilyIndex(uint32_t queueFamilyIndex_) {this->queueFamilyIndex = queueFamilyIndex_; return *this; }
    QueryPoolPerformanceCreateInfoKHR& setCounterIndexCount(uint32_t counterIndexCount_) {this->counterIndexCount = counterIndexCount_; return *this; }
    QueryPoolPerformanceCreateInfoKHR& setPCounterIndices(const uint32_t* pCounterIndices_) {this->pCounterIndices = pCounterIndices_; return *this; }
    QueryPoolPerformanceCreateInfoKHR& setPCounterIndices(detail::span<const uint32_t> pCounterIndices_) {this->counterIndexCount = pCounterIndices_.size(); this->pCounterIndices = pCounterIndices_.data();  return *this; }
};
union PerformanceCounterResultKHR {
    int32_t int32;
    int64_t int64;
    uint32_t uint32;
    uint64_t uint64;
    float float32;
    double float64;
    constexpr bool operator==(PerformanceCounterResultKHR const& value) const {
        return int32 == value.int32 && int64 == value.int64 && uint32 == value.uint32 && uint64 == value.uint64 && float32 == value.float32 && float64 == value.float64 
        ;}
    constexpr bool operator!=(PerformanceCounterResultKHR const& value) const {return !(*this == value);}
    PerformanceCounterResultKHR& setInt32(int32_t int32_) {this->int32 = int32_; return *this; }
    PerformanceCounterResultKHR& setInt64(int64_t int64_) {this->int64 = int64_; return *this; }
    PerformanceCounterResultKHR& setUint32(uint32_t uint32_) {this->uint32 = uint32_; return *this; }
    PerformanceCounterResultKHR& setUint64(uint64_t uint64_) {this->uint64 = uint64_; return *this; }
    PerformanceCounterResultKHR& setFloat32(float float32_) {this->float32 = float32_; return *this; }
    PerformanceCounterResultKHR& setFloat64(double float64_) {this->float64 = float64_; return *this; }
};
struct AcquireProfilingLockInfoKHR {
    StructureType sType{StructureType::AcquireProfilingLockInfoKHR};
    const void* pNext = nullptr;
    AcquireProfilingLockFlagsKHR flags{};
    uint64_t timeout{0};
    AcquireProfilingLockInfoKHR& setFlags(AcquireProfilingLockFlagsKHR flags_) {this->flags = flags_; return *this; }
    AcquireProfilingLockInfoKHR& setTimeout(uint64_t timeout_) {this->timeout = timeout_; return *this; }
};
struct PerformanceQuerySubmitInfoKHR {
    StructureType sType{StructureType::PerformanceQuerySubmitInfoKHR};
    const void* pNext = nullptr;
    uint32_t counterPassIndex{0};
    PerformanceQuerySubmitInfoKHR& setCounterPassIndex(uint32_t counterPassIndex_) {this->counterPassIndex = counterPassIndex_; return *this; }
};
struct HeadlessSurfaceCreateInfoEXT {
    StructureType sType{StructureType::HeadlessSurfaceCreateInfoEXT};
    const void* pNext = nullptr;
    HeadlessSurfaceCreateFlagsEXT flags{};
    HeadlessSurfaceCreateInfoEXT& setFlags(HeadlessSurfaceCreateFlagsEXT flags_) {this->flags = flags_; return *this; }
};
struct PhysicalDeviceCoverageReductionModeFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceCoverageReductionModeFeaturesNV};
    void* pNext = nullptr;
    Bool32 coverageReductionMode{0};
    PhysicalDeviceCoverageReductionModeFeaturesNV& setCoverageReductionMode(Bool32 coverageReductionMode_) {this->coverageReductionMode = coverageReductionMode_; return *this; }
};
struct PipelineCoverageReductionStateCreateInfoNV {
    StructureType sType{StructureType::PipelineCoverageReductionStateCreateInfoNV};
    const void* pNext = nullptr;
    PipelineCoverageReductionStateCreateFlagsNV flags{};
    CoverageReductionModeNV coverageReductionMode{static_cast<CoverageReductionModeNV>(0)};
    PipelineCoverageReductionStateCreateInfoNV& setFlags(PipelineCoverageReductionStateCreateFlagsNV flags_) {this->flags = flags_; return *this; }
    PipelineCoverageReductionStateCreateInfoNV& setCoverageReductionMode(CoverageReductionModeNV coverageReductionMode_) {this->coverageReductionMode = coverageReductionMode_; return *this; }
};
struct FramebufferMixedSamplesCombinationNV {
    StructureType sType{StructureType::FramebufferMixedSamplesCombinationNV};
    void* pNext = nullptr;
    CoverageReductionModeNV coverageReductionMode{static_cast<CoverageReductionModeNV>(0)};
    SampleCountFlagBits rasterizationSamples{static_cast<SampleCountFlagBits>(0)};
    SampleCountFlags depthStencilSamples{};
    SampleCountFlags colorSamples{};
    FramebufferMixedSamplesCombinationNV& setCoverageReductionMode(CoverageReductionModeNV coverageReductionMode_) {this->coverageReductionMode = coverageReductionMode_; return *this; }
    FramebufferMixedSamplesCombinationNV& setRasterizationSamples(SampleCountFlagBits rasterizationSamples_) {this->rasterizationSamples = rasterizationSamples_; return *this; }
    FramebufferMixedSamplesCombinationNV& setDepthStencilSamples(SampleCountFlags depthStencilSamples_) {this->depthStencilSamples = depthStencilSamples_; return *this; }
    FramebufferMixedSamplesCombinationNV& setColorSamples(SampleCountFlags colorSamples_) {this->colorSamples = colorSamples_; return *this; }
};
struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    StructureType sType{StructureType::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL};
    void* pNext = nullptr;
    Bool32 shaderIntegerFunctions2{0};
    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& setShaderIntegerFunctions2(Bool32 shaderIntegerFunctions2_) {this->shaderIntegerFunctions2 = shaderIntegerFunctions2_; return *this; }
};
union PerformanceValueDataINTEL {
    uint32_t value32;
    uint64_t value64;
    float valueFloat;
    Bool32 valueBool;
    const char* valueString;
    PerformanceValueDataINTEL& setValue32(uint32_t value32_) {this->value32 = value32_; return *this; }
    PerformanceValueDataINTEL& setValue64(uint64_t value64_) {this->value64 = value64_; return *this; }
    PerformanceValueDataINTEL& setValueFloat(float valueFloat_) {this->valueFloat = valueFloat_; return *this; }
    PerformanceValueDataINTEL& setValueBool(Bool32 valueBool_) {this->valueBool = valueBool_; return *this; }
    PerformanceValueDataINTEL& setValueString(const char* valueString_) {this->valueString = valueString_; return *this; }
};
struct PerformanceValueINTEL {
    PerformanceValueTypeINTEL type{static_cast<PerformanceValueTypeINTEL>(0)};
    PerformanceValueDataINTEL data{};
    PerformanceValueINTEL& setType(PerformanceValueTypeINTEL type_) {this->type = type_; return *this; }
    PerformanceValueINTEL& setData(PerformanceValueDataINTEL data_) {this->data = data_; return *this; }
};
struct InitializePerformanceApiInfoINTEL {
    StructureType sType{StructureType::InitializePerformanceApiInfoINTEL};
    const void* pNext = nullptr;
    void* pUserData = nullptr;
    InitializePerformanceApiInfoINTEL& setPUserData(void* pUserData_) {this->pUserData = pUserData_; return *this; }
};
struct QueryPoolPerformanceQueryCreateInfoINTEL {
    StructureType sType{StructureType::QueryPoolPerformanceQueryCreateInfoINTEL};
    const void* pNext = nullptr;
    QueryPoolSamplingModeINTEL performanceCountersSampling{static_cast<QueryPoolSamplingModeINTEL>(0)};
    QueryPoolPerformanceQueryCreateInfoINTEL& setPerformanceCountersSampling(QueryPoolSamplingModeINTEL performanceCountersSampling_) {this->performanceCountersSampling = performanceCountersSampling_; return *this; }
};
using QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
struct PerformanceMarkerInfoINTEL {
    StructureType sType{StructureType::PerformanceMarkerInfoINTEL};
    const void* pNext = nullptr;
    uint64_t marker{0};
    PerformanceMarkerInfoINTEL& setMarker(uint64_t marker_) {this->marker = marker_; return *this; }
};
struct PerformanceStreamMarkerInfoINTEL {
    StructureType sType{StructureType::PerformanceStreamMarkerInfoINTEL};
    const void* pNext = nullptr;
    uint32_t marker{0};
    PerformanceStreamMarkerInfoINTEL& setMarker(uint32_t marker_) {this->marker = marker_; return *this; }
};
struct PerformanceOverrideInfoINTEL {
    StructureType sType{StructureType::PerformanceOverrideInfoINTEL};
    const void* pNext = nullptr;
    PerformanceOverrideTypeINTEL type{static_cast<PerformanceOverrideTypeINTEL>(0)};
    Bool32 enable{0};
    uint64_t parameter{0};
    PerformanceOverrideInfoINTEL& setType(PerformanceOverrideTypeINTEL type_) {this->type = type_; return *this; }
    PerformanceOverrideInfoINTEL& setEnable(Bool32 enable_) {this->enable = enable_; return *this; }
    PerformanceOverrideInfoINTEL& setParameter(uint64_t parameter_) {this->parameter = parameter_; return *this; }
};
struct PerformanceConfigurationAcquireInfoINTEL {
    StructureType sType{StructureType::PerformanceConfigurationAcquireInfoINTEL};
    const void* pNext = nullptr;
    PerformanceConfigurationTypeINTEL type{static_cast<PerformanceConfigurationTypeINTEL>(0)};
    PerformanceConfigurationAcquireInfoINTEL& setType(PerformanceConfigurationTypeINTEL type_) {this->type = type_; return *this; }
};
struct PhysicalDeviceShaderClockFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceShaderClockFeaturesKHR};
    void* pNext = nullptr;
    Bool32 shaderSubgroupClock{0};
    Bool32 shaderDeviceClock{0};
    PhysicalDeviceShaderClockFeaturesKHR& setShaderSubgroupClock(Bool32 shaderSubgroupClock_) {this->shaderSubgroupClock = shaderSubgroupClock_; return *this; }
    PhysicalDeviceShaderClockFeaturesKHR& setShaderDeviceClock(Bool32 shaderDeviceClock_) {this->shaderDeviceClock = shaderDeviceClock_; return *this; }
};
struct PhysicalDeviceIndexTypeUint8FeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceIndexTypeUint8FeaturesEXT};
    void* pNext = nullptr;
    Bool32 indexTypeUint8{0};
    PhysicalDeviceIndexTypeUint8FeaturesEXT& setIndexTypeUint8(Bool32 indexTypeUint8_) {this->indexTypeUint8 = indexTypeUint8_; return *this; }
};
struct PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceShaderSmBuiltinsPropertiesNV};
    void* pNext = nullptr;
    uint32_t shaderSMCount{0};
    uint32_t shaderWarpsPerSM{0};
    PhysicalDeviceShaderSMBuiltinsPropertiesNV& setShaderSMCount(uint32_t shaderSMCount_) {this->shaderSMCount = shaderSMCount_; return *this; }
    PhysicalDeviceShaderSMBuiltinsPropertiesNV& setShaderWarpsPerSM(uint32_t shaderWarpsPerSM_) {this->shaderWarpsPerSM = shaderWarpsPerSM_; return *this; }
};
struct PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceShaderSmBuiltinsFeaturesNV};
    void* pNext = nullptr;
    Bool32 shaderSMBuiltins{0};
    PhysicalDeviceShaderSMBuiltinsFeaturesNV& setShaderSMBuiltins(Bool32 shaderSMBuiltins_) {this->shaderSMBuiltins = shaderSMBuiltins_; return *this; }
};
struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceFragmentShaderInterlockFeaturesEXT};
    void* pNext = nullptr;
    Bool32 fragmentShaderSampleInterlock{0};
    Bool32 fragmentShaderPixelInterlock{0};
    Bool32 fragmentShaderShadingRateInterlock{0};
    PhysicalDeviceFragmentShaderInterlockFeaturesEXT& setFragmentShaderSampleInterlock(Bool32 fragmentShaderSampleInterlock_) {this->fragmentShaderSampleInterlock = fragmentShaderSampleInterlock_; return *this; }
    PhysicalDeviceFragmentShaderInterlockFeaturesEXT& setFragmentShaderPixelInterlock(Bool32 fragmentShaderPixelInterlock_) {this->fragmentShaderPixelInterlock = fragmentShaderPixelInterlock_; return *this; }
    PhysicalDeviceFragmentShaderInterlockFeaturesEXT& setFragmentShaderShadingRateInterlock(Bool32 fragmentShaderShadingRateInterlock_) {this->fragmentShaderShadingRateInterlock = fragmentShaderShadingRateInterlock_; return *this; }
};
struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    StructureType sType{StructureType::PhysicalDeviceSeparateDepthStencilLayoutsFeatures};
    void* pNext = nullptr;
    Bool32 separateDepthStencilLayouts{0};
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures& setSeparateDepthStencilLayouts(Bool32 separateDepthStencilLayouts_) {this->separateDepthStencilLayouts = separateDepthStencilLayouts_; return *this; }
};
using PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
struct AttachmentReferenceStencilLayout {
    StructureType sType{StructureType::AttachmentReferenceStencilLayout};
    void* pNext = nullptr;
    ImageLayout stencilLayout{static_cast<ImageLayout>(0)};
    AttachmentReferenceStencilLayout& setStencilLayout(ImageLayout stencilLayout_) {this->stencilLayout = stencilLayout_; return *this; }
};
using AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
struct AttachmentDescriptionStencilLayout {
    StructureType sType{StructureType::AttachmentDescriptionStencilLayout};
    void* pNext = nullptr;
    ImageLayout stencilInitialLayout{static_cast<ImageLayout>(0)};
    ImageLayout stencilFinalLayout{static_cast<ImageLayout>(0)};
    AttachmentDescriptionStencilLayout& setStencilInitialLayout(ImageLayout stencilInitialLayout_) {this->stencilInitialLayout = stencilInitialLayout_; return *this; }
    AttachmentDescriptionStencilLayout& setStencilFinalLayout(ImageLayout stencilFinalLayout_) {this->stencilFinalLayout = stencilFinalLayout_; return *this; }
};
using AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;
struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    StructureType sType{StructureType::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR};
    void* pNext = nullptr;
    Bool32 pipelineExecutableInfo{0};
    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR& setPipelineExecutableInfo(Bool32 pipelineExecutableInfo_) {this->pipelineExecutableInfo = pipelineExecutableInfo_; return *this; }
};
struct PipelineInfoKHR {
    StructureType sType{StructureType::PipelineInfoKHR};
    const void* pNext = nullptr;
    Pipeline pipeline{};
    PipelineInfoKHR& setPipeline(Pipeline pipeline_) {this->pipeline = pipeline_; return *this; }
};
struct PipelineExecutablePropertiesKHR {
    StructureType sType{StructureType::PipelineExecutablePropertiesKHR};
    void* pNext = nullptr;
    ShaderStageFlags stages{};
    char name[MAX_DESCRIPTION_SIZE];
    char description[MAX_DESCRIPTION_SIZE];
    uint32_t subgroupSize{0};
    PipelineExecutablePropertiesKHR& setStages(ShaderStageFlags stages_) {this->stages = stages_; return *this; }
    PipelineExecutablePropertiesKHR& setName(char name_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->name[i] = name_[i]; return *this; }
    PipelineExecutablePropertiesKHR& setDescription(char description_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->description[i] = description_[i]; return *this; }
    PipelineExecutablePropertiesKHR& setSubgroupSize(uint32_t subgroupSize_) {this->subgroupSize = subgroupSize_; return *this; }
};
struct PipelineExecutableInfoKHR {
    StructureType sType{StructureType::PipelineExecutableInfoKHR};
    const void* pNext = nullptr;
    Pipeline pipeline{};
    uint32_t executableIndex{0};
    PipelineExecutableInfoKHR& setPipeline(Pipeline pipeline_) {this->pipeline = pipeline_; return *this; }
    PipelineExecutableInfoKHR& setExecutableIndex(uint32_t executableIndex_) {this->executableIndex = executableIndex_; return *this; }
};
union PipelineExecutableStatisticValueKHR {
    Bool32 b32;
    int64_t i64;
    uint64_t u64;
    double f64;
    constexpr bool operator==(PipelineExecutableStatisticValueKHR const& value) const {
        return b32 == value.b32 && i64 == value.i64 && u64 == value.u64 && f64 == value.f64 ;}
    constexpr bool operator!=(PipelineExecutableStatisticValueKHR const& value) const {return !(*this == value);}
    PipelineExecutableStatisticValueKHR& setB32(Bool32 b32_) {this->b32 = b32_; return *this; }
    PipelineExecutableStatisticValueKHR& setI64(int64_t i64_) {this->i64 = i64_; return *this; }
    PipelineExecutableStatisticValueKHR& setU64(uint64_t u64_) {this->u64 = u64_; return *this; }
    PipelineExecutableStatisticValueKHR& setF64(double f64_) {this->f64 = f64_; return *this; }
};
struct PipelineExecutableStatisticKHR {
    StructureType sType{StructureType::PipelineExecutableStatisticKHR};
    void* pNext = nullptr;
    char name[MAX_DESCRIPTION_SIZE];
    char description[MAX_DESCRIPTION_SIZE];
    PipelineExecutableStatisticFormatKHR format{static_cast<PipelineExecutableStatisticFormatKHR>(0)};
    PipelineExecutableStatisticValueKHR value{};
    PipelineExecutableStatisticKHR& setName(char name_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->name[i] = name_[i]; return *this; }
    PipelineExecutableStatisticKHR& setDescription(char description_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->description[i] = description_[i]; return *this; }
    PipelineExecutableStatisticKHR& setFormat(PipelineExecutableStatisticFormatKHR format_) {this->format = format_; return *this; }
    PipelineExecutableStatisticKHR& setValue(PipelineExecutableStatisticValueKHR value_) {this->value = value_; return *this; }
};
struct PipelineExecutableInternalRepresentationKHR {
    StructureType sType{StructureType::PipelineExecutableInternalRepresentationKHR};
    void* pNext = nullptr;
    char name[MAX_DESCRIPTION_SIZE];
    char description[MAX_DESCRIPTION_SIZE];
    Bool32 isText{0};
    size_t dataSize{0};
    void* pData = nullptr;
    PipelineExecutableInternalRepresentationKHR& setName(char name_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->name[i] = name_[i]; return *this; }
    PipelineExecutableInternalRepresentationKHR& setDescription(char description_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->description[i] = description_[i]; return *this; }
    PipelineExecutableInternalRepresentationKHR& setIsText(Bool32 isText_) {this->isText = isText_; return *this; }
    PipelineExecutableInternalRepresentationKHR& setDataSize(size_t dataSize_) {this->dataSize = dataSize_; return *this; }
    PipelineExecutableInternalRepresentationKHR& setPData(void* pData_) {this->pData = pData_; return *this; }
    PipelineExecutableInternalRepresentationKHR& setPData(detail::span<std::byte> pData_) {this->dataSize = pData_.size(); this->pData = pData_.data();  return *this; }
};
struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT};
    void* pNext = nullptr;
    Bool32 shaderDemoteToHelperInvocation{0};
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT& setShaderDemoteToHelperInvocation(Bool32 shaderDemoteToHelperInvocation_) {this->shaderDemoteToHelperInvocation = shaderDemoteToHelperInvocation_; return *this; }
};
struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceTexelBufferAlignmentFeaturesEXT};
    void* pNext = nullptr;
    Bool32 texelBufferAlignment{0};
    PhysicalDeviceTexelBufferAlignmentFeaturesEXT& setTexelBufferAlignment(Bool32 texelBufferAlignment_) {this->texelBufferAlignment = texelBufferAlignment_; return *this; }
};
struct PhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceTexelBufferAlignmentPropertiesEXT};
    void* pNext = nullptr;
    DeviceSize storageTexelBufferOffsetAlignmentBytes{0};
    Bool32 storageTexelBufferOffsetSingleTexelAlignment{0};
    DeviceSize uniformTexelBufferOffsetAlignmentBytes{0};
    Bool32 uniformTexelBufferOffsetSingleTexelAlignment{0};
    PhysicalDeviceTexelBufferAlignmentPropertiesEXT& setStorageTexelBufferOffsetAlignmentBytes(DeviceSize storageTexelBufferOffsetAlignmentBytes_) {this->storageTexelBufferOffsetAlignmentBytes = storageTexelBufferOffsetAlignmentBytes_; return *this; }
    PhysicalDeviceTexelBufferAlignmentPropertiesEXT& setStorageTexelBufferOffsetSingleTexelAlignment(Bool32 storageTexelBufferOffsetSingleTexelAlignment_) {this->storageTexelBufferOffsetSingleTexelAlignment = storageTexelBufferOffsetSingleTexelAlignment_; return *this; }
    PhysicalDeviceTexelBufferAlignmentPropertiesEXT& setUniformTexelBufferOffsetAlignmentBytes(DeviceSize uniformTexelBufferOffsetAlignmentBytes_) {this->uniformTexelBufferOffsetAlignmentBytes = uniformTexelBufferOffsetAlignmentBytes_; return *this; }
    PhysicalDeviceTexelBufferAlignmentPropertiesEXT& setUniformTexelBufferOffsetSingleTexelAlignment(Bool32 uniformTexelBufferOffsetSingleTexelAlignment_) {this->uniformTexelBufferOffsetSingleTexelAlignment = uniformTexelBufferOffsetSingleTexelAlignment_; return *this; }
};
struct PhysicalDeviceSubgroupSizeControlFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceSubgroupSizeControlFeaturesEXT};
    void* pNext = nullptr;
    Bool32 subgroupSizeControl{0};
    Bool32 computeFullSubgroups{0};
    PhysicalDeviceSubgroupSizeControlFeaturesEXT& setSubgroupSizeControl(Bool32 subgroupSizeControl_) {this->subgroupSizeControl = subgroupSizeControl_; return *this; }
    PhysicalDeviceSubgroupSizeControlFeaturesEXT& setComputeFullSubgroups(Bool32 computeFullSubgroups_) {this->computeFullSubgroups = computeFullSubgroups_; return *this; }
};
struct PhysicalDeviceSubgroupSizeControlPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceSubgroupSizeControlPropertiesEXT};
    void* pNext = nullptr;
    uint32_t minSubgroupSize{0};
    uint32_t maxSubgroupSize{0};
    uint32_t maxComputeWorkgroupSubgroups{0};
    ShaderStageFlags requiredSubgroupSizeStages{};
    PhysicalDeviceSubgroupSizeControlPropertiesEXT& setMinSubgroupSize(uint32_t minSubgroupSize_) {this->minSubgroupSize = minSubgroupSize_; return *this; }
    PhysicalDeviceSubgroupSizeControlPropertiesEXT& setMaxSubgroupSize(uint32_t maxSubgroupSize_) {this->maxSubgroupSize = maxSubgroupSize_; return *this; }
    PhysicalDeviceSubgroupSizeControlPropertiesEXT& setMaxComputeWorkgroupSubgroups(uint32_t maxComputeWorkgroupSubgroups_) {this->maxComputeWorkgroupSubgroups = maxComputeWorkgroupSubgroups_; return *this; }
    PhysicalDeviceSubgroupSizeControlPropertiesEXT& setRequiredSubgroupSizeStages(ShaderStageFlags requiredSubgroupSizeStages_) {this->requiredSubgroupSizeStages = requiredSubgroupSizeStages_; return *this; }
};
struct PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    StructureType sType{StructureType::PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT};
    void* pNext = nullptr;
    uint32_t requiredSubgroupSize{0};
    PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT& setRequiredSubgroupSize(uint32_t requiredSubgroupSize_) {this->requiredSubgroupSize = requiredSubgroupSize_; return *this; }
};
struct MemoryOpaqueCaptureAddressAllocateInfo {
    StructureType sType{StructureType::MemoryOpaqueCaptureAddressAllocateInfo};
    const void* pNext = nullptr;
    uint64_t opaqueCaptureAddress{0};
    MemoryOpaqueCaptureAddressAllocateInfo& setOpaqueCaptureAddress(uint64_t opaqueCaptureAddress_) {this->opaqueCaptureAddress = opaqueCaptureAddress_; return *this; }
};
using MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
struct DeviceMemoryOpaqueCaptureAddressInfo {
    StructureType sType{StructureType::DeviceMemoryOpaqueCaptureAddressInfo};
    const void* pNext = nullptr;
    DeviceMemory memory{};
    DeviceMemoryOpaqueCaptureAddressInfo& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
};
using DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;
struct PhysicalDeviceLineRasterizationFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceLineRasterizationFeaturesEXT};
    void* pNext = nullptr;
    Bool32 rectangularLines{0};
    Bool32 bresenhamLines{0};
    Bool32 smoothLines{0};
    Bool32 stippledRectangularLines{0};
    Bool32 stippledBresenhamLines{0};
    Bool32 stippledSmoothLines{0};
    PhysicalDeviceLineRasterizationFeaturesEXT& setRectangularLines(Bool32 rectangularLines_) {this->rectangularLines = rectangularLines_; return *this; }
    PhysicalDeviceLineRasterizationFeaturesEXT& setBresenhamLines(Bool32 bresenhamLines_) {this->bresenhamLines = bresenhamLines_; return *this; }
    PhysicalDeviceLineRasterizationFeaturesEXT& setSmoothLines(Bool32 smoothLines_) {this->smoothLines = smoothLines_; return *this; }
    PhysicalDeviceLineRasterizationFeaturesEXT& setStippledRectangularLines(Bool32 stippledRectangularLines_) {this->stippledRectangularLines = stippledRectangularLines_; return *this; }
    PhysicalDeviceLineRasterizationFeaturesEXT& setStippledBresenhamLines(Bool32 stippledBresenhamLines_) {this->stippledBresenhamLines = stippledBresenhamLines_; return *this; }
    PhysicalDeviceLineRasterizationFeaturesEXT& setStippledSmoothLines(Bool32 stippledSmoothLines_) {this->stippledSmoothLines = stippledSmoothLines_; return *this; }
};
struct PhysicalDeviceLineRasterizationPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceLineRasterizationPropertiesEXT};
    void* pNext = nullptr;
    uint32_t lineSubPixelPrecisionBits{0};
    PhysicalDeviceLineRasterizationPropertiesEXT& setLineSubPixelPrecisionBits(uint32_t lineSubPixelPrecisionBits_) {this->lineSubPixelPrecisionBits = lineSubPixelPrecisionBits_; return *this; }
};
struct PipelineRasterizationLineStateCreateInfoEXT {
    StructureType sType{StructureType::PipelineRasterizationLineStateCreateInfoEXT};
    const void* pNext = nullptr;
    LineRasterizationModeEXT lineRasterizationMode{static_cast<LineRasterizationModeEXT>(0)};
    Bool32 stippledLineEnable{0};
    uint32_t lineStippleFactor{0};
    uint16_t lineStipplePattern{0};
    PipelineRasterizationLineStateCreateInfoEXT& setLineRasterizationMode(LineRasterizationModeEXT lineRasterizationMode_) {this->lineRasterizationMode = lineRasterizationMode_; return *this; }
    PipelineRasterizationLineStateCreateInfoEXT& setStippledLineEnable(Bool32 stippledLineEnable_) {this->stippledLineEnable = stippledLineEnable_; return *this; }
    PipelineRasterizationLineStateCreateInfoEXT& setLineStippleFactor(uint32_t lineStippleFactor_) {this->lineStippleFactor = lineStippleFactor_; return *this; }
    PipelineRasterizationLineStateCreateInfoEXT& setLineStipplePattern(uint16_t lineStipplePattern_) {this->lineStipplePattern = lineStipplePattern_; return *this; }
};
struct PhysicalDevicePipelineCreationCacheControlFeaturesEXT {
    StructureType sType{StructureType::PhysicalDevicePipelineCreationCacheControlFeaturesEXT};
    void* pNext = nullptr;
    Bool32 pipelineCreationCacheControl{0};
    PhysicalDevicePipelineCreationCacheControlFeaturesEXT& setPipelineCreationCacheControl(Bool32 pipelineCreationCacheControl_) {this->pipelineCreationCacheControl = pipelineCreationCacheControl_; return *this; }
};
struct PhysicalDeviceVulkan11Features {
    StructureType sType{StructureType::PhysicalDeviceVulkan11Features};
    void* pNext = nullptr;
    Bool32 storageBuffer16BitAccess{0};
    Bool32 uniformAndStorageBuffer16BitAccess{0};
    Bool32 storagePushConstant16{0};
    Bool32 storageInputOutput16{0};
    Bool32 multiview{0};
    Bool32 multiviewGeometryShader{0};
    Bool32 multiviewTessellationShader{0};
    Bool32 variablePointersStorageBuffer{0};
    Bool32 variablePointers{0};
    Bool32 protectedMemory{0};
    Bool32 samplerYcbcrConversion{0};
    Bool32 shaderDrawParameters{0};
    PhysicalDeviceVulkan11Features& setStorageBuffer16BitAccess(Bool32 storageBuffer16BitAccess_) {this->storageBuffer16BitAccess = storageBuffer16BitAccess_; return *this; }
    PhysicalDeviceVulkan11Features& setUniformAndStorageBuffer16BitAccess(Bool32 uniformAndStorageBuffer16BitAccess_) {this->uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess_; return *this; }
    PhysicalDeviceVulkan11Features& setStoragePushConstant16(Bool32 storagePushConstant16_) {this->storagePushConstant16 = storagePushConstant16_; return *this; }
    PhysicalDeviceVulkan11Features& setStorageInputOutput16(Bool32 storageInputOutput16_) {this->storageInputOutput16 = storageInputOutput16_; return *this; }
    PhysicalDeviceVulkan11Features& setMultiview(Bool32 multiview_) {this->multiview = multiview_; return *this; }
    PhysicalDeviceVulkan11Features& setMultiviewGeometryShader(Bool32 multiviewGeometryShader_) {this->multiviewGeometryShader = multiviewGeometryShader_; return *this; }
    PhysicalDeviceVulkan11Features& setMultiviewTessellationShader(Bool32 multiviewTessellationShader_) {this->multiviewTessellationShader = multiviewTessellationShader_; return *this; }
    PhysicalDeviceVulkan11Features& setVariablePointersStorageBuffer(Bool32 variablePointersStorageBuffer_) {this->variablePointersStorageBuffer = variablePointersStorageBuffer_; return *this; }
    PhysicalDeviceVulkan11Features& setVariablePointers(Bool32 variablePointers_) {this->variablePointers = variablePointers_; return *this; }
    PhysicalDeviceVulkan11Features& setProtectedMemory(Bool32 protectedMemory_) {this->protectedMemory = protectedMemory_; return *this; }
    PhysicalDeviceVulkan11Features& setSamplerYcbcrConversion(Bool32 samplerYcbcrConversion_) {this->samplerYcbcrConversion = samplerYcbcrConversion_; return *this; }
    PhysicalDeviceVulkan11Features& setShaderDrawParameters(Bool32 shaderDrawParameters_) {this->shaderDrawParameters = shaderDrawParameters_; return *this; }
};
struct PhysicalDeviceVulkan11Properties {
    StructureType sType{StructureType::PhysicalDeviceVulkan11Properties};
    void* pNext = nullptr;
    uint8_t deviceUUID[UUID_SIZE];
    uint8_t driverUUID[UUID_SIZE];
    uint8_t deviceLUID[LUID_SIZE];
    uint32_t deviceNodeMask{0};
    Bool32 deviceLUIDValid{0};
    uint32_t subgroupSize{0};
    ShaderStageFlags subgroupSupportedStages{};
    SubgroupFeatureFlags subgroupSupportedOperations{};
    Bool32 subgroupQuadOperationsInAllStages{0};
    PointClippingBehavior pointClippingBehavior{static_cast<PointClippingBehavior>(0)};
    uint32_t maxMultiviewViewCount{0};
    uint32_t maxMultiviewInstanceIndex{0};
    Bool32 protectedNoFault{0};
    uint32_t maxPerSetDescriptors{0};
    DeviceSize maxMemoryAllocationSize{0};
    PhysicalDeviceVulkan11Properties& setDeviceUUID(uint8_t deviceUUID_[UUID_SIZE]) {for(uint32_t i = 0; i < UUID_SIZE; i++) this->deviceUUID[i] = deviceUUID_[i]; return *this; }
    PhysicalDeviceVulkan11Properties& setDriverUUID(uint8_t driverUUID_[UUID_SIZE]) {for(uint32_t i = 0; i < UUID_SIZE; i++) this->driverUUID[i] = driverUUID_[i]; return *this; }
    PhysicalDeviceVulkan11Properties& setDeviceLUID(uint8_t deviceLUID_[LUID_SIZE]) {for(uint32_t i = 0; i < LUID_SIZE; i++) this->deviceLUID[i] = deviceLUID_[i]; return *this; }
    PhysicalDeviceVulkan11Properties& setDeviceNodeMask(uint32_t deviceNodeMask_) {this->deviceNodeMask = deviceNodeMask_; return *this; }
    PhysicalDeviceVulkan11Properties& setDeviceLUIDValid(Bool32 deviceLUIDValid_) {this->deviceLUIDValid = deviceLUIDValid_; return *this; }
    PhysicalDeviceVulkan11Properties& setSubgroupSize(uint32_t subgroupSize_) {this->subgroupSize = subgroupSize_; return *this; }
    PhysicalDeviceVulkan11Properties& setSubgroupSupportedStages(ShaderStageFlags subgroupSupportedStages_) {this->subgroupSupportedStages = subgroupSupportedStages_; return *this; }
    PhysicalDeviceVulkan11Properties& setSubgroupSupportedOperations(SubgroupFeatureFlags subgroupSupportedOperations_) {this->subgroupSupportedOperations = subgroupSupportedOperations_; return *this; }
    PhysicalDeviceVulkan11Properties& setSubgroupQuadOperationsInAllStages(Bool32 subgroupQuadOperationsInAllStages_) {this->subgroupQuadOperationsInAllStages = subgroupQuadOperationsInAllStages_; return *this; }
    PhysicalDeviceVulkan11Properties& setPointClippingBehavior(PointClippingBehavior pointClippingBehavior_) {this->pointClippingBehavior = pointClippingBehavior_; return *this; }
    PhysicalDeviceVulkan11Properties& setMaxMultiviewViewCount(uint32_t maxMultiviewViewCount_) {this->maxMultiviewViewCount = maxMultiviewViewCount_; return *this; }
    PhysicalDeviceVulkan11Properties& setMaxMultiviewInstanceIndex(uint32_t maxMultiviewInstanceIndex_) {this->maxMultiviewInstanceIndex = maxMultiviewInstanceIndex_; return *this; }
    PhysicalDeviceVulkan11Properties& setProtectedNoFault(Bool32 protectedNoFault_) {this->protectedNoFault = protectedNoFault_; return *this; }
    PhysicalDeviceVulkan11Properties& setMaxPerSetDescriptors(uint32_t maxPerSetDescriptors_) {this->maxPerSetDescriptors = maxPerSetDescriptors_; return *this; }
    PhysicalDeviceVulkan11Properties& setMaxMemoryAllocationSize(DeviceSize maxMemoryAllocationSize_) {this->maxMemoryAllocationSize = maxMemoryAllocationSize_; return *this; }
};
struct PhysicalDeviceVulkan12Features {
    StructureType sType{StructureType::PhysicalDeviceVulkan12Features};
    void* pNext = nullptr;
    Bool32 samplerMirrorClampToEdge{0};
    Bool32 drawIndirectCount{0};
    Bool32 storageBuffer8BitAccess{0};
    Bool32 uniformAndStorageBuffer8BitAccess{0};
    Bool32 storagePushConstant8{0};
    Bool32 shaderBufferInt64Atomics{0};
    Bool32 shaderSharedInt64Atomics{0};
    Bool32 shaderFloat16{0};
    Bool32 shaderInt8{0};
    Bool32 descriptorIndexing{0};
    Bool32 shaderInputAttachmentArrayDynamicIndexing{0};
    Bool32 shaderUniformTexelBufferArrayDynamicIndexing{0};
    Bool32 shaderStorageTexelBufferArrayDynamicIndexing{0};
    Bool32 shaderUniformBufferArrayNonUniformIndexing{0};
    Bool32 shaderSampledImageArrayNonUniformIndexing{0};
    Bool32 shaderStorageBufferArrayNonUniformIndexing{0};
    Bool32 shaderStorageImageArrayNonUniformIndexing{0};
    Bool32 shaderInputAttachmentArrayNonUniformIndexing{0};
    Bool32 shaderUniformTexelBufferArrayNonUniformIndexing{0};
    Bool32 shaderStorageTexelBufferArrayNonUniformIndexing{0};
    Bool32 descriptorBindingUniformBufferUpdateAfterBind{0};
    Bool32 descriptorBindingSampledImageUpdateAfterBind{0};
    Bool32 descriptorBindingStorageImageUpdateAfterBind{0};
    Bool32 descriptorBindingStorageBufferUpdateAfterBind{0};
    Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind{0};
    Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind{0};
    Bool32 descriptorBindingUpdateUnusedWhilePending{0};
    Bool32 descriptorBindingPartiallyBound{0};
    Bool32 descriptorBindingVariableDescriptorCount{0};
    Bool32 runtimeDescriptorArray{0};
    Bool32 samplerFilterMinmax{0};
    Bool32 scalarBlockLayout{0};
    Bool32 imagelessFramebuffer{0};
    Bool32 uniformBufferStandardLayout{0};
    Bool32 shaderSubgroupExtendedTypes{0};
    Bool32 separateDepthStencilLayouts{0};
    Bool32 hostQueryReset{0};
    Bool32 timelineSemaphore{0};
    Bool32 bufferDeviceAddress{0};
    Bool32 bufferDeviceAddressCaptureReplay{0};
    Bool32 bufferDeviceAddressMultiDevice{0};
    Bool32 vulkanMemoryModel{0};
    Bool32 vulkanMemoryModelDeviceScope{0};
    Bool32 vulkanMemoryModelAvailabilityVisibilityChains{0};
    Bool32 shaderOutputViewportIndex{0};
    Bool32 shaderOutputLayer{0};
    Bool32 subgroupBroadcastDynamicId{0};
    PhysicalDeviceVulkan12Features& setSamplerMirrorClampToEdge(Bool32 samplerMirrorClampToEdge_) {this->samplerMirrorClampToEdge = samplerMirrorClampToEdge_; return *this; }
    PhysicalDeviceVulkan12Features& setDrawIndirectCount(Bool32 drawIndirectCount_) {this->drawIndirectCount = drawIndirectCount_; return *this; }
    PhysicalDeviceVulkan12Features& setStorageBuffer8BitAccess(Bool32 storageBuffer8BitAccess_) {this->storageBuffer8BitAccess = storageBuffer8BitAccess_; return *this; }
    PhysicalDeviceVulkan12Features& setUniformAndStorageBuffer8BitAccess(Bool32 uniformAndStorageBuffer8BitAccess_) {this->uniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess_; return *this; }
    PhysicalDeviceVulkan12Features& setStoragePushConstant8(Bool32 storagePushConstant8_) {this->storagePushConstant8 = storagePushConstant8_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderBufferInt64Atomics(Bool32 shaderBufferInt64Atomics_) {this->shaderBufferInt64Atomics = shaderBufferInt64Atomics_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderSharedInt64Atomics(Bool32 shaderSharedInt64Atomics_) {this->shaderSharedInt64Atomics = shaderSharedInt64Atomics_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderFloat16(Bool32 shaderFloat16_) {this->shaderFloat16 = shaderFloat16_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderInt8(Bool32 shaderInt8_) {this->shaderInt8 = shaderInt8_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorIndexing(Bool32 descriptorIndexing_) {this->descriptorIndexing = descriptorIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderInputAttachmentArrayDynamicIndexing(Bool32 shaderInputAttachmentArrayDynamicIndexing_) {this->shaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderUniformTexelBufferArrayDynamicIndexing(Bool32 shaderUniformTexelBufferArrayDynamicIndexing_) {this->shaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderStorageTexelBufferArrayDynamicIndexing(Bool32 shaderStorageTexelBufferArrayDynamicIndexing_) {this->shaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderUniformBufferArrayNonUniformIndexing(Bool32 shaderUniformBufferArrayNonUniformIndexing_) {this->shaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderSampledImageArrayNonUniformIndexing(Bool32 shaderSampledImageArrayNonUniformIndexing_) {this->shaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderStorageBufferArrayNonUniformIndexing(Bool32 shaderStorageBufferArrayNonUniformIndexing_) {this->shaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderStorageImageArrayNonUniformIndexing(Bool32 shaderStorageImageArrayNonUniformIndexing_) {this->shaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderInputAttachmentArrayNonUniformIndexing(Bool32 shaderInputAttachmentArrayNonUniformIndexing_) {this->shaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderUniformTexelBufferArrayNonUniformIndexing(Bool32 shaderUniformTexelBufferArrayNonUniformIndexing_) {this->shaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderStorageTexelBufferArrayNonUniformIndexing(Bool32 shaderStorageTexelBufferArrayNonUniformIndexing_) {this->shaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingUniformBufferUpdateAfterBind(Bool32 descriptorBindingUniformBufferUpdateAfterBind_) {this->descriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingSampledImageUpdateAfterBind(Bool32 descriptorBindingSampledImageUpdateAfterBind_) {this->descriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingStorageImageUpdateAfterBind(Bool32 descriptorBindingStorageImageUpdateAfterBind_) {this->descriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingStorageBufferUpdateAfterBind(Bool32 descriptorBindingStorageBufferUpdateAfterBind_) {this->descriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingUniformTexelBufferUpdateAfterBind(Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind_) {this->descriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingStorageTexelBufferUpdateAfterBind(Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind_) {this->descriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingUpdateUnusedWhilePending(Bool32 descriptorBindingUpdateUnusedWhilePending_) {this->descriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingPartiallyBound(Bool32 descriptorBindingPartiallyBound_) {this->descriptorBindingPartiallyBound = descriptorBindingPartiallyBound_; return *this; }
    PhysicalDeviceVulkan12Features& setDescriptorBindingVariableDescriptorCount(Bool32 descriptorBindingVariableDescriptorCount_) {this->descriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount_; return *this; }
    PhysicalDeviceVulkan12Features& setRuntimeDescriptorArray(Bool32 runtimeDescriptorArray_) {this->runtimeDescriptorArray = runtimeDescriptorArray_; return *this; }
    PhysicalDeviceVulkan12Features& setSamplerFilterMinmax(Bool32 samplerFilterMinmax_) {this->samplerFilterMinmax = samplerFilterMinmax_; return *this; }
    PhysicalDeviceVulkan12Features& setScalarBlockLayout(Bool32 scalarBlockLayout_) {this->scalarBlockLayout = scalarBlockLayout_; return *this; }
    PhysicalDeviceVulkan12Features& setImagelessFramebuffer(Bool32 imagelessFramebuffer_) {this->imagelessFramebuffer = imagelessFramebuffer_; return *this; }
    PhysicalDeviceVulkan12Features& setUniformBufferStandardLayout(Bool32 uniformBufferStandardLayout_) {this->uniformBufferStandardLayout = uniformBufferStandardLayout_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderSubgroupExtendedTypes(Bool32 shaderSubgroupExtendedTypes_) {this->shaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes_; return *this; }
    PhysicalDeviceVulkan12Features& setSeparateDepthStencilLayouts(Bool32 separateDepthStencilLayouts_) {this->separateDepthStencilLayouts = separateDepthStencilLayouts_; return *this; }
    PhysicalDeviceVulkan12Features& setHostQueryReset(Bool32 hostQueryReset_) {this->hostQueryReset = hostQueryReset_; return *this; }
    PhysicalDeviceVulkan12Features& setTimelineSemaphore(Bool32 timelineSemaphore_) {this->timelineSemaphore = timelineSemaphore_; return *this; }
    PhysicalDeviceVulkan12Features& setBufferDeviceAddress(Bool32 bufferDeviceAddress_) {this->bufferDeviceAddress = bufferDeviceAddress_; return *this; }
    PhysicalDeviceVulkan12Features& setBufferDeviceAddressCaptureReplay(Bool32 bufferDeviceAddressCaptureReplay_) {this->bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay_; return *this; }
    PhysicalDeviceVulkan12Features& setBufferDeviceAddressMultiDevice(Bool32 bufferDeviceAddressMultiDevice_) {this->bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice_; return *this; }
    PhysicalDeviceVulkan12Features& setVulkanMemoryModel(Bool32 vulkanMemoryModel_) {this->vulkanMemoryModel = vulkanMemoryModel_; return *this; }
    PhysicalDeviceVulkan12Features& setVulkanMemoryModelDeviceScope(Bool32 vulkanMemoryModelDeviceScope_) {this->vulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope_; return *this; }
    PhysicalDeviceVulkan12Features& setVulkanMemoryModelAvailabilityVisibilityChains(Bool32 vulkanMemoryModelAvailabilityVisibilityChains_) {this->vulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderOutputViewportIndex(Bool32 shaderOutputViewportIndex_) {this->shaderOutputViewportIndex = shaderOutputViewportIndex_; return *this; }
    PhysicalDeviceVulkan12Features& setShaderOutputLayer(Bool32 shaderOutputLayer_) {this->shaderOutputLayer = shaderOutputLayer_; return *this; }
    PhysicalDeviceVulkan12Features& setSubgroupBroadcastDynamicId(Bool32 subgroupBroadcastDynamicId_) {this->subgroupBroadcastDynamicId = subgroupBroadcastDynamicId_; return *this; }
};
struct PhysicalDeviceVulkan12Properties {
    StructureType sType{StructureType::PhysicalDeviceVulkan12Properties};
    void* pNext = nullptr;
    DriverId driverID{static_cast<DriverId>(0)};
    char driverName[MAX_DRIVER_NAME_SIZE];
    char driverInfo[MAX_DRIVER_INFO_SIZE];
    ConformanceVersion conformanceVersion{};
    ShaderFloatControlsIndependence denormBehaviorIndependence{static_cast<ShaderFloatControlsIndependence>(0)};
    ShaderFloatControlsIndependence roundingModeIndependence{static_cast<ShaderFloatControlsIndependence>(0)};
    Bool32 shaderSignedZeroInfNanPreserveFloat16{0};
    Bool32 shaderSignedZeroInfNanPreserveFloat32{0};
    Bool32 shaderSignedZeroInfNanPreserveFloat64{0};
    Bool32 shaderDenormPreserveFloat16{0};
    Bool32 shaderDenormPreserveFloat32{0};
    Bool32 shaderDenormPreserveFloat64{0};
    Bool32 shaderDenormFlushToZeroFloat16{0};
    Bool32 shaderDenormFlushToZeroFloat32{0};
    Bool32 shaderDenormFlushToZeroFloat64{0};
    Bool32 shaderRoundingModeRTEFloat16{0};
    Bool32 shaderRoundingModeRTEFloat32{0};
    Bool32 shaderRoundingModeRTEFloat64{0};
    Bool32 shaderRoundingModeRTZFloat16{0};
    Bool32 shaderRoundingModeRTZFloat32{0};
    Bool32 shaderRoundingModeRTZFloat64{0};
    uint32_t maxUpdateAfterBindDescriptorsInAllPools{0};
    Bool32 shaderUniformBufferArrayNonUniformIndexingNative{0};
    Bool32 shaderSampledImageArrayNonUniformIndexingNative{0};
    Bool32 shaderStorageBufferArrayNonUniformIndexingNative{0};
    Bool32 shaderStorageImageArrayNonUniformIndexingNative{0};
    Bool32 shaderInputAttachmentArrayNonUniformIndexingNative{0};
    Bool32 robustBufferAccessUpdateAfterBind{0};
    Bool32 quadDivergentImplicitLod{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages{0};
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments{0};
    uint32_t maxPerStageUpdateAfterBindResources{0};
    uint32_t maxDescriptorSetUpdateAfterBindSamplers{0};
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers{0};
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic{0};
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers{0};
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic{0};
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages{0};
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages{0};
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments{0};
    ResolveModeFlags supportedDepthResolveModes{};
    ResolveModeFlags supportedStencilResolveModes{};
    Bool32 independentResolveNone{0};
    Bool32 independentResolve{0};
    Bool32 filterMinmaxSingleComponentFormats{0};
    Bool32 filterMinmaxImageComponentMapping{0};
    uint64_t maxTimelineSemaphoreValueDifference{0};
    SampleCountFlags framebufferIntegerColorSampleCounts{};
    PhysicalDeviceVulkan12Properties& setDriverID(DriverId driverID_) {this->driverID = driverID_; return *this; }
    PhysicalDeviceVulkan12Properties& setDriverName(char driverName_[MAX_DRIVER_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_DRIVER_NAME_SIZE; i++) this->driverName[i] = driverName_[i]; return *this; }
    PhysicalDeviceVulkan12Properties& setDriverInfo(char driverInfo_[MAX_DRIVER_INFO_SIZE]) {for(uint32_t i = 0; i < MAX_DRIVER_INFO_SIZE; i++) this->driverInfo[i] = driverInfo_[i]; return *this; }
    PhysicalDeviceVulkan12Properties& setConformanceVersion(ConformanceVersion conformanceVersion_) {this->conformanceVersion = conformanceVersion_; return *this; }
    PhysicalDeviceVulkan12Properties& setDenormBehaviorIndependence(ShaderFloatControlsIndependence denormBehaviorIndependence_) {this->denormBehaviorIndependence = denormBehaviorIndependence_; return *this; }
    PhysicalDeviceVulkan12Properties& setRoundingModeIndependence(ShaderFloatControlsIndependence roundingModeIndependence_) {this->roundingModeIndependence = roundingModeIndependence_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderSignedZeroInfNanPreserveFloat16(Bool32 shaderSignedZeroInfNanPreserveFloat16_) {this->shaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderSignedZeroInfNanPreserveFloat32(Bool32 shaderSignedZeroInfNanPreserveFloat32_) {this->shaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderSignedZeroInfNanPreserveFloat64(Bool32 shaderSignedZeroInfNanPreserveFloat64_) {this->shaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderDenormPreserveFloat16(Bool32 shaderDenormPreserveFloat16_) {this->shaderDenormPreserveFloat16 = shaderDenormPreserveFloat16_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderDenormPreserveFloat32(Bool32 shaderDenormPreserveFloat32_) {this->shaderDenormPreserveFloat32 = shaderDenormPreserveFloat32_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderDenormPreserveFloat64(Bool32 shaderDenormPreserveFloat64_) {this->shaderDenormPreserveFloat64 = shaderDenormPreserveFloat64_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderDenormFlushToZeroFloat16(Bool32 shaderDenormFlushToZeroFloat16_) {this->shaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderDenormFlushToZeroFloat32(Bool32 shaderDenormFlushToZeroFloat32_) {this->shaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderDenormFlushToZeroFloat64(Bool32 shaderDenormFlushToZeroFloat64_) {this->shaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderRoundingModeRTEFloat16(Bool32 shaderRoundingModeRTEFloat16_) {this->shaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderRoundingModeRTEFloat32(Bool32 shaderRoundingModeRTEFloat32_) {this->shaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderRoundingModeRTEFloat64(Bool32 shaderRoundingModeRTEFloat64_) {this->shaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderRoundingModeRTZFloat16(Bool32 shaderRoundingModeRTZFloat16_) {this->shaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderRoundingModeRTZFloat32(Bool32 shaderRoundingModeRTZFloat32_) {this->shaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderRoundingModeRTZFloat64(Bool32 shaderRoundingModeRTZFloat64_) {this->shaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxUpdateAfterBindDescriptorsInAllPools(uint32_t maxUpdateAfterBindDescriptorsInAllPools_) {this->maxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderUniformBufferArrayNonUniformIndexingNative(Bool32 shaderUniformBufferArrayNonUniformIndexingNative_) {this->shaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderSampledImageArrayNonUniformIndexingNative(Bool32 shaderSampledImageArrayNonUniformIndexingNative_) {this->shaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderStorageBufferArrayNonUniformIndexingNative(Bool32 shaderStorageBufferArrayNonUniformIndexingNative_) {this->shaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderStorageImageArrayNonUniformIndexingNative(Bool32 shaderStorageImageArrayNonUniformIndexingNative_) {this->shaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceVulkan12Properties& setShaderInputAttachmentArrayNonUniformIndexingNative(Bool32 shaderInputAttachmentArrayNonUniformIndexingNative_) {this->shaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative_; return *this; }
    PhysicalDeviceVulkan12Properties& setRobustBufferAccessUpdateAfterBind(Bool32 robustBufferAccessUpdateAfterBind_) {this->robustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind_; return *this; }
    PhysicalDeviceVulkan12Properties& setQuadDivergentImplicitLod(Bool32 quadDivergentImplicitLod_) {this->quadDivergentImplicitLod = quadDivergentImplicitLod_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageDescriptorUpdateAfterBindSamplers(uint32_t maxPerStageDescriptorUpdateAfterBindSamplers_) {this->maxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageDescriptorUpdateAfterBindUniformBuffers(uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers_) {this->maxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageDescriptorUpdateAfterBindStorageBuffers(uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers_) {this->maxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageDescriptorUpdateAfterBindSampledImages(uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages_) {this->maxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageDescriptorUpdateAfterBindStorageImages(uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages_) {this->maxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageDescriptorUpdateAfterBindInputAttachments(uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments_) {this->maxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxPerStageUpdateAfterBindResources(uint32_t maxPerStageUpdateAfterBindResources_) {this->maxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindSamplers(uint32_t maxDescriptorSetUpdateAfterBindSamplers_) {this->maxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindUniformBuffers(uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers_) {this->maxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic(uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_) {this->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindStorageBuffers(uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers_) {this->maxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic(uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_) {this->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindSampledImages(uint32_t maxDescriptorSetUpdateAfterBindSampledImages_) {this->maxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindStorageImages(uint32_t maxDescriptorSetUpdateAfterBindStorageImages_) {this->maxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxDescriptorSetUpdateAfterBindInputAttachments(uint32_t maxDescriptorSetUpdateAfterBindInputAttachments_) {this->maxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments_; return *this; }
    PhysicalDeviceVulkan12Properties& setSupportedDepthResolveModes(ResolveModeFlags supportedDepthResolveModes_) {this->supportedDepthResolveModes = supportedDepthResolveModes_; return *this; }
    PhysicalDeviceVulkan12Properties& setSupportedStencilResolveModes(ResolveModeFlags supportedStencilResolveModes_) {this->supportedStencilResolveModes = supportedStencilResolveModes_; return *this; }
    PhysicalDeviceVulkan12Properties& setIndependentResolveNone(Bool32 independentResolveNone_) {this->independentResolveNone = independentResolveNone_; return *this; }
    PhysicalDeviceVulkan12Properties& setIndependentResolve(Bool32 independentResolve_) {this->independentResolve = independentResolve_; return *this; }
    PhysicalDeviceVulkan12Properties& setFilterMinmaxSingleComponentFormats(Bool32 filterMinmaxSingleComponentFormats_) {this->filterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats_; return *this; }
    PhysicalDeviceVulkan12Properties& setFilterMinmaxImageComponentMapping(Bool32 filterMinmaxImageComponentMapping_) {this->filterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping_; return *this; }
    PhysicalDeviceVulkan12Properties& setMaxTimelineSemaphoreValueDifference(uint64_t maxTimelineSemaphoreValueDifference_) {this->maxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference_; return *this; }
    PhysicalDeviceVulkan12Properties& setFramebufferIntegerColorSampleCounts(SampleCountFlags framebufferIntegerColorSampleCounts_) {this->framebufferIntegerColorSampleCounts = framebufferIntegerColorSampleCounts_; return *this; }
};
struct PipelineCompilerControlCreateInfoAMD {
    StructureType sType{StructureType::PipelineCompilerControlCreateInfoAMD};
    const void* pNext = nullptr;
    PipelineCompilerControlFlagsAMD compilerControlFlags{};
    PipelineCompilerControlCreateInfoAMD& setCompilerControlFlags(PipelineCompilerControlFlagsAMD compilerControlFlags_) {this->compilerControlFlags = compilerControlFlags_; return *this; }
};
struct PhysicalDeviceCoherentMemoryFeaturesAMD {
    StructureType sType{StructureType::PhysicalDeviceCoherentMemoryFeaturesAMD};
    void* pNext = nullptr;
    Bool32 deviceCoherentMemory{0};
    PhysicalDeviceCoherentMemoryFeaturesAMD& setDeviceCoherentMemory(Bool32 deviceCoherentMemory_) {this->deviceCoherentMemory = deviceCoherentMemory_; return *this; }
};
struct PhysicalDeviceToolPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceToolPropertiesEXT};
    void* pNext = nullptr;
    char name[MAX_EXTENSION_NAME_SIZE];
    char version[MAX_EXTENSION_NAME_SIZE];
    ToolPurposeFlagsEXT purposes{};
    char description[MAX_DESCRIPTION_SIZE];
    char layer[MAX_EXTENSION_NAME_SIZE];
    PhysicalDeviceToolPropertiesEXT& setName(char name_[MAX_EXTENSION_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_EXTENSION_NAME_SIZE; i++) this->name[i] = name_[i]; return *this; }
    PhysicalDeviceToolPropertiesEXT& setVersion(char version_[MAX_EXTENSION_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_EXTENSION_NAME_SIZE; i++) this->version[i] = version_[i]; return *this; }
    PhysicalDeviceToolPropertiesEXT& setPurposes(ToolPurposeFlagsEXT purposes_) {this->purposes = purposes_; return *this; }
    PhysicalDeviceToolPropertiesEXT& setDescription(char description_[MAX_DESCRIPTION_SIZE]) {for(uint32_t i = 0; i < MAX_DESCRIPTION_SIZE; i++) this->description[i] = description_[i]; return *this; }
    PhysicalDeviceToolPropertiesEXT& setLayer(char layer_[MAX_EXTENSION_NAME_SIZE]) {for(uint32_t i = 0; i < MAX_EXTENSION_NAME_SIZE; i++) this->layer[i] = layer_[i]; return *this; }
};
struct SamplerCustomBorderColorCreateInfoEXT {
    StructureType sType{StructureType::SamplerCustomBorderColorCreateInfoEXT};
    const void* pNext = nullptr;
    ClearColorValue customBorderColor{};
    Format format{static_cast<Format>(0)};
    SamplerCustomBorderColorCreateInfoEXT& setCustomBorderColor(ClearColorValue customBorderColor_) {this->customBorderColor = customBorderColor_; return *this; }
    SamplerCustomBorderColorCreateInfoEXT& setFormat(Format format_) {this->format = format_; return *this; }
};
struct PhysicalDeviceCustomBorderColorPropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceCustomBorderColorPropertiesEXT};
    void* pNext = nullptr;
    uint32_t maxCustomBorderColorSamplers{0};
    PhysicalDeviceCustomBorderColorPropertiesEXT& setMaxCustomBorderColorSamplers(uint32_t maxCustomBorderColorSamplers_) {this->maxCustomBorderColorSamplers = maxCustomBorderColorSamplers_; return *this; }
};
struct PhysicalDeviceCustomBorderColorFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceCustomBorderColorFeaturesEXT};
    void* pNext = nullptr;
    Bool32 customBorderColors{0};
    Bool32 customBorderColorWithoutFormat{0};
    PhysicalDeviceCustomBorderColorFeaturesEXT& setCustomBorderColors(Bool32 customBorderColors_) {this->customBorderColors = customBorderColors_; return *this; }
    PhysicalDeviceCustomBorderColorFeaturesEXT& setCustomBorderColorWithoutFormat(Bool32 customBorderColorWithoutFormat_) {this->customBorderColorWithoutFormat = customBorderColorWithoutFormat_; return *this; }
};
union DeviceOrHostAddressKHR {
    DeviceAddress deviceAddress;
    void* hostAddress;
    DeviceOrHostAddressKHR& setDeviceAddress(DeviceAddress deviceAddress_) {this->deviceAddress = deviceAddress_; return *this; }
    DeviceOrHostAddressKHR& setHostAddress(void* hostAddress_) {this->hostAddress = hostAddress_; return *this; }
};
union DeviceOrHostAddressConstKHR {
    DeviceAddress deviceAddress;
    const void* hostAddress;
    DeviceOrHostAddressConstKHR& setDeviceAddress(DeviceAddress deviceAddress_) {this->deviceAddress = deviceAddress_; return *this; }
    DeviceOrHostAddressConstKHR& setHostAddress(const void* hostAddress_) {this->hostAddress = hostAddress_; return *this; }
};
struct AccelerationStructureGeometryTrianglesDataKHR {
    StructureType sType{StructureType::AccelerationStructureGeometryTrianglesDataKHR};
    const void* pNext = nullptr;
    Format vertexFormat{static_cast<Format>(0)};
    DeviceOrHostAddressConstKHR vertexData{};
    DeviceSize vertexStride{0};
    uint32_t maxVertex{0};
    IndexType indexType{static_cast<IndexType>(0)};
    DeviceOrHostAddressConstKHR indexData{};
    DeviceOrHostAddressConstKHR transformData{};
    AccelerationStructureGeometryTrianglesDataKHR& setVertexFormat(Format vertexFormat_) {this->vertexFormat = vertexFormat_; return *this; }
    AccelerationStructureGeometryTrianglesDataKHR& setVertexData(DeviceOrHostAddressConstKHR vertexData_) {this->vertexData = vertexData_; return *this; }
    AccelerationStructureGeometryTrianglesDataKHR& setVertexStride(DeviceSize vertexStride_) {this->vertexStride = vertexStride_; return *this; }
    AccelerationStructureGeometryTrianglesDataKHR& setMaxVertex(uint32_t maxVertex_) {this->maxVertex = maxVertex_; return *this; }
    AccelerationStructureGeometryTrianglesDataKHR& setIndexType(IndexType indexType_) {this->indexType = indexType_; return *this; }
    AccelerationStructureGeometryTrianglesDataKHR& setIndexData(DeviceOrHostAddressConstKHR indexData_) {this->indexData = indexData_; return *this; }
    AccelerationStructureGeometryTrianglesDataKHR& setTransformData(DeviceOrHostAddressConstKHR transformData_) {this->transformData = transformData_; return *this; }
};
struct AccelerationStructureGeometryAabbsDataKHR {
    StructureType sType{StructureType::AccelerationStructureGeometryAabbsDataKHR};
    const void* pNext = nullptr;
    DeviceOrHostAddressConstKHR data{};
    DeviceSize stride{0};
    AccelerationStructureGeometryAabbsDataKHR& setData(DeviceOrHostAddressConstKHR data_) {this->data = data_; return *this; }
    AccelerationStructureGeometryAabbsDataKHR& setStride(DeviceSize stride_) {this->stride = stride_; return *this; }
};
struct AccelerationStructureGeometryInstancesDataKHR {
    StructureType sType{StructureType::AccelerationStructureGeometryInstancesDataKHR};
    const void* pNext = nullptr;
    Bool32 arrayOfPointers{0};
    DeviceOrHostAddressConstKHR data{};
    AccelerationStructureGeometryInstancesDataKHR& setArrayOfPointers(Bool32 arrayOfPointers_) {this->arrayOfPointers = arrayOfPointers_; return *this; }
    AccelerationStructureGeometryInstancesDataKHR& setData(DeviceOrHostAddressConstKHR data_) {this->data = data_; return *this; }
};
union AccelerationStructureGeometryDataKHR {
    AccelerationStructureGeometryTrianglesDataKHR triangles;
    AccelerationStructureGeometryAabbsDataKHR aabbs;
    AccelerationStructureGeometryInstancesDataKHR instances;
    AccelerationStructureGeometryDataKHR& setTriangles(AccelerationStructureGeometryTrianglesDataKHR triangles_) {this->triangles = triangles_; return *this; }
    AccelerationStructureGeometryDataKHR& setAabbs(AccelerationStructureGeometryAabbsDataKHR aabbs_) {this->aabbs = aabbs_; return *this; }
    AccelerationStructureGeometryDataKHR& setInstances(AccelerationStructureGeometryInstancesDataKHR instances_) {this->instances = instances_; return *this; }
};
struct AccelerationStructureGeometryKHR {
    StructureType sType{StructureType::AccelerationStructureGeometryKHR};
    const void* pNext = nullptr;
    GeometryTypeKHR geometryType{static_cast<GeometryTypeKHR>(0)};
    AccelerationStructureGeometryDataKHR geometry{};
    GeometryFlagsKHR flags{};
    AccelerationStructureGeometryKHR& setGeometryType(GeometryTypeKHR geometryType_) {this->geometryType = geometryType_; return *this; }
    AccelerationStructureGeometryKHR& setGeometry(AccelerationStructureGeometryDataKHR geometry_) {this->geometry = geometry_; return *this; }
    AccelerationStructureGeometryKHR& setFlags(GeometryFlagsKHR flags_) {this->flags = flags_; return *this; }
};
struct AccelerationStructureBuildGeometryInfoKHR {
    StructureType sType{StructureType::AccelerationStructureBuildGeometryInfoKHR};
    const void* pNext = nullptr;
    AccelerationStructureTypeKHR type{static_cast<AccelerationStructureTypeKHR>(0)};
    BuildAccelerationStructureFlagsKHR flags{};
    BuildAccelerationStructureModeKHR mode{static_cast<BuildAccelerationStructureModeKHR>(0)};
    AccelerationStructureKHR srcAccelerationStructure{};
    AccelerationStructureKHR dstAccelerationStructure{};
    uint32_t geometryCount{0};
    const AccelerationStructureGeometryKHR* pGeometries = nullptr;
    const AccelerationStructureGeometryKHR* const* ppGeometries = nullptr;
    DeviceOrHostAddressKHR scratchData{};
    AccelerationStructureBuildGeometryInfoKHR& setType(AccelerationStructureTypeKHR type_) {this->type = type_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setFlags(BuildAccelerationStructureFlagsKHR flags_) {this->flags = flags_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setMode(BuildAccelerationStructureModeKHR mode_) {this->mode = mode_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setSrcAccelerationStructure(AccelerationStructureKHR srcAccelerationStructure_) {this->srcAccelerationStructure = srcAccelerationStructure_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setDstAccelerationStructure(AccelerationStructureKHR dstAccelerationStructure_) {this->dstAccelerationStructure = dstAccelerationStructure_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setGeometryCount(uint32_t geometryCount_) {this->geometryCount = geometryCount_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setPGeometries(const AccelerationStructureGeometryKHR* pGeometries_) {this->pGeometries = pGeometries_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setPGeometries(detail::span<const AccelerationStructureGeometryKHR> pGeometries_) {this->geometryCount = pGeometries_.size(); this->pGeometries = pGeometries_.data();  return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setPpGeometries(const AccelerationStructureGeometryKHR* const* ppGeometries_) {this->ppGeometries = ppGeometries_; return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setPpGeometries(detail::span<const AccelerationStructureGeometryKHR*> ppGeometries_) {this->geometryCount = ppGeometries_.size(); this->ppGeometries = ppGeometries_.data();  return *this; }
    AccelerationStructureBuildGeometryInfoKHR& setScratchData(DeviceOrHostAddressKHR scratchData_) {this->scratchData = scratchData_; return *this; }
};
struct AccelerationStructureBuildRangeInfoKHR {
    uint32_t primitiveCount{0};
    uint32_t primitiveOffset{0};
    uint32_t firstVertex{0};
    uint32_t transformOffset{0};
    constexpr bool operator==(AccelerationStructureBuildRangeInfoKHR const& value) const {
        return primitiveCount == value.primitiveCount && primitiveOffset == value.primitiveOffset && firstVertex == value.firstVertex && transformOffset == value.transformOffset 
        ;}
    constexpr bool operator!=(AccelerationStructureBuildRangeInfoKHR const& value) const {return !(*this == value);}
    AccelerationStructureBuildRangeInfoKHR& setPrimitiveCount(uint32_t primitiveCount_) {this->primitiveCount = primitiveCount_; return *this; }
    AccelerationStructureBuildRangeInfoKHR& setPrimitiveOffset(uint32_t primitiveOffset_) {this->primitiveOffset = primitiveOffset_; return *this; }
    AccelerationStructureBuildRangeInfoKHR& setFirstVertex(uint32_t firstVertex_) {this->firstVertex = firstVertex_; return *this; }
    AccelerationStructureBuildRangeInfoKHR& setTransformOffset(uint32_t transformOffset_) {this->transformOffset = transformOffset_; return *this; }
};
struct AccelerationStructureCreateInfoKHR {
    StructureType sType{StructureType::AccelerationStructureCreateInfoKHR};
    const void* pNext = nullptr;
    AccelerationStructureCreateFlagsKHR createFlags{};
    Buffer buffer{};
    DeviceSize offset{0};
    DeviceSize size{0};
    AccelerationStructureTypeKHR type{static_cast<AccelerationStructureTypeKHR>(0)};
    DeviceAddress deviceAddress{0};
    AccelerationStructureCreateInfoKHR& setCreateFlags(AccelerationStructureCreateFlagsKHR createFlags_) {this->createFlags = createFlags_; return *this; }
    AccelerationStructureCreateInfoKHR& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    AccelerationStructureCreateInfoKHR& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    AccelerationStructureCreateInfoKHR& setSize(DeviceSize size_) {this->size = size_; return *this; }
    AccelerationStructureCreateInfoKHR& setType(AccelerationStructureTypeKHR type_) {this->type = type_; return *this; }
    AccelerationStructureCreateInfoKHR& setDeviceAddress(DeviceAddress deviceAddress_) {this->deviceAddress = deviceAddress_; return *this; }
};
struct AabbPositionsKHR {
    float minX{0.f};
    float minY{0.f};
    float minZ{0.f};
    float maxX{0.f};
    float maxY{0.f};
    float maxZ{0.f};
    constexpr bool operator==(AabbPositionsKHR const& value) const {
        return minX == value.minX && minY == value.minY && minZ == value.minZ && maxX == value.maxX && maxY == value.maxY && maxZ == value.maxZ ;}
    constexpr bool operator!=(AabbPositionsKHR const& value) const {return !(*this == value);}
    AabbPositionsKHR& setMinX(float minX_) {this->minX = minX_; return *this; }
    AabbPositionsKHR& setMinY(float minY_) {this->minY = minY_; return *this; }
    AabbPositionsKHR& setMinZ(float minZ_) {this->minZ = minZ_; return *this; }
    AabbPositionsKHR& setMaxX(float maxX_) {this->maxX = maxX_; return *this; }
    AabbPositionsKHR& setMaxY(float maxY_) {this->maxY = maxY_; return *this; }
    AabbPositionsKHR& setMaxZ(float maxZ_) {this->maxZ = maxZ_; return *this; }
};
using AabbPositionsNV = AabbPositionsKHR;
struct TransformMatrixKHR {
    float matrix[3][4];
    constexpr bool operator==(TransformMatrixKHR const& value) const {
        bool is_equal = true;
                for(uint32_t i = 0; i < 3; i++)
            for(uint32_t j = 0; j < 4; j++)
                is_equal &= matrix[i][j] == value.matrix[i][j];
        return is_equal;}
    constexpr bool operator!=(TransformMatrixKHR const& value) const {return !(*this == value);}
    TransformMatrixKHR& setMatrix(float matrix_[3][4]) {
        for(uint32_t i = 0; i < 3; i++){ for(uint32_t j = 0; j < 4; j++){
        this->matrix[i][j] = matrix_[i][j];}} return *this; }
};
using TransformMatrixNV = TransformMatrixKHR;
struct AccelerationStructureInstanceKHR {
    TransformMatrixKHR transform{};
    uint32_t instanceCustomIndex:24;
    uint32_t mask:8;
    uint32_t instanceShaderBindingTableRecordOffset:24;
    uint32_t flags:8;
    uint64_t accelerationStructureReference{0};
    constexpr bool operator==(AccelerationStructureInstanceKHR const& value) const {
        return transform == value.transform && instanceCustomIndex == value.instanceCustomIndex && mask == value.mask && instanceShaderBindingTableRecordOffset == value.instanceShaderBindingTableRecordOffset 
        && flags == value.flags && accelerationStructureReference == value.accelerationStructureReference ;}
    constexpr bool operator!=(AccelerationStructureInstanceKHR const& value) const {return !(*this == value);}
    AccelerationStructureInstanceKHR& setTransform(TransformMatrixKHR transform_) {this->transform = transform_; return *this; }
    AccelerationStructureInstanceKHR& setInstanceCustomIndex(uint32_t instanceCustomIndex_) {this->instanceCustomIndex = instanceCustomIndex_; return *this; }
    AccelerationStructureInstanceKHR& setMask(uint32_t mask_) {this->mask = mask_; return *this; }
    AccelerationStructureInstanceKHR& setInstanceShaderBindingTableRecordOffset(uint32_t instanceShaderBindingTableRecordOffset_) {this->instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset_; return *this; }
    AccelerationStructureInstanceKHR& setFlags(uint32_t flags_) {this->flags = flags_; return *this; }
    AccelerationStructureInstanceKHR& setAccelerationStructureReference(uint64_t accelerationStructureReference_) {this->accelerationStructureReference = accelerationStructureReference_; return *this; }
};
using AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;
struct AccelerationStructureDeviceAddressInfoKHR {
    StructureType sType{StructureType::AccelerationStructureDeviceAddressInfoKHR};
    const void* pNext = nullptr;
    AccelerationStructureKHR accelerationStructure{};
    AccelerationStructureDeviceAddressInfoKHR& setAccelerationStructure(AccelerationStructureKHR accelerationStructure_) {this->accelerationStructure = accelerationStructure_; return *this; }
};
struct AccelerationStructureVersionInfoKHR {
    StructureType sType{StructureType::AccelerationStructureVersionInfoKHR};
    const void* pNext = nullptr;
    const uint8_t* pVersionData = nullptr;
    AccelerationStructureVersionInfoKHR& setPVersionData(const uint8_t* pVersionData_) {this->pVersionData = pVersionData_; return *this; }
};
struct CopyAccelerationStructureInfoKHR {
    StructureType sType{StructureType::CopyAccelerationStructureInfoKHR};
    const void* pNext = nullptr;
    AccelerationStructureKHR src{};
    AccelerationStructureKHR dst{};
    CopyAccelerationStructureModeKHR mode{static_cast<CopyAccelerationStructureModeKHR>(0)};
    CopyAccelerationStructureInfoKHR& setSrc(AccelerationStructureKHR src_) {this->src = src_; return *this; }
    CopyAccelerationStructureInfoKHR& setDst(AccelerationStructureKHR dst_) {this->dst = dst_; return *this; }
    CopyAccelerationStructureInfoKHR& setMode(CopyAccelerationStructureModeKHR mode_) {this->mode = mode_; return *this; }
};
struct CopyAccelerationStructureToMemoryInfoKHR {
    StructureType sType{StructureType::CopyAccelerationStructureToMemoryInfoKHR};
    const void* pNext = nullptr;
    AccelerationStructureKHR src{};
    DeviceOrHostAddressKHR dst{};
    CopyAccelerationStructureModeKHR mode{static_cast<CopyAccelerationStructureModeKHR>(0)};
    CopyAccelerationStructureToMemoryInfoKHR& setSrc(AccelerationStructureKHR src_) {this->src = src_; return *this; }
    CopyAccelerationStructureToMemoryInfoKHR& setDst(DeviceOrHostAddressKHR dst_) {this->dst = dst_; return *this; }
    CopyAccelerationStructureToMemoryInfoKHR& setMode(CopyAccelerationStructureModeKHR mode_) {this->mode = mode_; return *this; }
};
struct CopyMemoryToAccelerationStructureInfoKHR {
    StructureType sType{StructureType::CopyMemoryToAccelerationStructureInfoKHR};
    const void* pNext = nullptr;
    DeviceOrHostAddressConstKHR src{};
    AccelerationStructureKHR dst{};
    CopyAccelerationStructureModeKHR mode{static_cast<CopyAccelerationStructureModeKHR>(0)};
    CopyMemoryToAccelerationStructureInfoKHR& setSrc(DeviceOrHostAddressConstKHR src_) {this->src = src_; return *this; }
    CopyMemoryToAccelerationStructureInfoKHR& setDst(AccelerationStructureKHR dst_) {this->dst = dst_; return *this; }
    CopyMemoryToAccelerationStructureInfoKHR& setMode(CopyAccelerationStructureModeKHR mode_) {this->mode = mode_; return *this; }
};
struct PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceExtendedDynamicStateFeaturesEXT};
    void* pNext = nullptr;
    Bool32 extendedDynamicState{0};
    PhysicalDeviceExtendedDynamicStateFeaturesEXT& setExtendedDynamicState(Bool32 extendedDynamicState_) {this->extendedDynamicState = extendedDynamicState_; return *this; }
};
struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceExtendedDynamicState2FeaturesEXT};
    void* pNext = nullptr;
    Bool32 extendedDynamicState2{0};
    Bool32 extendedDynamicState2LogicOp{0};
    Bool32 extendedDynamicState2PatchControlPoints{0};
    PhysicalDeviceExtendedDynamicState2FeaturesEXT& setExtendedDynamicState2(Bool32 extendedDynamicState2_) {this->extendedDynamicState2 = extendedDynamicState2_; return *this; }
    PhysicalDeviceExtendedDynamicState2FeaturesEXT& setExtendedDynamicState2LogicOp(Bool32 extendedDynamicState2LogicOp_) {this->extendedDynamicState2LogicOp = extendedDynamicState2LogicOp_; return *this; }
    PhysicalDeviceExtendedDynamicState2FeaturesEXT& setExtendedDynamicState2PatchControlPoints(Bool32 extendedDynamicState2PatchControlPoints_) {this->extendedDynamicState2PatchControlPoints = extendedDynamicState2PatchControlPoints_; return *this; }
};
struct RenderPassTransformBeginInfoQCOM {
    StructureType sType{StructureType::RenderPassTransformBeginInfoQCOM};
    void* pNext = nullptr;
    SurfaceTransformFlagBitsKHR transform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    RenderPassTransformBeginInfoQCOM& setTransform(SurfaceTransformFlagBitsKHR transform_) {this->transform = transform_; return *this; }
};
struct CopyCommandTransformInfoQCOM {
    StructureType sType{StructureType::CopyCommandTransformInfoQCOM};
    const void* pNext = nullptr;
    SurfaceTransformFlagBitsKHR transform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    CopyCommandTransformInfoQCOM& setTransform(SurfaceTransformFlagBitsKHR transform_) {this->transform = transform_; return *this; }
};
struct CommandBufferInheritanceRenderPassTransformInfoQCOM {
    StructureType sType{StructureType::CommandBufferInheritanceRenderPassTransformInfoQCOM};
    void* pNext = nullptr;
    SurfaceTransformFlagBitsKHR transform{static_cast<SurfaceTransformFlagBitsKHR>(0)};
    Rect2D renderArea{};
    CommandBufferInheritanceRenderPassTransformInfoQCOM& setTransform(SurfaceTransformFlagBitsKHR transform_) {this->transform = transform_; return *this; }
    CommandBufferInheritanceRenderPassTransformInfoQCOM& setRenderArea(Rect2D renderArea_) {this->renderArea = renderArea_; return *this; }
};
struct PhysicalDeviceDiagnosticsConfigFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceDiagnosticsConfigFeaturesNV};
    void* pNext = nullptr;
    Bool32 diagnosticsConfig{0};
    PhysicalDeviceDiagnosticsConfigFeaturesNV& setDiagnosticsConfig(Bool32 diagnosticsConfig_) {this->diagnosticsConfig = diagnosticsConfig_; return *this; }
};
struct DeviceDiagnosticsConfigCreateInfoNV {
    StructureType sType{StructureType::DeviceDiagnosticsConfigCreateInfoNV};
    const void* pNext = nullptr;
    DeviceDiagnosticsConfigFlagsNV flags{};
    DeviceDiagnosticsConfigCreateInfoNV& setFlags(DeviceDiagnosticsConfigFlagsNV flags_) {this->flags = flags_; return *this; }
};
struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR};
    void* pNext = nullptr;
    Bool32 shaderZeroInitializeWorkgroupMemory{0};
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR& setShaderZeroInitializeWorkgroupMemory(Bool32 shaderZeroInitializeWorkgroupMemory_) {this->shaderZeroInitializeWorkgroupMemory = shaderZeroInitializeWorkgroupMemory_; return *this; }
};
struct PhysicalDeviceRobustness2FeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceRobustness2FeaturesEXT};
    void* pNext = nullptr;
    Bool32 robustBufferAccess2{0};
    Bool32 robustImageAccess2{0};
    Bool32 nullDescriptor{0};
    PhysicalDeviceRobustness2FeaturesEXT& setRobustBufferAccess2(Bool32 robustBufferAccess2_) {this->robustBufferAccess2 = robustBufferAccess2_; return *this; }
    PhysicalDeviceRobustness2FeaturesEXT& setRobustImageAccess2(Bool32 robustImageAccess2_) {this->robustImageAccess2 = robustImageAccess2_; return *this; }
    PhysicalDeviceRobustness2FeaturesEXT& setNullDescriptor(Bool32 nullDescriptor_) {this->nullDescriptor = nullDescriptor_; return *this; }
};
struct PhysicalDeviceRobustness2PropertiesEXT {
    StructureType sType{StructureType::PhysicalDeviceRobustness2PropertiesEXT};
    void* pNext = nullptr;
    DeviceSize robustStorageBufferAccessSizeAlignment{0};
    DeviceSize robustUniformBufferAccessSizeAlignment{0};
    PhysicalDeviceRobustness2PropertiesEXT& setRobustStorageBufferAccessSizeAlignment(DeviceSize robustStorageBufferAccessSizeAlignment_) {this->robustStorageBufferAccessSizeAlignment = robustStorageBufferAccessSizeAlignment_; return *this; }
    PhysicalDeviceRobustness2PropertiesEXT& setRobustUniformBufferAccessSizeAlignment(DeviceSize robustUniformBufferAccessSizeAlignment_) {this->robustUniformBufferAccessSizeAlignment = robustUniformBufferAccessSizeAlignment_; return *this; }
};
struct PhysicalDeviceImageRobustnessFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceImageRobustnessFeaturesEXT};
    void* pNext = nullptr;
    Bool32 robustImageAccess{0};
    PhysicalDeviceImageRobustnessFeaturesEXT& setRobustImageAccess(Bool32 robustImageAccess_) {this->robustImageAccess = robustImageAccess_; return *this; }
};
struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR};
    void* pNext = nullptr;
    Bool32 workgroupMemoryExplicitLayout{0};
    Bool32 workgroupMemoryExplicitLayoutScalarBlockLayout{0};
    Bool32 workgroupMemoryExplicitLayout8BitAccess{0};
    Bool32 workgroupMemoryExplicitLayout16BitAccess{0};
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& setWorkgroupMemoryExplicitLayout(Bool32 workgroupMemoryExplicitLayout_) {this->workgroupMemoryExplicitLayout = workgroupMemoryExplicitLayout_; return *this; }
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& setWorkgroupMemoryExplicitLayoutScalarBlockLayout(Bool32 workgroupMemoryExplicitLayoutScalarBlockLayout_) {this->workgroupMemoryExplicitLayoutScalarBlockLayout = workgroupMemoryExplicitLayoutScalarBlockLayout_; return *this; }
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& setWorkgroupMemoryExplicitLayout8BitAccess(Bool32 workgroupMemoryExplicitLayout8BitAccess_) {this->workgroupMemoryExplicitLayout8BitAccess = workgroupMemoryExplicitLayout8BitAccess_; return *this; }
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& setWorkgroupMemoryExplicitLayout16BitAccess(Bool32 workgroupMemoryExplicitLayout16BitAccess_) {this->workgroupMemoryExplicitLayout16BitAccess = workgroupMemoryExplicitLayout16BitAccess_; return *this; }
};
#if defined(VK_ENABLE_BETA_EXTENSIONS)
struct PhysicalDevicePortabilitySubsetFeaturesKHR {
    StructureType sType{StructureType::PhysicalDevicePortabilitySubsetFeaturesKHR};
    void* pNext = nullptr;
    Bool32 constantAlphaColorBlendFactors{0};
    Bool32 events{0};
    Bool32 imageViewFormatReinterpretation{0};
    Bool32 imageViewFormatSwizzle{0};
    Bool32 imageView2DOn3DImage{0};
    Bool32 multisampleArrayImage{0};
    Bool32 mutableComparisonSamplers{0};
    Bool32 pointPolygons{0};
    Bool32 samplerMipLodBias{0};
    Bool32 separateStencilMaskRef{0};
    Bool32 shaderSampleRateInterpolationFunctions{0};
    Bool32 tessellationIsolines{0};
    Bool32 tessellationPointMode{0};
    Bool32 triangleFans{0};
    Bool32 vertexAttributeAccessBeyondStride{0};
    PhysicalDevicePortabilitySubsetFeaturesKHR& setConstantAlphaColorBlendFactors(Bool32 constantAlphaColorBlendFactors_) {this->constantAlphaColorBlendFactors = constantAlphaColorBlendFactors_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setEvents(Bool32 events_) {this->events = events_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setImageViewFormatReinterpretation(Bool32 imageViewFormatReinterpretation_) {this->imageViewFormatReinterpretation = imageViewFormatReinterpretation_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setImageViewFormatSwizzle(Bool32 imageViewFormatSwizzle_) {this->imageViewFormatSwizzle = imageViewFormatSwizzle_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setImageView2DOn3DImage(Bool32 imageView2DOn3DImage_) {this->imageView2DOn3DImage = imageView2DOn3DImage_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setMultisampleArrayImage(Bool32 multisampleArrayImage_) {this->multisampleArrayImage = multisampleArrayImage_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setMutableComparisonSamplers(Bool32 mutableComparisonSamplers_) {this->mutableComparisonSamplers = mutableComparisonSamplers_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setPointPolygons(Bool32 pointPolygons_) {this->pointPolygons = pointPolygons_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setSamplerMipLodBias(Bool32 samplerMipLodBias_) {this->samplerMipLodBias = samplerMipLodBias_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setSeparateStencilMaskRef(Bool32 separateStencilMaskRef_) {this->separateStencilMaskRef = separateStencilMaskRef_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setShaderSampleRateInterpolationFunctions(Bool32 shaderSampleRateInterpolationFunctions_) {this->shaderSampleRateInterpolationFunctions = shaderSampleRateInterpolationFunctions_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setTessellationIsolines(Bool32 tessellationIsolines_) {this->tessellationIsolines = tessellationIsolines_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setTessellationPointMode(Bool32 tessellationPointMode_) {this->tessellationPointMode = tessellationPointMode_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setTriangleFans(Bool32 triangleFans_) {this->triangleFans = triangleFans_; return *this; }
    PhysicalDevicePortabilitySubsetFeaturesKHR& setVertexAttributeAccessBeyondStride(Bool32 vertexAttributeAccessBeyondStride_) {this->vertexAttributeAccessBeyondStride = vertexAttributeAccessBeyondStride_; return *this; }
};
struct PhysicalDevicePortabilitySubsetPropertiesKHR {
    StructureType sType{StructureType::PhysicalDevicePortabilitySubsetPropertiesKHR};
    void* pNext = nullptr;
    uint32_t minVertexInputBindingStrideAlignment{0};
    PhysicalDevicePortabilitySubsetPropertiesKHR& setMinVertexInputBindingStrideAlignment(uint32_t minVertexInputBindingStrideAlignment_) {this->minVertexInputBindingStrideAlignment = minVertexInputBindingStrideAlignment_; return *this; }
};
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
struct PhysicalDevice4444FormatsFeaturesEXT {
    StructureType sType{StructureType::PhysicalDevice4444FormatsFeaturesEXT};
    void* pNext = nullptr;
    Bool32 formatA4R4G4B4{0};
    Bool32 formatA4B4G4R4{0};
    PhysicalDevice4444FormatsFeaturesEXT& setFormatA4R4G4B4(Bool32 formatA4R4G4B4_) {this->formatA4R4G4B4 = formatA4R4G4B4_; return *this; }
    PhysicalDevice4444FormatsFeaturesEXT& setFormatA4B4G4R4(Bool32 formatA4B4G4R4_) {this->formatA4B4G4R4 = formatA4B4G4R4_; return *this; }
};
struct BufferCopy2KHR {
    StructureType sType{StructureType::BufferCopy2KHR};
    const void* pNext = nullptr;
    DeviceSize srcOffset{0};
    DeviceSize dstOffset{0};
    DeviceSize size{0};
    BufferCopy2KHR& setSrcOffset(DeviceSize srcOffset_) {this->srcOffset = srcOffset_; return *this; }
    BufferCopy2KHR& setDstOffset(DeviceSize dstOffset_) {this->dstOffset = dstOffset_; return *this; }
    BufferCopy2KHR& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
struct ImageCopy2KHR {
    StructureType sType{StructureType::ImageCopy2KHR};
    const void* pNext = nullptr;
    ImageSubresourceLayers srcSubresource{};
    Offset3D srcOffset{};
    ImageSubresourceLayers dstSubresource{};
    Offset3D dstOffset{};
    Extent3D extent{};
    ImageCopy2KHR& setSrcSubresource(ImageSubresourceLayers srcSubresource_) {this->srcSubresource = srcSubresource_; return *this; }
    ImageCopy2KHR& setSrcOffset(Offset3D srcOffset_) {this->srcOffset = srcOffset_; return *this; }
    ImageCopy2KHR& setDstSubresource(ImageSubresourceLayers dstSubresource_) {this->dstSubresource = dstSubresource_; return *this; }
    ImageCopy2KHR& setDstOffset(Offset3D dstOffset_) {this->dstOffset = dstOffset_; return *this; }
    ImageCopy2KHR& setExtent(Extent3D extent_) {this->extent = extent_; return *this; }
};
struct ImageBlit2KHR {
    StructureType sType{StructureType::ImageBlit2KHR};
    const void* pNext = nullptr;
    ImageSubresourceLayers srcSubresource{};
    Offset3D srcOffsets[2];
    ImageSubresourceLayers dstSubresource{};
    Offset3D dstOffsets[2];
    ImageBlit2KHR& setSrcSubresource(ImageSubresourceLayers srcSubresource_) {this->srcSubresource = srcSubresource_; return *this; }
    ImageBlit2KHR& setSrcOffsets(Offset3D srcOffsets_[2]) {for(uint32_t i = 0; i < 2; i++) this->srcOffsets[i] = srcOffsets_[i]; return *this; }
    ImageBlit2KHR& setDstSubresource(ImageSubresourceLayers dstSubresource_) {this->dstSubresource = dstSubresource_; return *this; }
    ImageBlit2KHR& setDstOffsets(Offset3D dstOffsets_[2]) {for(uint32_t i = 0; i < 2; i++) this->dstOffsets[i] = dstOffsets_[i]; return *this; }
};
struct BufferImageCopy2KHR {
    StructureType sType{StructureType::BufferImageCopy2KHR};
    const void* pNext = nullptr;
    DeviceSize bufferOffset{0};
    uint32_t bufferRowLength{0};
    uint32_t bufferImageHeight{0};
    ImageSubresourceLayers imageSubresource{};
    Offset3D imageOffset{};
    Extent3D imageExtent{};
    BufferImageCopy2KHR& setBufferOffset(DeviceSize bufferOffset_) {this->bufferOffset = bufferOffset_; return *this; }
    BufferImageCopy2KHR& setBufferRowLength(uint32_t bufferRowLength_) {this->bufferRowLength = bufferRowLength_; return *this; }
    BufferImageCopy2KHR& setBufferImageHeight(uint32_t bufferImageHeight_) {this->bufferImageHeight = bufferImageHeight_; return *this; }
    BufferImageCopy2KHR& setImageSubresource(ImageSubresourceLayers imageSubresource_) {this->imageSubresource = imageSubresource_; return *this; }
    BufferImageCopy2KHR& setImageOffset(Offset3D imageOffset_) {this->imageOffset = imageOffset_; return *this; }
    BufferImageCopy2KHR& setImageExtent(Extent3D imageExtent_) {this->imageExtent = imageExtent_; return *this; }
};
struct ImageResolve2KHR {
    StructureType sType{StructureType::ImageResolve2KHR};
    const void* pNext = nullptr;
    ImageSubresourceLayers srcSubresource{};
    Offset3D srcOffset{};
    ImageSubresourceLayers dstSubresource{};
    Offset3D dstOffset{};
    Extent3D extent{};
    ImageResolve2KHR& setSrcSubresource(ImageSubresourceLayers srcSubresource_) {this->srcSubresource = srcSubresource_; return *this; }
    ImageResolve2KHR& setSrcOffset(Offset3D srcOffset_) {this->srcOffset = srcOffset_; return *this; }
    ImageResolve2KHR& setDstSubresource(ImageSubresourceLayers dstSubresource_) {this->dstSubresource = dstSubresource_; return *this; }
    ImageResolve2KHR& setDstOffset(Offset3D dstOffset_) {this->dstOffset = dstOffset_; return *this; }
    ImageResolve2KHR& setExtent(Extent3D extent_) {this->extent = extent_; return *this; }
};
struct CopyBufferInfo2KHR {
    StructureType sType{StructureType::CopyBufferInfo2KHR};
    const void* pNext = nullptr;
    Buffer srcBuffer{};
    Buffer dstBuffer{};
    uint32_t regionCount{0};
    const BufferCopy2KHR* pRegions = nullptr;
    CopyBufferInfo2KHR& setSrcBuffer(Buffer srcBuffer_) {this->srcBuffer = srcBuffer_; return *this; }
    CopyBufferInfo2KHR& setDstBuffer(Buffer dstBuffer_) {this->dstBuffer = dstBuffer_; return *this; }
    CopyBufferInfo2KHR& setRegionCount(uint32_t regionCount_) {this->regionCount = regionCount_; return *this; }
    CopyBufferInfo2KHR& setPRegions(const BufferCopy2KHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    CopyBufferInfo2KHR& setPRegions(detail::span<const BufferCopy2KHR> pRegions_) {this->regionCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
};
struct CopyImageInfo2KHR {
    StructureType sType{StructureType::CopyImageInfo2KHR};
    const void* pNext = nullptr;
    Image srcImage{};
    ImageLayout srcImageLayout{static_cast<ImageLayout>(0)};
    Image dstImage{};
    ImageLayout dstImageLayout{static_cast<ImageLayout>(0)};
    uint32_t regionCount{0};
    const ImageCopy2KHR* pRegions = nullptr;
    CopyImageInfo2KHR& setSrcImage(Image srcImage_) {this->srcImage = srcImage_; return *this; }
    CopyImageInfo2KHR& setSrcImageLayout(ImageLayout srcImageLayout_) {this->srcImageLayout = srcImageLayout_; return *this; }
    CopyImageInfo2KHR& setDstImage(Image dstImage_) {this->dstImage = dstImage_; return *this; }
    CopyImageInfo2KHR& setDstImageLayout(ImageLayout dstImageLayout_) {this->dstImageLayout = dstImageLayout_; return *this; }
    CopyImageInfo2KHR& setRegionCount(uint32_t regionCount_) {this->regionCount = regionCount_; return *this; }
    CopyImageInfo2KHR& setPRegions(const ImageCopy2KHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    CopyImageInfo2KHR& setPRegions(detail::span<const ImageCopy2KHR> pRegions_) {this->regionCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
};
struct BlitImageInfo2KHR {
    StructureType sType{StructureType::BlitImageInfo2KHR};
    const void* pNext = nullptr;
    Image srcImage{};
    ImageLayout srcImageLayout{static_cast<ImageLayout>(0)};
    Image dstImage{};
    ImageLayout dstImageLayout{static_cast<ImageLayout>(0)};
    uint32_t regionCount{0};
    const ImageBlit2KHR* pRegions = nullptr;
    Filter filter{static_cast<Filter>(0)};
    BlitImageInfo2KHR& setSrcImage(Image srcImage_) {this->srcImage = srcImage_; return *this; }
    BlitImageInfo2KHR& setSrcImageLayout(ImageLayout srcImageLayout_) {this->srcImageLayout = srcImageLayout_; return *this; }
    BlitImageInfo2KHR& setDstImage(Image dstImage_) {this->dstImage = dstImage_; return *this; }
    BlitImageInfo2KHR& setDstImageLayout(ImageLayout dstImageLayout_) {this->dstImageLayout = dstImageLayout_; return *this; }
    BlitImageInfo2KHR& setRegionCount(uint32_t regionCount_) {this->regionCount = regionCount_; return *this; }
    BlitImageInfo2KHR& setPRegions(const ImageBlit2KHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    BlitImageInfo2KHR& setPRegions(detail::span<const ImageBlit2KHR> pRegions_) {this->regionCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
    BlitImageInfo2KHR& setFilter(Filter filter_) {this->filter = filter_; return *this; }
};
struct CopyBufferToImageInfo2KHR {
    StructureType sType{StructureType::CopyBufferToImageInfo2KHR};
    const void* pNext = nullptr;
    Buffer srcBuffer{};
    Image dstImage{};
    ImageLayout dstImageLayout{static_cast<ImageLayout>(0)};
    uint32_t regionCount{0};
    const BufferImageCopy2KHR* pRegions = nullptr;
    CopyBufferToImageInfo2KHR& setSrcBuffer(Buffer srcBuffer_) {this->srcBuffer = srcBuffer_; return *this; }
    CopyBufferToImageInfo2KHR& setDstImage(Image dstImage_) {this->dstImage = dstImage_; return *this; }
    CopyBufferToImageInfo2KHR& setDstImageLayout(ImageLayout dstImageLayout_) {this->dstImageLayout = dstImageLayout_; return *this; }
    CopyBufferToImageInfo2KHR& setRegionCount(uint32_t regionCount_) {this->regionCount = regionCount_; return *this; }
    CopyBufferToImageInfo2KHR& setPRegions(const BufferImageCopy2KHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    CopyBufferToImageInfo2KHR& setPRegions(detail::span<const BufferImageCopy2KHR> pRegions_) {this->regionCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
};
struct CopyImageToBufferInfo2KHR {
    StructureType sType{StructureType::CopyImageToBufferInfo2KHR};
    const void* pNext = nullptr;
    Image srcImage{};
    ImageLayout srcImageLayout{static_cast<ImageLayout>(0)};
    Buffer dstBuffer{};
    uint32_t regionCount{0};
    const BufferImageCopy2KHR* pRegions = nullptr;
    CopyImageToBufferInfo2KHR& setSrcImage(Image srcImage_) {this->srcImage = srcImage_; return *this; }
    CopyImageToBufferInfo2KHR& setSrcImageLayout(ImageLayout srcImageLayout_) {this->srcImageLayout = srcImageLayout_; return *this; }
    CopyImageToBufferInfo2KHR& setDstBuffer(Buffer dstBuffer_) {this->dstBuffer = dstBuffer_; return *this; }
    CopyImageToBufferInfo2KHR& setRegionCount(uint32_t regionCount_) {this->regionCount = regionCount_; return *this; }
    CopyImageToBufferInfo2KHR& setPRegions(const BufferImageCopy2KHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    CopyImageToBufferInfo2KHR& setPRegions(detail::span<const BufferImageCopy2KHR> pRegions_) {this->regionCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
};
struct ResolveImageInfo2KHR {
    StructureType sType{StructureType::ResolveImageInfo2KHR};
    const void* pNext = nullptr;
    Image srcImage{};
    ImageLayout srcImageLayout{static_cast<ImageLayout>(0)};
    Image dstImage{};
    ImageLayout dstImageLayout{static_cast<ImageLayout>(0)};
    uint32_t regionCount{0};
    const ImageResolve2KHR* pRegions = nullptr;
    ResolveImageInfo2KHR& setSrcImage(Image srcImage_) {this->srcImage = srcImage_; return *this; }
    ResolveImageInfo2KHR& setSrcImageLayout(ImageLayout srcImageLayout_) {this->srcImageLayout = srcImageLayout_; return *this; }
    ResolveImageInfo2KHR& setDstImage(Image dstImage_) {this->dstImage = dstImage_; return *this; }
    ResolveImageInfo2KHR& setDstImageLayout(ImageLayout dstImageLayout_) {this->dstImageLayout = dstImageLayout_; return *this; }
    ResolveImageInfo2KHR& setRegionCount(uint32_t regionCount_) {this->regionCount = regionCount_; return *this; }
    ResolveImageInfo2KHR& setPRegions(const ImageResolve2KHR* pRegions_) {this->pRegions = pRegions_; return *this; }
    ResolveImageInfo2KHR& setPRegions(detail::span<const ImageResolve2KHR> pRegions_) {this->regionCount = pRegions_.size(); this->pRegions = pRegions_.data();  return *this; }
};
struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT};
    void* pNext = nullptr;
    Bool32 shaderImageInt64Atomics{0};
    Bool32 sparseImageInt64Atomics{0};
    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT& setShaderImageInt64Atomics(Bool32 shaderImageInt64Atomics_) {this->shaderImageInt64Atomics = shaderImageInt64Atomics_; return *this; }
    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT& setSparseImageInt64Atomics(Bool32 sparseImageInt64Atomics_) {this->sparseImageInt64Atomics = sparseImageInt64Atomics_; return *this; }
};
struct FragmentShadingRateAttachmentInfoKHR {
    StructureType sType{StructureType::FragmentShadingRateAttachmentInfoKHR};
    const void* pNext = nullptr;
    const AttachmentReference2* pFragmentShadingRateAttachment = nullptr;
    Extent2D shadingRateAttachmentTexelSize{};
    FragmentShadingRateAttachmentInfoKHR& setPFragmentShadingRateAttachment(const AttachmentReference2* pFragmentShadingRateAttachment_) {this->pFragmentShadingRateAttachment = pFragmentShadingRateAttachment_; return *this; }
    FragmentShadingRateAttachmentInfoKHR& setPFragmentShadingRateAttachment(AttachmentReference2 const& pFragmentShadingRateAttachment_) {this->pFragmentShadingRateAttachment = &pFragmentShadingRateAttachment_; return *this; }
    FragmentShadingRateAttachmentInfoKHR& setShadingRateAttachmentTexelSize(Extent2D shadingRateAttachmentTexelSize_) {this->shadingRateAttachmentTexelSize = shadingRateAttachmentTexelSize_; return *this; }
};
struct PipelineFragmentShadingRateStateCreateInfoKHR {
    StructureType sType{StructureType::PipelineFragmentShadingRateStateCreateInfoKHR};
    const void* pNext = nullptr;
    Extent2D fragmentSize{};
    FragmentShadingRateCombinerOpKHR combinerOps[2];
    PipelineFragmentShadingRateStateCreateInfoKHR& setFragmentSize(Extent2D fragmentSize_) {this->fragmentSize = fragmentSize_; return *this; }
    PipelineFragmentShadingRateStateCreateInfoKHR& setCombinerOps(FragmentShadingRateCombinerOpKHR combinerOps_[2]) {for(uint32_t i = 0; i < 2; i++) this->combinerOps[i] = combinerOps_[i]; return *this; }
};
struct PhysicalDeviceFragmentShadingRateFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceFragmentShadingRateFeaturesKHR};
    void* pNext = nullptr;
    Bool32 pipelineFragmentShadingRate{0};
    Bool32 primitiveFragmentShadingRate{0};
    Bool32 attachmentFragmentShadingRate{0};
    PhysicalDeviceFragmentShadingRateFeaturesKHR& setPipelineFragmentShadingRate(Bool32 pipelineFragmentShadingRate_) {this->pipelineFragmentShadingRate = pipelineFragmentShadingRate_; return *this; }
    PhysicalDeviceFragmentShadingRateFeaturesKHR& setPrimitiveFragmentShadingRate(Bool32 primitiveFragmentShadingRate_) {this->primitiveFragmentShadingRate = primitiveFragmentShadingRate_; return *this; }
    PhysicalDeviceFragmentShadingRateFeaturesKHR& setAttachmentFragmentShadingRate(Bool32 attachmentFragmentShadingRate_) {this->attachmentFragmentShadingRate = attachmentFragmentShadingRate_; return *this; }
};
struct PhysicalDeviceFragmentShadingRatePropertiesKHR {
    StructureType sType{StructureType::PhysicalDeviceFragmentShadingRatePropertiesKHR};
    void* pNext = nullptr;
    Extent2D minFragmentShadingRateAttachmentTexelSize{};
    Extent2D maxFragmentShadingRateAttachmentTexelSize{};
    uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio{0};
    Bool32 primitiveFragmentShadingRateWithMultipleViewports{0};
    Bool32 layeredShadingRateAttachments{0};
    Bool32 fragmentShadingRateNonTrivialCombinerOps{0};
    Extent2D maxFragmentSize{};
    uint32_t maxFragmentSizeAspectRatio{0};
    uint32_t maxFragmentShadingRateCoverageSamples{0};
    SampleCountFlagBits maxFragmentShadingRateRasterizationSamples{static_cast<SampleCountFlagBits>(0)};
    Bool32 fragmentShadingRateWithShaderDepthStencilWrites{0};
    Bool32 fragmentShadingRateWithSampleMask{0};
    Bool32 fragmentShadingRateWithShaderSampleMask{0};
    Bool32 fragmentShadingRateWithConservativeRasterization{0};
    Bool32 fragmentShadingRateWithFragmentShaderInterlock{0};
    Bool32 fragmentShadingRateWithCustomSampleLocations{0};
    Bool32 fragmentShadingRateStrictMultiplyCombiner{0};
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMinFragmentShadingRateAttachmentTexelSize(Extent2D minFragmentShadingRateAttachmentTexelSize_) {this->minFragmentShadingRateAttachmentTexelSize = minFragmentShadingRateAttachmentTexelSize_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMaxFragmentShadingRateAttachmentTexelSize(Extent2D maxFragmentShadingRateAttachmentTexelSize_) {this->maxFragmentShadingRateAttachmentTexelSize = maxFragmentShadingRateAttachmentTexelSize_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMaxFragmentShadingRateAttachmentTexelSizeAspectRatio(uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio_) {this->maxFragmentShadingRateAttachmentTexelSizeAspectRatio = maxFragmentShadingRateAttachmentTexelSizeAspectRatio_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setPrimitiveFragmentShadingRateWithMultipleViewports(Bool32 primitiveFragmentShadingRateWithMultipleViewports_) {this->primitiveFragmentShadingRateWithMultipleViewports = primitiveFragmentShadingRateWithMultipleViewports_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setLayeredShadingRateAttachments(Bool32 layeredShadingRateAttachments_) {this->layeredShadingRateAttachments = layeredShadingRateAttachments_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateNonTrivialCombinerOps(Bool32 fragmentShadingRateNonTrivialCombinerOps_) {this->fragmentShadingRateNonTrivialCombinerOps = fragmentShadingRateNonTrivialCombinerOps_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMaxFragmentSize(Extent2D maxFragmentSize_) {this->maxFragmentSize = maxFragmentSize_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMaxFragmentSizeAspectRatio(uint32_t maxFragmentSizeAspectRatio_) {this->maxFragmentSizeAspectRatio = maxFragmentSizeAspectRatio_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMaxFragmentShadingRateCoverageSamples(uint32_t maxFragmentShadingRateCoverageSamples_) {this->maxFragmentShadingRateCoverageSamples = maxFragmentShadingRateCoverageSamples_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setMaxFragmentShadingRateRasterizationSamples(SampleCountFlagBits maxFragmentShadingRateRasterizationSamples_) {this->maxFragmentShadingRateRasterizationSamples = maxFragmentShadingRateRasterizationSamples_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateWithShaderDepthStencilWrites(Bool32 fragmentShadingRateWithShaderDepthStencilWrites_) {this->fragmentShadingRateWithShaderDepthStencilWrites = fragmentShadingRateWithShaderDepthStencilWrites_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateWithSampleMask(Bool32 fragmentShadingRateWithSampleMask_) {this->fragmentShadingRateWithSampleMask = fragmentShadingRateWithSampleMask_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateWithShaderSampleMask(Bool32 fragmentShadingRateWithShaderSampleMask_) {this->fragmentShadingRateWithShaderSampleMask = fragmentShadingRateWithShaderSampleMask_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateWithConservativeRasterization(Bool32 fragmentShadingRateWithConservativeRasterization_) {this->fragmentShadingRateWithConservativeRasterization = fragmentShadingRateWithConservativeRasterization_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateWithFragmentShaderInterlock(Bool32 fragmentShadingRateWithFragmentShaderInterlock_) {this->fragmentShadingRateWithFragmentShaderInterlock = fragmentShadingRateWithFragmentShaderInterlock_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateWithCustomSampleLocations(Bool32 fragmentShadingRateWithCustomSampleLocations_) {this->fragmentShadingRateWithCustomSampleLocations = fragmentShadingRateWithCustomSampleLocations_; return *this; }
    PhysicalDeviceFragmentShadingRatePropertiesKHR& setFragmentShadingRateStrictMultiplyCombiner(Bool32 fragmentShadingRateStrictMultiplyCombiner_) {this->fragmentShadingRateStrictMultiplyCombiner = fragmentShadingRateStrictMultiplyCombiner_; return *this; }
};
struct PhysicalDeviceFragmentShadingRateKHR {
    StructureType sType{StructureType::PhysicalDeviceFragmentShadingRateKHR};
    void* pNext = nullptr;
    SampleCountFlags sampleCounts{};
    Extent2D fragmentSize{};
    PhysicalDeviceFragmentShadingRateKHR& setSampleCounts(SampleCountFlags sampleCounts_) {this->sampleCounts = sampleCounts_; return *this; }
    PhysicalDeviceFragmentShadingRateKHR& setFragmentSize(Extent2D fragmentSize_) {this->fragmentSize = fragmentSize_; return *this; }
};
struct PhysicalDeviceShaderTerminateInvocationFeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceShaderTerminateInvocationFeaturesKHR};
    void* pNext = nullptr;
    Bool32 shaderTerminateInvocation{0};
    PhysicalDeviceShaderTerminateInvocationFeaturesKHR& setShaderTerminateInvocation(Bool32 shaderTerminateInvocation_) {this->shaderTerminateInvocation = shaderTerminateInvocation_; return *this; }
};
struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV};
    void* pNext = nullptr;
    Bool32 fragmentShadingRateEnums{0};
    Bool32 supersampleFragmentShadingRates{0};
    Bool32 noInvocationFragmentShadingRates{0};
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& setFragmentShadingRateEnums(Bool32 fragmentShadingRateEnums_) {this->fragmentShadingRateEnums = fragmentShadingRateEnums_; return *this; }
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& setSupersampleFragmentShadingRates(Bool32 supersampleFragmentShadingRates_) {this->supersampleFragmentShadingRates = supersampleFragmentShadingRates_; return *this; }
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& setNoInvocationFragmentShadingRates(Bool32 noInvocationFragmentShadingRates_) {this->noInvocationFragmentShadingRates = noInvocationFragmentShadingRates_; return *this; }
};
struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    StructureType sType{StructureType::PhysicalDeviceFragmentShadingRateEnumsPropertiesNV};
    void* pNext = nullptr;
    SampleCountFlagBits maxFragmentShadingRateInvocationCount{static_cast<SampleCountFlagBits>(0)};
    PhysicalDeviceFragmentShadingRateEnumsPropertiesNV& setMaxFragmentShadingRateInvocationCount(SampleCountFlagBits maxFragmentShadingRateInvocationCount_) {this->maxFragmentShadingRateInvocationCount = maxFragmentShadingRateInvocationCount_; return *this; }
};
struct PipelineFragmentShadingRateEnumStateCreateInfoNV {
    StructureType sType{StructureType::PipelineFragmentShadingRateEnumStateCreateInfoNV};
    const void* pNext = nullptr;
    FragmentShadingRateTypeNV shadingRateType{static_cast<FragmentShadingRateTypeNV>(0)};
    FragmentShadingRateNV shadingRate{static_cast<FragmentShadingRateNV>(0)};
    FragmentShadingRateCombinerOpKHR combinerOps[2];
    PipelineFragmentShadingRateEnumStateCreateInfoNV& setShadingRateType(FragmentShadingRateTypeNV shadingRateType_) {this->shadingRateType = shadingRateType_; return *this; }
    PipelineFragmentShadingRateEnumStateCreateInfoNV& setShadingRate(FragmentShadingRateNV shadingRate_) {this->shadingRate = shadingRate_; return *this; }
    PipelineFragmentShadingRateEnumStateCreateInfoNV& setCombinerOps(FragmentShadingRateCombinerOpKHR combinerOps_[2]) {for(uint32_t i = 0; i < 2; i++) this->combinerOps[i] = combinerOps_[i]; return *this; }
};
struct AccelerationStructureBuildSizesInfoKHR {
    StructureType sType{StructureType::AccelerationStructureBuildSizesInfoKHR};
    const void* pNext = nullptr;
    DeviceSize accelerationStructureSize{0};
    DeviceSize updateScratchSize{0};
    DeviceSize buildScratchSize{0};
    AccelerationStructureBuildSizesInfoKHR& setAccelerationStructureSize(DeviceSize accelerationStructureSize_) {this->accelerationStructureSize = accelerationStructureSize_; return *this; }
    AccelerationStructureBuildSizesInfoKHR& setUpdateScratchSize(DeviceSize updateScratchSize_) {this->updateScratchSize = updateScratchSize_; return *this; }
    AccelerationStructureBuildSizesInfoKHR& setBuildScratchSize(DeviceSize buildScratchSize_) {this->buildScratchSize = buildScratchSize_; return *this; }
};
struct PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    StructureType sType{StructureType::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE};
    void* pNext = nullptr;
    Bool32 mutableDescriptorType{0};
    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE& setMutableDescriptorType(Bool32 mutableDescriptorType_) {this->mutableDescriptorType = mutableDescriptorType_; return *this; }
};
struct MutableDescriptorTypeListVALVE {
    uint32_t descriptorTypeCount{0};
    const DescriptorType* pDescriptorTypes = nullptr;
    MutableDescriptorTypeListVALVE& setDescriptorTypeCount(uint32_t descriptorTypeCount_) {this->descriptorTypeCount = descriptorTypeCount_; return *this; }
    MutableDescriptorTypeListVALVE& setPDescriptorTypes(const DescriptorType* pDescriptorTypes_) {this->pDescriptorTypes = pDescriptorTypes_; return *this; }
    MutableDescriptorTypeListVALVE& setPDescriptorTypes(detail::span<const DescriptorType> pDescriptorTypes_) {this->descriptorTypeCount = pDescriptorTypes_.size(); this->pDescriptorTypes = pDescriptorTypes_.data();  return *this; }
};
struct MutableDescriptorTypeCreateInfoVALVE {
    StructureType sType{StructureType::MutableDescriptorTypeCreateInfoVALVE};
    const void* pNext = nullptr;
    uint32_t mutableDescriptorTypeListCount{0};
    const MutableDescriptorTypeListVALVE* pMutableDescriptorTypeLists = nullptr;
    MutableDescriptorTypeCreateInfoVALVE& setMutableDescriptorTypeListCount(uint32_t mutableDescriptorTypeListCount_) {this->mutableDescriptorTypeListCount = mutableDescriptorTypeListCount_; return *this; }
    MutableDescriptorTypeCreateInfoVALVE& setPMutableDescriptorTypeLists(const MutableDescriptorTypeListVALVE* pMutableDescriptorTypeLists_) {this->pMutableDescriptorTypeLists = pMutableDescriptorTypeLists_; return *this; }
    MutableDescriptorTypeCreateInfoVALVE& setPMutableDescriptorTypeLists(detail::span<const MutableDescriptorTypeListVALVE> pMutableDescriptorTypeLists_) {this->mutableDescriptorTypeListCount = pMutableDescriptorTypeLists_.size(); this->pMutableDescriptorTypeLists = pMutableDescriptorTypeLists_.data();  return *this; }
};
struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceVertexInputDynamicStateFeaturesEXT};
    void* pNext = nullptr;
    Bool32 vertexInputDynamicState{0};
    PhysicalDeviceVertexInputDynamicStateFeaturesEXT& setVertexInputDynamicState(Bool32 vertexInputDynamicState_) {this->vertexInputDynamicState = vertexInputDynamicState_; return *this; }
};
struct VertexInputBindingDescription2EXT {
    StructureType sType{StructureType::VertexInputBindingDescription2EXT};
    void* pNext = nullptr;
    uint32_t binding{0};
    uint32_t stride{0};
    VertexInputRate inputRate{static_cast<VertexInputRate>(0)};
    uint32_t divisor{0};
    VertexInputBindingDescription2EXT& setBinding(uint32_t binding_) {this->binding = binding_; return *this; }
    VertexInputBindingDescription2EXT& setStride(uint32_t stride_) {this->stride = stride_; return *this; }
    VertexInputBindingDescription2EXT& setInputRate(VertexInputRate inputRate_) {this->inputRate = inputRate_; return *this; }
    VertexInputBindingDescription2EXT& setDivisor(uint32_t divisor_) {this->divisor = divisor_; return *this; }
};
struct VertexInputAttributeDescription2EXT {
    StructureType sType{StructureType::VertexInputAttributeDescription2EXT};
    void* pNext = nullptr;
    uint32_t location{0};
    uint32_t binding{0};
    Format format{static_cast<Format>(0)};
    uint32_t offset{0};
    VertexInputAttributeDescription2EXT& setLocation(uint32_t location_) {this->location = location_; return *this; }
    VertexInputAttributeDescription2EXT& setBinding(uint32_t binding_) {this->binding = binding_; return *this; }
    VertexInputAttributeDescription2EXT& setFormat(Format format_) {this->format = format_; return *this; }
    VertexInputAttributeDescription2EXT& setOffset(uint32_t offset_) {this->offset = offset_; return *this; }
};
struct PhysicalDeviceColorWriteEnableFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceColorWriteEnableFeaturesEXT};
    void* pNext = nullptr;
    Bool32 colorWriteEnable{0};
    PhysicalDeviceColorWriteEnableFeaturesEXT& setColorWriteEnable(Bool32 colorWriteEnable_) {this->colorWriteEnable = colorWriteEnable_; return *this; }
};
struct PipelineColorWriteCreateInfoEXT {
    StructureType sType{StructureType::PipelineColorWriteCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t attachmentCount{0};
    const Bool32* pColorWriteEnables = nullptr;
    PipelineColorWriteCreateInfoEXT& setAttachmentCount(uint32_t attachmentCount_) {this->attachmentCount = attachmentCount_; return *this; }
    PipelineColorWriteCreateInfoEXT& setPColorWriteEnables(const Bool32* pColorWriteEnables_) {this->pColorWriteEnables = pColorWriteEnables_; return *this; }
    PipelineColorWriteCreateInfoEXT& setPColorWriteEnables(detail::span<const Bool32> pColorWriteEnables_) {this->attachmentCount = pColorWriteEnables_.size(); this->pColorWriteEnables = pColorWriteEnables_.data();  return *this; }
};
struct MemoryBarrier2KHR {
    StructureType sType{StructureType::MemoryBarrier2KHR};
    const void* pNext = nullptr;
    PipelineStageFlags2KHR srcStageMask{};
    AccessFlags2KHR srcAccessMask{};
    PipelineStageFlags2KHR dstStageMask{};
    AccessFlags2KHR dstAccessMask{};
    MemoryBarrier2KHR& setSrcStageMask(PipelineStageFlags2KHR srcStageMask_) {this->srcStageMask = srcStageMask_; return *this; }
    MemoryBarrier2KHR& setSrcAccessMask(AccessFlags2KHR srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    MemoryBarrier2KHR& setDstStageMask(PipelineStageFlags2KHR dstStageMask_) {this->dstStageMask = dstStageMask_; return *this; }
    MemoryBarrier2KHR& setDstAccessMask(AccessFlags2KHR dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
};
struct ImageMemoryBarrier2KHR {
    StructureType sType{StructureType::ImageMemoryBarrier2KHR};
    const void* pNext = nullptr;
    PipelineStageFlags2KHR srcStageMask{};
    AccessFlags2KHR srcAccessMask{};
    PipelineStageFlags2KHR dstStageMask{};
    AccessFlags2KHR dstAccessMask{};
    ImageLayout oldLayout{static_cast<ImageLayout>(0)};
    ImageLayout newLayout{static_cast<ImageLayout>(0)};
    uint32_t srcQueueFamilyIndex{0};
    uint32_t dstQueueFamilyIndex{0};
    Image image{};
    ImageSubresourceRange subresourceRange{};
    ImageMemoryBarrier2KHR& setSrcStageMask(PipelineStageFlags2KHR srcStageMask_) {this->srcStageMask = srcStageMask_; return *this; }
    ImageMemoryBarrier2KHR& setSrcAccessMask(AccessFlags2KHR srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    ImageMemoryBarrier2KHR& setDstStageMask(PipelineStageFlags2KHR dstStageMask_) {this->dstStageMask = dstStageMask_; return *this; }
    ImageMemoryBarrier2KHR& setDstAccessMask(AccessFlags2KHR dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
    ImageMemoryBarrier2KHR& setOldLayout(ImageLayout oldLayout_) {this->oldLayout = oldLayout_; return *this; }
    ImageMemoryBarrier2KHR& setNewLayout(ImageLayout newLayout_) {this->newLayout = newLayout_; return *this; }
    ImageMemoryBarrier2KHR& setSrcQueueFamilyIndex(uint32_t srcQueueFamilyIndex_) {this->srcQueueFamilyIndex = srcQueueFamilyIndex_; return *this; }
    ImageMemoryBarrier2KHR& setDstQueueFamilyIndex(uint32_t dstQueueFamilyIndex_) {this->dstQueueFamilyIndex = dstQueueFamilyIndex_; return *this; }
    ImageMemoryBarrier2KHR& setImage(Image image_) {this->image = image_; return *this; }
    ImageMemoryBarrier2KHR& setSubresourceRange(ImageSubresourceRange subresourceRange_) {this->subresourceRange = subresourceRange_; return *this; }
};
struct BufferMemoryBarrier2KHR {
    StructureType sType{StructureType::BufferMemoryBarrier2KHR};
    const void* pNext = nullptr;
    PipelineStageFlags2KHR srcStageMask{};
    AccessFlags2KHR srcAccessMask{};
    PipelineStageFlags2KHR dstStageMask{};
    AccessFlags2KHR dstAccessMask{};
    uint32_t srcQueueFamilyIndex{0};
    uint32_t dstQueueFamilyIndex{0};
    Buffer buffer{};
    DeviceSize offset{0};
    DeviceSize size{0};
    BufferMemoryBarrier2KHR& setSrcStageMask(PipelineStageFlags2KHR srcStageMask_) {this->srcStageMask = srcStageMask_; return *this; }
    BufferMemoryBarrier2KHR& setSrcAccessMask(AccessFlags2KHR srcAccessMask_) {this->srcAccessMask = srcAccessMask_; return *this; }
    BufferMemoryBarrier2KHR& setDstStageMask(PipelineStageFlags2KHR dstStageMask_) {this->dstStageMask = dstStageMask_; return *this; }
    BufferMemoryBarrier2KHR& setDstAccessMask(AccessFlags2KHR dstAccessMask_) {this->dstAccessMask = dstAccessMask_; return *this; }
    BufferMemoryBarrier2KHR& setSrcQueueFamilyIndex(uint32_t srcQueueFamilyIndex_) {this->srcQueueFamilyIndex = srcQueueFamilyIndex_; return *this; }
    BufferMemoryBarrier2KHR& setDstQueueFamilyIndex(uint32_t dstQueueFamilyIndex_) {this->dstQueueFamilyIndex = dstQueueFamilyIndex_; return *this; }
    BufferMemoryBarrier2KHR& setBuffer(Buffer buffer_) {this->buffer = buffer_; return *this; }
    BufferMemoryBarrier2KHR& setOffset(DeviceSize offset_) {this->offset = offset_; return *this; }
    BufferMemoryBarrier2KHR& setSize(DeviceSize size_) {this->size = size_; return *this; }
};
struct DependencyInfoKHR {
    StructureType sType{StructureType::DependencyInfoKHR};
    const void* pNext = nullptr;
    DependencyFlags dependencyFlags{};
    uint32_t memoryBarrierCount{0};
    const MemoryBarrier2KHR* pMemoryBarriers = nullptr;
    uint32_t bufferMemoryBarrierCount{0};
    const BufferMemoryBarrier2KHR* pBufferMemoryBarriers = nullptr;
    uint32_t imageMemoryBarrierCount{0};
    const ImageMemoryBarrier2KHR* pImageMemoryBarriers = nullptr;
    DependencyInfoKHR& setDependencyFlags(DependencyFlags dependencyFlags_) {this->dependencyFlags = dependencyFlags_; return *this; }
    DependencyInfoKHR& setMemoryBarrierCount(uint32_t memoryBarrierCount_) {this->memoryBarrierCount = memoryBarrierCount_; return *this; }
    DependencyInfoKHR& setPMemoryBarriers(const MemoryBarrier2KHR* pMemoryBarriers_) {this->pMemoryBarriers = pMemoryBarriers_; return *this; }
    DependencyInfoKHR& setPMemoryBarriers(detail::span<const MemoryBarrier2KHR> pMemoryBarriers_) {this->memoryBarrierCount = pMemoryBarriers_.size(); this->pMemoryBarriers = pMemoryBarriers_.data();  return *this; }
    DependencyInfoKHR& setBufferMemoryBarrierCount(uint32_t bufferMemoryBarrierCount_) {this->bufferMemoryBarrierCount = bufferMemoryBarrierCount_; return *this; }
    DependencyInfoKHR& setPBufferMemoryBarriers(const BufferMemoryBarrier2KHR* pBufferMemoryBarriers_) {this->pBufferMemoryBarriers = pBufferMemoryBarriers_; return *this; }
    DependencyInfoKHR& setPBufferMemoryBarriers(detail::span<const BufferMemoryBarrier2KHR> pBufferMemoryBarriers_) {this->bufferMemoryBarrierCount = pBufferMemoryBarriers_.size(); this->pBufferMemoryBarriers = pBufferMemoryBarriers_.data();  return *this; }
    DependencyInfoKHR& setImageMemoryBarrierCount(uint32_t imageMemoryBarrierCount_) {this->imageMemoryBarrierCount = imageMemoryBarrierCount_; return *this; }
    DependencyInfoKHR& setPImageMemoryBarriers(const ImageMemoryBarrier2KHR* pImageMemoryBarriers_) {this->pImageMemoryBarriers = pImageMemoryBarriers_; return *this; }
    DependencyInfoKHR& setPImageMemoryBarriers(detail::span<const ImageMemoryBarrier2KHR> pImageMemoryBarriers_) {this->imageMemoryBarrierCount = pImageMemoryBarriers_.size(); this->pImageMemoryBarriers = pImageMemoryBarriers_.data();  return *this; }
};
struct SemaphoreSubmitInfoKHR {
    StructureType sType{StructureType::SemaphoreSubmitInfoKHR};
    const void* pNext = nullptr;
    Semaphore semaphore{};
    uint64_t value{0};
    PipelineStageFlags2KHR stageMask{};
    uint32_t deviceIndex{0};
    SemaphoreSubmitInfoKHR& setSemaphore(Semaphore semaphore_) {this->semaphore = semaphore_; return *this; }
    SemaphoreSubmitInfoKHR& setValue(uint64_t value_) {this->value = value_; return *this; }
    SemaphoreSubmitInfoKHR& setStageMask(PipelineStageFlags2KHR stageMask_) {this->stageMask = stageMask_; return *this; }
    SemaphoreSubmitInfoKHR& setDeviceIndex(uint32_t deviceIndex_) {this->deviceIndex = deviceIndex_; return *this; }
};
struct CommandBufferSubmitInfoKHR {
    StructureType sType{StructureType::CommandBufferSubmitInfoKHR};
    const void* pNext = nullptr;
    CommandBuffer commandBuffer{};
    uint32_t deviceMask{0};
    CommandBufferSubmitInfoKHR& setCommandBuffer(CommandBuffer commandBuffer_) {this->commandBuffer = commandBuffer_; return *this; }
    CommandBufferSubmitInfoKHR& setDeviceMask(uint32_t deviceMask_) {this->deviceMask = deviceMask_; return *this; }
};
struct SubmitInfo2KHR {
    StructureType sType{StructureType::SubmitInfo2KHR};
    const void* pNext = nullptr;
    SubmitFlagsKHR flags{};
    uint32_t waitSemaphoreInfoCount{0};
    const SemaphoreSubmitInfoKHR* pWaitSemaphoreInfos = nullptr;
    uint32_t commandBufferInfoCount{0};
    const CommandBufferSubmitInfoKHR* pCommandBufferInfos = nullptr;
    uint32_t signalSemaphoreInfoCount{0};
    const SemaphoreSubmitInfoKHR* pSignalSemaphoreInfos = nullptr;
    SubmitInfo2KHR& setFlags(SubmitFlagsKHR flags_) {this->flags = flags_; return *this; }
    SubmitInfo2KHR& setWaitSemaphoreInfoCount(uint32_t waitSemaphoreInfoCount_) {this->waitSemaphoreInfoCount = waitSemaphoreInfoCount_; return *this; }
    SubmitInfo2KHR& setPWaitSemaphoreInfos(const SemaphoreSubmitInfoKHR* pWaitSemaphoreInfos_) {this->pWaitSemaphoreInfos = pWaitSemaphoreInfos_; return *this; }
    SubmitInfo2KHR& setPWaitSemaphoreInfos(detail::span<const SemaphoreSubmitInfoKHR> pWaitSemaphoreInfos_) {this->waitSemaphoreInfoCount = pWaitSemaphoreInfos_.size(); this->pWaitSemaphoreInfos = pWaitSemaphoreInfos_.data();  return *this; }
    SubmitInfo2KHR& setCommandBufferInfoCount(uint32_t commandBufferInfoCount_) {this->commandBufferInfoCount = commandBufferInfoCount_; return *this; }
    SubmitInfo2KHR& setPCommandBufferInfos(const CommandBufferSubmitInfoKHR* pCommandBufferInfos_) {this->pCommandBufferInfos = pCommandBufferInfos_; return *this; }
    SubmitInfo2KHR& setPCommandBufferInfos(detail::span<const CommandBufferSubmitInfoKHR> pCommandBufferInfos_) {this->commandBufferInfoCount = pCommandBufferInfos_.size(); this->pCommandBufferInfos = pCommandBufferInfos_.data();  return *this; }
    SubmitInfo2KHR& setSignalSemaphoreInfoCount(uint32_t signalSemaphoreInfoCount_) {this->signalSemaphoreInfoCount = signalSemaphoreInfoCount_; return *this; }
    SubmitInfo2KHR& setPSignalSemaphoreInfos(const SemaphoreSubmitInfoKHR* pSignalSemaphoreInfos_) {this->pSignalSemaphoreInfos = pSignalSemaphoreInfos_; return *this; }
    SubmitInfo2KHR& setPSignalSemaphoreInfos(detail::span<const SemaphoreSubmitInfoKHR> pSignalSemaphoreInfos_) {this->signalSemaphoreInfoCount = pSignalSemaphoreInfos_.size(); this->pSignalSemaphoreInfos = pSignalSemaphoreInfos_.data();  return *this; }
};
struct QueueFamilyCheckpointProperties2NV {
    StructureType sType{StructureType::QueueFamilyCheckpointProperties2NV};
    void* pNext = nullptr;
    PipelineStageFlags2KHR checkpointExecutionStageMask{};
    QueueFamilyCheckpointProperties2NV& setCheckpointExecutionStageMask(PipelineStageFlags2KHR checkpointExecutionStageMask_) {this->checkpointExecutionStageMask = checkpointExecutionStageMask_; return *this; }
};
struct CheckpointData2NV {
    StructureType sType{StructureType::CheckpointData2NV};
    void* pNext = nullptr;
    PipelineStageFlags2KHR stage{};
    void* pCheckpointMarker = nullptr;
    CheckpointData2NV& setStage(PipelineStageFlags2KHR stage_) {this->stage = stage_; return *this; }
    CheckpointData2NV& setPCheckpointMarker(void* pCheckpointMarker_) {this->pCheckpointMarker = pCheckpointMarker_; return *this; }
};
struct PhysicalDeviceSynchronization2FeaturesKHR {
    StructureType sType{StructureType::PhysicalDeviceSynchronization2FeaturesKHR};
    void* pNext = nullptr;
    Bool32 synchronization2{0};
    PhysicalDeviceSynchronization2FeaturesKHR& setSynchronization2(Bool32 synchronization2_) {this->synchronization2 = synchronization2_; return *this; }
};
#if defined(VK_ENABLE_BETA_EXTENSIONS)
struct VideoQueueFamilyProperties2KHR {
    StructureType sType{StructureType::VideoQueueFamilyProperties2KHR};
    void* pNext = nullptr;
    VideoCodecOperationFlagsKHR videoCodecOperations{};
    VideoQueueFamilyProperties2KHR& setVideoCodecOperations(VideoCodecOperationFlagsKHR videoCodecOperations_) {this->videoCodecOperations = videoCodecOperations_; return *this; }
};
struct VideoProfileKHR {
    StructureType sType{StructureType::VideoProfileKHR};
    void* pNext = nullptr;
    VideoCodecOperationFlagBitsKHR videoCodecOperation{static_cast<VideoCodecOperationFlagBitsKHR>(0)};
    VideoChromaSubsamplingFlagsKHR chromaSubsampling{};
    VideoComponentBitDepthFlagsKHR lumaBitDepth{};
    VideoComponentBitDepthFlagsKHR chromaBitDepth{};
    VideoProfileKHR& setVideoCodecOperation(VideoCodecOperationFlagBitsKHR videoCodecOperation_) {this->videoCodecOperation = videoCodecOperation_; return *this; }
    VideoProfileKHR& setChromaSubsampling(VideoChromaSubsamplingFlagsKHR chromaSubsampling_) {this->chromaSubsampling = chromaSubsampling_; return *this; }
    VideoProfileKHR& setLumaBitDepth(VideoComponentBitDepthFlagsKHR lumaBitDepth_) {this->lumaBitDepth = lumaBitDepth_; return *this; }
    VideoProfileKHR& setChromaBitDepth(VideoComponentBitDepthFlagsKHR chromaBitDepth_) {this->chromaBitDepth = chromaBitDepth_; return *this; }
};
struct VideoProfilesKHR {
    StructureType sType{StructureType::VideoProfilesKHR};
    void* pNext = nullptr;
    uint32_t profileCount{0};
    const VideoProfileKHR* pProfiles = nullptr;
    VideoProfilesKHR& setProfileCount(uint32_t profileCount_) {this->profileCount = profileCount_; return *this; }
    VideoProfilesKHR& setPProfiles(const VideoProfileKHR* pProfiles_) {this->pProfiles = pProfiles_; return *this; }
    VideoProfilesKHR& setPProfiles(VideoProfileKHR const& pProfiles_) {this->pProfiles = &pProfiles_; return *this; }
};
struct PhysicalDeviceVideoFormatInfoKHR {
    StructureType sType{StructureType::PhysicalDeviceVideoFormatInfoKHR};
    const void* pNext = nullptr;
    ImageUsageFlags imageUsage{};
    const VideoProfilesKHR* pVideoProfiles = nullptr;
    PhysicalDeviceVideoFormatInfoKHR& setImageUsage(ImageUsageFlags imageUsage_) {this->imageUsage = imageUsage_; return *this; }
    PhysicalDeviceVideoFormatInfoKHR& setPVideoProfiles(const VideoProfilesKHR* pVideoProfiles_) {this->pVideoProfiles = pVideoProfiles_; return *this; }
    PhysicalDeviceVideoFormatInfoKHR& setPVideoProfiles(VideoProfilesKHR const& pVideoProfiles_) {this->pVideoProfiles = &pVideoProfiles_; return *this; }
};
struct VideoFormatPropertiesKHR {
    StructureType sType{StructureType::VideoFormatPropertiesKHR};
    void* pNext = nullptr;
    Format format{static_cast<Format>(0)};
    VideoFormatPropertiesKHR& setFormat(Format format_) {this->format = format_; return *this; }
};
struct VideoCapabilitiesKHR {
    StructureType sType{StructureType::VideoCapabilitiesKHR};
    void* pNext = nullptr;
    VideoCapabilitiesFlagsKHR capabilityFlags{};
    DeviceSize minBitstreamBufferOffsetAlignment{0};
    DeviceSize minBitstreamBufferSizeAlignment{0};
    Extent2D videoPictureExtentGranularity{};
    Extent2D minExtent{};
    Extent2D maxExtent{};
    uint32_t maxReferencePicturesSlotsCount{0};
    uint32_t maxReferencePicturesActiveCount{0};
    VideoCapabilitiesKHR& setCapabilityFlags(VideoCapabilitiesFlagsKHR capabilityFlags_) {this->capabilityFlags = capabilityFlags_; return *this; }
    VideoCapabilitiesKHR& setMinBitstreamBufferOffsetAlignment(DeviceSize minBitstreamBufferOffsetAlignment_) {this->minBitstreamBufferOffsetAlignment = minBitstreamBufferOffsetAlignment_; return *this; }
    VideoCapabilitiesKHR& setMinBitstreamBufferSizeAlignment(DeviceSize minBitstreamBufferSizeAlignment_) {this->minBitstreamBufferSizeAlignment = minBitstreamBufferSizeAlignment_; return *this; }
    VideoCapabilitiesKHR& setVideoPictureExtentGranularity(Extent2D videoPictureExtentGranularity_) {this->videoPictureExtentGranularity = videoPictureExtentGranularity_; return *this; }
    VideoCapabilitiesKHR& setMinExtent(Extent2D minExtent_) {this->minExtent = minExtent_; return *this; }
    VideoCapabilitiesKHR& setMaxExtent(Extent2D maxExtent_) {this->maxExtent = maxExtent_; return *this; }
    VideoCapabilitiesKHR& setMaxReferencePicturesSlotsCount(uint32_t maxReferencePicturesSlotsCount_) {this->maxReferencePicturesSlotsCount = maxReferencePicturesSlotsCount_; return *this; }
    VideoCapabilitiesKHR& setMaxReferencePicturesActiveCount(uint32_t maxReferencePicturesActiveCount_) {this->maxReferencePicturesActiveCount = maxReferencePicturesActiveCount_; return *this; }
};
struct VideoGetMemoryPropertiesKHR {
    StructureType sType{StructureType::VideoGetMemoryPropertiesKHR};
    const void* pNext = nullptr;
    uint32_t memoryBindIndex{0};
    MemoryRequirements2* pMemoryRequirements = nullptr;
    VideoGetMemoryPropertiesKHR& setMemoryBindIndex(uint32_t memoryBindIndex_) {this->memoryBindIndex = memoryBindIndex_; return *this; }
    VideoGetMemoryPropertiesKHR& setPMemoryRequirements(MemoryRequirements2* pMemoryRequirements_) {this->pMemoryRequirements = pMemoryRequirements_; return *this; }
    VideoGetMemoryPropertiesKHR& setPMemoryRequirements(MemoryRequirements2 & pMemoryRequirements_) {this->pMemoryRequirements = &pMemoryRequirements_; return *this; }
};
struct VideoBindMemoryKHR {
    StructureType sType{StructureType::VideoBindMemoryKHR};
    const void* pNext = nullptr;
    uint32_t memoryBindIndex{0};
    DeviceMemory memory{};
    DeviceSize memoryOffset{0};
    DeviceSize memorySize{0};
    VideoBindMemoryKHR& setMemoryBindIndex(uint32_t memoryBindIndex_) {this->memoryBindIndex = memoryBindIndex_; return *this; }
    VideoBindMemoryKHR& setMemory(DeviceMemory memory_) {this->memory = memory_; return *this; }
    VideoBindMemoryKHR& setMemoryOffset(DeviceSize memoryOffset_) {this->memoryOffset = memoryOffset_; return *this; }
    VideoBindMemoryKHR& setMemorySize(DeviceSize memorySize_) {this->memorySize = memorySize_; return *this; }
};
struct VideoPictureResourceKHR {
    StructureType sType{StructureType::VideoPictureResourceKHR};
    const void* pNext = nullptr;
    Offset2D codedOffset{};
    Extent2D codedExtent{};
    uint32_t baseArrayLayer{0};
    ImageView imageViewBinding{};
    VideoPictureResourceKHR& setCodedOffset(Offset2D codedOffset_) {this->codedOffset = codedOffset_; return *this; }
    VideoPictureResourceKHR& setCodedExtent(Extent2D codedExtent_) {this->codedExtent = codedExtent_; return *this; }
    VideoPictureResourceKHR& setBaseArrayLayer(uint32_t baseArrayLayer_) {this->baseArrayLayer = baseArrayLayer_; return *this; }
    VideoPictureResourceKHR& setImageViewBinding(ImageView imageViewBinding_) {this->imageViewBinding = imageViewBinding_; return *this; }
};
struct VideoReferenceSlotKHR {
    StructureType sType{StructureType::VideoReferenceSlotKHR};
    const void* pNext = nullptr;
    int8_t slotIndex{};
    const VideoPictureResourceKHR* pPictureResource = nullptr;
    VideoReferenceSlotKHR& setSlotIndex(int8_t slotIndex_) {this->slotIndex = slotIndex_; return *this; }
    VideoReferenceSlotKHR& setPPictureResource(const VideoPictureResourceKHR* pPictureResource_) {this->pPictureResource = pPictureResource_; return *this; }
    VideoReferenceSlotKHR& setPPictureResource(VideoPictureResourceKHR const& pPictureResource_) {this->pPictureResource = &pPictureResource_; return *this; }
};
struct VideoDecodeInfoKHR {
    StructureType sType{StructureType::VideoDecodeInfoKHR};
    const void* pNext = nullptr;
    VideoDecodeFlagsKHR flags{};
    Offset2D codedOffset{};
    Extent2D codedExtent{};
    Buffer srcBuffer{};
    DeviceSize srcBufferOffset{0};
    DeviceSize srcBufferRange{0};
    VideoPictureResourceKHR dstPictureResource{};
    const VideoReferenceSlotKHR* pSetupReferenceSlot = nullptr;
    uint32_t referenceSlotCount{0};
    const VideoReferenceSlotKHR* pReferenceSlots = nullptr;
    VideoDecodeInfoKHR& setFlags(VideoDecodeFlagsKHR flags_) {this->flags = flags_; return *this; }
    VideoDecodeInfoKHR& setCodedOffset(Offset2D codedOffset_) {this->codedOffset = codedOffset_; return *this; }
    VideoDecodeInfoKHR& setCodedExtent(Extent2D codedExtent_) {this->codedExtent = codedExtent_; return *this; }
    VideoDecodeInfoKHR& setSrcBuffer(Buffer srcBuffer_) {this->srcBuffer = srcBuffer_; return *this; }
    VideoDecodeInfoKHR& setSrcBufferOffset(DeviceSize srcBufferOffset_) {this->srcBufferOffset = srcBufferOffset_; return *this; }
    VideoDecodeInfoKHR& setSrcBufferRange(DeviceSize srcBufferRange_) {this->srcBufferRange = srcBufferRange_; return *this; }
    VideoDecodeInfoKHR& setDstPictureResource(VideoPictureResourceKHR dstPictureResource_) {this->dstPictureResource = dstPictureResource_; return *this; }
    VideoDecodeInfoKHR& setPSetupReferenceSlot(const VideoReferenceSlotKHR* pSetupReferenceSlot_) {this->pSetupReferenceSlot = pSetupReferenceSlot_; return *this; }
    VideoDecodeInfoKHR& setPSetupReferenceSlot(VideoReferenceSlotKHR const& pSetupReferenceSlot_) {this->pSetupReferenceSlot = &pSetupReferenceSlot_; return *this; }
    VideoDecodeInfoKHR& setReferenceSlotCount(uint32_t referenceSlotCount_) {this->referenceSlotCount = referenceSlotCount_; return *this; }
    VideoDecodeInfoKHR& setPReferenceSlots(const VideoReferenceSlotKHR* pReferenceSlots_) {this->pReferenceSlots = pReferenceSlots_; return *this; }
    VideoDecodeInfoKHR& setPReferenceSlots(detail::span<const VideoReferenceSlotKHR> pReferenceSlots_) {this->referenceSlotCount = pReferenceSlots_.size(); this->pReferenceSlots = pReferenceSlots_.data();  return *this; }
};
struct VideoDecodeH264ProfileEXT {
    StructureType sType{StructureType::VideoDecodeH264ProfileEXT};
    const void* pNext = nullptr;
    StdVideoH264ProfileIdc stdProfileIdc{};
    VideoDecodeH264FieldLayoutFlagsEXT fieldLayout{};
    VideoDecodeH264ProfileEXT& setStdProfileIdc(StdVideoH264ProfileIdc stdProfileIdc_) {this->stdProfileIdc = stdProfileIdc_; return *this; }
    VideoDecodeH264ProfileEXT& setFieldLayout(VideoDecodeH264FieldLayoutFlagsEXT fieldLayout_) {this->fieldLayout = fieldLayout_; return *this; }
};
struct VideoDecodeH264CapabilitiesEXT {
    StructureType sType{StructureType::VideoDecodeH264CapabilitiesEXT};
    void* pNext = nullptr;
    uint32_t maxLevel{0};
    Offset2D fieldOffsetGranularity{};
    ExtensionProperties stdExtensionVersion{};
    VideoDecodeH264CapabilitiesEXT& setMaxLevel(uint32_t maxLevel_) {this->maxLevel = maxLevel_; return *this; }
    VideoDecodeH264CapabilitiesEXT& setFieldOffsetGranularity(Offset2D fieldOffsetGranularity_) {this->fieldOffsetGranularity = fieldOffsetGranularity_; return *this; }
    VideoDecodeH264CapabilitiesEXT& setStdExtensionVersion(ExtensionProperties stdExtensionVersion_) {this->stdExtensionVersion = stdExtensionVersion_; return *this; }
};
struct VideoDecodeH264SessionCreateInfoEXT {
    StructureType sType{StructureType::VideoDecodeH264SessionCreateInfoEXT};
    const void* pNext = nullptr;
    VideoDecodeH264CreateFlagsEXT flags{};
    const ExtensionProperties* pStdExtensionVersion = nullptr;
    VideoDecodeH264SessionCreateInfoEXT& setFlags(VideoDecodeH264CreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    VideoDecodeH264SessionCreateInfoEXT& setPStdExtensionVersion(const ExtensionProperties* pStdExtensionVersion_) {this->pStdExtensionVersion = pStdExtensionVersion_; return *this; }
    VideoDecodeH264SessionCreateInfoEXT& setPStdExtensionVersion(ExtensionProperties const& pStdExtensionVersion_) {this->pStdExtensionVersion = &pStdExtensionVersion_; return *this; }
};
struct VideoDecodeH264SessionParametersAddInfoEXT {
    StructureType sType{StructureType::VideoDecodeH264SessionParametersAddInfoEXT};
    const void* pNext = nullptr;
    uint32_t spsStdCount{0};
    const StdVideoH264SequenceParameterSet* pSpsStd = nullptr;
    uint32_t ppsStdCount{0};
    const StdVideoH264PictureParameterSet* pPpsStd = nullptr;
    VideoDecodeH264SessionParametersAddInfoEXT& setSpsStdCount(uint32_t spsStdCount_) {this->spsStdCount = spsStdCount_; return *this; }
    VideoDecodeH264SessionParametersAddInfoEXT& setPSpsStd(const StdVideoH264SequenceParameterSet* pSpsStd_) {this->pSpsStd = pSpsStd_; return *this; }
    VideoDecodeH264SessionParametersAddInfoEXT& setPSpsStd(detail::span<const StdVideoH264SequenceParameterSet> pSpsStd_) {this->spsStdCount = pSpsStd_.size(); this->pSpsStd = pSpsStd_.data();  return *this; }
    VideoDecodeH264SessionParametersAddInfoEXT& setPpsStdCount(uint32_t ppsStdCount_) {this->ppsStdCount = ppsStdCount_; return *this; }
    VideoDecodeH264SessionParametersAddInfoEXT& setPPpsStd(const StdVideoH264PictureParameterSet* pPpsStd_) {this->pPpsStd = pPpsStd_; return *this; }
    VideoDecodeH264SessionParametersAddInfoEXT& setPPpsStd(detail::span<const StdVideoH264PictureParameterSet> pPpsStd_) {this->ppsStdCount = pPpsStd_.size(); this->pPpsStd = pPpsStd_.data();  return *this; }
};
struct VideoDecodeH264SessionParametersCreateInfoEXT {
    StructureType sType{StructureType::VideoDecodeH264SessionParametersCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t maxSpsStdCount{0};
    uint32_t maxPpsStdCount{0};
    const VideoDecodeH264SessionParametersAddInfoEXT* pParametersAddInfo = nullptr;
    VideoDecodeH264SessionParametersCreateInfoEXT& setMaxSpsStdCount(uint32_t maxSpsStdCount_) {this->maxSpsStdCount = maxSpsStdCount_; return *this; }
    VideoDecodeH264SessionParametersCreateInfoEXT& setMaxPpsStdCount(uint32_t maxPpsStdCount_) {this->maxPpsStdCount = maxPpsStdCount_; return *this; }
    VideoDecodeH264SessionParametersCreateInfoEXT& setPParametersAddInfo(const VideoDecodeH264SessionParametersAddInfoEXT* pParametersAddInfo_) {this->pParametersAddInfo = pParametersAddInfo_; return *this; }
    VideoDecodeH264SessionParametersCreateInfoEXT& setPParametersAddInfo(VideoDecodeH264SessionParametersAddInfoEXT const& pParametersAddInfo_) {this->pParametersAddInfo = &pParametersAddInfo_; return *this; }
};
struct VideoDecodeH264PictureInfoEXT {
    StructureType sType{StructureType::VideoDecodeH264PictureInfoEXT};
    const void* pNext = nullptr;
    const StdVideoDecodeH264PictureInfo* pStdPictureInfo = nullptr;
    uint32_t slicesCount{0};
    const uint32_t* pSlicesDataOffsets = nullptr;
    VideoDecodeH264PictureInfoEXT& setPStdPictureInfo(const StdVideoDecodeH264PictureInfo* pStdPictureInfo_) {this->pStdPictureInfo = pStdPictureInfo_; return *this; }
    VideoDecodeH264PictureInfoEXT& setPStdPictureInfo(StdVideoDecodeH264PictureInfo const& pStdPictureInfo_) {this->pStdPictureInfo = &pStdPictureInfo_; return *this; }
    VideoDecodeH264PictureInfoEXT& setSlicesCount(uint32_t slicesCount_) {this->slicesCount = slicesCount_; return *this; }
    VideoDecodeH264PictureInfoEXT& setPSlicesDataOffsets(const uint32_t* pSlicesDataOffsets_) {this->pSlicesDataOffsets = pSlicesDataOffsets_; return *this; }
    VideoDecodeH264PictureInfoEXT& setPSlicesDataOffsets(detail::span<const uint32_t> pSlicesDataOffsets_) {this->slicesCount = pSlicesDataOffsets_.size(); this->pSlicesDataOffsets = pSlicesDataOffsets_.data();  return *this; }
};
struct VideoDecodeH264DpbSlotInfoEXT {
    StructureType sType{StructureType::VideoDecodeH264DpbSlotInfoEXT};
    const void* pNext = nullptr;
    const StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo = nullptr;
    VideoDecodeH264DpbSlotInfoEXT& setPStdReferenceInfo(const StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo_) {this->pStdReferenceInfo = pStdReferenceInfo_; return *this; }
    VideoDecodeH264DpbSlotInfoEXT& setPStdReferenceInfo(StdVideoDecodeH264ReferenceInfo const& pStdReferenceInfo_) {this->pStdReferenceInfo = &pStdReferenceInfo_; return *this; }
};
struct VideoDecodeH264MvcEXT {
    StructureType sType{StructureType::VideoDecodeH264MvcEXT};
    const void* pNext = nullptr;
    const StdVideoDecodeH264Mvc* pStdMvc = nullptr;
    VideoDecodeH264MvcEXT& setPStdMvc(const StdVideoDecodeH264Mvc* pStdMvc_) {this->pStdMvc = pStdMvc_; return *this; }
    VideoDecodeH264MvcEXT& setPStdMvc(StdVideoDecodeH264Mvc const& pStdMvc_) {this->pStdMvc = &pStdMvc_; return *this; }
};
struct VideoDecodeH265ProfileEXT {
    StructureType sType{StructureType::VideoDecodeH265ProfileEXT};
    const void* pNext = nullptr;
    StdVideoH265ProfileIdc stdProfileIdc{};
    VideoDecodeH265ProfileEXT& setStdProfileIdc(StdVideoH265ProfileIdc stdProfileIdc_) {this->stdProfileIdc = stdProfileIdc_; return *this; }
};
struct VideoDecodeH265CapabilitiesEXT {
    StructureType sType{StructureType::VideoDecodeH265CapabilitiesEXT};
    void* pNext = nullptr;
    uint32_t maxLevel{0};
    ExtensionProperties stdExtensionVersion{};
    VideoDecodeH265CapabilitiesEXT& setMaxLevel(uint32_t maxLevel_) {this->maxLevel = maxLevel_; return *this; }
    VideoDecodeH265CapabilitiesEXT& setStdExtensionVersion(ExtensionProperties stdExtensionVersion_) {this->stdExtensionVersion = stdExtensionVersion_; return *this; }
};
struct VideoDecodeH265SessionCreateInfoEXT {
    StructureType sType{StructureType::VideoDecodeH265SessionCreateInfoEXT};
    const void* pNext = nullptr;
    VideoDecodeH265CreateFlagsEXT flags{};
    const ExtensionProperties* pStdExtensionVersion = nullptr;
    VideoDecodeH265SessionCreateInfoEXT& setFlags(VideoDecodeH265CreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    VideoDecodeH265SessionCreateInfoEXT& setPStdExtensionVersion(const ExtensionProperties* pStdExtensionVersion_) {this->pStdExtensionVersion = pStdExtensionVersion_; return *this; }
    VideoDecodeH265SessionCreateInfoEXT& setPStdExtensionVersion(ExtensionProperties const& pStdExtensionVersion_) {this->pStdExtensionVersion = &pStdExtensionVersion_; return *this; }
};
struct VideoDecodeH265SessionParametersAddInfoEXT {
    StructureType sType{StructureType::VideoDecodeH265SessionParametersAddInfoEXT};
    const void* pNext = nullptr;
    uint32_t spsStdCount{0};
    const StdVideoH265SequenceParameterSet* pSpsStd = nullptr;
    uint32_t ppsStdCount{0};
    const StdVideoH265PictureParameterSet* pPpsStd = nullptr;
    VideoDecodeH265SessionParametersAddInfoEXT& setSpsStdCount(uint32_t spsStdCount_) {this->spsStdCount = spsStdCount_; return *this; }
    VideoDecodeH265SessionParametersAddInfoEXT& setPSpsStd(const StdVideoH265SequenceParameterSet* pSpsStd_) {this->pSpsStd = pSpsStd_; return *this; }
    VideoDecodeH265SessionParametersAddInfoEXT& setPSpsStd(detail::span<const StdVideoH265SequenceParameterSet> pSpsStd_) {this->spsStdCount = pSpsStd_.size(); this->pSpsStd = pSpsStd_.data();  return *this; }
    VideoDecodeH265SessionParametersAddInfoEXT& setPpsStdCount(uint32_t ppsStdCount_) {this->ppsStdCount = ppsStdCount_; return *this; }
    VideoDecodeH265SessionParametersAddInfoEXT& setPPpsStd(const StdVideoH265PictureParameterSet* pPpsStd_) {this->pPpsStd = pPpsStd_; return *this; }
    VideoDecodeH265SessionParametersAddInfoEXT& setPPpsStd(detail::span<const StdVideoH265PictureParameterSet> pPpsStd_) {this->ppsStdCount = pPpsStd_.size(); this->pPpsStd = pPpsStd_.data();  return *this; }
};
struct VideoDecodeH265SessionParametersCreateInfoEXT {
    StructureType sType{StructureType::VideoDecodeH265SessionParametersCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t maxSpsStdCount{0};
    uint32_t maxPpsStdCount{0};
    const VideoDecodeH265SessionParametersAddInfoEXT* pParametersAddInfo = nullptr;
    VideoDecodeH265SessionParametersCreateInfoEXT& setMaxSpsStdCount(uint32_t maxSpsStdCount_) {this->maxSpsStdCount = maxSpsStdCount_; return *this; }
    VideoDecodeH265SessionParametersCreateInfoEXT& setMaxPpsStdCount(uint32_t maxPpsStdCount_) {this->maxPpsStdCount = maxPpsStdCount_; return *this; }
    VideoDecodeH265SessionParametersCreateInfoEXT& setPParametersAddInfo(const VideoDecodeH265SessionParametersAddInfoEXT* pParametersAddInfo_) {this->pParametersAddInfo = pParametersAddInfo_; return *this; }
    VideoDecodeH265SessionParametersCreateInfoEXT& setPParametersAddInfo(VideoDecodeH265SessionParametersAddInfoEXT const& pParametersAddInfo_) {this->pParametersAddInfo = &pParametersAddInfo_; return *this; }
};
struct VideoDecodeH265PictureInfoEXT {
    StructureType sType{StructureType::VideoDecodeH265PictureInfoEXT};
    const void* pNext = nullptr;
    StdVideoDecodeH265PictureInfo* pStdPictureInfo = nullptr;
    uint32_t slicesCount{0};
    const uint32_t* pSlicesDataOffsets = nullptr;
    VideoDecodeH265PictureInfoEXT& setPStdPictureInfo(StdVideoDecodeH265PictureInfo* pStdPictureInfo_) {this->pStdPictureInfo = pStdPictureInfo_; return *this; }
    VideoDecodeH265PictureInfoEXT& setPStdPictureInfo(StdVideoDecodeH265PictureInfo & pStdPictureInfo_) {this->pStdPictureInfo = &pStdPictureInfo_; return *this; }
    VideoDecodeH265PictureInfoEXT& setSlicesCount(uint32_t slicesCount_) {this->slicesCount = slicesCount_; return *this; }
    VideoDecodeH265PictureInfoEXT& setPSlicesDataOffsets(const uint32_t* pSlicesDataOffsets_) {this->pSlicesDataOffsets = pSlicesDataOffsets_; return *this; }
    VideoDecodeH265PictureInfoEXT& setPSlicesDataOffsets(detail::span<const uint32_t> pSlicesDataOffsets_) {this->slicesCount = pSlicesDataOffsets_.size(); this->pSlicesDataOffsets = pSlicesDataOffsets_.data();  return *this; }
};
struct VideoDecodeH265DpbSlotInfoEXT {
    StructureType sType{StructureType::VideoDecodeH265DpbSlotInfoEXT};
    const void* pNext = nullptr;
    const StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo = nullptr;
    VideoDecodeH265DpbSlotInfoEXT& setPStdReferenceInfo(const StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo_) {this->pStdReferenceInfo = pStdReferenceInfo_; return *this; }
    VideoDecodeH265DpbSlotInfoEXT& setPStdReferenceInfo(StdVideoDecodeH265ReferenceInfo const& pStdReferenceInfo_) {this->pStdReferenceInfo = &pStdReferenceInfo_; return *this; }
};
struct VideoSessionCreateInfoKHR {
    StructureType sType{StructureType::VideoSessionCreateInfoKHR};
    const void* pNext = nullptr;
    uint32_t queueFamilyIndex{0};
    VideoSessionCreateFlagsKHR flags{};
    const VideoProfileKHR* pVideoProfile = nullptr;
    Format pictureFormat{static_cast<Format>(0)};
    Extent2D maxCodedExtent{};
    Format referencePicturesFormat{static_cast<Format>(0)};
    uint32_t maxReferencePicturesSlotsCount{0};
    uint32_t maxReferencePicturesActiveCount{0};
    VideoSessionCreateInfoKHR& setQueueFamilyIndex(uint32_t queueFamilyIndex_) {this->queueFamilyIndex = queueFamilyIndex_; return *this; }
    VideoSessionCreateInfoKHR& setFlags(VideoSessionCreateFlagsKHR flags_) {this->flags = flags_; return *this; }
    VideoSessionCreateInfoKHR& setPVideoProfile(const VideoProfileKHR* pVideoProfile_) {this->pVideoProfile = pVideoProfile_; return *this; }
    VideoSessionCreateInfoKHR& setPVideoProfile(VideoProfileKHR const& pVideoProfile_) {this->pVideoProfile = &pVideoProfile_; return *this; }
    VideoSessionCreateInfoKHR& setPictureFormat(Format pictureFormat_) {this->pictureFormat = pictureFormat_; return *this; }
    VideoSessionCreateInfoKHR& setMaxCodedExtent(Extent2D maxCodedExtent_) {this->maxCodedExtent = maxCodedExtent_; return *this; }
    VideoSessionCreateInfoKHR& setReferencePicturesFormat(Format referencePicturesFormat_) {this->referencePicturesFormat = referencePicturesFormat_; return *this; }
    VideoSessionCreateInfoKHR& setMaxReferencePicturesSlotsCount(uint32_t maxReferencePicturesSlotsCount_) {this->maxReferencePicturesSlotsCount = maxReferencePicturesSlotsCount_; return *this; }
    VideoSessionCreateInfoKHR& setMaxReferencePicturesActiveCount(uint32_t maxReferencePicturesActiveCount_) {this->maxReferencePicturesActiveCount = maxReferencePicturesActiveCount_; return *this; }
};
struct VideoSessionParametersCreateInfoKHR {
    StructureType sType{StructureType::VideoSessionParametersCreateInfoKHR};
    const void* pNext = nullptr;
    VideoSessionParametersKHR videoSessionParametersTemplate{};
    VideoSessionKHR videoSession{};
    VideoSessionParametersCreateInfoKHR& setVideoSessionParametersTemplate(VideoSessionParametersKHR videoSessionParametersTemplate_) {this->videoSessionParametersTemplate = videoSessionParametersTemplate_; return *this; }
    VideoSessionParametersCreateInfoKHR& setVideoSession(VideoSessionKHR videoSession_) {this->videoSession = videoSession_; return *this; }
};
struct VideoSessionParametersUpdateInfoKHR {
    StructureType sType{StructureType::VideoSessionParametersUpdateInfoKHR};
    const void* pNext = nullptr;
    uint32_t updateSequenceCount{0};
    VideoSessionParametersUpdateInfoKHR& setUpdateSequenceCount(uint32_t updateSequenceCount_) {this->updateSequenceCount = updateSequenceCount_; return *this; }
};
struct VideoBeginCodingInfoKHR {
    StructureType sType{StructureType::VideoBeginCodingInfoKHR};
    const void* pNext = nullptr;
    VideoBeginCodingFlagsKHR flags{};
    VideoCodingQualityPresetFlagsKHR codecQualityPreset{};
    VideoSessionKHR videoSession{};
    VideoSessionParametersKHR videoSessionParameters{};
    uint32_t referenceSlotCount{0};
    const VideoReferenceSlotKHR* pReferenceSlots = nullptr;
    VideoBeginCodingInfoKHR& setFlags(VideoBeginCodingFlagsKHR flags_) {this->flags = flags_; return *this; }
    VideoBeginCodingInfoKHR& setCodecQualityPreset(VideoCodingQualityPresetFlagsKHR codecQualityPreset_) {this->codecQualityPreset = codecQualityPreset_; return *this; }
    VideoBeginCodingInfoKHR& setVideoSession(VideoSessionKHR videoSession_) {this->videoSession = videoSession_; return *this; }
    VideoBeginCodingInfoKHR& setVideoSessionParameters(VideoSessionParametersKHR videoSessionParameters_) {this->videoSessionParameters = videoSessionParameters_; return *this; }
    VideoBeginCodingInfoKHR& setReferenceSlotCount(uint32_t referenceSlotCount_) {this->referenceSlotCount = referenceSlotCount_; return *this; }
    VideoBeginCodingInfoKHR& setPReferenceSlots(const VideoReferenceSlotKHR* pReferenceSlots_) {this->pReferenceSlots = pReferenceSlots_; return *this; }
    VideoBeginCodingInfoKHR& setPReferenceSlots(detail::span<const VideoReferenceSlotKHR> pReferenceSlots_) {this->referenceSlotCount = pReferenceSlots_.size(); this->pReferenceSlots = pReferenceSlots_.data();  return *this; }
};
struct VideoEndCodingInfoKHR {
    StructureType sType{StructureType::VideoEndCodingInfoKHR};
    const void* pNext = nullptr;
    VideoEndCodingFlagsKHR flags{};
    VideoEndCodingInfoKHR& setFlags(VideoEndCodingFlagsKHR flags_) {this->flags = flags_; return *this; }
};
struct VideoCodingControlInfoKHR {
    StructureType sType{StructureType::VideoCodingControlInfoKHR};
    const void* pNext = nullptr;
    VideoCodingControlFlagsKHR flags{};
    VideoCodingControlInfoKHR& setFlags(VideoCodingControlFlagsKHR flags_) {this->flags = flags_; return *this; }
};
struct VideoEncodeInfoKHR {
    StructureType sType{StructureType::VideoEncodeInfoKHR};
    const void* pNext = nullptr;
    VideoEncodeFlagsKHR flags{};
    uint32_t qualityLevel{0};
    Extent2D codedExtent{};
    Buffer dstBitstreamBuffer{};
    DeviceSize dstBitstreamBufferOffset{0};
    DeviceSize dstBitstreamBufferMaxRange{0};
    VideoPictureResourceKHR srcPictureResource{};
    const VideoReferenceSlotKHR* pSetupReferenceSlot = nullptr;
    uint32_t referenceSlotCount{0};
    const VideoReferenceSlotKHR* pReferenceSlots = nullptr;
    VideoEncodeInfoKHR& setFlags(VideoEncodeFlagsKHR flags_) {this->flags = flags_; return *this; }
    VideoEncodeInfoKHR& setQualityLevel(uint32_t qualityLevel_) {this->qualityLevel = qualityLevel_; return *this; }
    VideoEncodeInfoKHR& setCodedExtent(Extent2D codedExtent_) {this->codedExtent = codedExtent_; return *this; }
    VideoEncodeInfoKHR& setDstBitstreamBuffer(Buffer dstBitstreamBuffer_) {this->dstBitstreamBuffer = dstBitstreamBuffer_; return *this; }
    VideoEncodeInfoKHR& setDstBitstreamBufferOffset(DeviceSize dstBitstreamBufferOffset_) {this->dstBitstreamBufferOffset = dstBitstreamBufferOffset_; return *this; }
    VideoEncodeInfoKHR& setDstBitstreamBufferMaxRange(DeviceSize dstBitstreamBufferMaxRange_) {this->dstBitstreamBufferMaxRange = dstBitstreamBufferMaxRange_; return *this; }
    VideoEncodeInfoKHR& setSrcPictureResource(VideoPictureResourceKHR srcPictureResource_) {this->srcPictureResource = srcPictureResource_; return *this; }
    VideoEncodeInfoKHR& setPSetupReferenceSlot(const VideoReferenceSlotKHR* pSetupReferenceSlot_) {this->pSetupReferenceSlot = pSetupReferenceSlot_; return *this; }
    VideoEncodeInfoKHR& setPSetupReferenceSlot(VideoReferenceSlotKHR const& pSetupReferenceSlot_) {this->pSetupReferenceSlot = &pSetupReferenceSlot_; return *this; }
    VideoEncodeInfoKHR& setReferenceSlotCount(uint32_t referenceSlotCount_) {this->referenceSlotCount = referenceSlotCount_; return *this; }
    VideoEncodeInfoKHR& setPReferenceSlots(const VideoReferenceSlotKHR* pReferenceSlots_) {this->pReferenceSlots = pReferenceSlots_; return *this; }
    VideoEncodeInfoKHR& setPReferenceSlots(detail::span<const VideoReferenceSlotKHR> pReferenceSlots_) {this->referenceSlotCount = pReferenceSlots_.size(); this->pReferenceSlots = pReferenceSlots_.data();  return *this; }
};
struct VideoEncodeRateControlInfoKHR {
    StructureType sType{StructureType::VideoEncodeRateControlInfoKHR};
    const void* pNext = nullptr;
    VideoEncodeRateControlFlagsKHR flags{};
    VideoEncodeRateControlModeFlagBitsKHR rateControlMode{static_cast<VideoEncodeRateControlModeFlagBitsKHR>(0)};
    uint32_t averageBitrate{0};
    uint16_t peakToAverageBitrateRatio{0};
    uint16_t frameRateNumerator{0};
    uint16_t frameRateDenominator{0};
    uint32_t virtualBufferSizeInMs{0};
    VideoEncodeRateControlInfoKHR& setFlags(VideoEncodeRateControlFlagsKHR flags_) {this->flags = flags_; return *this; }
    VideoEncodeRateControlInfoKHR& setRateControlMode(VideoEncodeRateControlModeFlagBitsKHR rateControlMode_) {this->rateControlMode = rateControlMode_; return *this; }
    VideoEncodeRateControlInfoKHR& setAverageBitrate(uint32_t averageBitrate_) {this->averageBitrate = averageBitrate_; return *this; }
    VideoEncodeRateControlInfoKHR& setPeakToAverageBitrateRatio(uint16_t peakToAverageBitrateRatio_) {this->peakToAverageBitrateRatio = peakToAverageBitrateRatio_; return *this; }
    VideoEncodeRateControlInfoKHR& setFrameRateNumerator(uint16_t frameRateNumerator_) {this->frameRateNumerator = frameRateNumerator_; return *this; }
    VideoEncodeRateControlInfoKHR& setFrameRateDenominator(uint16_t frameRateDenominator_) {this->frameRateDenominator = frameRateDenominator_; return *this; }
    VideoEncodeRateControlInfoKHR& setVirtualBufferSizeInMs(uint32_t virtualBufferSizeInMs_) {this->virtualBufferSizeInMs = virtualBufferSizeInMs_; return *this; }
};
struct VideoEncodeH264CapabilitiesEXT {
    StructureType sType{StructureType::VideoEncodeH264CapabilitiesEXT};
    const void* pNext = nullptr;
    VideoEncodeH264CapabilitiesFlagsEXT flags{};
    VideoEncodeH264InputModeFlagsEXT inputModeFlags{};
    VideoEncodeH264OutputModeFlagsEXT outputModeFlags{};
    Extent2D minPictureSizeInMbs{};
    Extent2D maxPictureSizeInMbs{};
    Extent2D inputImageDataAlignment{};
    uint8_t maxNumL0ReferenceForP{0};
    uint8_t maxNumL0ReferenceForB{0};
    uint8_t maxNumL1Reference{0};
    uint8_t qualityLevelCount{0};
    ExtensionProperties stdExtensionVersion{};
    VideoEncodeH264CapabilitiesEXT& setFlags(VideoEncodeH264CapabilitiesFlagsEXT flags_) {this->flags = flags_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setInputModeFlags(VideoEncodeH264InputModeFlagsEXT inputModeFlags_) {this->inputModeFlags = inputModeFlags_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setOutputModeFlags(VideoEncodeH264OutputModeFlagsEXT outputModeFlags_) {this->outputModeFlags = outputModeFlags_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setMinPictureSizeInMbs(Extent2D minPictureSizeInMbs_) {this->minPictureSizeInMbs = minPictureSizeInMbs_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setMaxPictureSizeInMbs(Extent2D maxPictureSizeInMbs_) {this->maxPictureSizeInMbs = maxPictureSizeInMbs_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setInputImageDataAlignment(Extent2D inputImageDataAlignment_) {this->inputImageDataAlignment = inputImageDataAlignment_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setMaxNumL0ReferenceForP(uint8_t maxNumL0ReferenceForP_) {this->maxNumL0ReferenceForP = maxNumL0ReferenceForP_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setMaxNumL0ReferenceForB(uint8_t maxNumL0ReferenceForB_) {this->maxNumL0ReferenceForB = maxNumL0ReferenceForB_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setMaxNumL1Reference(uint8_t maxNumL1Reference_) {this->maxNumL1Reference = maxNumL1Reference_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setQualityLevelCount(uint8_t qualityLevelCount_) {this->qualityLevelCount = qualityLevelCount_; return *this; }
    VideoEncodeH264CapabilitiesEXT& setStdExtensionVersion(ExtensionProperties stdExtensionVersion_) {this->stdExtensionVersion = stdExtensionVersion_; return *this; }
};
struct VideoEncodeH264SessionCreateInfoEXT {
    StructureType sType{StructureType::VideoEncodeH264SessionCreateInfoEXT};
    const void* pNext = nullptr;
    VideoEncodeH264CreateFlagsEXT flags{};
    Extent2D maxPictureSizeInMbs{};
    const ExtensionProperties* pStdExtensionVersion = nullptr;
    VideoEncodeH264SessionCreateInfoEXT& setFlags(VideoEncodeH264CreateFlagsEXT flags_) {this->flags = flags_; return *this; }
    VideoEncodeH264SessionCreateInfoEXT& setMaxPictureSizeInMbs(Extent2D maxPictureSizeInMbs_) {this->maxPictureSizeInMbs = maxPictureSizeInMbs_; return *this; }
    VideoEncodeH264SessionCreateInfoEXT& setPStdExtensionVersion(const ExtensionProperties* pStdExtensionVersion_) {this->pStdExtensionVersion = pStdExtensionVersion_; return *this; }
    VideoEncodeH264SessionCreateInfoEXT& setPStdExtensionVersion(ExtensionProperties const& pStdExtensionVersion_) {this->pStdExtensionVersion = &pStdExtensionVersion_; return *this; }
};
struct VideoEncodeH264SessionParametersAddInfoEXT {
    StructureType sType{StructureType::VideoEncodeH264SessionParametersAddInfoEXT};
    const void* pNext = nullptr;
    uint32_t spsStdCount{0};
    const StdVideoH264SequenceParameterSet* pSpsStd = nullptr;
    uint32_t ppsStdCount{0};
    const StdVideoH264PictureParameterSet* pPpsStd = nullptr;
    VideoEncodeH264SessionParametersAddInfoEXT& setSpsStdCount(uint32_t spsStdCount_) {this->spsStdCount = spsStdCount_; return *this; }
    VideoEncodeH264SessionParametersAddInfoEXT& setPSpsStd(const StdVideoH264SequenceParameterSet* pSpsStd_) {this->pSpsStd = pSpsStd_; return *this; }
    VideoEncodeH264SessionParametersAddInfoEXT& setPSpsStd(detail::span<const StdVideoH264SequenceParameterSet> pSpsStd_) {this->spsStdCount = pSpsStd_.size(); this->pSpsStd = pSpsStd_.data();  return *this; }
    VideoEncodeH264SessionParametersAddInfoEXT& setPpsStdCount(uint32_t ppsStdCount_) {this->ppsStdCount = ppsStdCount_; return *this; }
    VideoEncodeH264SessionParametersAddInfoEXT& setPPpsStd(const StdVideoH264PictureParameterSet* pPpsStd_) {this->pPpsStd = pPpsStd_; return *this; }
    VideoEncodeH264SessionParametersAddInfoEXT& setPPpsStd(detail::span<const StdVideoH264PictureParameterSet> pPpsStd_) {this->ppsStdCount = pPpsStd_.size(); this->pPpsStd = pPpsStd_.data();  return *this; }
};
struct VideoEncodeH264SessionParametersCreateInfoEXT {
    StructureType sType{StructureType::VideoEncodeH264SessionParametersCreateInfoEXT};
    const void* pNext = nullptr;
    uint32_t maxSpsStdCount{0};
    uint32_t maxPpsStdCount{0};
    const VideoEncodeH264SessionParametersAddInfoEXT* pParametersAddInfo = nullptr;
    VideoEncodeH264SessionParametersCreateInfoEXT& setMaxSpsStdCount(uint32_t maxSpsStdCount_) {this->maxSpsStdCount = maxSpsStdCount_; return *this; }
    VideoEncodeH264SessionParametersCreateInfoEXT& setMaxPpsStdCount(uint32_t maxPpsStdCount_) {this->maxPpsStdCount = maxPpsStdCount_; return *this; }
    VideoEncodeH264SessionParametersCreateInfoEXT& setPParametersAddInfo(const VideoEncodeH264SessionParametersAddInfoEXT* pParametersAddInfo_) {this->pParametersAddInfo = pParametersAddInfo_; return *this; }
    VideoEncodeH264SessionParametersCreateInfoEXT& setPParametersAddInfo(VideoEncodeH264SessionParametersAddInfoEXT const& pParametersAddInfo_) {this->pParametersAddInfo = &pParametersAddInfo_; return *this; }
};
struct VideoEncodeH264DpbSlotInfoEXT {
    StructureType sType{StructureType::VideoEncodeH264DpbSlotInfoEXT};
    const void* pNext = nullptr;
    int8_t slotIndex{};
    const StdVideoEncodeH264PictureInfo* pStdPictureInfo = nullptr;
    VideoEncodeH264DpbSlotInfoEXT& setSlotIndex(int8_t slotIndex_) {this->slotIndex = slotIndex_; return *this; }
    VideoEncodeH264DpbSlotInfoEXT& setPStdPictureInfo(const StdVideoEncodeH264PictureInfo* pStdPictureInfo_) {this->pStdPictureInfo = pStdPictureInfo_; return *this; }
    VideoEncodeH264DpbSlotInfoEXT& setPStdPictureInfo(StdVideoEncodeH264PictureInfo const& pStdPictureInfo_) {this->pStdPictureInfo = &pStdPictureInfo_; return *this; }
};
struct VideoEncodeH264NaluSliceEXT {
    StructureType sType{StructureType::VideoEncodeH264NaluSliceEXT};
    const void* pNext = nullptr;
    const StdVideoEncodeH264SliceHeader* pSliceHeaderStd = nullptr;
    uint32_t mbCount{0};
    uint8_t refFinalList0EntryCount{0};
    const VideoEncodeH264DpbSlotInfoEXT* pRefFinalList0Entries = nullptr;
    uint8_t refFinalList1EntryCount{0};
    const VideoEncodeH264DpbSlotInfoEXT* pRefFinalList1Entries = nullptr;
    uint32_t precedingNaluBytes{0};
    uint8_t minQp{0};
    uint8_t maxQp{0};
    VideoEncodeH264NaluSliceEXT& setPSliceHeaderStd(const StdVideoEncodeH264SliceHeader* pSliceHeaderStd_) {this->pSliceHeaderStd = pSliceHeaderStd_; return *this; }
    VideoEncodeH264NaluSliceEXT& setPSliceHeaderStd(StdVideoEncodeH264SliceHeader const& pSliceHeaderStd_) {this->pSliceHeaderStd = &pSliceHeaderStd_; return *this; }
    VideoEncodeH264NaluSliceEXT& setMbCount(uint32_t mbCount_) {this->mbCount = mbCount_; return *this; }
    VideoEncodeH264NaluSliceEXT& setRefFinalList0EntryCount(uint8_t refFinalList0EntryCount_) {this->refFinalList0EntryCount = refFinalList0EntryCount_; return *this; }
    VideoEncodeH264NaluSliceEXT& setPRefFinalList0Entries(const VideoEncodeH264DpbSlotInfoEXT* pRefFinalList0Entries_) {this->pRefFinalList0Entries = pRefFinalList0Entries_; return *this; }
    VideoEncodeH264NaluSliceEXT& setPRefFinalList0Entries(detail::span<const VideoEncodeH264DpbSlotInfoEXT> pRefFinalList0Entries_) {this->refFinalList0EntryCount = pRefFinalList0Entries_.size(); this->pRefFinalList0Entries = pRefFinalList0Entries_.data();  return *this; }
    VideoEncodeH264NaluSliceEXT& setRefFinalList1EntryCount(uint8_t refFinalList1EntryCount_) {this->refFinalList1EntryCount = refFinalList1EntryCount_; return *this; }
    VideoEncodeH264NaluSliceEXT& setPRefFinalList1Entries(const VideoEncodeH264DpbSlotInfoEXT* pRefFinalList1Entries_) {this->pRefFinalList1Entries = pRefFinalList1Entries_; return *this; }
    VideoEncodeH264NaluSliceEXT& setPRefFinalList1Entries(detail::span<const VideoEncodeH264DpbSlotInfoEXT> pRefFinalList1Entries_) {this->refFinalList1EntryCount = pRefFinalList1Entries_.size(); this->pRefFinalList1Entries = pRefFinalList1Entries_.data();  return *this; }
    VideoEncodeH264NaluSliceEXT& setPrecedingNaluBytes(uint32_t precedingNaluBytes_) {this->precedingNaluBytes = precedingNaluBytes_; return *this; }
    VideoEncodeH264NaluSliceEXT& setMinQp(uint8_t minQp_) {this->minQp = minQp_; return *this; }
    VideoEncodeH264NaluSliceEXT& setMaxQp(uint8_t maxQp_) {this->maxQp = maxQp_; return *this; }
};
struct VideoEncodeH264VclFrameInfoEXT {
    StructureType sType{StructureType::VideoEncodeH264VclFrameInfoEXT};
    const void* pNext = nullptr;
    uint8_t refDefaultFinalList0EntryCount{0};
    const VideoEncodeH264DpbSlotInfoEXT* pRefDefaultFinalList0Entries = nullptr;
    uint8_t refDefaultFinalList1EntryCount{0};
    const VideoEncodeH264DpbSlotInfoEXT* pRefDefaultFinalList1Entries = nullptr;
    uint32_t naluSliceEntryCount{0};
    const VideoEncodeH264NaluSliceEXT* pNaluSliceEntries = nullptr;
    const VideoEncodeH264DpbSlotInfoEXT* pCurrentPictureInfo = nullptr;
    VideoEncodeH264VclFrameInfoEXT& setRefDefaultFinalList0EntryCount(uint8_t refDefaultFinalList0EntryCount_) {this->refDefaultFinalList0EntryCount = refDefaultFinalList0EntryCount_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPRefDefaultFinalList0Entries(const VideoEncodeH264DpbSlotInfoEXT* pRefDefaultFinalList0Entries_) {this->pRefDefaultFinalList0Entries = pRefDefaultFinalList0Entries_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPRefDefaultFinalList0Entries(detail::span<const VideoEncodeH264DpbSlotInfoEXT> pRefDefaultFinalList0Entries_) {this->refDefaultFinalList0EntryCount = pRefDefaultFinalList0Entries_.size(); this->pRefDefaultFinalList0Entries = pRefDefaultFinalList0Entries_.data();  return *this; }
    VideoEncodeH264VclFrameInfoEXT& setRefDefaultFinalList1EntryCount(uint8_t refDefaultFinalList1EntryCount_) {this->refDefaultFinalList1EntryCount = refDefaultFinalList1EntryCount_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPRefDefaultFinalList1Entries(const VideoEncodeH264DpbSlotInfoEXT* pRefDefaultFinalList1Entries_) {this->pRefDefaultFinalList1Entries = pRefDefaultFinalList1Entries_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPRefDefaultFinalList1Entries(detail::span<const VideoEncodeH264DpbSlotInfoEXT> pRefDefaultFinalList1Entries_) {this->refDefaultFinalList1EntryCount = pRefDefaultFinalList1Entries_.size(); this->pRefDefaultFinalList1Entries = pRefDefaultFinalList1Entries_.data();  return *this; }
    VideoEncodeH264VclFrameInfoEXT& setNaluSliceEntryCount(uint32_t naluSliceEntryCount_) {this->naluSliceEntryCount = naluSliceEntryCount_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPNaluSliceEntries(const VideoEncodeH264NaluSliceEXT* pNaluSliceEntries_) {this->pNaluSliceEntries = pNaluSliceEntries_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPNaluSliceEntries(detail::span<const VideoEncodeH264NaluSliceEXT> pNaluSliceEntries_) {this->naluSliceEntryCount = pNaluSliceEntries_.size(); this->pNaluSliceEntries = pNaluSliceEntries_.data();  return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPCurrentPictureInfo(const VideoEncodeH264DpbSlotInfoEXT* pCurrentPictureInfo_) {this->pCurrentPictureInfo = pCurrentPictureInfo_; return *this; }
    VideoEncodeH264VclFrameInfoEXT& setPCurrentPictureInfo(VideoEncodeH264DpbSlotInfoEXT const& pCurrentPictureInfo_) {this->pCurrentPictureInfo = &pCurrentPictureInfo_; return *this; }
};
struct VideoEncodeH264EmitPictureParametersEXT {
    StructureType sType{StructureType::VideoEncodeH264EmitPictureParametersEXT};
    const void* pNext = nullptr;
    uint8_t spsId{0};
    Bool32 emitSpsEnable{0};
    uint32_t ppsIdEntryCount{0};
    const uint8_t* ppsIdEntries = nullptr;
    VideoEncodeH264EmitPictureParametersEXT& setSpsId(uint8_t spsId_) {this->spsId = spsId_; return *this; }
    VideoEncodeH264EmitPictureParametersEXT& setEmitSpsEnable(Bool32 emitSpsEnable_) {this->emitSpsEnable = emitSpsEnable_; return *this; }
    VideoEncodeH264EmitPictureParametersEXT& setPpsIdEntryCount(uint32_t ppsIdEntryCount_) {this->ppsIdEntryCount = ppsIdEntryCount_; return *this; }
    VideoEncodeH264EmitPictureParametersEXT& setPpsIdEntries(const uint8_t* ppsIdEntries_) {this->ppsIdEntries = ppsIdEntries_; return *this; }
    VideoEncodeH264EmitPictureParametersEXT& setPpsIdEntries(detail::span<const uint8_t> ppsIdEntries_) {this->ppsIdEntryCount = ppsIdEntries_.size(); this->ppsIdEntries = ppsIdEntries_.data();  return *this; }
};
struct VideoEncodeH264ProfileEXT {
    StructureType sType{StructureType::VideoEncodeH264ProfileEXT};
    const void* pNext = nullptr;
    StdVideoH264ProfileIdc stdProfileIdc{};
    VideoEncodeH264ProfileEXT& setStdProfileIdc(StdVideoH264ProfileIdc stdProfileIdc_) {this->stdProfileIdc = stdProfileIdc_; return *this; }
};
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
    StructureType sType{StructureType::PhysicalDeviceInheritedViewportScissorFeaturesNV};
    void* pNext = nullptr;
    Bool32 inheritedViewportScissor2D{0};
    PhysicalDeviceInheritedViewportScissorFeaturesNV& setInheritedViewportScissor2D(Bool32 inheritedViewportScissor2D_) {this->inheritedViewportScissor2D = inheritedViewportScissor2D_; return *this; }
};
struct CommandBufferInheritanceViewportScissorInfoNV {
    StructureType sType{StructureType::CommandBufferInheritanceViewportScissorInfoNV};
    const void* pNext = nullptr;
    Bool32 viewportScissor2D{0};
    uint32_t viewportDepthCount{0};
    const Viewport* pViewportDepths = nullptr;
    CommandBufferInheritanceViewportScissorInfoNV& setViewportScissor2D(Bool32 viewportScissor2D_) {this->viewportScissor2D = viewportScissor2D_; return *this; }
    CommandBufferInheritanceViewportScissorInfoNV& setViewportDepthCount(uint32_t viewportDepthCount_) {this->viewportDepthCount = viewportDepthCount_; return *this; }
    CommandBufferInheritanceViewportScissorInfoNV& setPViewportDepths(const Viewport* pViewportDepths_) {this->pViewportDepths = pViewportDepths_; return *this; }
    CommandBufferInheritanceViewportScissorInfoNV& setPViewportDepths(Viewport const& pViewportDepths_) {this->pViewportDepths = &pViewportDepths_; return *this; }
};
struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    StructureType sType{StructureType::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT};
    void* pNext = nullptr;
    Bool32 ycbcr2plane444Formats{0};
    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& setYcbcr2plane444Formats(Bool32 ycbcr2plane444Formats_) {this->ycbcr2plane444Formats = ycbcr2plane444Formats_; return *this; }
};
namespace detail {
using PFN_CreateInstance = Result (*) (const InstanceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Instance* pInstance);
using PFN_DestroyInstance = void (*) (Instance instance, const AllocationCallbacks* pAllocator);
using PFN_EnumeratePhysicalDevices = Result (*) (Instance instance, uint32_t* pPhysicalDeviceCount, PhysicalDevice* pPhysicalDevices);
using PFN_GetDeviceProcAddr = PFN_VoidFunction (*) (Device device, const char* pName);
using PFN_GetInstanceProcAddr = PFN_VoidFunction (*) (Instance instance, const char* pName);
using PFN_GetPhysicalDeviceProperties = void (*) (PhysicalDevice physicalDevice, PhysicalDeviceProperties* pProperties);
using PFN_GetPhysicalDeviceQueueFamilyProperties = void (*) (PhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties* pQueueFamilyProperties);
using PFN_GetPhysicalDeviceMemoryProperties = void (*) (PhysicalDevice physicalDevice, PhysicalDeviceMemoryProperties* pMemoryProperties);
using PFN_GetPhysicalDeviceFeatures = void (*) (PhysicalDevice physicalDevice, PhysicalDeviceFeatures* pFeatures);
using PFN_GetPhysicalDeviceFormatProperties = void (*) (PhysicalDevice physicalDevice, Format format, FormatProperties* pFormatProperties);
using PFN_GetPhysicalDeviceImageFormatProperties = Result (*) (PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ImageFormatProperties* pImageFormatProperties);
using PFN_CreateDevice = Result (*) (PhysicalDevice physicalDevice, const DeviceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Device* pDevice);
using PFN_DestroyDevice = void (*) (Device device, const AllocationCallbacks* pAllocator);
using PFN_EnumerateInstanceVersion = Result (*) (uint32_t* pApiVersion);
using PFN_EnumerateInstanceLayerProperties = Result (*) (uint32_t* pPropertyCount, LayerProperties* pProperties);
using PFN_EnumerateInstanceExtensionProperties = Result (*) (const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties);
using PFN_EnumerateDeviceExtensionProperties = Result (*) (PhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties);
using PFN_GetDeviceQueue = void (*) (Device device, uint32_t queueFamilyIndex, uint32_t queueIndex, Queue* pQueue);
using PFN_QueueSubmit = Result (*) (Queue queue, uint32_t submitCount, const SubmitInfo* pSubmits, Fence fence);
using PFN_QueueWaitIdle = Result (*) (Queue queue);
using PFN_DeviceWaitIdle = Result (*) (Device device);
using PFN_AllocateMemory = Result (*) (Device device, const MemoryAllocateInfo* pAllocateInfo, const AllocationCallbacks* pAllocator, DeviceMemory* pMemory);
using PFN_FreeMemory = void (*) (Device device, DeviceMemory memory, const AllocationCallbacks* pAllocator);
using PFN_MapMemory = Result (*) (Device device, DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags, void** ppData);
using PFN_UnmapMemory = void (*) (Device device, DeviceMemory memory);
using PFN_FlushMappedMemoryRanges = Result (*) (Device device, uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges);
using PFN_InvalidateMappedMemoryRanges = Result (*) (Device device, uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges);
using PFN_GetDeviceMemoryCommitment = void (*) (Device device, DeviceMemory memory, DeviceSize* pCommittedMemoryInBytes);
using PFN_GetBufferMemoryRequirements = void (*) (Device device, Buffer buffer, MemoryRequirements* pMemoryRequirements);
using PFN_BindBufferMemory = Result (*) (Device device, Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset);
using PFN_GetImageMemoryRequirements = void (*) (Device device, Image image, MemoryRequirements* pMemoryRequirements);
using PFN_BindImageMemory = Result (*) (Device device, Image image, DeviceMemory memory, DeviceSize memoryOffset);
using PFN_GetImageSparseMemoryRequirements = void (*) (Device device, Image image, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements* pSparseMemoryRequirements);
using PFN_GetPhysicalDeviceSparseImageFormatProperties = void (*) (PhysicalDevice physicalDevice, Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling, uint32_t* pPropertyCount, SparseImageFormatProperties* pProperties);
using PFN_QueueBindSparse = Result (*) (Queue queue, uint32_t bindInfoCount, const BindSparseInfo* pBindInfo, Fence fence);
using PFN_CreateFence = Result (*) (Device device, const FenceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Fence* pFence);
using PFN_DestroyFence = void (*) (Device device, Fence fence, const AllocationCallbacks* pAllocator);
using PFN_ResetFences = Result (*) (Device device, uint32_t fenceCount, const Fence* pFences);
using PFN_GetFenceStatus = Result (*) (Device device, Fence fence);
using PFN_WaitForFences = Result (*) (Device device, uint32_t fenceCount, const Fence* pFences, Bool32 waitAll, uint64_t timeout);
using PFN_CreateSemaphore = Result (*) (Device device, const SemaphoreCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Semaphore* pSemaphore);
using PFN_DestroySemaphore = void (*) (Device device, Semaphore semaphore, const AllocationCallbacks* pAllocator);
using PFN_CreateEvent = Result (*) (Device device, const EventCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Event* pEvent);
using PFN_DestroyEvent = void (*) (Device device, Event event, const AllocationCallbacks* pAllocator);
using PFN_GetEventStatus = Result (*) (Device device, Event event);
using PFN_SetEvent = Result (*) (Device device, Event event);
using PFN_ResetEvent = Result (*) (Device device, Event event);
using PFN_CreateQueryPool = Result (*) (Device device, const QueryPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, QueryPool* pQueryPool);
using PFN_DestroyQueryPool = void (*) (Device device, QueryPool queryPool, const AllocationCallbacks* pAllocator);
using PFN_GetQueryPoolResults = Result (*) (Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, DeviceSize stride, QueryResultFlags flags);
using PFN_ResetQueryPool = void (*) (Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
using PFN_ResetQueryPoolEXT = PFN_ResetQueryPool;
using PFN_CreateBuffer = Result (*) (Device device, const BufferCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Buffer* pBuffer);
using PFN_DestroyBuffer = void (*) (Device device, Buffer buffer, const AllocationCallbacks* pAllocator);
using PFN_CreateBufferView = Result (*) (Device device, const BufferViewCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, BufferView* pView);
using PFN_DestroyBufferView = void (*) (Device device, BufferView bufferView, const AllocationCallbacks* pAllocator);
using PFN_CreateImage = Result (*) (Device device, const ImageCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Image* pImage);
using PFN_DestroyImage = void (*) (Device device, Image image, const AllocationCallbacks* pAllocator);
using PFN_GetImageSubresourceLayout = void (*) (Device device, Image image, const ImageSubresource* pSubresource, SubresourceLayout* pLayout);
using PFN_CreateImageView = Result (*) (Device device, const ImageViewCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, ImageView* pView);
using PFN_DestroyImageView = void (*) (Device device, ImageView imageView, const AllocationCallbacks* pAllocator);
using PFN_CreateShaderModule = Result (*) (Device device, const ShaderModuleCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, ShaderModule* pShaderModule);
using PFN_DestroyShaderModule = void (*) (Device device, ShaderModule shaderModule, const AllocationCallbacks* pAllocator);
using PFN_CreatePipelineCache = Result (*) (Device device, const PipelineCacheCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, PipelineCache* pPipelineCache);
using PFN_DestroyPipelineCache = void (*) (Device device, PipelineCache pipelineCache, const AllocationCallbacks* pAllocator);
using PFN_GetPipelineCacheData = Result (*) (Device device, PipelineCache pipelineCache, size_t* pDataSize, void* pData);
using PFN_MergePipelineCaches = Result (*) (Device device, PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache* pSrcCaches);
using PFN_CreateGraphicsPipelines = Result (*) (Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines);
using PFN_CreateComputePipelines = Result (*) (Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines);
using PFN_DestroyPipeline = void (*) (Device device, Pipeline pipeline, const AllocationCallbacks* pAllocator);
using PFN_CreatePipelineLayout = Result (*) (Device device, const PipelineLayoutCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, PipelineLayout* pPipelineLayout);
using PFN_DestroyPipelineLayout = void (*) (Device device, PipelineLayout pipelineLayout, const AllocationCallbacks* pAllocator);
using PFN_CreateSampler = Result (*) (Device device, const SamplerCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Sampler* pSampler);
using PFN_DestroySampler = void (*) (Device device, Sampler sampler, const AllocationCallbacks* pAllocator);
using PFN_CreateDescriptorSetLayout = Result (*) (Device device, const DescriptorSetLayoutCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorSetLayout* pSetLayout);
using PFN_DestroyDescriptorSetLayout = void (*) (Device device, DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks* pAllocator);
using PFN_CreateDescriptorPool = Result (*) (Device device, const DescriptorPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorPool* pDescriptorPool);
using PFN_DestroyDescriptorPool = void (*) (Device device, DescriptorPool descriptorPool, const AllocationCallbacks* pAllocator);
using PFN_ResetDescriptorPool = Result (*) (Device device, DescriptorPool descriptorPool, DescriptorPoolResetFlags flags);
using PFN_AllocateDescriptorSets = Result (*) (Device device, const DescriptorSetAllocateInfo* pAllocateInfo, DescriptorSet* pDescriptorSets);
using PFN_FreeDescriptorSets = Result (*) (Device device, DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets);
using PFN_UpdateDescriptorSets = void (*) (Device device, uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet* pDescriptorCopies);
using PFN_CreateFramebuffer = Result (*) (Device device, const FramebufferCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Framebuffer* pFramebuffer);
using PFN_DestroyFramebuffer = void (*) (Device device, Framebuffer framebuffer, const AllocationCallbacks* pAllocator);
using PFN_CreateRenderPass = Result (*) (Device device, const RenderPassCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, RenderPass* pRenderPass);
using PFN_DestroyRenderPass = void (*) (Device device, RenderPass renderPass, const AllocationCallbacks* pAllocator);
using PFN_GetRenderAreaGranularity = void (*) (Device device, RenderPass renderPass, Extent2D* pGranularity);
using PFN_CreateCommandPool = Result (*) (Device device, const CommandPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, CommandPool* pCommandPool);
using PFN_DestroyCommandPool = void (*) (Device device, CommandPool commandPool, const AllocationCallbacks* pAllocator);
using PFN_ResetCommandPool = Result (*) (Device device, CommandPool commandPool, CommandPoolResetFlags flags);
using PFN_AllocateCommandBuffers = Result (*) (Device device, const CommandBufferAllocateInfo* pAllocateInfo, CommandBuffer* pCommandBuffers);
using PFN_FreeCommandBuffers = void (*) (Device device, CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers);
using PFN_BeginCommandBuffer = Result (*) (CommandBuffer commandBuffer, const CommandBufferBeginInfo* pBeginInfo);
using PFN_EndCommandBuffer = Result (*) (CommandBuffer commandBuffer);
using PFN_ResetCommandBuffer = Result (*) (CommandBuffer commandBuffer, CommandBufferResetFlags flags);
using PFN_CmdBindPipeline = void (*) (CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, Pipeline pipeline);
using PFN_CmdSetViewport = void (*) (CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const Viewport* pViewports);
using PFN_CmdSetScissor = void (*) (CommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const Rect2D* pScissors);
using PFN_CmdSetLineWidth = void (*) (CommandBuffer commandBuffer, float lineWidth);
using PFN_CmdSetDepthBias = void (*) (CommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
using PFN_CmdSetBlendConstants = void (*) (CommandBuffer commandBuffer, const float blendConstants[4]);
using PFN_CmdSetDepthBounds = void (*) (CommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
using PFN_CmdSetStencilCompareMask = void (*) (CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t compareMask);
using PFN_CmdSetStencilWriteMask = void (*) (CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t writeMask);
using PFN_CmdSetStencilReference = void (*) (CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t reference);
using PFN_CmdBindDescriptorSets = void (*) (CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
using PFN_CmdBindIndexBuffer = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, IndexType indexType);
using PFN_CmdBindVertexBuffers = void (*) (CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets);
using PFN_CmdDraw = void (*) (CommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
using PFN_CmdDrawIndexed = void (*) (CommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
using PFN_CmdDrawIndirect = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride);
using PFN_CmdDrawIndexedIndirect = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride);
using PFN_CmdDispatch = void (*) (CommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
using PFN_CmdDispatchIndirect = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset);
using PFN_CmdCopyBuffer = void (*) (CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy* pRegions);
using PFN_CmdCopyImage = void (*) (CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy* pRegions);
using PFN_CmdBlitImage = void (*) (CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit* pRegions, Filter filter);
using PFN_CmdCopyBufferToImage = void (*) (CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy* pRegions);
using PFN_CmdCopyImageToBuffer = void (*) (CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy* pRegions);
using PFN_CmdUpdateBuffer = void (*) (CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void* pData);
using PFN_CmdFillBuffer = void (*) (CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data);
using PFN_CmdClearColorImage = void (*) (CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue* pColor, uint32_t rangeCount, const ImageSubresourceRange* pRanges);
using PFN_CmdClearDepthStencilImage = void (*) (CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange* pRanges);
using PFN_CmdClearAttachments = void (*) (CommandBuffer commandBuffer, uint32_t attachmentCount, const ClearAttachment* pAttachments, uint32_t rectCount, const ClearRect* pRects);
using PFN_CmdResolveImage = void (*) (CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve* pRegions);
using PFN_CmdSetEvent = void (*) (CommandBuffer commandBuffer, Event event, PipelineStageFlags stageMask);
using PFN_CmdResetEvent = void (*) (CommandBuffer commandBuffer, Event event, PipelineStageFlags stageMask);
using PFN_CmdWaitEvents = void (*) (CommandBuffer commandBuffer, uint32_t eventCount, const Event* pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier* pImageMemoryBarriers);
using PFN_CmdPipelineBarrier = void (*) (CommandBuffer commandBuffer, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier* pImageMemoryBarriers);
using PFN_CmdBeginQuery = void (*) (CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags);
using PFN_CmdEndQuery = void (*) (CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query);
using PFN_CmdBeginConditionalRenderingEXT = void (*) (CommandBuffer commandBuffer, const ConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin);
using PFN_CmdEndConditionalRenderingEXT = void (*) (CommandBuffer commandBuffer);
using PFN_CmdResetQueryPool = void (*) (CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
using PFN_CmdWriteTimestamp = void (*) (CommandBuffer commandBuffer, PipelineStageFlagBits pipelineStage, QueryPool queryPool, uint32_t query);
using PFN_CmdCopyQueryPoolResults = void (*) (CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags);
using PFN_CmdPushConstants = void (*) (CommandBuffer commandBuffer, PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues);
using PFN_CmdBeginRenderPass = void (*) (CommandBuffer commandBuffer, const RenderPassBeginInfo* pRenderPassBegin, SubpassContents contents);
using PFN_CmdNextSubpass = void (*) (CommandBuffer commandBuffer, SubpassContents contents);
using PFN_CmdEndRenderPass = void (*) (CommandBuffer commandBuffer);
using PFN_CmdExecuteCommands = void (*) (CommandBuffer commandBuffer, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
using PFN_CreateAndroidSurfaceKHR = Result (*) (Instance instance, const AndroidSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
using PFN_GetPhysicalDeviceDisplayPropertiesKHR = Result (*) (PhysicalDevice physicalDevice, uint32_t* pPropertyCount, DisplayPropertiesKHR* pProperties);
using PFN_GetPhysicalDeviceDisplayPlanePropertiesKHR = Result (*) (PhysicalDevice physicalDevice, uint32_t* pPropertyCount, DisplayPlanePropertiesKHR* pProperties);
using PFN_GetDisplayPlaneSupportedDisplaysKHR = Result (*) (PhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, DisplayKHR* pDisplays);
using PFN_GetDisplayModePropertiesKHR = Result (*) (PhysicalDevice physicalDevice, DisplayKHR display, uint32_t* pPropertyCount, DisplayModePropertiesKHR* pProperties);
using PFN_CreateDisplayModeKHR = Result (*) (PhysicalDevice physicalDevice, DisplayKHR display, const DisplayModeCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, DisplayModeKHR* pMode);
using PFN_GetDisplayPlaneCapabilitiesKHR = Result (*) (PhysicalDevice physicalDevice, DisplayModeKHR mode, uint32_t planeIndex, DisplayPlaneCapabilitiesKHR* pCapabilities);
using PFN_CreateDisplayPlaneSurfaceKHR = Result (*) (Instance instance, const DisplaySurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_CreateSharedSwapchainsKHR = Result (*) (Device device, uint32_t swapchainCount, const SwapchainCreateInfoKHR* pCreateInfos, const AllocationCallbacks* pAllocator, SwapchainKHR* pSwapchains);
using PFN_DestroySurfaceKHR = void (*) (Instance instance, SurfaceKHR surface, const AllocationCallbacks* pAllocator);
using PFN_GetPhysicalDeviceSurfaceSupportKHR = Result (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, SurfaceKHR surface, Bool32* pSupported);
using PFN_GetPhysicalDeviceSurfaceCapabilitiesKHR = Result (*) (PhysicalDevice physicalDevice, SurfaceKHR surface, SurfaceCapabilitiesKHR* pSurfaceCapabilities);
using PFN_GetPhysicalDeviceSurfaceFormatsKHR = Result (*) (PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t* pSurfaceFormatCount, SurfaceFormatKHR* pSurfaceFormats);
using PFN_GetPhysicalDeviceSurfacePresentModesKHR = Result (*) (PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t* pPresentModeCount, PresentModeKHR* pPresentModes);
using PFN_CreateSwapchainKHR = Result (*) (Device device, const SwapchainCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SwapchainKHR* pSwapchain);
using PFN_DestroySwapchainKHR = void (*) (Device device, SwapchainKHR swapchain, const AllocationCallbacks* pAllocator);
using PFN_GetSwapchainImagesKHR = Result (*) (Device device, SwapchainKHR swapchain, uint32_t* pSwapchainImageCount, Image* pSwapchainImages);
using PFN_AcquireNextImageKHR = Result (*) (Device device, SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, uint32_t* pImageIndex);
using PFN_QueuePresentKHR = Result (*) (Queue queue, const PresentInfoKHR* pPresentInfo);
#if defined(VK_USE_PLATFORM_VI_NN)
using PFN_CreateViSurfaceNN = Result (*) (Instance instance, const ViSurfaceCreateInfoNN* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_VI_NN)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
using PFN_CreateWaylandSurfaceKHR = Result (*) (Instance instance, const WaylandSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceWaylandPresentationSupportKHR = Bool32 (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, wl_display* display);
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_CreateWin32SurfaceKHR = Result (*) (Instance instance, const Win32SurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceWin32PresentationSupportKHR = Bool32 (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_XLIB_KHR)
using PFN_CreateXlibSurfaceKHR = Result (*) (Instance instance, const XlibSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceXlibPresentationSupportKHR = Bool32 (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
using PFN_CreateXcbSurfaceKHR = Result (*) (Instance instance, const XcbSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceXcbPresentationSupportKHR = Bool32 (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
using PFN_CreateDirectFBSurfaceEXT = Result (*) (Instance instance, const DirectFBSurfaceCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceDirectFBPresentationSupportEXT = Bool32 (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB* dfb);
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_FUCHSIA)
using PFN_CreateImagePipeSurfaceFUCHSIA = Result (*) (Instance instance, const ImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_GGP)
using PFN_CreateStreamDescriptorSurfaceGGP = Result (*) (Instance instance, const StreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_GGP)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
using PFN_CreateScreenSurfaceQNX = Result (*) (Instance instance, const ScreenSurfaceCreateInfoQNX* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceScreenPresentationSupportQNX = Bool32 (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, _screen_window* window);
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
using PFN_CreateDebugReportCallbackEXT = Result (*) (Instance instance, const DebugReportCallbackCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, DebugReportCallbackEXT* pCallback);
using PFN_DestroyDebugReportCallbackEXT = void (*) (Instance instance, DebugReportCallbackEXT callback, const AllocationCallbacks* pAllocator);
using PFN_DebugReportMessageEXT = void (*) (Instance instance, DebugReportFlagsEXT flags, DebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage);
using PFN_DebugMarkerSetObjectNameEXT = Result (*) (Device device, const DebugMarkerObjectNameInfoEXT* pNameInfo);
using PFN_DebugMarkerSetObjectTagEXT = Result (*) (Device device, const DebugMarkerObjectTagInfoEXT* pTagInfo);
using PFN_CmdDebugMarkerBeginEXT = void (*) (CommandBuffer commandBuffer, const DebugMarkerMarkerInfoEXT* pMarkerInfo);
using PFN_CmdDebugMarkerEndEXT = void (*) (CommandBuffer commandBuffer);
using PFN_CmdDebugMarkerInsertEXT = void (*) (CommandBuffer commandBuffer, const DebugMarkerMarkerInfoEXT* pMarkerInfo);
using PFN_GetPhysicalDeviceExternalImageFormatPropertiesNV = Result (*) (PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ExternalMemoryHandleTypeFlagsNV externalHandleType, ExternalImageFormatPropertiesNV* pExternalImageFormatProperties);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetMemoryWin32HandleNV = Result (*) (Device device, DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_CmdExecuteGeneratedCommandsNV = void (*) (CommandBuffer commandBuffer, Bool32 isPreprocessed, const GeneratedCommandsInfoNV* pGeneratedCommandsInfo);
using PFN_CmdPreprocessGeneratedCommandsNV = void (*) (CommandBuffer commandBuffer, const GeneratedCommandsInfoNV* pGeneratedCommandsInfo);
using PFN_CmdBindPipelineShaderGroupNV = void (*) (CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, Pipeline pipeline, uint32_t groupIndex);
using PFN_GetGeneratedCommandsMemoryRequirementsNV = void (*) (Device device, const GeneratedCommandsMemoryRequirementsInfoNV* pInfo, MemoryRequirements2* pMemoryRequirements);
using PFN_CreateIndirectCommandsLayoutNV = Result (*) (Device device, const IndirectCommandsLayoutCreateInfoNV* pCreateInfo, const AllocationCallbacks* pAllocator, IndirectCommandsLayoutNV* pIndirectCommandsLayout);
using PFN_DestroyIndirectCommandsLayoutNV = void (*) (Device device, IndirectCommandsLayoutNV indirectCommandsLayout, const AllocationCallbacks* pAllocator);
using PFN_GetPhysicalDeviceFeatures2 = void (*) (PhysicalDevice physicalDevice, PhysicalDeviceFeatures2* pFeatures);
using PFN_GetPhysicalDeviceFeatures2KHR = PFN_GetPhysicalDeviceFeatures2;
using PFN_GetPhysicalDeviceProperties2 = void (*) (PhysicalDevice physicalDevice, PhysicalDeviceProperties2* pProperties);
using PFN_GetPhysicalDeviceProperties2KHR = PFN_GetPhysicalDeviceProperties2;
using PFN_GetPhysicalDeviceFormatProperties2 = void (*) (PhysicalDevice physicalDevice, Format format, FormatProperties2* pFormatProperties);
using PFN_GetPhysicalDeviceFormatProperties2KHR = PFN_GetPhysicalDeviceFormatProperties2;
using PFN_GetPhysicalDeviceImageFormatProperties2 = Result (*) (PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2* pImageFormatInfo, ImageFormatProperties2* pImageFormatProperties);
using PFN_GetPhysicalDeviceImageFormatProperties2KHR = PFN_GetPhysicalDeviceImageFormatProperties2;
using PFN_GetPhysicalDeviceQueueFamilyProperties2 = void (*) (PhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties);
using PFN_GetPhysicalDeviceQueueFamilyProperties2KHR = PFN_GetPhysicalDeviceQueueFamilyProperties2;
using PFN_GetPhysicalDeviceMemoryProperties2 = void (*) (PhysicalDevice physicalDevice, PhysicalDeviceMemoryProperties2* pMemoryProperties);
using PFN_GetPhysicalDeviceMemoryProperties2KHR = PFN_GetPhysicalDeviceMemoryProperties2;
using PFN_GetPhysicalDeviceSparseImageFormatProperties2 = void (*) (PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties);
using PFN_GetPhysicalDeviceSparseImageFormatProperties2KHR = PFN_GetPhysicalDeviceSparseImageFormatProperties2;
using PFN_CmdPushDescriptorSetKHR = void (*) (CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites);
using PFN_TrimCommandPool = void (*) (Device device, CommandPool commandPool, CommandPoolTrimFlags flags);
using PFN_TrimCommandPoolKHR = PFN_TrimCommandPool;
using PFN_GetPhysicalDeviceExternalBufferProperties = void (*) (PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo* pExternalBufferInfo, ExternalBufferProperties* pExternalBufferProperties);
using PFN_GetPhysicalDeviceExternalBufferPropertiesKHR = PFN_GetPhysicalDeviceExternalBufferProperties;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetMemoryWin32HandleKHR = Result (*) (Device device, const MemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
using PFN_GetMemoryWin32HandlePropertiesKHR = Result (*) (Device device, ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, MemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetMemoryFdKHR = Result (*) (Device device, const MemoryGetFdInfoKHR* pGetFdInfo, int* pFd);
using PFN_GetMemoryFdPropertiesKHR = Result (*) (Device device, ExternalMemoryHandleTypeFlagBits handleType, int fd, MemoryFdPropertiesKHR* pMemoryFdProperties);
#if defined(VK_USE_PLATFORM_FUCHSIA)
using PFN_GetMemoryZirconHandleFUCHSIA = Result (*) (Device device, const MemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle);
using PFN_GetMemoryZirconHandlePropertiesFUCHSIA = Result (*) (Device device, ExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, MemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties);
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
using PFN_GetPhysicalDeviceExternalSemaphoreProperties = void (*) (PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties);
using PFN_GetPhysicalDeviceExternalSemaphorePropertiesKHR = PFN_GetPhysicalDeviceExternalSemaphoreProperties;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetSemaphoreWin32HandleKHR = Result (*) (Device device, const SemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
using PFN_ImportSemaphoreWin32HandleKHR = Result (*) (Device device, const ImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetSemaphoreFdKHR = Result (*) (Device device, const SemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);
using PFN_ImportSemaphoreFdKHR = Result (*) (Device device, const ImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
#if defined(VK_USE_PLATFORM_FUCHSIA)
using PFN_GetSemaphoreZirconHandleFUCHSIA = Result (*) (Device device, const SemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle);
using PFN_ImportSemaphoreZirconHandleFUCHSIA = Result (*) (Device device, const ImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo);
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
using PFN_GetPhysicalDeviceExternalFenceProperties = void (*) (PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo* pExternalFenceInfo, ExternalFenceProperties* pExternalFenceProperties);
using PFN_GetPhysicalDeviceExternalFencePropertiesKHR = PFN_GetPhysicalDeviceExternalFenceProperties;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetFenceWin32HandleKHR = Result (*) (Device device, const FenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
using PFN_ImportFenceWin32HandleKHR = Result (*) (Device device, const ImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetFenceFdKHR = Result (*) (Device device, const FenceGetFdInfoKHR* pGetFdInfo, int* pFd);
using PFN_ImportFenceFdKHR = Result (*) (Device device, const ImportFenceFdInfoKHR* pImportFenceFdInfo);
using PFN_ReleaseDisplayEXT = Result (*) (PhysicalDevice physicalDevice, DisplayKHR display);
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
using PFN_AcquireXlibDisplayEXT = Result (*) (PhysicalDevice physicalDevice, Display* dpy, DisplayKHR display);
using PFN_GetRandROutputDisplayEXT = Result (*) (PhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, DisplayKHR* pDisplay);
#endif // defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_AcquireWinrtDisplayNV = Result (*) (PhysicalDevice physicalDevice, DisplayKHR display);
using PFN_GetWinrtDisplayNV = Result (*) (PhysicalDevice physicalDevice, uint32_t deviceRelativeId, DisplayKHR* pDisplay);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_DisplayPowerControlEXT = Result (*) (Device device, DisplayKHR display, const DisplayPowerInfoEXT* pDisplayPowerInfo);
using PFN_RegisterDeviceEventEXT = Result (*) (Device device, const DeviceEventInfoEXT* pDeviceEventInfo, const AllocationCallbacks* pAllocator, Fence* pFence);
using PFN_RegisterDisplayEventEXT = Result (*) (Device device, DisplayKHR display, const DisplayEventInfoEXT* pDisplayEventInfo, const AllocationCallbacks* pAllocator, Fence* pFence);
using PFN_GetSwapchainCounterEXT = Result (*) (Device device, SwapchainKHR swapchain, SurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue);
using PFN_GetPhysicalDeviceSurfaceCapabilities2EXT = Result (*) (PhysicalDevice physicalDevice, SurfaceKHR surface, SurfaceCapabilities2EXT* pSurfaceCapabilities);
using PFN_EnumeratePhysicalDeviceGroups = Result (*) (Instance instance, uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
using PFN_EnumeratePhysicalDeviceGroupsKHR = PFN_EnumeratePhysicalDeviceGroups;
using PFN_GetDeviceGroupPeerMemoryFeatures = void (*) (Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeatureFlags* pPeerMemoryFeatures);
using PFN_GetDeviceGroupPeerMemoryFeaturesKHR = PFN_GetDeviceGroupPeerMemoryFeatures;
using PFN_BindBufferMemory2 = Result (*) (Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos);
using PFN_BindBufferMemory2KHR = PFN_BindBufferMemory2;
using PFN_BindImageMemory2 = Result (*) (Device device, uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos);
using PFN_BindImageMemory2KHR = PFN_BindImageMemory2;
using PFN_CmdSetDeviceMask = void (*) (CommandBuffer commandBuffer, uint32_t deviceMask);
using PFN_CmdSetDeviceMaskKHR = PFN_CmdSetDeviceMask;
using PFN_GetDeviceGroupPresentCapabilitiesKHR = Result (*) (Device device, DeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities);
using PFN_GetDeviceGroupSurfacePresentModesKHR = Result (*) (Device device, SurfaceKHR surface, DeviceGroupPresentModeFlagsKHR* pModes);
using PFN_AcquireNextImage2KHR = Result (*) (Device device, const AcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex);
using PFN_CmdDispatchBase = void (*) (CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
using PFN_CmdDispatchBaseKHR = PFN_CmdDispatchBase;
using PFN_GetPhysicalDevicePresentRectanglesKHR = Result (*) (PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t* pRectCount, Rect2D* pRects);
using PFN_CreateDescriptorUpdateTemplate = Result (*) (Device device, const DescriptorUpdateTemplateCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorUpdateTemplate* pDescriptorUpdateTemplate);
using PFN_CreateDescriptorUpdateTemplateKHR = PFN_CreateDescriptorUpdateTemplate;
using PFN_DestroyDescriptorUpdateTemplate = void (*) (Device device, DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator);
using PFN_DestroyDescriptorUpdateTemplateKHR = PFN_DestroyDescriptorUpdateTemplate;
using PFN_UpdateDescriptorSetWithTemplate = void (*) (Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData);
using PFN_UpdateDescriptorSetWithTemplateKHR = PFN_UpdateDescriptorSetWithTemplate;
using PFN_CmdPushDescriptorSetWithTemplateKHR = void (*) (CommandBuffer commandBuffer, DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData);
using PFN_SetHdrMetadataEXT = void (*) (Device device, uint32_t swapchainCount, const SwapchainKHR* pSwapchains, const HdrMetadataEXT* pMetadata);
using PFN_GetSwapchainStatusKHR = Result (*) (Device device, SwapchainKHR swapchain);
using PFN_GetRefreshCycleDurationGOOGLE = Result (*) (Device device, SwapchainKHR swapchain, RefreshCycleDurationGOOGLE* pDisplayTimingProperties);
using PFN_GetPastPresentationTimingGOOGLE = Result (*) (Device device, SwapchainKHR swapchain, uint32_t* pPresentationTimingCount, PastPresentationTimingGOOGLE* pPresentationTimings);
#if defined(VK_USE_PLATFORM_IOS_MVK)
using PFN_CreateIOSSurfaceMVK = Result (*) (Instance instance, const IOSSurfaceCreateInfoMVK* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
using PFN_CreateMacOSSurfaceMVK = Result (*) (Instance instance, const MacOSSurfaceCreateInfoMVK* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
#if defined(VK_USE_PLATFORM_METAL_EXT)
using PFN_CreateMetalSurfaceEXT = Result (*) (Instance instance, const MetalSurfaceCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
using PFN_CmdSetViewportWScalingNV = void (*) (CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const ViewportWScalingNV* pViewportWScalings);
using PFN_CmdSetDiscardRectangleEXT = void (*) (CommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const Rect2D* pDiscardRectangles);
using PFN_CmdSetSampleLocationsEXT = void (*) (CommandBuffer commandBuffer, const SampleLocationsInfoEXT* pSampleLocationsInfo);
using PFN_GetPhysicalDeviceMultisamplePropertiesEXT = void (*) (PhysicalDevice physicalDevice, SampleCountFlagBits samples, MultisamplePropertiesEXT* pMultisampleProperties);
using PFN_GetPhysicalDeviceSurfaceCapabilities2KHR = Result (*) (PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, SurfaceCapabilities2KHR* pSurfaceCapabilities);
using PFN_GetPhysicalDeviceSurfaceFormats2KHR = Result (*) (PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, SurfaceFormat2KHR* pSurfaceFormats);
using PFN_GetPhysicalDeviceDisplayProperties2KHR = Result (*) (PhysicalDevice physicalDevice, uint32_t* pPropertyCount, DisplayProperties2KHR* pProperties);
using PFN_GetPhysicalDeviceDisplayPlaneProperties2KHR = Result (*) (PhysicalDevice physicalDevice, uint32_t* pPropertyCount, DisplayPlaneProperties2KHR* pProperties);
using PFN_GetDisplayModeProperties2KHR = Result (*) (PhysicalDevice physicalDevice, DisplayKHR display, uint32_t* pPropertyCount, DisplayModeProperties2KHR* pProperties);
using PFN_GetDisplayPlaneCapabilities2KHR = Result (*) (PhysicalDevice physicalDevice, const DisplayPlaneInfo2KHR* pDisplayPlaneInfo, DisplayPlaneCapabilities2KHR* pCapabilities);
using PFN_GetBufferMemoryRequirements2 = void (*) (Device device, const BufferMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements);
using PFN_GetBufferMemoryRequirements2KHR = PFN_GetBufferMemoryRequirements2;
using PFN_GetImageMemoryRequirements2 = void (*) (Device device, const ImageMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements);
using PFN_GetImageMemoryRequirements2KHR = PFN_GetImageMemoryRequirements2;
using PFN_GetImageSparseMemoryRequirements2 = void (*) (Device device, const ImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements);
using PFN_GetImageSparseMemoryRequirements2KHR = PFN_GetImageSparseMemoryRequirements2;
using PFN_CreateSamplerYcbcrConversion = Result (*) (Device device, const SamplerYcbcrConversionCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, SamplerYcbcrConversion* pYcbcrConversion);
using PFN_CreateSamplerYcbcrConversionKHR = PFN_CreateSamplerYcbcrConversion;
using PFN_DestroySamplerYcbcrConversion = void (*) (Device device, SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator);
using PFN_DestroySamplerYcbcrConversionKHR = PFN_DestroySamplerYcbcrConversion;
using PFN_GetDeviceQueue2 = void (*) (Device device, const DeviceQueueInfo2* pQueueInfo, Queue* pQueue);
using PFN_CreateValidationCacheEXT = Result (*) (Device device, const ValidationCacheCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, ValidationCacheEXT* pValidationCache);
using PFN_DestroyValidationCacheEXT = void (*) (Device device, ValidationCacheEXT validationCache, const AllocationCallbacks* pAllocator);
using PFN_GetValidationCacheDataEXT = Result (*) (Device device, ValidationCacheEXT validationCache, size_t* pDataSize, void* pData);
using PFN_MergeValidationCachesEXT = Result (*) (Device device, ValidationCacheEXT dstCache, uint32_t srcCacheCount, const ValidationCacheEXT* pSrcCaches);
using PFN_GetDescriptorSetLayoutSupport = void (*) (Device device, const DescriptorSetLayoutCreateInfo* pCreateInfo, DescriptorSetLayoutSupport* pSupport);
using PFN_GetDescriptorSetLayoutSupportKHR = PFN_GetDescriptorSetLayoutSupport;
using PFN_GetShaderInfoAMD = Result (*) (Device device, Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo);
using PFN_SetLocalDimmingAMD = void (*) (Device device, SwapchainKHR swapChain, Bool32 localDimmingEnable);
using PFN_GetPhysicalDeviceCalibrateableTimeDomainsEXT = Result (*) (PhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, TimeDomainEXT* pTimeDomains);
using PFN_GetCalibratedTimestampsEXT = Result (*) (Device device, uint32_t timestampCount, const CalibratedTimestampInfoEXT* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation);
using PFN_SetDebugUtilsObjectNameEXT = Result (*) (Device device, const DebugUtilsObjectNameInfoEXT* pNameInfo);
using PFN_SetDebugUtilsObjectTagEXT = Result (*) (Device device, const DebugUtilsObjectTagInfoEXT* pTagInfo);
using PFN_QueueBeginDebugUtilsLabelEXT = void (*) (Queue queue, const DebugUtilsLabelEXT* pLabelInfo);
using PFN_QueueEndDebugUtilsLabelEXT = void (*) (Queue queue);
using PFN_QueueInsertDebugUtilsLabelEXT = void (*) (Queue queue, const DebugUtilsLabelEXT* pLabelInfo);
using PFN_CmdBeginDebugUtilsLabelEXT = void (*) (CommandBuffer commandBuffer, const DebugUtilsLabelEXT* pLabelInfo);
using PFN_CmdEndDebugUtilsLabelEXT = void (*) (CommandBuffer commandBuffer);
using PFN_CmdInsertDebugUtilsLabelEXT = void (*) (CommandBuffer commandBuffer, const DebugUtilsLabelEXT* pLabelInfo);
using PFN_CreateDebugUtilsMessengerEXT = Result (*) (Instance instance, const DebugUtilsMessengerCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, DebugUtilsMessengerEXT* pMessenger);
using PFN_DestroyDebugUtilsMessengerEXT = void (*) (Instance instance, DebugUtilsMessengerEXT messenger, const AllocationCallbacks* pAllocator);
using PFN_SubmitDebugUtilsMessageEXT = void (*) (Instance instance, DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT* pCallbackData);
using PFN_GetMemoryHostPointerPropertiesEXT = Result (*) (Device device, ExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, MemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties);
using PFN_CmdWriteBufferMarkerAMD = void (*) (CommandBuffer commandBuffer, PipelineStageFlagBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker);
using PFN_CreateRenderPass2 = Result (*) (Device device, const RenderPassCreateInfo2* pCreateInfo, const AllocationCallbacks* pAllocator, RenderPass* pRenderPass);
using PFN_CreateRenderPass2KHR = PFN_CreateRenderPass2;
using PFN_CmdBeginRenderPass2 = void (*) (CommandBuffer commandBuffer, const RenderPassBeginInfo* pRenderPassBegin, const SubpassBeginInfo* pSubpassBeginInfo);
using PFN_CmdBeginRenderPass2KHR = PFN_CmdBeginRenderPass2;
using PFN_CmdNextSubpass2 = void (*) (CommandBuffer commandBuffer, const SubpassBeginInfo* pSubpassBeginInfo, const SubpassEndInfo* pSubpassEndInfo);
using PFN_CmdNextSubpass2KHR = PFN_CmdNextSubpass2;
using PFN_CmdEndRenderPass2 = void (*) (CommandBuffer commandBuffer, const SubpassEndInfo* pSubpassEndInfo);
using PFN_CmdEndRenderPass2KHR = PFN_CmdEndRenderPass2;
using PFN_GetSemaphoreCounterValue = Result (*) (Device device, Semaphore semaphore, uint64_t* pValue);
using PFN_GetSemaphoreCounterValueKHR = PFN_GetSemaphoreCounterValue;
using PFN_WaitSemaphores = Result (*) (Device device, const SemaphoreWaitInfo* pWaitInfo, uint64_t timeout);
using PFN_WaitSemaphoresKHR = PFN_WaitSemaphores;
using PFN_SignalSemaphore = Result (*) (Device device, const SemaphoreSignalInfo* pSignalInfo);
using PFN_SignalSemaphoreKHR = PFN_SignalSemaphore;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
using PFN_GetAndroidHardwareBufferPropertiesANDROID = Result (*) (Device device, const AHardwareBuffer* buffer, AndroidHardwareBufferPropertiesANDROID* pProperties);
using PFN_GetMemoryAndroidHardwareBufferANDROID = Result (*) (Device device, const MemoryGetAndroidHardwareBufferInfoANDROID* pInfo, AHardwareBuffer** pBuffer);
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
using PFN_CmdDrawIndirectCount = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
using PFN_CmdDrawIndirectCountKHR = PFN_CmdDrawIndirectCount;
using PFN_CmdDrawIndirectCountAMD = PFN_CmdDrawIndirectCount;
using PFN_CmdDrawIndexedIndirectCount = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
using PFN_CmdDrawIndexedIndirectCountKHR = PFN_CmdDrawIndexedIndirectCount;
using PFN_CmdDrawIndexedIndirectCountAMD = PFN_CmdDrawIndexedIndirectCount;
using PFN_CmdSetCheckpointNV = void (*) (CommandBuffer commandBuffer, const void* pCheckpointMarker);
using PFN_GetQueueCheckpointDataNV = void (*) (Queue queue, uint32_t* pCheckpointDataCount, CheckpointDataNV* pCheckpointData);
using PFN_CmdBindTransformFeedbackBuffersEXT = void (*) (CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, const DeviceSize* pSizes);
using PFN_CmdBeginTransformFeedbackEXT = void (*) (CommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const Buffer* pCounterBuffers, const DeviceSize* pCounterBufferOffsets);
using PFN_CmdEndTransformFeedbackEXT = void (*) (CommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const Buffer* pCounterBuffers, const DeviceSize* pCounterBufferOffsets);
using PFN_CmdBeginQueryIndexedEXT = void (*) (CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags, uint32_t index);
using PFN_CmdEndQueryIndexedEXT = void (*) (CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, uint32_t index);
using PFN_CmdDrawIndirectByteCountEXT = void (*) (CommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, Buffer counterBuffer, DeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride);
using PFN_CmdSetExclusiveScissorNV = void (*) (CommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const Rect2D* pExclusiveScissors);
using PFN_CmdBindShadingRateImageNV = void (*) (CommandBuffer commandBuffer, ImageView imageView, ImageLayout imageLayout);
using PFN_CmdSetViewportShadingRatePaletteNV = void (*) (CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const ShadingRatePaletteNV* pShadingRatePalettes);
using PFN_CmdSetCoarseSampleOrderNV = void (*) (CommandBuffer commandBuffer, CoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const CoarseSampleOrderCustomNV* pCustomSampleOrders);
using PFN_CmdDrawMeshTasksNV = void (*) (CommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask);
using PFN_CmdDrawMeshTasksIndirectNV = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride);
using PFN_CmdDrawMeshTasksIndirectCountNV = void (*) (CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
using PFN_CompileDeferredNV = Result (*) (Device device, Pipeline pipeline, uint32_t shader);
using PFN_CreateAccelerationStructureNV = Result (*) (Device device, const AccelerationStructureCreateInfoNV* pCreateInfo, const AllocationCallbacks* pAllocator, AccelerationStructureNV* pAccelerationStructure);
using PFN_DestroyAccelerationStructureKHR = void (*) (Device device, AccelerationStructureKHR accelerationStructure, const AllocationCallbacks* pAllocator);
using PFN_DestroyAccelerationStructureNV = void (*) (Device device, AccelerationStructureNV accelerationStructure, const AllocationCallbacks* pAllocator);
using PFN_GetAccelerationStructureMemoryRequirementsNV = void (*) (Device device, const AccelerationStructureMemoryRequirementsInfoNV* pInfo, MemoryRequirements2KHR* pMemoryRequirements);
using PFN_BindAccelerationStructureMemoryNV = Result (*) (Device device, uint32_t bindInfoCount, const BindAccelerationStructureMemoryInfoNV* pBindInfos);
using PFN_CmdCopyAccelerationStructureNV = void (*) (CommandBuffer commandBuffer, AccelerationStructureNV dst, AccelerationStructureNV src, CopyAccelerationStructureModeKHR mode);
using PFN_CmdCopyAccelerationStructureKHR = void (*) (CommandBuffer commandBuffer, const CopyAccelerationStructureInfoKHR* pInfo);
using PFN_CopyAccelerationStructureKHR = Result (*) (Device device, DeferredOperationKHR deferredOperation, const CopyAccelerationStructureInfoKHR* pInfo);
using PFN_CmdCopyAccelerationStructureToMemoryKHR = void (*) (CommandBuffer commandBuffer, const CopyAccelerationStructureToMemoryInfoKHR* pInfo);
using PFN_CopyAccelerationStructureToMemoryKHR = Result (*) (Device device, DeferredOperationKHR deferredOperation, const CopyAccelerationStructureToMemoryInfoKHR* pInfo);
using PFN_CmdCopyMemoryToAccelerationStructureKHR = void (*) (CommandBuffer commandBuffer, const CopyMemoryToAccelerationStructureInfoKHR* pInfo);
using PFN_CopyMemoryToAccelerationStructureKHR = Result (*) (Device device, DeferredOperationKHR deferredOperation, const CopyMemoryToAccelerationStructureInfoKHR* pInfo);
using PFN_CmdWriteAccelerationStructuresPropertiesKHR = void (*) (CommandBuffer commandBuffer, uint32_t accelerationStructureCount, const AccelerationStructureKHR* pAccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery);
using PFN_CmdWriteAccelerationStructuresPropertiesNV = void (*) (CommandBuffer commandBuffer, uint32_t accelerationStructureCount, const AccelerationStructureNV* pAccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery);
using PFN_CmdBuildAccelerationStructureNV = void (*) (CommandBuffer commandBuffer, const AccelerationStructureInfoNV* pInfo, Buffer instanceData, DeviceSize instanceOffset, Bool32 update, AccelerationStructureNV dst, AccelerationStructureNV src, Buffer scratch, DeviceSize scratchOffset);
using PFN_WriteAccelerationStructuresPropertiesKHR = Result (*) (Device device, uint32_t accelerationStructureCount, const AccelerationStructureKHR* pAccelerationStructures, QueryType queryType, size_t dataSize, void* pData, size_t stride);
using PFN_CmdTraceRaysKHR = void (*) (CommandBuffer commandBuffer, const StridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const StridedDeviceAddressRegionKHR* pMissShaderBindingTable, const StridedDeviceAddressRegionKHR* pHitShaderBindingTable, const StridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth);
using PFN_CmdTraceRaysNV = void (*) (CommandBuffer commandBuffer, Buffer raygenShaderBindingTableBuffer, DeviceSize raygenShaderBindingOffset, Buffer missShaderBindingTableBuffer, DeviceSize missShaderBindingOffset, DeviceSize missShaderBindingStride, Buffer hitShaderBindingTableBuffer, DeviceSize hitShaderBindingOffset, DeviceSize hitShaderBindingStride, Buffer callableShaderBindingTableBuffer, DeviceSize callableShaderBindingOffset, DeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth);
using PFN_GetRayTracingShaderGroupHandlesKHR = Result (*) (Device device, Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData);
using PFN_GetRayTracingShaderGroupHandlesNV = PFN_GetRayTracingShaderGroupHandlesKHR;
using PFN_GetRayTracingCaptureReplayShaderGroupHandlesKHR = Result (*) (Device device, Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData);
using PFN_GetAccelerationStructureHandleNV = Result (*) (Device device, AccelerationStructureNV accelerationStructure, size_t dataSize, void* pData);
using PFN_CreateRayTracingPipelinesNV = Result (*) (Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const RayTracingPipelineCreateInfoNV* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines);
using PFN_CreateRayTracingPipelinesKHR = Result (*) (Device device, DeferredOperationKHR deferredOperation, PipelineCache pipelineCache, uint32_t createInfoCount, const RayTracingPipelineCreateInfoKHR* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines);
using PFN_GetPhysicalDeviceCooperativeMatrixPropertiesNV = Result (*) (PhysicalDevice physicalDevice, uint32_t* pPropertyCount, CooperativeMatrixPropertiesNV* pProperties);
using PFN_CmdTraceRaysIndirectKHR = void (*) (CommandBuffer commandBuffer, const StridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const StridedDeviceAddressRegionKHR* pMissShaderBindingTable, const StridedDeviceAddressRegionKHR* pHitShaderBindingTable, const StridedDeviceAddressRegionKHR* pCallableShaderBindingTable, DeviceAddress indirectDeviceAddress);
using PFN_GetDeviceAccelerationStructureCompatibilityKHR = void (*) (Device device, const AccelerationStructureVersionInfoKHR* pVersionInfo, AccelerationStructureCompatibilityKHR* pCompatibility);
using PFN_GetRayTracingShaderGroupStackSizeKHR = DeviceSize (*) (Device device, Pipeline pipeline, uint32_t group, ShaderGroupShaderKHR groupShader);
using PFN_CmdSetRayTracingPipelineStackSizeKHR = void (*) (CommandBuffer commandBuffer, uint32_t pipelineStackSize);
using PFN_GetImageViewHandleNVX = uint32_t (*) (Device device, const ImageViewHandleInfoNVX* pInfo);
using PFN_GetImageViewAddressNVX = Result (*) (Device device, ImageView imageView, ImageViewAddressPropertiesNVX* pProperties);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_GetPhysicalDeviceSurfacePresentModes2EXT = Result (*) (PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, PresentModeKHR* pPresentModes);
using PFN_GetDeviceGroupSurfacePresentModes2EXT = Result (*) (Device device, const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, DeviceGroupPresentModeFlagsKHR* pModes);
using PFN_AcquireFullScreenExclusiveModeEXT = Result (*) (Device device, SwapchainKHR swapchain);
using PFN_ReleaseFullScreenExclusiveModeEXT = Result (*) (Device device, SwapchainKHR swapchain);
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
using PFN_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = Result (*) (PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, PerformanceCounterKHR* pCounters, PerformanceCounterDescriptionKHR* pCounterDescriptions);
using PFN_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = void (*) (PhysicalDevice physicalDevice, const QueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses);
using PFN_AcquireProfilingLockKHR = Result (*) (Device device, const AcquireProfilingLockInfoKHR* pInfo);
using PFN_ReleaseProfilingLockKHR = void (*) (Device device);
using PFN_GetImageDrmFormatModifierPropertiesEXT = Result (*) (Device device, Image image, ImageDrmFormatModifierPropertiesEXT* pProperties);
using PFN_GetBufferOpaqueCaptureAddress = uint64_t (*) (Device device, const BufferDeviceAddressInfo* pInfo);
using PFN_GetBufferOpaqueCaptureAddressKHR = PFN_GetBufferOpaqueCaptureAddress;
using PFN_GetBufferDeviceAddress = DeviceAddress (*) (Device device, const BufferDeviceAddressInfo* pInfo);
using PFN_GetBufferDeviceAddressKHR = PFN_GetBufferDeviceAddress;
using PFN_GetBufferDeviceAddressEXT = PFN_GetBufferDeviceAddress;
using PFN_CreateHeadlessSurfaceEXT = Result (*) (Instance instance, const HeadlessSurfaceCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface);
using PFN_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = Result (*) (PhysicalDevice physicalDevice, uint32_t* pCombinationCount, FramebufferMixedSamplesCombinationNV* pCombinations);
using PFN_InitializePerformanceApiINTEL = Result (*) (Device device, const InitializePerformanceApiInfoINTEL* pInitializeInfo);
using PFN_UninitializePerformanceApiINTEL = void (*) (Device device);
using PFN_CmdSetPerformanceMarkerINTEL = Result (*) (CommandBuffer commandBuffer, const PerformanceMarkerInfoINTEL* pMarkerInfo);
using PFN_CmdSetPerformanceStreamMarkerINTEL = Result (*) (CommandBuffer commandBuffer, const PerformanceStreamMarkerInfoINTEL* pMarkerInfo);
using PFN_CmdSetPerformanceOverrideINTEL = Result (*) (CommandBuffer commandBuffer, const PerformanceOverrideInfoINTEL* pOverrideInfo);
using PFN_AcquirePerformanceConfigurationINTEL = Result (*) (Device device, const PerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, PerformanceConfigurationINTEL* pConfiguration);
using PFN_ReleasePerformanceConfigurationINTEL = Result (*) (Device device, PerformanceConfigurationINTEL configuration);
using PFN_QueueSetPerformanceConfigurationINTEL = Result (*) (Queue queue, PerformanceConfigurationINTEL configuration);
using PFN_GetPerformanceParameterINTEL = Result (*) (Device device, PerformanceParameterTypeINTEL parameter, PerformanceValueINTEL* pValue);
using PFN_GetDeviceMemoryOpaqueCaptureAddress = uint64_t (*) (Device device, const DeviceMemoryOpaqueCaptureAddressInfo* pInfo);
using PFN_GetDeviceMemoryOpaqueCaptureAddressKHR = PFN_GetDeviceMemoryOpaqueCaptureAddress;
using PFN_GetPipelineExecutablePropertiesKHR = Result (*) (Device device, const PipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, PipelineExecutablePropertiesKHR* pProperties);
using PFN_GetPipelineExecutableStatisticsKHR = Result (*) (Device device, const PipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, PipelineExecutableStatisticKHR* pStatistics);
using PFN_GetPipelineExecutableInternalRepresentationsKHR = Result (*) (Device device, const PipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, PipelineExecutableInternalRepresentationKHR* pInternalRepresentations);
using PFN_CmdSetLineStippleEXT = void (*) (CommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
using PFN_GetPhysicalDeviceToolPropertiesEXT = Result (*) (PhysicalDevice physicalDevice, uint32_t* pToolCount, PhysicalDeviceToolPropertiesEXT* pToolProperties);
using PFN_CreateAccelerationStructureKHR = Result (*) (Device device, const AccelerationStructureCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, AccelerationStructureKHR* pAccelerationStructure);
using PFN_CmdBuildAccelerationStructuresKHR = void (*) (CommandBuffer commandBuffer, uint32_t infoCount, const AccelerationStructureBuildGeometryInfoKHR* pInfos, const AccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos);
using PFN_CmdBuildAccelerationStructuresIndirectKHR = void (*) (CommandBuffer commandBuffer, uint32_t infoCount, const AccelerationStructureBuildGeometryInfoKHR* pInfos, const DeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts);
using PFN_BuildAccelerationStructuresKHR = Result (*) (Device device, DeferredOperationKHR deferredOperation, uint32_t infoCount, const AccelerationStructureBuildGeometryInfoKHR* pInfos, const AccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos);
using PFN_GetAccelerationStructureDeviceAddressKHR = DeviceAddress (*) (Device device, const AccelerationStructureDeviceAddressInfoKHR* pInfo);
using PFN_CreateDeferredOperationKHR = Result (*) (Device device, const AllocationCallbacks* pAllocator, DeferredOperationKHR* pDeferredOperation);
using PFN_DestroyDeferredOperationKHR = void (*) (Device device, DeferredOperationKHR operation, const AllocationCallbacks* pAllocator);
using PFN_GetDeferredOperationMaxConcurrencyKHR = uint32_t (*) (Device device, DeferredOperationKHR operation);
using PFN_GetDeferredOperationResultKHR = Result (*) (Device device, DeferredOperationKHR operation);
using PFN_DeferredOperationJoinKHR = Result (*) (Device device, DeferredOperationKHR operation);
using PFN_CmdSetCullModeEXT = void (*) (CommandBuffer commandBuffer, CullModeFlags cullMode);
using PFN_CmdSetFrontFaceEXT = void (*) (CommandBuffer commandBuffer, FrontFace frontFace);
using PFN_CmdSetPrimitiveTopologyEXT = void (*) (CommandBuffer commandBuffer, PrimitiveTopology primitiveTopology);
using PFN_CmdSetViewportWithCountEXT = void (*) (CommandBuffer commandBuffer, uint32_t viewportCount, const Viewport* pViewports);
using PFN_CmdSetScissorWithCountEXT = void (*) (CommandBuffer commandBuffer, uint32_t scissorCount, const Rect2D* pScissors);
using PFN_CmdBindVertexBuffers2EXT = void (*) (CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, const DeviceSize* pSizes, const DeviceSize* pStrides);
using PFN_CmdSetDepthTestEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 depthTestEnable);
using PFN_CmdSetDepthWriteEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 depthWriteEnable);
using PFN_CmdSetDepthCompareOpEXT = void (*) (CommandBuffer commandBuffer, CompareOp depthCompareOp);
using PFN_CmdSetDepthBoundsTestEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 depthBoundsTestEnable);
using PFN_CmdSetStencilTestEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 stencilTestEnable);
using PFN_CmdSetStencilOpEXT = void (*) (CommandBuffer commandBuffer, StencilFaceFlags faceMask, StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp);
using PFN_CmdSetPatchControlPointsEXT = void (*) (CommandBuffer commandBuffer, uint32_t patchControlPoints);
using PFN_CmdSetRasterizerDiscardEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 rasterizerDiscardEnable);
using PFN_CmdSetDepthBiasEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 depthBiasEnable);
using PFN_CmdSetLogicOpEXT = void (*) (CommandBuffer commandBuffer, LogicOp logicOp);
using PFN_CmdSetPrimitiveRestartEnableEXT = void (*) (CommandBuffer commandBuffer, Bool32 primitiveRestartEnable);
using PFN_CreatePrivateDataSlotEXT = Result (*) (Device device, const PrivateDataSlotCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, PrivateDataSlotEXT* pPrivateDataSlot);
using PFN_DestroyPrivateDataSlotEXT = void (*) (Device device, PrivateDataSlotEXT privateDataSlot, const AllocationCallbacks* pAllocator);
using PFN_SetPrivateDataEXT = Result (*) (Device device, ObjectType objectType, uint64_t objectHandle, PrivateDataSlotEXT privateDataSlot, uint64_t data);
using PFN_GetPrivateDataEXT = void (*) (Device device, ObjectType objectType, uint64_t objectHandle, PrivateDataSlotEXT privateDataSlot, uint64_t* pData);
using PFN_CmdCopyBuffer2KHR = void (*) (CommandBuffer commandBuffer, const CopyBufferInfo2KHR* pCopyBufferInfo);
using PFN_CmdCopyImage2KHR = void (*) (CommandBuffer commandBuffer, const CopyImageInfo2KHR* pCopyImageInfo);
using PFN_CmdBlitImage2KHR = void (*) (CommandBuffer commandBuffer, const BlitImageInfo2KHR* pBlitImageInfo);
using PFN_CmdCopyBufferToImage2KHR = void (*) (CommandBuffer commandBuffer, const CopyBufferToImageInfo2KHR* pCopyBufferToImageInfo);
using PFN_CmdCopyImageToBuffer2KHR = void (*) (CommandBuffer commandBuffer, const CopyImageToBufferInfo2KHR* pCopyImageToBufferInfo);
using PFN_CmdResolveImage2KHR = void (*) (CommandBuffer commandBuffer, const ResolveImageInfo2KHR* pResolveImageInfo);
using PFN_CmdSetFragmentShadingRateKHR = void (*) (CommandBuffer commandBuffer, const Extent2D* pFragmentSize, const FragmentShadingRateCombinerOpKHR combinerOps[2]);
using PFN_GetPhysicalDeviceFragmentShadingRatesKHR = Result (*) (PhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, PhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates);
using PFN_CmdSetFragmentShadingRateEnumNV = void (*) (CommandBuffer commandBuffer, FragmentShadingRateNV shadingRate, const FragmentShadingRateCombinerOpKHR combinerOps[2]);
using PFN_GetAccelerationStructureBuildSizesKHR = void (*) (Device device, AccelerationStructureBuildTypeKHR buildType, const AccelerationStructureBuildGeometryInfoKHR* pBuildInfo, const uint32_t* pMaxPrimitiveCounts, AccelerationStructureBuildSizesInfoKHR* pSizeInfo);
using PFN_CmdSetVertexInputEXT = void (*) (CommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VertexInputAttributeDescription2EXT* pVertexAttributeDescriptions);
using PFN_CmdSetColorWriteEnableEXT = void (*) (CommandBuffer commandBuffer, uint32_t attachmentCount, const Bool32* pColorWriteEnables);
using PFN_CmdSetEvent2KHR = void (*) (CommandBuffer commandBuffer, Event event, const DependencyInfoKHR* pDependencyInfo);
using PFN_CmdResetEvent2KHR = void (*) (CommandBuffer commandBuffer, Event event, PipelineStageFlags2KHR stageMask);
using PFN_CmdWaitEvents2KHR = void (*) (CommandBuffer commandBuffer, uint32_t eventCount, const Event* pEvents, const DependencyInfoKHR* pDependencyInfos);
using PFN_CmdPipelineBarrier2KHR = void (*) (CommandBuffer commandBuffer, const DependencyInfoKHR* pDependencyInfo);
using PFN_QueueSubmit2KHR = Result (*) (Queue queue, uint32_t submitCount, const SubmitInfo2KHR* pSubmits, Fence fence);
using PFN_CmdWriteTimestamp2KHR = void (*) (CommandBuffer commandBuffer, PipelineStageFlags2KHR stage, QueryPool queryPool, uint32_t query);
using PFN_CmdWriteBufferMarker2AMD = void (*) (CommandBuffer commandBuffer, PipelineStageFlags2KHR stage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker);
using PFN_GetQueueCheckpointData2NV = void (*) (Queue queue, uint32_t* pCheckpointDataCount, CheckpointData2NV* pCheckpointData);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
using PFN_GetPhysicalDeviceVideoCapabilitiesKHR = Result (*) (PhysicalDevice physicalDevice, const VideoProfileKHR* pVideoProfile, VideoCapabilitiesKHR* pCapabilities);
using PFN_GetPhysicalDeviceVideoFormatPropertiesKHR = Result (*) (PhysicalDevice physicalDevice, const PhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VideoFormatPropertiesKHR* pVideoFormatProperties);
using PFN_CreateVideoSessionKHR = Result (*) (Device device, const VideoSessionCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, VideoSessionKHR* pVideoSession);
using PFN_DestroyVideoSessionKHR = void (*) (Device device, VideoSessionKHR videoSession, const AllocationCallbacks* pAllocator);
using PFN_CreateVideoSessionParametersKHR = Result (*) (Device device, const VideoSessionParametersCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, VideoSessionParametersKHR* pVideoSessionParameters);
using PFN_UpdateVideoSessionParametersKHR = Result (*) (Device device, VideoSessionParametersKHR videoSessionParameters, const VideoSessionParametersUpdateInfoKHR* pUpdateInfo);
using PFN_DestroyVideoSessionParametersKHR = void (*) (Device device, VideoSessionParametersKHR videoSessionParameters, const AllocationCallbacks* pAllocator);
using PFN_GetVideoSessionMemoryRequirementsKHR = Result (*) (Device device, VideoSessionKHR videoSession, uint32_t* pVideoSessionMemoryRequirementsCount, VideoGetMemoryPropertiesKHR* pVideoSessionMemoryRequirements);
using PFN_BindVideoSessionMemoryKHR = Result (*) (Device device, VideoSessionKHR videoSession, uint32_t videoSessionBindMemoryCount, const VideoBindMemoryKHR* pVideoSessionBindMemories);
using PFN_CmdDecodeVideoKHR = void (*) (CommandBuffer commandBuffer, const VideoDecodeInfoKHR* pFrameInfo);
using PFN_CmdBeginVideoCodingKHR = void (*) (CommandBuffer commandBuffer, const VideoBeginCodingInfoKHR* pBeginInfo);
using PFN_CmdControlVideoCodingKHR = void (*) (CommandBuffer commandBuffer, const VideoCodingControlInfoKHR* pCodingControlInfo);
using PFN_CmdEndVideoCodingKHR = void (*) (CommandBuffer commandBuffer, const VideoEndCodingInfoKHR* pEndCodingInfo);
using PFN_CmdEncodeVideoKHR = void (*) (CommandBuffer commandBuffer, const VideoEncodeInfoKHR* pEncodeInfo);
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
} //namespace detail

} // namespace vk
#if defined(_WIN32)
    typedef struct HINSTANCE__ * HINSTANCE;
    #if defined( _WIN64 )
    typedef int64_t( __stdcall * FARPROC )();
    #else
    typedef int( __stdcall * FARPROC )();
    #endif
    extern "C" __declspec( dllimport ) HINSTANCE __stdcall LoadLibraryA( char const * lpLibFileName );
    extern "C" __declspec( dllimport ) int __stdcall FreeLibrary( HINSTANCE hLibModule );
    extern "C" __declspec( dllimport ) FARPROC __stdcall GetProcAddress( HINSTANCE hModule, const char * lpProcName );
#elif defined(__linux__) || defined(__APPLE__)
    #include <dlfcn.h>
#endif
using PFN_vkVoidFunction = void (VKAPI_PTR *)(void);
using PFN_vkGetInstanceProcAddr = PFN_vkVoidFunction (VKAPI_PTR *)(VkInstance instance, const char* pName);
export namespace vk {
class DynamicLibrary {
    public:
    // Used to enable RAII vk::DynamicLibrary behavior
    struct LoadAtConstruction {};

    explicit DynamicLibrary() noexcept {}
    explicit DynamicLibrary([[maybe_unused]] LoadAtConstruction load) noexcept {
        init();
    }
    explicit DynamicLibrary(PFN_vkGetInstanceProcAddr pfn_vkGetInstanceProcAddr) noexcept :
        get_instance_proc_addr(pfn_vkGetInstanceProcAddr) { }
    ~DynamicLibrary() noexcept {
        close();
    }
    DynamicLibrary(DynamicLibrary const& other) = delete;
    DynamicLibrary& operator=(DynamicLibrary const& other) = delete;
    DynamicLibrary(DynamicLibrary && other) noexcept: library(other.library), get_instance_proc_addr(other.get_instance_proc_addr) {
        other.get_instance_proc_addr = 0;
        other.library = 0;
    }
    DynamicLibrary& operator=(DynamicLibrary && other) noexcept {
        if (this != &other)
        {
            close();
            library = other.library;
            get_instance_proc_addr = other.get_instance_proc_addr;
            other.get_instance_proc_addr = 0;
            other.library = 0;
        }
        return *this;
    }

    Result init(PFN_vkGetInstanceProcAddr pfn_vkGetInstanceProcAddr = nullptr) noexcept {
        if (pfn_vkGetInstanceProcAddr != nullptr) {
            get_instance_proc_addr = pfn_vkGetInstanceProcAddr;
            return Result::Success;
        }
#if defined(__linux__)
        library = dlopen("libvulkan.so", RTLD_NOW | RTLD_LOCAL);
        if (!library) library = dlopen("libvulkan.so.1", RTLD_NOW | RTLD_LOCAL);
#elif defined(__APPLE__)
        library = dlopen("libvulkan.dylib", RTLD_NOW | RTLD_LOCAL);
#elif defined(_WIN32)
        library = ::LoadLibraryA("vulkan-1.dll");
#endif
        if (library == 0) return Result::ErrorInitializationFailed;
        Load(get_instance_proc_addr, "vkGetInstanceProcAddr");
        if (get_instance_proc_addr == nullptr) return Result::ErrorInitializationFailed;
        return Result::Success;
    }
    void close() noexcept {
        if (library != nullptr) {
#if defined(__linux__) || defined(__APPLE__)
            dlclose(library);
#elif defined(_WIN32)
            ::FreeLibrary(library);
#endif
        library = 0;
        }
    }

    // Check if vulkan is loaded and ready for use
    [[nodiscard]] bool is_init() const noexcept { return get_instance_proc_addr != 0; }

    // Get `vkGetInstanceProcAddr` if it was loaded, 0 if not
    [[nodiscard]] PFN_vkGetInstanceProcAddr get() const noexcept {
        VULKAN_CUSTOM_ASSERT(get_instance_proc_addr != nullptr && "Must call init() before use");
        return get_instance_proc_addr;
    }

private:

    template <typename T>
    void Load(T &func_dest, const char *func_name) {
#if defined(__linux__) || defined(__APPLE__)
        func_dest = reinterpret_cast<T>(dlsym(library, func_name));
#elif defined(_WIN32)
        func_dest = reinterpret_cast<T>(::GetProcAddress(library, func_name));
#endif
    }

#if defined(__linux__) || defined(__APPLE__)
    void *library = nullptr;
#elif defined(_WIN32)
    ::HINSTANCE library = nullptr;
#endif

    PFN_vkGetInstanceProcAddr get_instance_proc_addr = nullptr;

};


struct GlobalFunctions {
    detail::PFN_CreateInstance pfn_CreateInstance = nullptr;
    detail::PFN_GetInstanceProcAddr pfn_GetInstanceProcAddr = nullptr;
    detail::PFN_EnumerateInstanceExtensionProperties pfn_EnumerateInstanceExtensionProperties = nullptr;
    detail::PFN_EnumerateInstanceLayerProperties pfn_EnumerateInstanceLayerProperties = nullptr;
    detail::PFN_EnumerateInstanceVersion pfn_EnumerateInstanceVersion = nullptr;
[[nodiscard]] expected<Instance> CreateInstance(const InstanceCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Instance pInstance;
        Result result = pfn_CreateInstance(&pCreateInfo,
        pAllocator,
        &pInstance);
    return expected<Instance>(pInstance, result);
}
[[nodiscard]] PFN_VoidFunction GetInstanceProcAddr(Instance instance, 
    detail::span<const char> Name) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetInstanceProcAddr(instance,
        Name.data());
}
[[nodiscard]] expected<std::vector<ExtensionProperties>> EnumerateInstanceExtensionProperties(const char* pLayerName = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_EnumerateInstanceExtensionProperties(pLayerName,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<ExtensionProperties>{}, result);
    std::vector<ExtensionProperties> pProperties(pPropertyCount);
    result = pfn_EnumerateInstanceExtensionProperties(pLayerName,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<LayerProperties>> EnumerateInstanceLayerProperties() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_EnumerateInstanceLayerProperties(&pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<LayerProperties>{}, result);
    std::vector<LayerProperties> pProperties(pPropertyCount);
    result = pfn_EnumerateInstanceLayerProperties(&pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<uint32_t> EnumerateInstanceVersion() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    if (pfn_EnumerateInstanceVersion == 0) return expected<uint32_t>(make_vk_version(1,0,0), Result::Success);
    uint32_t pApiVersion;
        Result result = pfn_EnumerateInstanceVersion(&pApiVersion);
    return expected<uint32_t>(pApiVersion, result);
}
GlobalFunctions() noexcept {}
explicit GlobalFunctions(DynamicLibrary const& library) noexcept {
    detail::PFN_GetInstanceProcAddr get_instance_proc_addr = reinterpret_cast<detail::PFN_GetInstanceProcAddr>(library.get());
    pfn_CreateInstance = reinterpret_cast<detail::PFN_CreateInstance>(get_instance_proc_addr(nullptr,"vkCreateInstance"));
    pfn_GetInstanceProcAddr = reinterpret_cast<detail::PFN_GetInstanceProcAddr>(get_instance_proc_addr(nullptr,"vkGetInstanceProcAddr"));
    pfn_EnumerateInstanceExtensionProperties = reinterpret_cast<detail::PFN_EnumerateInstanceExtensionProperties>(get_instance_proc_addr(nullptr,"vkEnumerateInstanceExtensionProperties"));
    pfn_EnumerateInstanceLayerProperties = reinterpret_cast<detail::PFN_EnumerateInstanceLayerProperties>(get_instance_proc_addr(nullptr,"vkEnumerateInstanceLayerProperties"));
    pfn_EnumerateInstanceVersion = reinterpret_cast<detail::PFN_EnumerateInstanceVersion>(get_instance_proc_addr(nullptr,"vkEnumerateInstanceVersion"));
}
};
struct InstanceFunctions {
    Instance instance;
    detail::PFN_DestroyInstance pfn_DestroyInstance = nullptr;
    detail::PFN_EnumeratePhysicalDevices pfn_EnumeratePhysicalDevices = nullptr;
    detail::PFN_GetDeviceProcAddr pfn_GetDeviceProcAddr = nullptr;
    detail::PFN_GetInstanceProcAddr pfn_GetInstanceProcAddr = nullptr;
    detail::PFN_GetPhysicalDeviceProperties pfn_GetPhysicalDeviceProperties = nullptr;
    detail::PFN_GetPhysicalDeviceQueueFamilyProperties pfn_GetPhysicalDeviceQueueFamilyProperties = nullptr;
    detail::PFN_GetPhysicalDeviceMemoryProperties pfn_GetPhysicalDeviceMemoryProperties = nullptr;
    detail::PFN_GetPhysicalDeviceFeatures pfn_GetPhysicalDeviceFeatures = nullptr;
    detail::PFN_GetPhysicalDeviceFormatProperties pfn_GetPhysicalDeviceFormatProperties = nullptr;
    detail::PFN_GetPhysicalDeviceImageFormatProperties pfn_GetPhysicalDeviceImageFormatProperties = nullptr;
    detail::PFN_CreateDevice pfn_CreateDevice = nullptr;
    detail::PFN_EnumerateDeviceExtensionProperties pfn_EnumerateDeviceExtensionProperties = nullptr;
    detail::PFN_GetPhysicalDeviceSparseImageFormatProperties pfn_GetPhysicalDeviceSparseImageFormatProperties = nullptr;
    detail::PFN_EnumeratePhysicalDeviceGroups pfn_EnumeratePhysicalDeviceGroups = nullptr;
    detail::PFN_GetPhysicalDeviceFeatures2 pfn_GetPhysicalDeviceFeatures2 = nullptr;
    detail::PFN_GetPhysicalDeviceProperties2 pfn_GetPhysicalDeviceProperties2 = nullptr;
    detail::PFN_GetPhysicalDeviceFormatProperties2 pfn_GetPhysicalDeviceFormatProperties2 = nullptr;
    detail::PFN_GetPhysicalDeviceImageFormatProperties2 pfn_GetPhysicalDeviceImageFormatProperties2 = nullptr;
    detail::PFN_GetPhysicalDeviceQueueFamilyProperties2 pfn_GetPhysicalDeviceQueueFamilyProperties2 = nullptr;
    detail::PFN_GetPhysicalDeviceMemoryProperties2 pfn_GetPhysicalDeviceMemoryProperties2 = nullptr;
    detail::PFN_GetPhysicalDeviceSparseImageFormatProperties2 pfn_GetPhysicalDeviceSparseImageFormatProperties2 = nullptr;
    detail::PFN_GetPhysicalDeviceExternalBufferProperties pfn_GetPhysicalDeviceExternalBufferProperties = nullptr;
    detail::PFN_GetPhysicalDeviceExternalFenceProperties pfn_GetPhysicalDeviceExternalFenceProperties = nullptr;
    detail::PFN_GetPhysicalDeviceExternalSemaphoreProperties pfn_GetPhysicalDeviceExternalSemaphoreProperties = nullptr;
    detail::PFN_DestroySurfaceKHR pfn_DestroySurfaceKHR = nullptr;
    detail::PFN_GetPhysicalDeviceSurfaceSupportKHR pfn_GetPhysicalDeviceSurfaceSupportKHR = nullptr;
    detail::PFN_GetPhysicalDeviceSurfaceCapabilitiesKHR pfn_GetPhysicalDeviceSurfaceCapabilitiesKHR = nullptr;
    detail::PFN_GetPhysicalDeviceSurfaceFormatsKHR pfn_GetPhysicalDeviceSurfaceFormatsKHR = nullptr;
    detail::PFN_GetPhysicalDeviceSurfacePresentModesKHR pfn_GetPhysicalDeviceSurfacePresentModesKHR = nullptr;
    detail::PFN_GetPhysicalDevicePresentRectanglesKHR pfn_GetPhysicalDevicePresentRectanglesKHR = nullptr;
    detail::PFN_GetPhysicalDeviceDisplayPropertiesKHR pfn_GetPhysicalDeviceDisplayPropertiesKHR = nullptr;
    detail::PFN_GetPhysicalDeviceDisplayPlanePropertiesKHR pfn_GetPhysicalDeviceDisplayPlanePropertiesKHR = nullptr;
    detail::PFN_GetDisplayPlaneSupportedDisplaysKHR pfn_GetDisplayPlaneSupportedDisplaysKHR = nullptr;
    detail::PFN_GetDisplayModePropertiesKHR pfn_GetDisplayModePropertiesKHR = nullptr;
    detail::PFN_CreateDisplayModeKHR pfn_CreateDisplayModeKHR = nullptr;
    detail::PFN_GetDisplayPlaneCapabilitiesKHR pfn_GetDisplayPlaneCapabilitiesKHR = nullptr;
    detail::PFN_CreateDisplayPlaneSurfaceKHR pfn_CreateDisplayPlaneSurfaceKHR = nullptr;
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    detail::PFN_CreateXlibSurfaceKHR pfn_CreateXlibSurfaceKHR = nullptr;
    detail::PFN_GetPhysicalDeviceXlibPresentationSupportKHR pfn_GetPhysicalDeviceXlibPresentationSupportKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
    detail::PFN_CreateXcbSurfaceKHR pfn_CreateXcbSurfaceKHR = nullptr;
    detail::PFN_GetPhysicalDeviceXcbPresentationSupportKHR pfn_GetPhysicalDeviceXcbPresentationSupportKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    detail::PFN_CreateWaylandSurfaceKHR pfn_CreateWaylandSurfaceKHR = nullptr;
    detail::PFN_GetPhysicalDeviceWaylandPresentationSupportKHR pfn_GetPhysicalDeviceWaylandPresentationSupportKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    detail::PFN_CreateAndroidSurfaceKHR pfn_CreateAndroidSurfaceKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_CreateWin32SurfaceKHR pfn_CreateWin32SurfaceKHR = nullptr;
    detail::PFN_GetPhysicalDeviceWin32PresentationSupportKHR pfn_GetPhysicalDeviceWin32PresentationSupportKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_CreateDebugReportCallbackEXT pfn_CreateDebugReportCallbackEXT = nullptr;
    detail::PFN_DestroyDebugReportCallbackEXT pfn_DestroyDebugReportCallbackEXT = nullptr;
    detail::PFN_DebugReportMessageEXT pfn_DebugReportMessageEXT = nullptr;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    detail::PFN_GetPhysicalDeviceVideoCapabilitiesKHR pfn_GetPhysicalDeviceVideoCapabilitiesKHR = nullptr;
    detail::PFN_GetPhysicalDeviceVideoFormatPropertiesKHR pfn_GetPhysicalDeviceVideoFormatPropertiesKHR = nullptr;
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
#if defined(VK_USE_PLATFORM_GGP)
    detail::PFN_CreateStreamDescriptorSurfaceGGP pfn_CreateStreamDescriptorSurfaceGGP = nullptr;
#endif // defined(VK_USE_PLATFORM_GGP)
    detail::PFN_GetPhysicalDeviceExternalImageFormatPropertiesNV pfn_GetPhysicalDeviceExternalImageFormatPropertiesNV = nullptr;
#if defined(VK_USE_PLATFORM_VI_NN)
    detail::PFN_CreateViSurfaceNN pfn_CreateViSurfaceNN = nullptr;
#endif // defined(VK_USE_PLATFORM_VI_NN)
    detail::PFN_ReleaseDisplayEXT pfn_ReleaseDisplayEXT = nullptr;
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    detail::PFN_AcquireXlibDisplayEXT pfn_AcquireXlibDisplayEXT = nullptr;
    detail::PFN_GetRandROutputDisplayEXT pfn_GetRandROutputDisplayEXT = nullptr;
#endif // defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    detail::PFN_GetPhysicalDeviceSurfaceCapabilities2EXT pfn_GetPhysicalDeviceSurfaceCapabilities2EXT = nullptr;
    detail::PFN_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR pfn_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = nullptr;
    detail::PFN_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR pfn_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = nullptr;
    detail::PFN_GetPhysicalDeviceSurfaceCapabilities2KHR pfn_GetPhysicalDeviceSurfaceCapabilities2KHR = nullptr;
    detail::PFN_GetPhysicalDeviceSurfaceFormats2KHR pfn_GetPhysicalDeviceSurfaceFormats2KHR = nullptr;
    detail::PFN_GetPhysicalDeviceDisplayProperties2KHR pfn_GetPhysicalDeviceDisplayProperties2KHR = nullptr;
    detail::PFN_GetPhysicalDeviceDisplayPlaneProperties2KHR pfn_GetPhysicalDeviceDisplayPlaneProperties2KHR = nullptr;
    detail::PFN_GetDisplayModeProperties2KHR pfn_GetDisplayModeProperties2KHR = nullptr;
    detail::PFN_GetDisplayPlaneCapabilities2KHR pfn_GetDisplayPlaneCapabilities2KHR = nullptr;
#if defined(VK_USE_PLATFORM_IOS_MVK)
    detail::PFN_CreateIOSSurfaceMVK pfn_CreateIOSSurfaceMVK = nullptr;
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    detail::PFN_CreateMacOSSurfaceMVK pfn_CreateMacOSSurfaceMVK = nullptr;
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
    detail::PFN_CreateDebugUtilsMessengerEXT pfn_CreateDebugUtilsMessengerEXT = nullptr;
    detail::PFN_DestroyDebugUtilsMessengerEXT pfn_DestroyDebugUtilsMessengerEXT = nullptr;
    detail::PFN_SubmitDebugUtilsMessageEXT pfn_SubmitDebugUtilsMessageEXT = nullptr;
    detail::PFN_GetPhysicalDeviceMultisamplePropertiesEXT pfn_GetPhysicalDeviceMultisamplePropertiesEXT = nullptr;
    detail::PFN_GetPhysicalDeviceCalibrateableTimeDomainsEXT pfn_GetPhysicalDeviceCalibrateableTimeDomainsEXT = nullptr;
#if defined(VK_USE_PLATFORM_FUCHSIA)
    detail::PFN_CreateImagePipeSurfaceFUCHSIA pfn_CreateImagePipeSurfaceFUCHSIA = nullptr;
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_METAL_EXT)
    detail::PFN_CreateMetalSurfaceEXT pfn_CreateMetalSurfaceEXT = nullptr;
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
    detail::PFN_GetPhysicalDeviceFragmentShadingRatesKHR pfn_GetPhysicalDeviceFragmentShadingRatesKHR = nullptr;
    detail::PFN_GetPhysicalDeviceToolPropertiesEXT pfn_GetPhysicalDeviceToolPropertiesEXT = nullptr;
    detail::PFN_GetPhysicalDeviceCooperativeMatrixPropertiesNV pfn_GetPhysicalDeviceCooperativeMatrixPropertiesNV = nullptr;
    detail::PFN_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV pfn_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = nullptr;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetPhysicalDeviceSurfacePresentModes2EXT pfn_GetPhysicalDeviceSurfacePresentModes2EXT = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_CreateHeadlessSurfaceEXT pfn_CreateHeadlessSurfaceEXT = nullptr;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_AcquireWinrtDisplayNV pfn_AcquireWinrtDisplayNV = nullptr;
    detail::PFN_GetWinrtDisplayNV pfn_GetWinrtDisplayNV = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    detail::PFN_CreateDirectFBSurfaceEXT pfn_CreateDirectFBSurfaceEXT = nullptr;
    detail::PFN_GetPhysicalDeviceDirectFBPresentationSupportEXT pfn_GetPhysicalDeviceDirectFBPresentationSupportEXT = nullptr;
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    detail::PFN_CreateScreenSurfaceQNX pfn_CreateScreenSurfaceQNX = nullptr;
    detail::PFN_GetPhysicalDeviceScreenPresentationSupportQNX pfn_GetPhysicalDeviceScreenPresentationSupportQNX = nullptr;
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
void DestroyInstance(const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyInstance(instance,
        pAllocator);
}
[[nodiscard]] expected<std::vector<PhysicalDevice>> EnumeratePhysicalDevices() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPhysicalDeviceCount = 0;
        Result result = pfn_EnumeratePhysicalDevices(instance,
        &pPhysicalDeviceCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PhysicalDevice>{}, result);
    std::vector<PhysicalDevice> pPhysicalDevices(pPhysicalDeviceCount);
    result = pfn_EnumeratePhysicalDevices(instance,
        &pPhysicalDeviceCount,
        pPhysicalDevices.data());
    return expected(std::move(pPhysicalDevices), result);
}
[[nodiscard]] PFN_VoidFunction GetDeviceProcAddr(Device device, 
    detail::span<const char> Name) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetDeviceProcAddr(device,
        Name.data());
}
[[nodiscard]] PFN_VoidFunction GetInstanceProcAddr(detail::span<const char> Name) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetInstanceProcAddr(instance,
        Name.data());
}
[[nodiscard]] PhysicalDeviceProperties GetPhysicalDeviceProperties(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PhysicalDeviceProperties pProperties;
    pfn_GetPhysicalDeviceProperties(physicalDevice,
        &pProperties);
    return pProperties;
}
[[nodiscard]] std::vector<QueueFamilyProperties> GetPhysicalDeviceQueueFamilyProperties(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pQueueFamilyPropertyCount = 0;
    pfn_GetPhysicalDeviceQueueFamilyProperties(physicalDevice,
        &pQueueFamilyPropertyCount,
        nullptr);
    std::vector<QueueFamilyProperties> pQueueFamilyProperties(pQueueFamilyPropertyCount);
pfn_GetPhysicalDeviceQueueFamilyProperties(physicalDevice,
        &pQueueFamilyPropertyCount,
        pQueueFamilyProperties.data());
    return pQueueFamilyProperties;
}
[[nodiscard]] PhysicalDeviceMemoryProperties GetPhysicalDeviceMemoryProperties(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PhysicalDeviceMemoryProperties pMemoryProperties;
    pfn_GetPhysicalDeviceMemoryProperties(physicalDevice,
        &pMemoryProperties);
    return pMemoryProperties;
}
[[nodiscard]] PhysicalDeviceFeatures GetPhysicalDeviceFeatures(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PhysicalDeviceFeatures pFeatures;
    pfn_GetPhysicalDeviceFeatures(physicalDevice,
        &pFeatures);
    return pFeatures;
}
[[nodiscard]] FormatProperties GetPhysicalDeviceFormatProperties(PhysicalDevice physicalDevice, 
    Format format) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    FormatProperties pFormatProperties;
    pfn_GetPhysicalDeviceFormatProperties(physicalDevice,
        format,
        &pFormatProperties);
    return pFormatProperties;
}
[[nodiscard]] expected<ImageFormatProperties> GetPhysicalDeviceImageFormatProperties(PhysicalDevice physicalDevice, 
    Format format, 
    ImageType type, 
    ImageTiling tiling, 
    ImageUsageFlags usage, 
    ImageCreateFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ImageFormatProperties pImageFormatProperties;
        Result result = pfn_GetPhysicalDeviceImageFormatProperties(physicalDevice,
        format,
        type,
        tiling,
        usage,
        flags,
        &pImageFormatProperties);
    return expected<ImageFormatProperties>(pImageFormatProperties, result);
}
[[nodiscard]] expected<Device> CreateDevice(PhysicalDevice physicalDevice, 
    const DeviceCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Device pDevice;
        Result result = pfn_CreateDevice(physicalDevice,
        &pCreateInfo,
        pAllocator,
        &pDevice);
    return expected<Device>(pDevice, result);
}
[[nodiscard]] expected<std::vector<ExtensionProperties>> EnumerateDeviceExtensionProperties(PhysicalDevice physicalDevice, 
    const char* pLayerName = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_EnumerateDeviceExtensionProperties(physicalDevice,
        pLayerName,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<ExtensionProperties>{}, result);
    std::vector<ExtensionProperties> pProperties(pPropertyCount);
    result = pfn_EnumerateDeviceExtensionProperties(physicalDevice,
        pLayerName,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] std::vector<SparseImageFormatProperties> GetPhysicalDeviceSparseImageFormatProperties(PhysicalDevice physicalDevice, 
    Format format, 
    ImageType type, 
    SampleCountFlagBits samples, 
    ImageUsageFlags usage, 
    ImageTiling tiling) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
    pfn_GetPhysicalDeviceSparseImageFormatProperties(physicalDevice,
        format,
        type,
        samples,
        usage,
        tiling,
        &pPropertyCount,
        nullptr);
    std::vector<SparseImageFormatProperties> pProperties(pPropertyCount);
pfn_GetPhysicalDeviceSparseImageFormatProperties(physicalDevice,
        format,
        type,
        samples,
        usage,
        tiling,
        &pPropertyCount,
        pProperties.data());
    return pProperties;
}
[[nodiscard]] expected<std::vector<PhysicalDeviceGroupProperties>> EnumeratePhysicalDeviceGroups() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPhysicalDeviceGroupCount = 0;
        Result result = pfn_EnumeratePhysicalDeviceGroups(instance,
        &pPhysicalDeviceGroupCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PhysicalDeviceGroupProperties>{}, result);
    std::vector<PhysicalDeviceGroupProperties> pPhysicalDeviceGroupProperties(pPhysicalDeviceGroupCount);
    result = pfn_EnumeratePhysicalDeviceGroups(instance,
        &pPhysicalDeviceGroupCount,
        pPhysicalDeviceGroupProperties.data());
    return expected(std::move(pPhysicalDeviceGroupProperties), result);
}
[[nodiscard]] PhysicalDeviceFeatures2 GetPhysicalDeviceFeatures2(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PhysicalDeviceFeatures2 pFeatures;
    pfn_GetPhysicalDeviceFeatures2(physicalDevice,
        &pFeatures);
    return pFeatures;
}
[[nodiscard]] PhysicalDeviceProperties2 GetPhysicalDeviceProperties2(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PhysicalDeviceProperties2 pProperties;
    pfn_GetPhysicalDeviceProperties2(physicalDevice,
        &pProperties);
    return pProperties;
}
[[nodiscard]] FormatProperties2 GetPhysicalDeviceFormatProperties2(PhysicalDevice physicalDevice, 
    Format format) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    FormatProperties2 pFormatProperties;
    pfn_GetPhysicalDeviceFormatProperties2(physicalDevice,
        format,
        &pFormatProperties);
    return pFormatProperties;
}
[[nodiscard]] expected<ImageFormatProperties2> GetPhysicalDeviceImageFormatProperties2(PhysicalDevice physicalDevice, 
    const PhysicalDeviceImageFormatInfo2&  pImageFormatInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ImageFormatProperties2 pImageFormatProperties;
        Result result = pfn_GetPhysicalDeviceImageFormatProperties2(physicalDevice,
        &pImageFormatInfo,
        &pImageFormatProperties);
    return expected<ImageFormatProperties2>(pImageFormatProperties, result);
}
[[nodiscard]] std::vector<QueueFamilyProperties2> GetPhysicalDeviceQueueFamilyProperties2(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pQueueFamilyPropertyCount = 0;
    pfn_GetPhysicalDeviceQueueFamilyProperties2(physicalDevice,
        &pQueueFamilyPropertyCount,
        nullptr);
    std::vector<QueueFamilyProperties2> pQueueFamilyProperties(pQueueFamilyPropertyCount);
pfn_GetPhysicalDeviceQueueFamilyProperties2(physicalDevice,
        &pQueueFamilyPropertyCount,
        pQueueFamilyProperties.data());
    return pQueueFamilyProperties;
}
[[nodiscard]] PhysicalDeviceMemoryProperties2 GetPhysicalDeviceMemoryProperties2(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PhysicalDeviceMemoryProperties2 pMemoryProperties;
    pfn_GetPhysicalDeviceMemoryProperties2(physicalDevice,
        &pMemoryProperties);
    return pMemoryProperties;
}
[[nodiscard]] std::vector<SparseImageFormatProperties2> GetPhysicalDeviceSparseImageFormatProperties2(PhysicalDevice physicalDevice, 
    const PhysicalDeviceSparseImageFormatInfo2&  pFormatInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
    pfn_GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice,
        &pFormatInfo,
        &pPropertyCount,
        nullptr);
    std::vector<SparseImageFormatProperties2> pProperties(pPropertyCount);
pfn_GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice,
        &pFormatInfo,
        &pPropertyCount,
        pProperties.data());
    return pProperties;
}
[[nodiscard]] ExternalBufferProperties GetPhysicalDeviceExternalBufferProperties(PhysicalDevice physicalDevice, 
    const PhysicalDeviceExternalBufferInfo&  pExternalBufferInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ExternalBufferProperties pExternalBufferProperties;
    pfn_GetPhysicalDeviceExternalBufferProperties(physicalDevice,
        &pExternalBufferInfo,
        &pExternalBufferProperties);
    return pExternalBufferProperties;
}
[[nodiscard]] ExternalFenceProperties GetPhysicalDeviceExternalFenceProperties(PhysicalDevice physicalDevice, 
    const PhysicalDeviceExternalFenceInfo&  pExternalFenceInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ExternalFenceProperties pExternalFenceProperties;
    pfn_GetPhysicalDeviceExternalFenceProperties(physicalDevice,
        &pExternalFenceInfo,
        &pExternalFenceProperties);
    return pExternalFenceProperties;
}
[[nodiscard]] ExternalSemaphoreProperties GetPhysicalDeviceExternalSemaphoreProperties(PhysicalDevice physicalDevice, 
    const PhysicalDeviceExternalSemaphoreInfo&  pExternalSemaphoreInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ExternalSemaphoreProperties pExternalSemaphoreProperties;
    pfn_GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice,
        &pExternalSemaphoreInfo,
        &pExternalSemaphoreProperties);
    return pExternalSemaphoreProperties;
}
void DestroySurfaceKHR(SurfaceKHR surface = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroySurfaceKHR(instance,
        surface,
        pAllocator);
}
[[nodiscard]] expected<Bool32> GetPhysicalDeviceSurfaceSupportKHR(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex, 
    SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Bool32 pSupported;
        Result result = pfn_GetPhysicalDeviceSurfaceSupportKHR(physicalDevice,
        queueFamilyIndex,
        surface,
        &pSupported);
    return expected<Bool32>(pSupported, result);
}
[[nodiscard]] expected<SurfaceCapabilitiesKHR> GetPhysicalDeviceSurfaceCapabilitiesKHR(PhysicalDevice physicalDevice, 
    SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceCapabilitiesKHR pSurfaceCapabilities;
        Result result = pfn_GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice,
        surface,
        &pSurfaceCapabilities);
    return expected<SurfaceCapabilitiesKHR>(pSurfaceCapabilities, result);
}
[[nodiscard]] expected<std::vector<SurfaceFormatKHR>> GetPhysicalDeviceSurfaceFormatsKHR(PhysicalDevice physicalDevice, 
    SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pSurfaceFormatCount = 0;
        Result result = pfn_GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice,
        surface,
        &pSurfaceFormatCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<SurfaceFormatKHR>{}, result);
    std::vector<SurfaceFormatKHR> pSurfaceFormats(pSurfaceFormatCount);
    result = pfn_GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice,
        surface,
        &pSurfaceFormatCount,
        pSurfaceFormats.data());
    return expected(std::move(pSurfaceFormats), result);
}
[[nodiscard]] expected<std::vector<PresentModeKHR>> GetPhysicalDeviceSurfacePresentModesKHR(PhysicalDevice physicalDevice, 
    SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPresentModeCount = 0;
        Result result = pfn_GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice,
        surface,
        &pPresentModeCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PresentModeKHR>{}, result);
    std::vector<PresentModeKHR> pPresentModes(pPresentModeCount);
    result = pfn_GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice,
        surface,
        &pPresentModeCount,
        pPresentModes.data());
    return expected(std::move(pPresentModes), result);
}
[[nodiscard]] expected<std::vector<Rect2D>> GetPhysicalDevicePresentRectanglesKHR(PhysicalDevice physicalDevice, 
    SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pRectCount = 0;
        Result result = pfn_GetPhysicalDevicePresentRectanglesKHR(physicalDevice,
        surface,
        &pRectCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<Rect2D>{}, result);
    std::vector<Rect2D> pRects(pRectCount);
    result = pfn_GetPhysicalDevicePresentRectanglesKHR(physicalDevice,
        surface,
        &pRectCount,
        pRects.data());
    return expected(std::move(pRects), result);
}
[[nodiscard]] expected<std::vector<DisplayPropertiesKHR>> GetPhysicalDeviceDisplayPropertiesKHR(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayPropertiesKHR>{}, result);
    std::vector<DisplayPropertiesKHR> pProperties(pPropertyCount);
    result = pfn_GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<DisplayPlanePropertiesKHR>> GetPhysicalDeviceDisplayPlanePropertiesKHR(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayPlanePropertiesKHR>{}, result);
    std::vector<DisplayPlanePropertiesKHR> pProperties(pPropertyCount);
    result = pfn_GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<DisplayKHR>> GetDisplayPlaneSupportedDisplaysKHR(PhysicalDevice physicalDevice, 
    uint32_t planeIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pDisplayCount = 0;
        Result result = pfn_GetDisplayPlaneSupportedDisplaysKHR(physicalDevice,
        planeIndex,
        &pDisplayCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayKHR>{}, result);
    std::vector<DisplayKHR> pDisplays(pDisplayCount);
    result = pfn_GetDisplayPlaneSupportedDisplaysKHR(physicalDevice,
        planeIndex,
        &pDisplayCount,
        pDisplays.data());
    return expected(std::move(pDisplays), result);
}
[[nodiscard]] expected<std::vector<DisplayModePropertiesKHR>> GetDisplayModePropertiesKHR(PhysicalDevice physicalDevice, 
    DisplayKHR display) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetDisplayModePropertiesKHR(physicalDevice,
        display,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayModePropertiesKHR>{}, result);
    std::vector<DisplayModePropertiesKHR> pProperties(pPropertyCount);
    result = pfn_GetDisplayModePropertiesKHR(physicalDevice,
        display,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<DisplayModeKHR> CreateDisplayModeKHR(PhysicalDevice physicalDevice, 
    DisplayKHR display, 
    const DisplayModeCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DisplayModeKHR pMode;
        Result result = pfn_CreateDisplayModeKHR(physicalDevice,
        display,
        &pCreateInfo,
        pAllocator,
        &pMode);
    return expected<DisplayModeKHR>(pMode, result);
}
[[nodiscard]] expected<DisplayPlaneCapabilitiesKHR> GetDisplayPlaneCapabilitiesKHR(PhysicalDevice physicalDevice, 
    DisplayModeKHR mode, 
    uint32_t planeIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DisplayPlaneCapabilitiesKHR pCapabilities;
        Result result = pfn_GetDisplayPlaneCapabilitiesKHR(physicalDevice,
        mode,
        planeIndex,
        &pCapabilities);
    return expected<DisplayPlaneCapabilitiesKHR>(pCapabilities, result);
}
[[nodiscard]] expected<SurfaceKHR> CreateDisplayPlaneSurfaceKHR(const DisplaySurfaceCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateDisplayPlaneSurfaceKHR(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
[[nodiscard]] expected<SurfaceKHR> CreateXlibSurfaceKHR(const XlibSurfaceCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateXlibSurfaceKHR(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
[[nodiscard]] Bool32 GetPhysicalDeviceXlibPresentationSupportKHR(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex, 
    Display&  dpy, 
    VisualID visualID) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice,
        queueFamilyIndex,
        &dpy,
        visualID);
}
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
[[nodiscard]] expected<SurfaceKHR> CreateXcbSurfaceKHR(const XcbSurfaceCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateXcbSurfaceKHR(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
[[nodiscard]] Bool32 GetPhysicalDeviceXcbPresentationSupportKHR(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex, 
    xcb_connection_t&  connection, 
    xcb_visualid_t visual_id) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice,
        queueFamilyIndex,
        &connection,
        visual_id);
}
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
[[nodiscard]] expected<SurfaceKHR> CreateWaylandSurfaceKHR(const WaylandSurfaceCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateWaylandSurfaceKHR(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
[[nodiscard]] expected<wl_display> GetPhysicalDeviceWaylandPresentationSupportKHR(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    wl_display display;
        Result result = pfn_GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice,
        queueFamilyIndex,
        &display);
    return expected<wl_display>(display, result);
}
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
[[nodiscard]] expected<SurfaceKHR> CreateAndroidSurfaceKHR(const AndroidSurfaceCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateAndroidSurfaceKHR(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<SurfaceKHR> CreateWin32SurfaceKHR(const Win32SurfaceCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateWin32SurfaceKHR(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
[[nodiscard]] Bool32 GetPhysicalDeviceWin32PresentationSupportKHR(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice,
        queueFamilyIndex);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<DebugReportCallbackEXT> CreateDebugReportCallbackEXT(const DebugReportCallbackCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DebugReportCallbackEXT pCallback;
        Result result = pfn_CreateDebugReportCallbackEXT(instance,
        &pCreateInfo,
        pAllocator,
        &pCallback);
    return expected<DebugReportCallbackEXT>(pCallback, result);
}
void DestroyDebugReportCallbackEXT(DebugReportCallbackEXT callback = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDebugReportCallbackEXT(instance,
        callback,
        pAllocator);
}
void DebugReportMessageEXT(DebugReportFlagsEXT flags, 
    DebugReportObjectTypeEXT objectType, 
    uint64_t object, 
    size_t location, 
    int32_t messageCode, 
    detail::span<const char> LayerPrefix, 
    detail::span<const char> Message) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DebugReportMessageEXT(instance,
        flags,
        objectType,
        object,
        location,
        messageCode,
        LayerPrefix.data(),
        Message.data());
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
[[nodiscard]] expected<VideoCapabilitiesKHR> GetPhysicalDeviceVideoCapabilitiesKHR(PhysicalDevice physicalDevice, 
    const VideoProfileKHR&  pVideoProfile) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    VideoCapabilitiesKHR pCapabilities;
        Result result = pfn_GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice,
        &pVideoProfile,
        &pCapabilities);
    return expected<VideoCapabilitiesKHR>(pCapabilities, result);
}
[[nodiscard]] Result GetPhysicalDeviceVideoFormatPropertiesKHR(PhysicalDevice physicalDevice, 
    const PhysicalDeviceVideoFormatInfoKHR&  pVideoFormatInfo, 
    uint32_t&  pVideoFormatPropertyCount, 
    VideoFormatPropertiesKHR* pVideoFormatProperties = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice,
        &pVideoFormatInfo,
        &pVideoFormatPropertyCount,
        pVideoFormatProperties);
}
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
#if defined(VK_USE_PLATFORM_GGP)
[[nodiscard]] expected<SurfaceKHR> CreateStreamDescriptorSurfaceGGP(const StreamDescriptorSurfaceCreateInfoGGP&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateStreamDescriptorSurfaceGGP(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_GGP)
[[nodiscard]] expected<ExternalImageFormatPropertiesNV> GetPhysicalDeviceExternalImageFormatPropertiesNV(PhysicalDevice physicalDevice, 
    Format format, 
    ImageType type, 
    ImageTiling tiling, 
    ImageUsageFlags usage, 
    ImageCreateFlags flags = {}, 
    ExternalMemoryHandleTypeFlagsNV externalHandleType = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ExternalImageFormatPropertiesNV pExternalImageFormatProperties;
        Result result = pfn_GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice,
        format,
        type,
        tiling,
        usage,
        flags,
        externalHandleType,
        &pExternalImageFormatProperties);
    return expected<ExternalImageFormatPropertiesNV>(pExternalImageFormatProperties, result);
}
#if defined(VK_USE_PLATFORM_VI_NN)
[[nodiscard]] expected<SurfaceKHR> CreateViSurfaceNN(const ViSurfaceCreateInfoNN&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateViSurfaceNN(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_VI_NN)
[[nodiscard]] Result ReleaseDisplayEXT(PhysicalDevice physicalDevice, 
    DisplayKHR display) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ReleaseDisplayEXT(physicalDevice,
        display);
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
[[nodiscard]] Result AcquireXlibDisplayEXT(PhysicalDevice physicalDevice, 
    Display&  dpy, 
    DisplayKHR display) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_AcquireXlibDisplayEXT(physicalDevice,
        &dpy,
        display);
}
[[nodiscard]] expected<DisplayKHR> GetRandROutputDisplayEXT(PhysicalDevice physicalDevice, 
    Display&  dpy, 
    RROutput rrOutput) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DisplayKHR pDisplay;
        Result result = pfn_GetRandROutputDisplayEXT(physicalDevice,
        &dpy,
        rrOutput,
        &pDisplay);
    return expected<DisplayKHR>(pDisplay, result);
}
#endif // defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
[[nodiscard]] expected<SurfaceCapabilities2EXT> GetPhysicalDeviceSurfaceCapabilities2EXT(PhysicalDevice physicalDevice, 
    SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceCapabilities2EXT pSurfaceCapabilities;
        Result result = pfn_GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice,
        surface,
        &pSurfaceCapabilities);
    return expected<SurfaceCapabilities2EXT>(pSurfaceCapabilities, result);
}
[[nodiscard]] Result EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex, 
    uint32_t&  pCounterCount, 
    PerformanceCounterKHR* pCounters = nullptr, 
    PerformanceCounterDescriptionKHR* pCounterDescriptions = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice,
        queueFamilyIndex,
        &pCounterCount,
        pCounters,
        pCounterDescriptions);
}
[[nodiscard]] uint32_t GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(PhysicalDevice physicalDevice, 
    const QueryPoolPerformanceCreateInfoKHR&  pPerformanceQueryCreateInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pNumPasses;
    pfn_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice,
        &pPerformanceQueryCreateInfo,
        &pNumPasses);
    return pNumPasses;
}
[[nodiscard]] expected<SurfaceCapabilities2KHR> GetPhysicalDeviceSurfaceCapabilities2KHR(PhysicalDevice physicalDevice, 
    const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceCapabilities2KHR pSurfaceCapabilities;
        Result result = pfn_GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice,
        &pSurfaceInfo,
        &pSurfaceCapabilities);
    return expected<SurfaceCapabilities2KHR>(pSurfaceCapabilities, result);
}
[[nodiscard]] expected<std::vector<SurfaceFormat2KHR>> GetPhysicalDeviceSurfaceFormats2KHR(PhysicalDevice physicalDevice, 
    const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pSurfaceFormatCount = 0;
        Result result = pfn_GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice,
        &pSurfaceInfo,
        &pSurfaceFormatCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<SurfaceFormat2KHR>{}, result);
    std::vector<SurfaceFormat2KHR> pSurfaceFormats(pSurfaceFormatCount);
    result = pfn_GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice,
        &pSurfaceInfo,
        &pSurfaceFormatCount,
        pSurfaceFormats.data());
    return expected(std::move(pSurfaceFormats), result);
}
[[nodiscard]] expected<std::vector<DisplayProperties2KHR>> GetPhysicalDeviceDisplayProperties2KHR(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetPhysicalDeviceDisplayProperties2KHR(physicalDevice,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayProperties2KHR>{}, result);
    std::vector<DisplayProperties2KHR> pProperties(pPropertyCount);
    result = pfn_GetPhysicalDeviceDisplayProperties2KHR(physicalDevice,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<DisplayPlaneProperties2KHR>> GetPhysicalDeviceDisplayPlaneProperties2KHR(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayPlaneProperties2KHR>{}, result);
    std::vector<DisplayPlaneProperties2KHR> pProperties(pPropertyCount);
    result = pfn_GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<DisplayModeProperties2KHR>> GetDisplayModeProperties2KHR(PhysicalDevice physicalDevice, 
    DisplayKHR display) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetDisplayModeProperties2KHR(physicalDevice,
        display,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<DisplayModeProperties2KHR>{}, result);
    std::vector<DisplayModeProperties2KHR> pProperties(pPropertyCount);
    result = pfn_GetDisplayModeProperties2KHR(physicalDevice,
        display,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<DisplayPlaneCapabilities2KHR> GetDisplayPlaneCapabilities2KHR(PhysicalDevice physicalDevice, 
    const DisplayPlaneInfo2KHR&  pDisplayPlaneInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DisplayPlaneCapabilities2KHR pCapabilities;
        Result result = pfn_GetDisplayPlaneCapabilities2KHR(physicalDevice,
        &pDisplayPlaneInfo,
        &pCapabilities);
    return expected<DisplayPlaneCapabilities2KHR>(pCapabilities, result);
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
[[nodiscard]] expected<SurfaceKHR> CreateIOSSurfaceMVK(const IOSSurfaceCreateInfoMVK&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateIOSSurfaceMVK(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
[[nodiscard]] expected<SurfaceKHR> CreateMacOSSurfaceMVK(const MacOSSurfaceCreateInfoMVK&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateMacOSSurfaceMVK(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
[[nodiscard]] expected<DebugUtilsMessengerEXT> CreateDebugUtilsMessengerEXT(const DebugUtilsMessengerCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DebugUtilsMessengerEXT pMessenger;
        Result result = pfn_CreateDebugUtilsMessengerEXT(instance,
        &pCreateInfo,
        pAllocator,
        &pMessenger);
    return expected<DebugUtilsMessengerEXT>(pMessenger, result);
}
void DestroyDebugUtilsMessengerEXT(DebugUtilsMessengerEXT messenger = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDebugUtilsMessengerEXT(instance,
        messenger,
        pAllocator);
}
void SubmitDebugUtilsMessageEXT(DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, 
    DebugUtilsMessageTypeFlagsEXT messageTypes, 
    const DebugUtilsMessengerCallbackDataEXT&  pCallbackData) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_SubmitDebugUtilsMessageEXT(instance,
        messageSeverity,
        messageTypes,
        &pCallbackData);
}
[[nodiscard]] MultisamplePropertiesEXT GetPhysicalDeviceMultisamplePropertiesEXT(PhysicalDevice physicalDevice, 
    SampleCountFlagBits samples) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MultisamplePropertiesEXT pMultisampleProperties;
    pfn_GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice,
        samples,
        &pMultisampleProperties);
    return pMultisampleProperties;
}
[[nodiscard]] expected<std::vector<TimeDomainEXT>> GetPhysicalDeviceCalibrateableTimeDomainsEXT(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pTimeDomainCount = 0;
        Result result = pfn_GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice,
        &pTimeDomainCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<TimeDomainEXT>{}, result);
    std::vector<TimeDomainEXT> pTimeDomains(pTimeDomainCount);
    result = pfn_GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice,
        &pTimeDomainCount,
        pTimeDomains.data());
    return expected(std::move(pTimeDomains), result);
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
[[nodiscard]] expected<SurfaceKHR> CreateImagePipeSurfaceFUCHSIA(const ImagePipeSurfaceCreateInfoFUCHSIA&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateImagePipeSurfaceFUCHSIA(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_METAL_EXT)
[[nodiscard]] expected<SurfaceKHR> CreateMetalSurfaceEXT(const MetalSurfaceCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateMetalSurfaceEXT(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
[[nodiscard]] expected<std::vector<PhysicalDeviceFragmentShadingRateKHR>> GetPhysicalDeviceFragmentShadingRatesKHR(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pFragmentShadingRateCount = 0;
        Result result = pfn_GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice,
        &pFragmentShadingRateCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PhysicalDeviceFragmentShadingRateKHR>{}, result);
    std::vector<PhysicalDeviceFragmentShadingRateKHR> pFragmentShadingRates(pFragmentShadingRateCount);
    result = pfn_GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice,
        &pFragmentShadingRateCount,
        pFragmentShadingRates.data());
    return expected(std::move(pFragmentShadingRates), result);
}
[[nodiscard]] expected<std::vector<PhysicalDeviceToolPropertiesEXT>> GetPhysicalDeviceToolPropertiesEXT(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pToolCount = 0;
        Result result = pfn_GetPhysicalDeviceToolPropertiesEXT(physicalDevice,
        &pToolCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PhysicalDeviceToolPropertiesEXT>{}, result);
    std::vector<PhysicalDeviceToolPropertiesEXT> pToolProperties(pToolCount);
    result = pfn_GetPhysicalDeviceToolPropertiesEXT(physicalDevice,
        &pToolCount,
        pToolProperties.data());
    return expected(std::move(pToolProperties), result);
}
[[nodiscard]] expected<std::vector<CooperativeMatrixPropertiesNV>> GetPhysicalDeviceCooperativeMatrixPropertiesNV(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPropertyCount = 0;
        Result result = pfn_GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice,
        &pPropertyCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<CooperativeMatrixPropertiesNV>{}, result);
    std::vector<CooperativeMatrixPropertiesNV> pProperties(pPropertyCount);
    result = pfn_GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice,
        &pPropertyCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<FramebufferMixedSamplesCombinationNV>> GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(PhysicalDevice physicalDevice) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pCombinationCount = 0;
        Result result = pfn_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice,
        &pCombinationCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<FramebufferMixedSamplesCombinationNV>{}, result);
    std::vector<FramebufferMixedSamplesCombinationNV> pCombinations(pCombinationCount);
    result = pfn_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice,
        &pCombinationCount,
        pCombinations.data());
    return expected(std::move(pCombinations), result);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<std::vector<PresentModeKHR>> GetPhysicalDeviceSurfacePresentModes2EXT(PhysicalDevice physicalDevice, 
    const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPresentModeCount = 0;
        Result result = pfn_GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice,
        &pSurfaceInfo,
        &pPresentModeCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PresentModeKHR>{}, result);
    std::vector<PresentModeKHR> pPresentModes(pPresentModeCount);
    result = pfn_GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice,
        &pSurfaceInfo,
        &pPresentModeCount,
        pPresentModes.data());
    return expected(std::move(pPresentModes), result);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<SurfaceKHR> CreateHeadlessSurfaceEXT(const HeadlessSurfaceCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateHeadlessSurfaceEXT(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] Result AcquireWinrtDisplayNV(PhysicalDevice physicalDevice, 
    DisplayKHR display) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_AcquireWinrtDisplayNV(physicalDevice,
        display);
}
[[nodiscard]] expected<DisplayKHR> GetWinrtDisplayNV(PhysicalDevice physicalDevice, 
    uint32_t deviceRelativeId) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DisplayKHR pDisplay;
        Result result = pfn_GetWinrtDisplayNV(physicalDevice,
        deviceRelativeId,
        &pDisplay);
    return expected<DisplayKHR>(pDisplay, result);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
[[nodiscard]] expected<SurfaceKHR> CreateDirectFBSurfaceEXT(const DirectFBSurfaceCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateDirectFBSurfaceEXT(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
[[nodiscard]] expected<IDirectFB> GetPhysicalDeviceDirectFBPresentationSupportEXT(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    IDirectFB dfb;
        Result result = pfn_GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice,
        queueFamilyIndex,
        &dfb);
    return expected<IDirectFB>(dfb, result);
}
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
[[nodiscard]] expected<SurfaceKHR> CreateScreenSurfaceQNX(const ScreenSurfaceCreateInfoQNX&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SurfaceKHR pSurface;
        Result result = pfn_CreateScreenSurfaceQNX(instance,
        &pCreateInfo,
        pAllocator,
        &pSurface);
    return expected<SurfaceKHR>(pSurface, result);
}
[[nodiscard]] expected<_screen_window> GetPhysicalDeviceScreenPresentationSupportQNX(PhysicalDevice physicalDevice, 
    uint32_t queueFamilyIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    _screen_window window;
        Result result = pfn_GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice,
        queueFamilyIndex,
        &window);
    return expected<_screen_window>(window, result);
}
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
InstanceFunctions() noexcept {}
explicit InstanceFunctions(GlobalFunctions const& global_functions, Instance instance) noexcept 
    :instance(instance) { 
    detail::PFN_GetInstanceProcAddr get_instance_proc_addr = global_functions.pfn_GetInstanceProcAddr;
    pfn_DestroyInstance = reinterpret_cast<detail::PFN_DestroyInstance>(get_instance_proc_addr(instance,"vkDestroyInstance"));
    pfn_EnumeratePhysicalDevices = reinterpret_cast<detail::PFN_EnumeratePhysicalDevices>(get_instance_proc_addr(instance,"vkEnumeratePhysicalDevices"));
    pfn_GetDeviceProcAddr = reinterpret_cast<detail::PFN_GetDeviceProcAddr>(get_instance_proc_addr(instance,"vkGetDeviceProcAddr"));
    pfn_GetInstanceProcAddr = reinterpret_cast<detail::PFN_GetInstanceProcAddr>(get_instance_proc_addr(instance,"vkGetInstanceProcAddr"));
    pfn_GetPhysicalDeviceProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceProperties"));
    pfn_GetPhysicalDeviceQueueFamilyProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceQueueFamilyProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceQueueFamilyProperties"));
    pfn_GetPhysicalDeviceMemoryProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceMemoryProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceMemoryProperties"));
    pfn_GetPhysicalDeviceFeatures = reinterpret_cast<detail::PFN_GetPhysicalDeviceFeatures>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceFeatures"));
    pfn_GetPhysicalDeviceFormatProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceFormatProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceFormatProperties"));
    pfn_GetPhysicalDeviceImageFormatProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceImageFormatProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceImageFormatProperties"));
    pfn_CreateDevice = reinterpret_cast<detail::PFN_CreateDevice>(get_instance_proc_addr(instance,"vkCreateDevice"));
    pfn_EnumerateDeviceExtensionProperties = reinterpret_cast<detail::PFN_EnumerateDeviceExtensionProperties>(get_instance_proc_addr(instance,"vkEnumerateDeviceExtensionProperties"));
    pfn_GetPhysicalDeviceSparseImageFormatProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceSparseImageFormatProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSparseImageFormatProperties"));
    pfn_EnumeratePhysicalDeviceGroups = reinterpret_cast<detail::PFN_EnumeratePhysicalDeviceGroups>(get_instance_proc_addr(instance,"vkEnumeratePhysicalDeviceGroups"));
    pfn_GetPhysicalDeviceFeatures2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceFeatures2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceFeatures2"));
    pfn_GetPhysicalDeviceProperties2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceProperties2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceProperties2"));
    pfn_GetPhysicalDeviceFormatProperties2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceFormatProperties2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceFormatProperties2"));
    pfn_GetPhysicalDeviceImageFormatProperties2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceImageFormatProperties2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceImageFormatProperties2"));
    pfn_GetPhysicalDeviceQueueFamilyProperties2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceQueueFamilyProperties2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceQueueFamilyProperties2"));
    pfn_GetPhysicalDeviceMemoryProperties2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceMemoryProperties2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceMemoryProperties2"));
    pfn_GetPhysicalDeviceSparseImageFormatProperties2 = reinterpret_cast<detail::PFN_GetPhysicalDeviceSparseImageFormatProperties2>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSparseImageFormatProperties2"));
    pfn_GetPhysicalDeviceExternalBufferProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceExternalBufferProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceExternalBufferProperties"));
    pfn_GetPhysicalDeviceExternalFenceProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceExternalFenceProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceExternalFenceProperties"));
    pfn_GetPhysicalDeviceExternalSemaphoreProperties = reinterpret_cast<detail::PFN_GetPhysicalDeviceExternalSemaphoreProperties>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceExternalSemaphoreProperties"));
    pfn_DestroySurfaceKHR = reinterpret_cast<detail::PFN_DestroySurfaceKHR>(get_instance_proc_addr(instance,"vkDestroySurfaceKHR"));
    pfn_GetPhysicalDeviceSurfaceSupportKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfaceSupportKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfaceSupportKHR"));
    pfn_GetPhysicalDeviceSurfaceCapabilitiesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfaceCapabilitiesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR"));
    pfn_GetPhysicalDeviceSurfaceFormatsKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfaceFormatsKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfaceFormatsKHR"));
    pfn_GetPhysicalDeviceSurfacePresentModesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfacePresentModesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfacePresentModesKHR"));
    pfn_GetPhysicalDevicePresentRectanglesKHR = reinterpret_cast<detail::PFN_GetPhysicalDevicePresentRectanglesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDevicePresentRectanglesKHR"));
    pfn_GetPhysicalDeviceDisplayPropertiesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceDisplayPropertiesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceDisplayPropertiesKHR"));
    pfn_GetPhysicalDeviceDisplayPlanePropertiesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceDisplayPlanePropertiesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR"));
    pfn_GetDisplayPlaneSupportedDisplaysKHR = reinterpret_cast<detail::PFN_GetDisplayPlaneSupportedDisplaysKHR>(get_instance_proc_addr(instance,"vkGetDisplayPlaneSupportedDisplaysKHR"));
    pfn_GetDisplayModePropertiesKHR = reinterpret_cast<detail::PFN_GetDisplayModePropertiesKHR>(get_instance_proc_addr(instance,"vkGetDisplayModePropertiesKHR"));
    pfn_CreateDisplayModeKHR = reinterpret_cast<detail::PFN_CreateDisplayModeKHR>(get_instance_proc_addr(instance,"vkCreateDisplayModeKHR"));
    pfn_GetDisplayPlaneCapabilitiesKHR = reinterpret_cast<detail::PFN_GetDisplayPlaneCapabilitiesKHR>(get_instance_proc_addr(instance,"vkGetDisplayPlaneCapabilitiesKHR"));
    pfn_CreateDisplayPlaneSurfaceKHR = reinterpret_cast<detail::PFN_CreateDisplayPlaneSurfaceKHR>(get_instance_proc_addr(instance,"vkCreateDisplayPlaneSurfaceKHR"));
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    pfn_CreateXlibSurfaceKHR = reinterpret_cast<detail::PFN_CreateXlibSurfaceKHR>(get_instance_proc_addr(instance,"vkCreateXlibSurfaceKHR"));
    pfn_GetPhysicalDeviceXlibPresentationSupportKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceXlibPresentationSupportKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceXlibPresentationSupportKHR"));
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
    pfn_CreateXcbSurfaceKHR = reinterpret_cast<detail::PFN_CreateXcbSurfaceKHR>(get_instance_proc_addr(instance,"vkCreateXcbSurfaceKHR"));
    pfn_GetPhysicalDeviceXcbPresentationSupportKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceXcbPresentationSupportKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceXcbPresentationSupportKHR"));
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    pfn_CreateWaylandSurfaceKHR = reinterpret_cast<detail::PFN_CreateWaylandSurfaceKHR>(get_instance_proc_addr(instance,"vkCreateWaylandSurfaceKHR"));
    pfn_GetPhysicalDeviceWaylandPresentationSupportKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceWaylandPresentationSupportKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceWaylandPresentationSupportKHR"));
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    pfn_CreateAndroidSurfaceKHR = reinterpret_cast<detail::PFN_CreateAndroidSurfaceKHR>(get_instance_proc_addr(instance,"vkCreateAndroidSurfaceKHR"));
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_CreateWin32SurfaceKHR = reinterpret_cast<detail::PFN_CreateWin32SurfaceKHR>(get_instance_proc_addr(instance,"vkCreateWin32SurfaceKHR"));
    pfn_GetPhysicalDeviceWin32PresentationSupportKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceWin32PresentationSupportKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceWin32PresentationSupportKHR"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_CreateDebugReportCallbackEXT = reinterpret_cast<detail::PFN_CreateDebugReportCallbackEXT>(get_instance_proc_addr(instance,"vkCreateDebugReportCallbackEXT"));
    pfn_DestroyDebugReportCallbackEXT = reinterpret_cast<detail::PFN_DestroyDebugReportCallbackEXT>(get_instance_proc_addr(instance,"vkDestroyDebugReportCallbackEXT"));
    pfn_DebugReportMessageEXT = reinterpret_cast<detail::PFN_DebugReportMessageEXT>(get_instance_proc_addr(instance,"vkDebugReportMessageEXT"));
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    pfn_GetPhysicalDeviceVideoCapabilitiesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceVideoCapabilitiesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceVideoCapabilitiesKHR"));
    pfn_GetPhysicalDeviceVideoFormatPropertiesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceVideoFormatPropertiesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceVideoFormatPropertiesKHR"));
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
#if defined(VK_USE_PLATFORM_GGP)
    pfn_CreateStreamDescriptorSurfaceGGP = reinterpret_cast<detail::PFN_CreateStreamDescriptorSurfaceGGP>(get_instance_proc_addr(instance,"vkCreateStreamDescriptorSurfaceGGP"));
#endif // defined(VK_USE_PLATFORM_GGP)
    pfn_GetPhysicalDeviceExternalImageFormatPropertiesNV = reinterpret_cast<detail::PFN_GetPhysicalDeviceExternalImageFormatPropertiesNV>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV"));
#if defined(VK_USE_PLATFORM_VI_NN)
    pfn_CreateViSurfaceNN = reinterpret_cast<detail::PFN_CreateViSurfaceNN>(get_instance_proc_addr(instance,"vkCreateViSurfaceNN"));
#endif // defined(VK_USE_PLATFORM_VI_NN)
    pfn_ReleaseDisplayEXT = reinterpret_cast<detail::PFN_ReleaseDisplayEXT>(get_instance_proc_addr(instance,"vkReleaseDisplayEXT"));
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    pfn_AcquireXlibDisplayEXT = reinterpret_cast<detail::PFN_AcquireXlibDisplayEXT>(get_instance_proc_addr(instance,"vkAcquireXlibDisplayEXT"));
    pfn_GetRandROutputDisplayEXT = reinterpret_cast<detail::PFN_GetRandROutputDisplayEXT>(get_instance_proc_addr(instance,"vkGetRandROutputDisplayEXT"));
#endif // defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    pfn_GetPhysicalDeviceSurfaceCapabilities2EXT = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfaceCapabilities2EXT>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfaceCapabilities2EXT"));
    pfn_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = reinterpret_cast<detail::PFN_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR>(get_instance_proc_addr(instance,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"));
    pfn_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"));
    pfn_GetPhysicalDeviceSurfaceCapabilities2KHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfaceCapabilities2KHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfaceCapabilities2KHR"));
    pfn_GetPhysicalDeviceSurfaceFormats2KHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfaceFormats2KHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfaceFormats2KHR"));
    pfn_GetPhysicalDeviceDisplayProperties2KHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceDisplayProperties2KHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceDisplayProperties2KHR"));
    pfn_GetPhysicalDeviceDisplayPlaneProperties2KHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceDisplayPlaneProperties2KHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR"));
    pfn_GetDisplayModeProperties2KHR = reinterpret_cast<detail::PFN_GetDisplayModeProperties2KHR>(get_instance_proc_addr(instance,"vkGetDisplayModeProperties2KHR"));
    pfn_GetDisplayPlaneCapabilities2KHR = reinterpret_cast<detail::PFN_GetDisplayPlaneCapabilities2KHR>(get_instance_proc_addr(instance,"vkGetDisplayPlaneCapabilities2KHR"));
#if defined(VK_USE_PLATFORM_IOS_MVK)
    pfn_CreateIOSSurfaceMVK = reinterpret_cast<detail::PFN_CreateIOSSurfaceMVK>(get_instance_proc_addr(instance,"vkCreateIOSSurfaceMVK"));
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    pfn_CreateMacOSSurfaceMVK = reinterpret_cast<detail::PFN_CreateMacOSSurfaceMVK>(get_instance_proc_addr(instance,"vkCreateMacOSSurfaceMVK"));
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
    pfn_CreateDebugUtilsMessengerEXT = reinterpret_cast<detail::PFN_CreateDebugUtilsMessengerEXT>(get_instance_proc_addr(instance,"vkCreateDebugUtilsMessengerEXT"));
    pfn_DestroyDebugUtilsMessengerEXT = reinterpret_cast<detail::PFN_DestroyDebugUtilsMessengerEXT>(get_instance_proc_addr(instance,"vkDestroyDebugUtilsMessengerEXT"));
    pfn_SubmitDebugUtilsMessageEXT = reinterpret_cast<detail::PFN_SubmitDebugUtilsMessageEXT>(get_instance_proc_addr(instance,"vkSubmitDebugUtilsMessageEXT"));
    pfn_GetPhysicalDeviceMultisamplePropertiesEXT = reinterpret_cast<detail::PFN_GetPhysicalDeviceMultisamplePropertiesEXT>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceMultisamplePropertiesEXT"));
    pfn_GetPhysicalDeviceCalibrateableTimeDomainsEXT = reinterpret_cast<detail::PFN_GetPhysicalDeviceCalibrateableTimeDomainsEXT>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"));
#if defined(VK_USE_PLATFORM_FUCHSIA)
    pfn_CreateImagePipeSurfaceFUCHSIA = reinterpret_cast<detail::PFN_CreateImagePipeSurfaceFUCHSIA>(get_instance_proc_addr(instance,"vkCreateImagePipeSurfaceFUCHSIA"));
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_METAL_EXT)
    pfn_CreateMetalSurfaceEXT = reinterpret_cast<detail::PFN_CreateMetalSurfaceEXT>(get_instance_proc_addr(instance,"vkCreateMetalSurfaceEXT"));
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
    pfn_GetPhysicalDeviceFragmentShadingRatesKHR = reinterpret_cast<detail::PFN_GetPhysicalDeviceFragmentShadingRatesKHR>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceFragmentShadingRatesKHR"));
    pfn_GetPhysicalDeviceToolPropertiesEXT = reinterpret_cast<detail::PFN_GetPhysicalDeviceToolPropertiesEXT>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceToolPropertiesEXT"));
    pfn_GetPhysicalDeviceCooperativeMatrixPropertiesNV = reinterpret_cast<detail::PFN_GetPhysicalDeviceCooperativeMatrixPropertiesNV>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"));
    pfn_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = reinterpret_cast<detail::PFN_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"));
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetPhysicalDeviceSurfacePresentModes2EXT = reinterpret_cast<detail::PFN_GetPhysicalDeviceSurfacePresentModes2EXT>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceSurfacePresentModes2EXT"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_CreateHeadlessSurfaceEXT = reinterpret_cast<detail::PFN_CreateHeadlessSurfaceEXT>(get_instance_proc_addr(instance,"vkCreateHeadlessSurfaceEXT"));
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_AcquireWinrtDisplayNV = reinterpret_cast<detail::PFN_AcquireWinrtDisplayNV>(get_instance_proc_addr(instance,"vkAcquireWinrtDisplayNV"));
    pfn_GetWinrtDisplayNV = reinterpret_cast<detail::PFN_GetWinrtDisplayNV>(get_instance_proc_addr(instance,"vkGetWinrtDisplayNV"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    pfn_CreateDirectFBSurfaceEXT = reinterpret_cast<detail::PFN_CreateDirectFBSurfaceEXT>(get_instance_proc_addr(instance,"vkCreateDirectFBSurfaceEXT"));
    pfn_GetPhysicalDeviceDirectFBPresentationSupportEXT = reinterpret_cast<detail::PFN_GetPhysicalDeviceDirectFBPresentationSupportEXT>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceDirectFBPresentationSupportEXT"));
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    pfn_CreateScreenSurfaceQNX = reinterpret_cast<detail::PFN_CreateScreenSurfaceQNX>(get_instance_proc_addr(instance,"vkCreateScreenSurfaceQNX"));
    pfn_GetPhysicalDeviceScreenPresentationSupportQNX = reinterpret_cast<detail::PFN_GetPhysicalDeviceScreenPresentationSupportQNX>(get_instance_proc_addr(instance,"vkGetPhysicalDeviceScreenPresentationSupportQNX"));
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
}
};
struct DeviceFunctions {
    Device device;
    detail::PFN_DestroyDevice pfn_DestroyDevice = nullptr;
    detail::PFN_GetDeviceQueue pfn_GetDeviceQueue = nullptr;
    detail::PFN_QueueSubmit pfn_QueueSubmit = nullptr;
    detail::PFN_QueueWaitIdle pfn_QueueWaitIdle = nullptr;
    detail::PFN_DeviceWaitIdle pfn_DeviceWaitIdle = nullptr;
    detail::PFN_AllocateMemory pfn_AllocateMemory = nullptr;
    detail::PFN_FreeMemory pfn_FreeMemory = nullptr;
    detail::PFN_MapMemory pfn_MapMemory = nullptr;
    detail::PFN_UnmapMemory pfn_UnmapMemory = nullptr;
    detail::PFN_FlushMappedMemoryRanges pfn_FlushMappedMemoryRanges = nullptr;
    detail::PFN_InvalidateMappedMemoryRanges pfn_InvalidateMappedMemoryRanges = nullptr;
    detail::PFN_GetDeviceMemoryCommitment pfn_GetDeviceMemoryCommitment = nullptr;
    detail::PFN_GetBufferMemoryRequirements pfn_GetBufferMemoryRequirements = nullptr;
    detail::PFN_BindBufferMemory pfn_BindBufferMemory = nullptr;
    detail::PFN_GetImageMemoryRequirements pfn_GetImageMemoryRequirements = nullptr;
    detail::PFN_BindImageMemory pfn_BindImageMemory = nullptr;
    detail::PFN_GetImageSparseMemoryRequirements pfn_GetImageSparseMemoryRequirements = nullptr;
    detail::PFN_QueueBindSparse pfn_QueueBindSparse = nullptr;
    detail::PFN_CreateFence pfn_CreateFence = nullptr;
    detail::PFN_DestroyFence pfn_DestroyFence = nullptr;
    detail::PFN_ResetFences pfn_ResetFences = nullptr;
    detail::PFN_GetFenceStatus pfn_GetFenceStatus = nullptr;
    detail::PFN_WaitForFences pfn_WaitForFences = nullptr;
    detail::PFN_CreateSemaphore pfn_CreateSemaphore = nullptr;
    detail::PFN_DestroySemaphore pfn_DestroySemaphore = nullptr;
    detail::PFN_CreateEvent pfn_CreateEvent = nullptr;
    detail::PFN_DestroyEvent pfn_DestroyEvent = nullptr;
    detail::PFN_GetEventStatus pfn_GetEventStatus = nullptr;
    detail::PFN_SetEvent pfn_SetEvent = nullptr;
    detail::PFN_ResetEvent pfn_ResetEvent = nullptr;
    detail::PFN_CreateQueryPool pfn_CreateQueryPool = nullptr;
    detail::PFN_DestroyQueryPool pfn_DestroyQueryPool = nullptr;
    detail::PFN_GetQueryPoolResults pfn_GetQueryPoolResults = nullptr;
    detail::PFN_CreateBuffer pfn_CreateBuffer = nullptr;
    detail::PFN_DestroyBuffer pfn_DestroyBuffer = nullptr;
    detail::PFN_CreateBufferView pfn_CreateBufferView = nullptr;
    detail::PFN_DestroyBufferView pfn_DestroyBufferView = nullptr;
    detail::PFN_CreateImage pfn_CreateImage = nullptr;
    detail::PFN_DestroyImage pfn_DestroyImage = nullptr;
    detail::PFN_GetImageSubresourceLayout pfn_GetImageSubresourceLayout = nullptr;
    detail::PFN_CreateImageView pfn_CreateImageView = nullptr;
    detail::PFN_DestroyImageView pfn_DestroyImageView = nullptr;
    detail::PFN_CreateShaderModule pfn_CreateShaderModule = nullptr;
    detail::PFN_DestroyShaderModule pfn_DestroyShaderModule = nullptr;
    detail::PFN_CreatePipelineCache pfn_CreatePipelineCache = nullptr;
    detail::PFN_DestroyPipelineCache pfn_DestroyPipelineCache = nullptr;
    detail::PFN_GetPipelineCacheData pfn_GetPipelineCacheData = nullptr;
    detail::PFN_MergePipelineCaches pfn_MergePipelineCaches = nullptr;
    detail::PFN_CreateGraphicsPipelines pfn_CreateGraphicsPipelines = nullptr;
    detail::PFN_CreateComputePipelines pfn_CreateComputePipelines = nullptr;
    detail::PFN_DestroyPipeline pfn_DestroyPipeline = nullptr;
    detail::PFN_CreatePipelineLayout pfn_CreatePipelineLayout = nullptr;
    detail::PFN_DestroyPipelineLayout pfn_DestroyPipelineLayout = nullptr;
    detail::PFN_CreateSampler pfn_CreateSampler = nullptr;
    detail::PFN_DestroySampler pfn_DestroySampler = nullptr;
    detail::PFN_CreateDescriptorSetLayout pfn_CreateDescriptorSetLayout = nullptr;
    detail::PFN_DestroyDescriptorSetLayout pfn_DestroyDescriptorSetLayout = nullptr;
    detail::PFN_CreateDescriptorPool pfn_CreateDescriptorPool = nullptr;
    detail::PFN_DestroyDescriptorPool pfn_DestroyDescriptorPool = nullptr;
    detail::PFN_ResetDescriptorPool pfn_ResetDescriptorPool = nullptr;
    detail::PFN_AllocateDescriptorSets pfn_AllocateDescriptorSets = nullptr;
    detail::PFN_FreeDescriptorSets pfn_FreeDescriptorSets = nullptr;
    detail::PFN_UpdateDescriptorSets pfn_UpdateDescriptorSets = nullptr;
    detail::PFN_CreateFramebuffer pfn_CreateFramebuffer = nullptr;
    detail::PFN_DestroyFramebuffer pfn_DestroyFramebuffer = nullptr;
    detail::PFN_CreateRenderPass pfn_CreateRenderPass = nullptr;
    detail::PFN_DestroyRenderPass pfn_DestroyRenderPass = nullptr;
    detail::PFN_GetRenderAreaGranularity pfn_GetRenderAreaGranularity = nullptr;
    detail::PFN_CreateCommandPool pfn_CreateCommandPool = nullptr;
    detail::PFN_DestroyCommandPool pfn_DestroyCommandPool = nullptr;
    detail::PFN_ResetCommandPool pfn_ResetCommandPool = nullptr;
    detail::PFN_AllocateCommandBuffers pfn_AllocateCommandBuffers = nullptr;
    detail::PFN_FreeCommandBuffers pfn_FreeCommandBuffers = nullptr;
    detail::PFN_BeginCommandBuffer pfn_BeginCommandBuffer = nullptr;
    detail::PFN_EndCommandBuffer pfn_EndCommandBuffer = nullptr;
    detail::PFN_ResetCommandBuffer pfn_ResetCommandBuffer = nullptr;
    detail::PFN_CmdBindPipeline pfn_CmdBindPipeline = nullptr;
    detail::PFN_CmdSetViewport pfn_CmdSetViewport = nullptr;
    detail::PFN_CmdSetScissor pfn_CmdSetScissor = nullptr;
    detail::PFN_CmdSetLineWidth pfn_CmdSetLineWidth = nullptr;
    detail::PFN_CmdSetDepthBias pfn_CmdSetDepthBias = nullptr;
    detail::PFN_CmdSetBlendConstants pfn_CmdSetBlendConstants = nullptr;
    detail::PFN_CmdSetDepthBounds pfn_CmdSetDepthBounds = nullptr;
    detail::PFN_CmdSetStencilCompareMask pfn_CmdSetStencilCompareMask = nullptr;
    detail::PFN_CmdSetStencilWriteMask pfn_CmdSetStencilWriteMask = nullptr;
    detail::PFN_CmdSetStencilReference pfn_CmdSetStencilReference = nullptr;
    detail::PFN_CmdBindDescriptorSets pfn_CmdBindDescriptorSets = nullptr;
    detail::PFN_CmdBindIndexBuffer pfn_CmdBindIndexBuffer = nullptr;
    detail::PFN_CmdBindVertexBuffers pfn_CmdBindVertexBuffers = nullptr;
    detail::PFN_CmdDraw pfn_CmdDraw = nullptr;
    detail::PFN_CmdDrawIndexed pfn_CmdDrawIndexed = nullptr;
    detail::PFN_CmdDrawIndirect pfn_CmdDrawIndirect = nullptr;
    detail::PFN_CmdDrawIndexedIndirect pfn_CmdDrawIndexedIndirect = nullptr;
    detail::PFN_CmdDispatch pfn_CmdDispatch = nullptr;
    detail::PFN_CmdDispatchIndirect pfn_CmdDispatchIndirect = nullptr;
    detail::PFN_CmdCopyBuffer pfn_CmdCopyBuffer = nullptr;
    detail::PFN_CmdCopyImage pfn_CmdCopyImage = nullptr;
    detail::PFN_CmdBlitImage pfn_CmdBlitImage = nullptr;
    detail::PFN_CmdCopyBufferToImage pfn_CmdCopyBufferToImage = nullptr;
    detail::PFN_CmdCopyImageToBuffer pfn_CmdCopyImageToBuffer = nullptr;
    detail::PFN_CmdUpdateBuffer pfn_CmdUpdateBuffer = nullptr;
    detail::PFN_CmdFillBuffer pfn_CmdFillBuffer = nullptr;
    detail::PFN_CmdClearColorImage pfn_CmdClearColorImage = nullptr;
    detail::PFN_CmdClearDepthStencilImage pfn_CmdClearDepthStencilImage = nullptr;
    detail::PFN_CmdClearAttachments pfn_CmdClearAttachments = nullptr;
    detail::PFN_CmdResolveImage pfn_CmdResolveImage = nullptr;
    detail::PFN_CmdSetEvent pfn_CmdSetEvent = nullptr;
    detail::PFN_CmdResetEvent pfn_CmdResetEvent = nullptr;
    detail::PFN_CmdWaitEvents pfn_CmdWaitEvents = nullptr;
    detail::PFN_CmdPipelineBarrier pfn_CmdPipelineBarrier = nullptr;
    detail::PFN_CmdBeginQuery pfn_CmdBeginQuery = nullptr;
    detail::PFN_CmdEndQuery pfn_CmdEndQuery = nullptr;
    detail::PFN_CmdResetQueryPool pfn_CmdResetQueryPool = nullptr;
    detail::PFN_CmdWriteTimestamp pfn_CmdWriteTimestamp = nullptr;
    detail::PFN_CmdCopyQueryPoolResults pfn_CmdCopyQueryPoolResults = nullptr;
    detail::PFN_CmdPushConstants pfn_CmdPushConstants = nullptr;
    detail::PFN_CmdBeginRenderPass pfn_CmdBeginRenderPass = nullptr;
    detail::PFN_CmdNextSubpass pfn_CmdNextSubpass = nullptr;
    detail::PFN_CmdEndRenderPass pfn_CmdEndRenderPass = nullptr;
    detail::PFN_CmdExecuteCommands pfn_CmdExecuteCommands = nullptr;
    detail::PFN_BindBufferMemory2 pfn_BindBufferMemory2 = nullptr;
    detail::PFN_BindImageMemory2 pfn_BindImageMemory2 = nullptr;
    detail::PFN_GetDeviceGroupPeerMemoryFeatures pfn_GetDeviceGroupPeerMemoryFeatures = nullptr;
    detail::PFN_CmdSetDeviceMask pfn_CmdSetDeviceMask = nullptr;
    detail::PFN_CmdDispatchBase pfn_CmdDispatchBase = nullptr;
    detail::PFN_GetBufferMemoryRequirements2 pfn_GetBufferMemoryRequirements2 = nullptr;
    detail::PFN_GetImageMemoryRequirements2 pfn_GetImageMemoryRequirements2 = nullptr;
    detail::PFN_GetImageSparseMemoryRequirements2 pfn_GetImageSparseMemoryRequirements2 = nullptr;
    detail::PFN_TrimCommandPool pfn_TrimCommandPool = nullptr;
    detail::PFN_GetDeviceQueue2 pfn_GetDeviceQueue2 = nullptr;
    detail::PFN_CreateSamplerYcbcrConversion pfn_CreateSamplerYcbcrConversion = nullptr;
    detail::PFN_DestroySamplerYcbcrConversion pfn_DestroySamplerYcbcrConversion = nullptr;
    detail::PFN_CreateDescriptorUpdateTemplate pfn_CreateDescriptorUpdateTemplate = nullptr;
    detail::PFN_DestroyDescriptorUpdateTemplate pfn_DestroyDescriptorUpdateTemplate = nullptr;
    detail::PFN_UpdateDescriptorSetWithTemplate pfn_UpdateDescriptorSetWithTemplate = nullptr;
    detail::PFN_GetDescriptorSetLayoutSupport pfn_GetDescriptorSetLayoutSupport = nullptr;
    detail::PFN_CmdDrawIndirectCount pfn_CmdDrawIndirectCount = nullptr;
    detail::PFN_CmdDrawIndexedIndirectCount pfn_CmdDrawIndexedIndirectCount = nullptr;
    detail::PFN_CreateRenderPass2 pfn_CreateRenderPass2 = nullptr;
    detail::PFN_CmdBeginRenderPass2 pfn_CmdBeginRenderPass2 = nullptr;
    detail::PFN_CmdNextSubpass2 pfn_CmdNextSubpass2 = nullptr;
    detail::PFN_CmdEndRenderPass2 pfn_CmdEndRenderPass2 = nullptr;
    detail::PFN_ResetQueryPool pfn_ResetQueryPool = nullptr;
    detail::PFN_GetSemaphoreCounterValue pfn_GetSemaphoreCounterValue = nullptr;
    detail::PFN_WaitSemaphores pfn_WaitSemaphores = nullptr;
    detail::PFN_SignalSemaphore pfn_SignalSemaphore = nullptr;
    detail::PFN_GetBufferOpaqueCaptureAddress pfn_GetBufferOpaqueCaptureAddress = nullptr;
    detail::PFN_GetBufferDeviceAddress pfn_GetBufferDeviceAddress = nullptr;
    detail::PFN_GetDeviceMemoryOpaqueCaptureAddress pfn_GetDeviceMemoryOpaqueCaptureAddress = nullptr;
    detail::PFN_CreateSwapchainKHR pfn_CreateSwapchainKHR = nullptr;
    detail::PFN_DestroySwapchainKHR pfn_DestroySwapchainKHR = nullptr;
    detail::PFN_GetSwapchainImagesKHR pfn_GetSwapchainImagesKHR = nullptr;
    detail::PFN_AcquireNextImageKHR pfn_AcquireNextImageKHR = nullptr;
    detail::PFN_QueuePresentKHR pfn_QueuePresentKHR = nullptr;
    detail::PFN_GetDeviceGroupPresentCapabilitiesKHR pfn_GetDeviceGroupPresentCapabilitiesKHR = nullptr;
    detail::PFN_GetDeviceGroupSurfacePresentModesKHR pfn_GetDeviceGroupSurfacePresentModesKHR = nullptr;
    detail::PFN_AcquireNextImage2KHR pfn_AcquireNextImage2KHR = nullptr;
    detail::PFN_CreateSharedSwapchainsKHR pfn_CreateSharedSwapchainsKHR = nullptr;
    detail::PFN_DebugMarkerSetObjectNameEXT pfn_DebugMarkerSetObjectNameEXT = nullptr;
    detail::PFN_DebugMarkerSetObjectTagEXT pfn_DebugMarkerSetObjectTagEXT = nullptr;
    detail::PFN_CmdDebugMarkerBeginEXT pfn_CmdDebugMarkerBeginEXT = nullptr;
    detail::PFN_CmdDebugMarkerEndEXT pfn_CmdDebugMarkerEndEXT = nullptr;
    detail::PFN_CmdDebugMarkerInsertEXT pfn_CmdDebugMarkerInsertEXT = nullptr;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    detail::PFN_CreateVideoSessionKHR pfn_CreateVideoSessionKHR = nullptr;
    detail::PFN_DestroyVideoSessionKHR pfn_DestroyVideoSessionKHR = nullptr;
    detail::PFN_CreateVideoSessionParametersKHR pfn_CreateVideoSessionParametersKHR = nullptr;
    detail::PFN_UpdateVideoSessionParametersKHR pfn_UpdateVideoSessionParametersKHR = nullptr;
    detail::PFN_DestroyVideoSessionParametersKHR pfn_DestroyVideoSessionParametersKHR = nullptr;
    detail::PFN_GetVideoSessionMemoryRequirementsKHR pfn_GetVideoSessionMemoryRequirementsKHR = nullptr;
    detail::PFN_BindVideoSessionMemoryKHR pfn_BindVideoSessionMemoryKHR = nullptr;
    detail::PFN_CmdBeginVideoCodingKHR pfn_CmdBeginVideoCodingKHR = nullptr;
    detail::PFN_CmdControlVideoCodingKHR pfn_CmdControlVideoCodingKHR = nullptr;
    detail::PFN_CmdEndVideoCodingKHR pfn_CmdEndVideoCodingKHR = nullptr;
    detail::PFN_CmdDecodeVideoKHR pfn_CmdDecodeVideoKHR = nullptr;
    detail::PFN_CmdEncodeVideoKHR pfn_CmdEncodeVideoKHR = nullptr;
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
    detail::PFN_CmdBindTransformFeedbackBuffersEXT pfn_CmdBindTransformFeedbackBuffersEXT = nullptr;
    detail::PFN_CmdBeginTransformFeedbackEXT pfn_CmdBeginTransformFeedbackEXT = nullptr;
    detail::PFN_CmdEndTransformFeedbackEXT pfn_CmdEndTransformFeedbackEXT = nullptr;
    detail::PFN_CmdBeginQueryIndexedEXT pfn_CmdBeginQueryIndexedEXT = nullptr;
    detail::PFN_CmdEndQueryIndexedEXT pfn_CmdEndQueryIndexedEXT = nullptr;
    detail::PFN_CmdDrawIndirectByteCountEXT pfn_CmdDrawIndirectByteCountEXT = nullptr;
    detail::PFN_GetImageViewHandleNVX pfn_GetImageViewHandleNVX = nullptr;
    detail::PFN_GetImageViewAddressNVX pfn_GetImageViewAddressNVX = nullptr;
    detail::PFN_GetShaderInfoAMD pfn_GetShaderInfoAMD = nullptr;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetMemoryWin32HandleNV pfn_GetMemoryWin32HandleNV = nullptr;
    detail::PFN_GetMemoryWin32HandleKHR pfn_GetMemoryWin32HandleKHR = nullptr;
    detail::PFN_GetMemoryWin32HandlePropertiesKHR pfn_GetMemoryWin32HandlePropertiesKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetMemoryFdKHR pfn_GetMemoryFdKHR = nullptr;
    detail::PFN_GetMemoryFdPropertiesKHR pfn_GetMemoryFdPropertiesKHR = nullptr;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetSemaphoreWin32HandleKHR pfn_GetSemaphoreWin32HandleKHR = nullptr;
    detail::PFN_ImportSemaphoreWin32HandleKHR pfn_ImportSemaphoreWin32HandleKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetSemaphoreFdKHR pfn_GetSemaphoreFdKHR = nullptr;
    detail::PFN_ImportSemaphoreFdKHR pfn_ImportSemaphoreFdKHR = nullptr;
    detail::PFN_CmdPushDescriptorSetKHR pfn_CmdPushDescriptorSetKHR = nullptr;
    detail::PFN_CmdPushDescriptorSetWithTemplateKHR pfn_CmdPushDescriptorSetWithTemplateKHR = nullptr;
    detail::PFN_CmdBeginConditionalRenderingEXT pfn_CmdBeginConditionalRenderingEXT = nullptr;
    detail::PFN_CmdEndConditionalRenderingEXT pfn_CmdEndConditionalRenderingEXT = nullptr;
    detail::PFN_CmdSetViewportWScalingNV pfn_CmdSetViewportWScalingNV = nullptr;
    detail::PFN_DisplayPowerControlEXT pfn_DisplayPowerControlEXT = nullptr;
    detail::PFN_RegisterDeviceEventEXT pfn_RegisterDeviceEventEXT = nullptr;
    detail::PFN_RegisterDisplayEventEXT pfn_RegisterDisplayEventEXT = nullptr;
    detail::PFN_GetSwapchainCounterEXT pfn_GetSwapchainCounterEXT = nullptr;
    detail::PFN_GetRefreshCycleDurationGOOGLE pfn_GetRefreshCycleDurationGOOGLE = nullptr;
    detail::PFN_GetPastPresentationTimingGOOGLE pfn_GetPastPresentationTimingGOOGLE = nullptr;
    detail::PFN_CmdSetDiscardRectangleEXT pfn_CmdSetDiscardRectangleEXT = nullptr;
    detail::PFN_SetHdrMetadataEXT pfn_SetHdrMetadataEXT = nullptr;
    detail::PFN_GetSwapchainStatusKHR pfn_GetSwapchainStatusKHR = nullptr;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetFenceWin32HandleKHR pfn_GetFenceWin32HandleKHR = nullptr;
    detail::PFN_ImportFenceWin32HandleKHR pfn_ImportFenceWin32HandleKHR = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_GetFenceFdKHR pfn_GetFenceFdKHR = nullptr;
    detail::PFN_ImportFenceFdKHR pfn_ImportFenceFdKHR = nullptr;
    detail::PFN_AcquireProfilingLockKHR pfn_AcquireProfilingLockKHR = nullptr;
    detail::PFN_ReleaseProfilingLockKHR pfn_ReleaseProfilingLockKHR = nullptr;
    detail::PFN_SetDebugUtilsObjectNameEXT pfn_SetDebugUtilsObjectNameEXT = nullptr;
    detail::PFN_SetDebugUtilsObjectTagEXT pfn_SetDebugUtilsObjectTagEXT = nullptr;
    detail::PFN_QueueBeginDebugUtilsLabelEXT pfn_QueueBeginDebugUtilsLabelEXT = nullptr;
    detail::PFN_QueueEndDebugUtilsLabelEXT pfn_QueueEndDebugUtilsLabelEXT = nullptr;
    detail::PFN_QueueInsertDebugUtilsLabelEXT pfn_QueueInsertDebugUtilsLabelEXT = nullptr;
    detail::PFN_CmdBeginDebugUtilsLabelEXT pfn_CmdBeginDebugUtilsLabelEXT = nullptr;
    detail::PFN_CmdEndDebugUtilsLabelEXT pfn_CmdEndDebugUtilsLabelEXT = nullptr;
    detail::PFN_CmdInsertDebugUtilsLabelEXT pfn_CmdInsertDebugUtilsLabelEXT = nullptr;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    detail::PFN_GetAndroidHardwareBufferPropertiesANDROID pfn_GetAndroidHardwareBufferPropertiesANDROID = nullptr;
    detail::PFN_GetMemoryAndroidHardwareBufferANDROID pfn_GetMemoryAndroidHardwareBufferANDROID = nullptr;
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
    detail::PFN_CmdSetSampleLocationsEXT pfn_CmdSetSampleLocationsEXT = nullptr;
    detail::PFN_DestroyAccelerationStructureKHR pfn_DestroyAccelerationStructureKHR = nullptr;
    detail::PFN_CmdCopyAccelerationStructureKHR pfn_CmdCopyAccelerationStructureKHR = nullptr;
    detail::PFN_CopyAccelerationStructureKHR pfn_CopyAccelerationStructureKHR = nullptr;
    detail::PFN_CmdCopyAccelerationStructureToMemoryKHR pfn_CmdCopyAccelerationStructureToMemoryKHR = nullptr;
    detail::PFN_CopyAccelerationStructureToMemoryKHR pfn_CopyAccelerationStructureToMemoryKHR = nullptr;
    detail::PFN_CmdCopyMemoryToAccelerationStructureKHR pfn_CmdCopyMemoryToAccelerationStructureKHR = nullptr;
    detail::PFN_CopyMemoryToAccelerationStructureKHR pfn_CopyMemoryToAccelerationStructureKHR = nullptr;
    detail::PFN_CmdWriteAccelerationStructuresPropertiesKHR pfn_CmdWriteAccelerationStructuresPropertiesKHR = nullptr;
    detail::PFN_WriteAccelerationStructuresPropertiesKHR pfn_WriteAccelerationStructuresPropertiesKHR = nullptr;
    detail::PFN_GetDeviceAccelerationStructureCompatibilityKHR pfn_GetDeviceAccelerationStructureCompatibilityKHR = nullptr;
    detail::PFN_CreateAccelerationStructureKHR pfn_CreateAccelerationStructureKHR = nullptr;
    detail::PFN_CmdBuildAccelerationStructuresKHR pfn_CmdBuildAccelerationStructuresKHR = nullptr;
    detail::PFN_CmdBuildAccelerationStructuresIndirectKHR pfn_CmdBuildAccelerationStructuresIndirectKHR = nullptr;
    detail::PFN_BuildAccelerationStructuresKHR pfn_BuildAccelerationStructuresKHR = nullptr;
    detail::PFN_GetAccelerationStructureDeviceAddressKHR pfn_GetAccelerationStructureDeviceAddressKHR = nullptr;
    detail::PFN_GetAccelerationStructureBuildSizesKHR pfn_GetAccelerationStructureBuildSizesKHR = nullptr;
    detail::PFN_CmdTraceRaysKHR pfn_CmdTraceRaysKHR = nullptr;
    detail::PFN_GetRayTracingShaderGroupHandlesKHR pfn_GetRayTracingShaderGroupHandlesKHR = nullptr;
    detail::PFN_GetRayTracingCaptureReplayShaderGroupHandlesKHR pfn_GetRayTracingCaptureReplayShaderGroupHandlesKHR = nullptr;
    detail::PFN_CreateRayTracingPipelinesKHR pfn_CreateRayTracingPipelinesKHR = nullptr;
    detail::PFN_CmdTraceRaysIndirectKHR pfn_CmdTraceRaysIndirectKHR = nullptr;
    detail::PFN_GetRayTracingShaderGroupStackSizeKHR pfn_GetRayTracingShaderGroupStackSizeKHR = nullptr;
    detail::PFN_CmdSetRayTracingPipelineStackSizeKHR pfn_CmdSetRayTracingPipelineStackSizeKHR = nullptr;
    detail::PFN_GetImageDrmFormatModifierPropertiesEXT pfn_GetImageDrmFormatModifierPropertiesEXT = nullptr;
    detail::PFN_CreateValidationCacheEXT pfn_CreateValidationCacheEXT = nullptr;
    detail::PFN_DestroyValidationCacheEXT pfn_DestroyValidationCacheEXT = nullptr;
    detail::PFN_GetValidationCacheDataEXT pfn_GetValidationCacheDataEXT = nullptr;
    detail::PFN_MergeValidationCachesEXT pfn_MergeValidationCachesEXT = nullptr;
    detail::PFN_CmdBindShadingRateImageNV pfn_CmdBindShadingRateImageNV = nullptr;
    detail::PFN_CmdSetViewportShadingRatePaletteNV pfn_CmdSetViewportShadingRatePaletteNV = nullptr;
    detail::PFN_CmdSetCoarseSampleOrderNV pfn_CmdSetCoarseSampleOrderNV = nullptr;
    detail::PFN_CompileDeferredNV pfn_CompileDeferredNV = nullptr;
    detail::PFN_CreateAccelerationStructureNV pfn_CreateAccelerationStructureNV = nullptr;
    detail::PFN_DestroyAccelerationStructureNV pfn_DestroyAccelerationStructureNV = nullptr;
    detail::PFN_GetAccelerationStructureMemoryRequirementsNV pfn_GetAccelerationStructureMemoryRequirementsNV = nullptr;
    detail::PFN_BindAccelerationStructureMemoryNV pfn_BindAccelerationStructureMemoryNV = nullptr;
    detail::PFN_CmdCopyAccelerationStructureNV pfn_CmdCopyAccelerationStructureNV = nullptr;
    detail::PFN_CmdWriteAccelerationStructuresPropertiesNV pfn_CmdWriteAccelerationStructuresPropertiesNV = nullptr;
    detail::PFN_CmdBuildAccelerationStructureNV pfn_CmdBuildAccelerationStructureNV = nullptr;
    detail::PFN_CmdTraceRaysNV pfn_CmdTraceRaysNV = nullptr;
    detail::PFN_GetAccelerationStructureHandleNV pfn_GetAccelerationStructureHandleNV = nullptr;
    detail::PFN_CreateRayTracingPipelinesNV pfn_CreateRayTracingPipelinesNV = nullptr;
    detail::PFN_GetMemoryHostPointerPropertiesEXT pfn_GetMemoryHostPointerPropertiesEXT = nullptr;
    detail::PFN_CmdWriteBufferMarkerAMD pfn_CmdWriteBufferMarkerAMD = nullptr;
    detail::PFN_GetCalibratedTimestampsEXT pfn_GetCalibratedTimestampsEXT = nullptr;
    detail::PFN_CmdDrawMeshTasksNV pfn_CmdDrawMeshTasksNV = nullptr;
    detail::PFN_CmdDrawMeshTasksIndirectNV pfn_CmdDrawMeshTasksIndirectNV = nullptr;
    detail::PFN_CmdDrawMeshTasksIndirectCountNV pfn_CmdDrawMeshTasksIndirectCountNV = nullptr;
    detail::PFN_CmdSetExclusiveScissorNV pfn_CmdSetExclusiveScissorNV = nullptr;
    detail::PFN_CmdSetCheckpointNV pfn_CmdSetCheckpointNV = nullptr;
    detail::PFN_GetQueueCheckpointDataNV pfn_GetQueueCheckpointDataNV = nullptr;
    detail::PFN_InitializePerformanceApiINTEL pfn_InitializePerformanceApiINTEL = nullptr;
    detail::PFN_UninitializePerformanceApiINTEL pfn_UninitializePerformanceApiINTEL = nullptr;
    detail::PFN_CmdSetPerformanceMarkerINTEL pfn_CmdSetPerformanceMarkerINTEL = nullptr;
    detail::PFN_CmdSetPerformanceStreamMarkerINTEL pfn_CmdSetPerformanceStreamMarkerINTEL = nullptr;
    detail::PFN_CmdSetPerformanceOverrideINTEL pfn_CmdSetPerformanceOverrideINTEL = nullptr;
    detail::PFN_AcquirePerformanceConfigurationINTEL pfn_AcquirePerformanceConfigurationINTEL = nullptr;
    detail::PFN_ReleasePerformanceConfigurationINTEL pfn_ReleasePerformanceConfigurationINTEL = nullptr;
    detail::PFN_QueueSetPerformanceConfigurationINTEL pfn_QueueSetPerformanceConfigurationINTEL = nullptr;
    detail::PFN_GetPerformanceParameterINTEL pfn_GetPerformanceParameterINTEL = nullptr;
    detail::PFN_SetLocalDimmingAMD pfn_SetLocalDimmingAMD = nullptr;
    detail::PFN_CmdSetFragmentShadingRateKHR pfn_CmdSetFragmentShadingRateKHR = nullptr;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_AcquireFullScreenExclusiveModeEXT pfn_AcquireFullScreenExclusiveModeEXT = nullptr;
    detail::PFN_ReleaseFullScreenExclusiveModeEXT pfn_ReleaseFullScreenExclusiveModeEXT = nullptr;
    detail::PFN_GetDeviceGroupSurfacePresentModes2EXT pfn_GetDeviceGroupSurfacePresentModes2EXT = nullptr;
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    detail::PFN_CmdSetLineStippleEXT pfn_CmdSetLineStippleEXT = nullptr;
    detail::PFN_CmdSetCullModeEXT pfn_CmdSetCullModeEXT = nullptr;
    detail::PFN_CmdSetFrontFaceEXT pfn_CmdSetFrontFaceEXT = nullptr;
    detail::PFN_CmdSetPrimitiveTopologyEXT pfn_CmdSetPrimitiveTopologyEXT = nullptr;
    detail::PFN_CmdSetViewportWithCountEXT pfn_CmdSetViewportWithCountEXT = nullptr;
    detail::PFN_CmdSetScissorWithCountEXT pfn_CmdSetScissorWithCountEXT = nullptr;
    detail::PFN_CmdBindVertexBuffers2EXT pfn_CmdBindVertexBuffers2EXT = nullptr;
    detail::PFN_CmdSetDepthTestEnableEXT pfn_CmdSetDepthTestEnableEXT = nullptr;
    detail::PFN_CmdSetDepthWriteEnableEXT pfn_CmdSetDepthWriteEnableEXT = nullptr;
    detail::PFN_CmdSetDepthCompareOpEXT pfn_CmdSetDepthCompareOpEXT = nullptr;
    detail::PFN_CmdSetDepthBoundsTestEnableEXT pfn_CmdSetDepthBoundsTestEnableEXT = nullptr;
    detail::PFN_CmdSetStencilTestEnableEXT pfn_CmdSetStencilTestEnableEXT = nullptr;
    detail::PFN_CmdSetStencilOpEXT pfn_CmdSetStencilOpEXT = nullptr;
    detail::PFN_CreateDeferredOperationKHR pfn_CreateDeferredOperationKHR = nullptr;
    detail::PFN_DestroyDeferredOperationKHR pfn_DestroyDeferredOperationKHR = nullptr;
    detail::PFN_GetDeferredOperationMaxConcurrencyKHR pfn_GetDeferredOperationMaxConcurrencyKHR = nullptr;
    detail::PFN_GetDeferredOperationResultKHR pfn_GetDeferredOperationResultKHR = nullptr;
    detail::PFN_DeferredOperationJoinKHR pfn_DeferredOperationJoinKHR = nullptr;
    detail::PFN_GetPipelineExecutablePropertiesKHR pfn_GetPipelineExecutablePropertiesKHR = nullptr;
    detail::PFN_GetPipelineExecutableStatisticsKHR pfn_GetPipelineExecutableStatisticsKHR = nullptr;
    detail::PFN_GetPipelineExecutableInternalRepresentationsKHR pfn_GetPipelineExecutableInternalRepresentationsKHR = nullptr;
    detail::PFN_CmdExecuteGeneratedCommandsNV pfn_CmdExecuteGeneratedCommandsNV = nullptr;
    detail::PFN_CmdPreprocessGeneratedCommandsNV pfn_CmdPreprocessGeneratedCommandsNV = nullptr;
    detail::PFN_CmdBindPipelineShaderGroupNV pfn_CmdBindPipelineShaderGroupNV = nullptr;
    detail::PFN_GetGeneratedCommandsMemoryRequirementsNV pfn_GetGeneratedCommandsMemoryRequirementsNV = nullptr;
    detail::PFN_CreateIndirectCommandsLayoutNV pfn_CreateIndirectCommandsLayoutNV = nullptr;
    detail::PFN_DestroyIndirectCommandsLayoutNV pfn_DestroyIndirectCommandsLayoutNV = nullptr;
    detail::PFN_CreatePrivateDataSlotEXT pfn_CreatePrivateDataSlotEXT = nullptr;
    detail::PFN_DestroyPrivateDataSlotEXT pfn_DestroyPrivateDataSlotEXT = nullptr;
    detail::PFN_SetPrivateDataEXT pfn_SetPrivateDataEXT = nullptr;
    detail::PFN_GetPrivateDataEXT pfn_GetPrivateDataEXT = nullptr;
    detail::PFN_CmdSetEvent2KHR pfn_CmdSetEvent2KHR = nullptr;
    detail::PFN_CmdResetEvent2KHR pfn_CmdResetEvent2KHR = nullptr;
    detail::PFN_CmdWaitEvents2KHR pfn_CmdWaitEvents2KHR = nullptr;
    detail::PFN_CmdPipelineBarrier2KHR pfn_CmdPipelineBarrier2KHR = nullptr;
    detail::PFN_QueueSubmit2KHR pfn_QueueSubmit2KHR = nullptr;
    detail::PFN_CmdWriteTimestamp2KHR pfn_CmdWriteTimestamp2KHR = nullptr;
    detail::PFN_CmdWriteBufferMarker2AMD pfn_CmdWriteBufferMarker2AMD = nullptr;
    detail::PFN_GetQueueCheckpointData2NV pfn_GetQueueCheckpointData2NV = nullptr;
    detail::PFN_CmdSetFragmentShadingRateEnumNV pfn_CmdSetFragmentShadingRateEnumNV = nullptr;
    detail::PFN_CmdCopyBuffer2KHR pfn_CmdCopyBuffer2KHR = nullptr;
    detail::PFN_CmdCopyImage2KHR pfn_CmdCopyImage2KHR = nullptr;
    detail::PFN_CmdBlitImage2KHR pfn_CmdBlitImage2KHR = nullptr;
    detail::PFN_CmdCopyBufferToImage2KHR pfn_CmdCopyBufferToImage2KHR = nullptr;
    detail::PFN_CmdCopyImageToBuffer2KHR pfn_CmdCopyImageToBuffer2KHR = nullptr;
    detail::PFN_CmdResolveImage2KHR pfn_CmdResolveImage2KHR = nullptr;
    detail::PFN_CmdSetVertexInputEXT pfn_CmdSetVertexInputEXT = nullptr;
#if defined(VK_USE_PLATFORM_FUCHSIA)
    detail::PFN_GetMemoryZirconHandleFUCHSIA pfn_GetMemoryZirconHandleFUCHSIA = nullptr;
    detail::PFN_GetMemoryZirconHandlePropertiesFUCHSIA pfn_GetMemoryZirconHandlePropertiesFUCHSIA = nullptr;
    detail::PFN_GetSemaphoreZirconHandleFUCHSIA pfn_GetSemaphoreZirconHandleFUCHSIA = nullptr;
    detail::PFN_ImportSemaphoreZirconHandleFUCHSIA pfn_ImportSemaphoreZirconHandleFUCHSIA = nullptr;
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
    detail::PFN_CmdSetPatchControlPointsEXT pfn_CmdSetPatchControlPointsEXT = nullptr;
    detail::PFN_CmdSetRasterizerDiscardEnableEXT pfn_CmdSetRasterizerDiscardEnableEXT = nullptr;
    detail::PFN_CmdSetDepthBiasEnableEXT pfn_CmdSetDepthBiasEnableEXT = nullptr;
    detail::PFN_CmdSetLogicOpEXT pfn_CmdSetLogicOpEXT = nullptr;
    detail::PFN_CmdSetPrimitiveRestartEnableEXT pfn_CmdSetPrimitiveRestartEnableEXT = nullptr;
    detail::PFN_CmdSetColorWriteEnableEXT pfn_CmdSetColorWriteEnableEXT = nullptr;
void DestroyDevice(const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDevice(device,
        pAllocator);
}
[[nodiscard]] Queue GetDeviceQueue(uint32_t queueFamilyIndex, 
    uint32_t queueIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Queue pQueue;
    pfn_GetDeviceQueue(device,
        queueFamilyIndex,
        queueIndex,
        &pQueue);
    return pQueue;
}
[[nodiscard]] Result QueueSubmit(Queue queue, 
    detail::span<const SubmitInfo> Submits, 
    Fence fence = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t submitCount = Submits.size();
    return pfn_QueueSubmit(queue,
        submitCount,
        Submits.data(),
        fence);
}
[[nodiscard]] Result QueueWaitIdle(Queue queue) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_QueueWaitIdle(queue);
}
[[nodiscard]] Result DeviceWaitIdle() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_DeviceWaitIdle(device);
}
[[nodiscard]] expected<DeviceMemory> AllocateMemory(const MemoryAllocateInfo&  pAllocateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeviceMemory pMemory;
        Result result = pfn_AllocateMemory(device,
        &pAllocateInfo,
        pAllocator,
        &pMemory);
    return expected<DeviceMemory>(pMemory, result);
}
void FreeMemory(DeviceMemory memory = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_FreeMemory(device,
        memory,
        pAllocator);
}
[[nodiscard]] expected<void*> MapMemory(DeviceMemory memory, 
    DeviceSize offset, 
    DeviceSize size, 
    MemoryMapFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    void* ppData;
        Result result = pfn_MapMemory(device,
        memory,
        offset,
        size,
        flags,
        &ppData);
    return expected<void*>(ppData, result);
}
void UnmapMemory(DeviceMemory memory) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_UnmapMemory(device,
        memory);
}
[[nodiscard]] Result FlushMappedMemoryRanges(detail::span<const MappedMemoryRange> MemoryRanges) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t memoryRangeCount = MemoryRanges.size();
    return pfn_FlushMappedMemoryRanges(device,
        memoryRangeCount,
        MemoryRanges.data());
}
[[nodiscard]] Result InvalidateMappedMemoryRanges(detail::span<const MappedMemoryRange> MemoryRanges) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t memoryRangeCount = MemoryRanges.size();
    return pfn_InvalidateMappedMemoryRanges(device,
        memoryRangeCount,
        MemoryRanges.data());
}
[[nodiscard]] DeviceSize GetDeviceMemoryCommitment(DeviceMemory memory) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeviceSize pCommittedMemoryInBytes;
    pfn_GetDeviceMemoryCommitment(device,
        memory,
        &pCommittedMemoryInBytes);
    return pCommittedMemoryInBytes;
}
[[nodiscard]] MemoryRequirements GetBufferMemoryRequirements(Buffer buffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryRequirements pMemoryRequirements;
    pfn_GetBufferMemoryRequirements(device,
        buffer,
        &pMemoryRequirements);
    return pMemoryRequirements;
}
[[nodiscard]] Result BindBufferMemory(Buffer buffer, 
    DeviceMemory memory, 
    DeviceSize memoryOffset) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_BindBufferMemory(device,
        buffer,
        memory,
        memoryOffset);
}
[[nodiscard]] MemoryRequirements GetImageMemoryRequirements(Image image) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryRequirements pMemoryRequirements;
    pfn_GetImageMemoryRequirements(device,
        image,
        &pMemoryRequirements);
    return pMemoryRequirements;
}
[[nodiscard]] Result BindImageMemory(Image image, 
    DeviceMemory memory, 
    DeviceSize memoryOffset) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_BindImageMemory(device,
        image,
        memory,
        memoryOffset);
}
[[nodiscard]] std::vector<SparseImageMemoryRequirements> GetImageSparseMemoryRequirements(Image image) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pSparseMemoryRequirementCount = 0;
    pfn_GetImageSparseMemoryRequirements(device,
        image,
        &pSparseMemoryRequirementCount,
        nullptr);
    std::vector<SparseImageMemoryRequirements> pSparseMemoryRequirements(pSparseMemoryRequirementCount);
pfn_GetImageSparseMemoryRequirements(device,
        image,
        &pSparseMemoryRequirementCount,
        pSparseMemoryRequirements.data());
    return pSparseMemoryRequirements;
}
[[nodiscard]] Result QueueBindSparse(Queue queue, 
    detail::span<const BindSparseInfo> BindInfo, 
    Fence fence = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindInfoCount = BindInfo.size();
    return pfn_QueueBindSparse(queue,
        bindInfoCount,
        BindInfo.data(),
        fence);
}
[[nodiscard]] expected<Fence> CreateFence(const FenceCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Fence pFence;
        Result result = pfn_CreateFence(device,
        &pCreateInfo,
        pAllocator,
        &pFence);
    return expected<Fence>(pFence, result);
}
void DestroyFence(Fence fence = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyFence(device,
        fence,
        pAllocator);
}
[[nodiscard]] Result ResetFences(detail::span<const Fence> Fences) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t fenceCount = Fences.size();
    return pfn_ResetFences(device,
        fenceCount,
        Fences.data());
}
[[nodiscard]] Result GetFenceStatus(Fence fence) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetFenceStatus(device,
        fence);
}
[[nodiscard]] Result WaitForFences(detail::span<const Fence> Fences, 
    Bool32 waitAll, 
    uint64_t timeout) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t fenceCount = Fences.size();
    return pfn_WaitForFences(device,
        fenceCount,
        Fences.data(),
        waitAll,
        timeout);
}
[[nodiscard]] expected<Semaphore> CreateSemaphore(const SemaphoreCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Semaphore pSemaphore;
        Result result = pfn_CreateSemaphore(device,
        &pCreateInfo,
        pAllocator,
        &pSemaphore);
    return expected<Semaphore>(pSemaphore, result);
}
void DestroySemaphore(Semaphore semaphore = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroySemaphore(device,
        semaphore,
        pAllocator);
}
[[nodiscard]] expected<Event> CreateEvent(const EventCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Event pEvent;
        Result result = pfn_CreateEvent(device,
        &pCreateInfo,
        pAllocator,
        &pEvent);
    return expected<Event>(pEvent, result);
}
void DestroyEvent(Event event = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyEvent(device,
        event,
        pAllocator);
}
[[nodiscard]] Result GetEventStatus(Event event) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetEventStatus(device,
        event);
}
[[nodiscard]] Result SetEvent(Event event) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_SetEvent(device,
        event);
}
[[nodiscard]] Result ResetEvent(Event event) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ResetEvent(device,
        event);
}
[[nodiscard]] expected<QueryPool> CreateQueryPool(const QueryPoolCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    QueryPool pQueryPool;
        Result result = pfn_CreateQueryPool(device,
        &pCreateInfo,
        pAllocator,
        &pQueryPool);
    return expected<QueryPool>(pQueryPool, result);
}
void DestroyQueryPool(QueryPool queryPool = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyQueryPool(device,
        queryPool,
        pAllocator);
}
[[nodiscard]] Result GetQueryPoolResults(QueryPool queryPool, 
    uint32_t firstQuery, 
    uint32_t queryCount, 
    detail::span<std::byte> Data, 
    DeviceSize stride, 
    QueryResultFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t dataSize = Data.size();
    return pfn_GetQueryPoolResults(device,
        queryPool,
        firstQuery,
        queryCount,
        dataSize,
        Data.data(),
        stride,
        flags);
}
[[nodiscard]] expected<Buffer> CreateBuffer(const BufferCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Buffer pBuffer;
        Result result = pfn_CreateBuffer(device,
        &pCreateInfo,
        pAllocator,
        &pBuffer);
    return expected<Buffer>(pBuffer, result);
}
void DestroyBuffer(Buffer buffer = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyBuffer(device,
        buffer,
        pAllocator);
}
[[nodiscard]] expected<BufferView> CreateBufferView(const BufferViewCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    BufferView pView;
        Result result = pfn_CreateBufferView(device,
        &pCreateInfo,
        pAllocator,
        &pView);
    return expected<BufferView>(pView, result);
}
void DestroyBufferView(BufferView bufferView = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyBufferView(device,
        bufferView,
        pAllocator);
}
[[nodiscard]] expected<Image> CreateImage(const ImageCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Image pImage;
        Result result = pfn_CreateImage(device,
        &pCreateInfo,
        pAllocator,
        &pImage);
    return expected<Image>(pImage, result);
}
void DestroyImage(Image image = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyImage(device,
        image,
        pAllocator);
}
[[nodiscard]] SubresourceLayout GetImageSubresourceLayout(Image image, 
    const ImageSubresource&  pSubresource) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SubresourceLayout pLayout;
    pfn_GetImageSubresourceLayout(device,
        image,
        &pSubresource,
        &pLayout);
    return pLayout;
}
[[nodiscard]] expected<ImageView> CreateImageView(const ImageViewCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ImageView pView;
        Result result = pfn_CreateImageView(device,
        &pCreateInfo,
        pAllocator,
        &pView);
    return expected<ImageView>(pView, result);
}
void DestroyImageView(ImageView imageView = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyImageView(device,
        imageView,
        pAllocator);
}
[[nodiscard]] expected<ShaderModule> CreateShaderModule(const ShaderModuleCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ShaderModule pShaderModule;
        Result result = pfn_CreateShaderModule(device,
        &pCreateInfo,
        pAllocator,
        &pShaderModule);
    return expected<ShaderModule>(pShaderModule, result);
}
void DestroyShaderModule(ShaderModule shaderModule = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyShaderModule(device,
        shaderModule,
        pAllocator);
}
[[nodiscard]] expected<PipelineCache> CreatePipelineCache(const PipelineCacheCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PipelineCache pPipelineCache;
        Result result = pfn_CreatePipelineCache(device,
        &pCreateInfo,
        pAllocator,
        &pPipelineCache);
    return expected<PipelineCache>(pPipelineCache, result);
}
void DestroyPipelineCache(PipelineCache pipelineCache = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyPipelineCache(device,
        pipelineCache,
        pAllocator);
}
[[nodiscard]] expected<std::vector<void*>> GetPipelineCacheData(PipelineCache pipelineCache) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t pDataSize = 0;
        Result result = pfn_GetPipelineCacheData(device,
        pipelineCache,
        &pDataSize,
        nullptr);
    if (result < Result::Success) return expected(std::vector<void*>{}, result);
    std::vector<void*> pData(pDataSize);
    result = pfn_GetPipelineCacheData(device,
        pipelineCache,
        &pDataSize,
        pData.data());
    return expected(std::move(pData), result);
}
[[nodiscard]] Result MergePipelineCaches(PipelineCache dstCache, 
    detail::span<const PipelineCache> SrcCaches) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t srcCacheCount = SrcCaches.size();
    return pfn_MergePipelineCaches(device,
        dstCache,
        srcCacheCount,
        SrcCaches.data());
}
[[nodiscard]] expected<std::vector<Pipeline>> CreateGraphicsPipelines(PipelineCache pipelineCache, 
    detail::span<const GraphicsPipelineCreateInfo> CreateInfos, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t createInfoCount = CreateInfos.size();
    std::vector<Pipeline> pPipelines{createInfoCount};
    Result result = pfn_CreateGraphicsPipelines(device,
        pipelineCache,
        createInfoCount,
        CreateInfos.data(),
        pAllocator,
        pPipelines.data());
    return expected<std::vector<Pipeline>>(std::move(pPipelines), result);
}
[[nodiscard]] expected<std::vector<Pipeline>> CreateComputePipelines(PipelineCache pipelineCache, 
    detail::span<const ComputePipelineCreateInfo> CreateInfos, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t createInfoCount = CreateInfos.size();
    std::vector<Pipeline> pPipelines{createInfoCount};
    Result result = pfn_CreateComputePipelines(device,
        pipelineCache,
        createInfoCount,
        CreateInfos.data(),
        pAllocator,
        pPipelines.data());
    return expected<std::vector<Pipeline>>(std::move(pPipelines), result);
}
void DestroyPipeline(Pipeline pipeline = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyPipeline(device,
        pipeline,
        pAllocator);
}
[[nodiscard]] expected<PipelineLayout> CreatePipelineLayout(const PipelineLayoutCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PipelineLayout pPipelineLayout;
        Result result = pfn_CreatePipelineLayout(device,
        &pCreateInfo,
        pAllocator,
        &pPipelineLayout);
    return expected<PipelineLayout>(pPipelineLayout, result);
}
void DestroyPipelineLayout(PipelineLayout pipelineLayout = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyPipelineLayout(device,
        pipelineLayout,
        pAllocator);
}
[[nodiscard]] expected<Sampler> CreateSampler(const SamplerCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Sampler pSampler;
        Result result = pfn_CreateSampler(device,
        &pCreateInfo,
        pAllocator,
        &pSampler);
    return expected<Sampler>(pSampler, result);
}
void DestroySampler(Sampler sampler = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroySampler(device,
        sampler,
        pAllocator);
}
[[nodiscard]] expected<DescriptorSetLayout> CreateDescriptorSetLayout(const DescriptorSetLayoutCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DescriptorSetLayout pSetLayout;
        Result result = pfn_CreateDescriptorSetLayout(device,
        &pCreateInfo,
        pAllocator,
        &pSetLayout);
    return expected<DescriptorSetLayout>(pSetLayout, result);
}
void DestroyDescriptorSetLayout(DescriptorSetLayout descriptorSetLayout = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDescriptorSetLayout(device,
        descriptorSetLayout,
        pAllocator);
}
[[nodiscard]] expected<DescriptorPool> CreateDescriptorPool(const DescriptorPoolCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DescriptorPool pDescriptorPool;
        Result result = pfn_CreateDescriptorPool(device,
        &pCreateInfo,
        pAllocator,
        &pDescriptorPool);
    return expected<DescriptorPool>(pDescriptorPool, result);
}
void DestroyDescriptorPool(DescriptorPool descriptorPool = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDescriptorPool(device,
        descriptorPool,
        pAllocator);
}
[[nodiscard]] Result ResetDescriptorPool(DescriptorPool descriptorPool, 
    DescriptorPoolResetFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ResetDescriptorPool(device,
        descriptorPool,
        flags);
}
[[nodiscard]] expected<std::vector<DescriptorSet>> AllocateDescriptorSets(const DescriptorSetAllocateInfo&  pAllocateInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    std::vector<DescriptorSet> pDescriptorSets{pAllocateInfo.descriptorSetCount};
    Result result = pfn_AllocateDescriptorSets(device,
        &pAllocateInfo,
        pDescriptorSets.data());
    return expected<std::vector<DescriptorSet>>(std::move(pDescriptorSets), result);
}
[[nodiscard]] Result FreeDescriptorSets(DescriptorPool descriptorPool, 
    detail::span<const DescriptorSet> DescriptorSets) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t descriptorSetCount = DescriptorSets.size();
    return pfn_FreeDescriptorSets(device,
        descriptorPool,
        descriptorSetCount,
        DescriptorSets.data());
}
void UpdateDescriptorSets(detail::span<const WriteDescriptorSet> DescriptorWrites, 
    detail::span<const CopyDescriptorSet> DescriptorCopies) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t descriptorWriteCount = DescriptorWrites.size();
    uint32_t descriptorCopyCount = DescriptorCopies.size();
    pfn_UpdateDescriptorSets(device,
        descriptorWriteCount,
        DescriptorWrites.data(),
        descriptorCopyCount,
        DescriptorCopies.data());
}
[[nodiscard]] expected<Framebuffer> CreateFramebuffer(const FramebufferCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Framebuffer pFramebuffer;
        Result result = pfn_CreateFramebuffer(device,
        &pCreateInfo,
        pAllocator,
        &pFramebuffer);
    return expected<Framebuffer>(pFramebuffer, result);
}
void DestroyFramebuffer(Framebuffer framebuffer = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyFramebuffer(device,
        framebuffer,
        pAllocator);
}
[[nodiscard]] expected<RenderPass> CreateRenderPass(const RenderPassCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    RenderPass pRenderPass;
        Result result = pfn_CreateRenderPass(device,
        &pCreateInfo,
        pAllocator,
        &pRenderPass);
    return expected<RenderPass>(pRenderPass, result);
}
void DestroyRenderPass(RenderPass renderPass = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyRenderPass(device,
        renderPass,
        pAllocator);
}
[[nodiscard]] Extent2D GetRenderAreaGranularity(RenderPass renderPass) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Extent2D pGranularity;
    pfn_GetRenderAreaGranularity(device,
        renderPass,
        &pGranularity);
    return pGranularity;
}
[[nodiscard]] expected<CommandPool> CreateCommandPool(const CommandPoolCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    CommandPool pCommandPool;
        Result result = pfn_CreateCommandPool(device,
        &pCreateInfo,
        pAllocator,
        &pCommandPool);
    return expected<CommandPool>(pCommandPool, result);
}
void DestroyCommandPool(CommandPool commandPool = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyCommandPool(device,
        commandPool,
        pAllocator);
}
[[nodiscard]] Result ResetCommandPool(CommandPool commandPool, 
    CommandPoolResetFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ResetCommandPool(device,
        commandPool,
        flags);
}
[[nodiscard]] expected<std::vector<CommandBuffer>> AllocateCommandBuffers(const CommandBufferAllocateInfo&  pAllocateInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    std::vector<CommandBuffer> pCommandBuffers{pAllocateInfo.commandBufferCount};
    Result result = pfn_AllocateCommandBuffers(device,
        &pAllocateInfo,
        pCommandBuffers.data());
    return expected<std::vector<CommandBuffer>>(std::move(pCommandBuffers), result);
}
void FreeCommandBuffers(CommandPool commandPool, 
    detail::span<const CommandBuffer> CommandBuffers) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t commandBufferCount = CommandBuffers.size();
    pfn_FreeCommandBuffers(device,
        commandPool,
        commandBufferCount,
        CommandBuffers.data());
}
[[nodiscard]] Result BeginCommandBuffer(CommandBuffer commandBuffer, 
    const CommandBufferBeginInfo&  pBeginInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_BeginCommandBuffer(commandBuffer,
        &pBeginInfo);
}
[[nodiscard]] Result EndCommandBuffer(CommandBuffer commandBuffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_EndCommandBuffer(commandBuffer);
}
[[nodiscard]] Result ResetCommandBuffer(CommandBuffer commandBuffer, 
    CommandBufferResetFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ResetCommandBuffer(commandBuffer,
        flags);
}
void CmdBindPipeline(CommandBuffer commandBuffer, 
    PipelineBindPoint pipelineBindPoint, 
    Pipeline pipeline) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBindPipeline(commandBuffer,
        pipelineBindPoint,
        pipeline);
}
void CmdSetViewport(CommandBuffer commandBuffer, 
    uint32_t firstViewport, 
    detail::span<const Viewport> Viewports) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t viewportCount = Viewports.size();
    pfn_CmdSetViewport(commandBuffer,
        firstViewport,
        viewportCount,
        Viewports.data());
}
void CmdSetScissor(CommandBuffer commandBuffer, 
    uint32_t firstScissor, 
    detail::span<const Rect2D> Scissors) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t scissorCount = Scissors.size();
    pfn_CmdSetScissor(commandBuffer,
        firstScissor,
        scissorCount,
        Scissors.data());
}
void CmdSetLineWidth(CommandBuffer commandBuffer, 
    float lineWidth) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetLineWidth(commandBuffer,
        lineWidth);
}
void CmdSetDepthBias(CommandBuffer commandBuffer, 
    float depthBiasConstantFactor, 
    float depthBiasClamp, 
    float depthBiasSlopeFactor) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthBias(commandBuffer,
        depthBiasConstantFactor,
        depthBiasClamp,
        depthBiasSlopeFactor);
}
void CmdSetBlendConstants(CommandBuffer commandBuffer, 
    const float blendConstants[4]) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetBlendConstants(commandBuffer,
        blendConstants);
}
void CmdSetDepthBounds(CommandBuffer commandBuffer, 
    float minDepthBounds, 
    float maxDepthBounds) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthBounds(commandBuffer,
        minDepthBounds,
        maxDepthBounds);
}
void CmdSetStencilCompareMask(CommandBuffer commandBuffer, 
    StencilFaceFlags faceMask, 
    uint32_t compareMask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetStencilCompareMask(commandBuffer,
        faceMask,
        compareMask);
}
void CmdSetStencilWriteMask(CommandBuffer commandBuffer, 
    StencilFaceFlags faceMask, 
    uint32_t writeMask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetStencilWriteMask(commandBuffer,
        faceMask,
        writeMask);
}
void CmdSetStencilReference(CommandBuffer commandBuffer, 
    StencilFaceFlags faceMask, 
    uint32_t reference) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetStencilReference(commandBuffer,
        faceMask,
        reference);
}
void CmdBindDescriptorSets(CommandBuffer commandBuffer, 
    PipelineBindPoint pipelineBindPoint, 
    PipelineLayout layout, 
    uint32_t firstSet, 
    detail::span<const DescriptorSet> DescriptorSets, 
    detail::span<const uint32_t> DynamicOffsets) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t descriptorSetCount = DescriptorSets.size();
    uint32_t dynamicOffsetCount = DynamicOffsets.size();
    pfn_CmdBindDescriptorSets(commandBuffer,
        pipelineBindPoint,
        layout,
        firstSet,
        descriptorSetCount,
        DescriptorSets.data(),
        dynamicOffsetCount,
        DynamicOffsets.data());
}
void CmdBindIndexBuffer(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    IndexType indexType) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBindIndexBuffer(commandBuffer,
        buffer,
        offset,
        indexType);
}
void CmdBindVertexBuffers(CommandBuffer commandBuffer, 
    uint32_t firstBinding, 
    detail::span<const Buffer> Buffers, 
    detail::span<const DeviceSize> Offsets) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindingCount = Buffers.size();
    pfn_CmdBindVertexBuffers(commandBuffer,
        firstBinding,
        bindingCount,
        Buffers.data(),
        Offsets.data());
}
void CmdDraw(CommandBuffer commandBuffer, 
    uint32_t vertexCount, 
    uint32_t instanceCount, 
    uint32_t firstVertex, 
    uint32_t firstInstance) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDraw(commandBuffer,
        vertexCount,
        instanceCount,
        firstVertex,
        firstInstance);
}
void CmdDrawIndexed(CommandBuffer commandBuffer, 
    uint32_t indexCount, 
    uint32_t instanceCount, 
    uint32_t firstIndex, 
    int32_t vertexOffset, 
    uint32_t firstInstance) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawIndexed(commandBuffer,
        indexCount,
        instanceCount,
        firstIndex,
        vertexOffset,
        firstInstance);
}
void CmdDrawIndirect(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    uint32_t drawCount, 
    uint32_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawIndirect(commandBuffer,
        buffer,
        offset,
        drawCount,
        stride);
}
void CmdDrawIndexedIndirect(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    uint32_t drawCount, 
    uint32_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawIndexedIndirect(commandBuffer,
        buffer,
        offset,
        drawCount,
        stride);
}
void CmdDispatch(CommandBuffer commandBuffer, 
    uint32_t groupCountX, 
    uint32_t groupCountY, 
    uint32_t groupCountZ) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDispatch(commandBuffer,
        groupCountX,
        groupCountY,
        groupCountZ);
}
void CmdDispatchIndirect(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDispatchIndirect(commandBuffer,
        buffer,
        offset);
}
void CmdCopyBuffer(CommandBuffer commandBuffer, 
    Buffer srcBuffer, 
    Buffer dstBuffer, 
    detail::span<const BufferCopy> Regions) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t regionCount = Regions.size();
    pfn_CmdCopyBuffer(commandBuffer,
        srcBuffer,
        dstBuffer,
        regionCount,
        Regions.data());
}
void CmdCopyImage(CommandBuffer commandBuffer, 
    Image srcImage, 
    ImageLayout srcImageLayout, 
    Image dstImage, 
    ImageLayout dstImageLayout, 
    detail::span<const ImageCopy> Regions) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t regionCount = Regions.size();
    pfn_CmdCopyImage(commandBuffer,
        srcImage,
        srcImageLayout,
        dstImage,
        dstImageLayout,
        regionCount,
        Regions.data());
}
void CmdBlitImage(CommandBuffer commandBuffer, 
    Image srcImage, 
    ImageLayout srcImageLayout, 
    Image dstImage, 
    ImageLayout dstImageLayout, 
    detail::span<const ImageBlit> Regions, 
    Filter filter) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t regionCount = Regions.size();
    pfn_CmdBlitImage(commandBuffer,
        srcImage,
        srcImageLayout,
        dstImage,
        dstImageLayout,
        regionCount,
        Regions.data(),
        filter);
}
void CmdCopyBufferToImage(CommandBuffer commandBuffer, 
    Buffer srcBuffer, 
    Image dstImage, 
    ImageLayout dstImageLayout, 
    detail::span<const BufferImageCopy> Regions) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t regionCount = Regions.size();
    pfn_CmdCopyBufferToImage(commandBuffer,
        srcBuffer,
        dstImage,
        dstImageLayout,
        regionCount,
        Regions.data());
}
void CmdCopyImageToBuffer(CommandBuffer commandBuffer, 
    Image srcImage, 
    ImageLayout srcImageLayout, 
    Buffer dstBuffer, 
    detail::span<const BufferImageCopy> Regions) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t regionCount = Regions.size();
    pfn_CmdCopyImageToBuffer(commandBuffer,
        srcImage,
        srcImageLayout,
        dstBuffer,
        regionCount,
        Regions.data());
}
void CmdUpdateBuffer(CommandBuffer commandBuffer, 
    Buffer dstBuffer, 
    DeviceSize dstOffset, 
    detail::span<const std::byte> Data) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeviceSize dataSize = Data.size();
    pfn_CmdUpdateBuffer(commandBuffer,
        dstBuffer,
        dstOffset,
        dataSize,
        Data.data());
}
void CmdFillBuffer(CommandBuffer commandBuffer, 
    Buffer dstBuffer, 
    DeviceSize dstOffset, 
    DeviceSize size, 
    uint32_t data) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdFillBuffer(commandBuffer,
        dstBuffer,
        dstOffset,
        size,
        data);
}
void CmdClearColorImage(CommandBuffer commandBuffer, 
    Image image, 
    ImageLayout imageLayout, 
    const ClearColorValue&  pColor, 
    detail::span<const ImageSubresourceRange> Ranges) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t rangeCount = Ranges.size();
    pfn_CmdClearColorImage(commandBuffer,
        image,
        imageLayout,
        &pColor,
        rangeCount,
        Ranges.data());
}
void CmdClearDepthStencilImage(CommandBuffer commandBuffer, 
    Image image, 
    ImageLayout imageLayout, 
    const ClearDepthStencilValue&  pDepthStencil, 
    detail::span<const ImageSubresourceRange> Ranges) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t rangeCount = Ranges.size();
    pfn_CmdClearDepthStencilImage(commandBuffer,
        image,
        imageLayout,
        &pDepthStencil,
        rangeCount,
        Ranges.data());
}
void CmdClearAttachments(CommandBuffer commandBuffer, 
    detail::span<const ClearAttachment> Attachments, 
    detail::span<const ClearRect> Rects) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t attachmentCount = Attachments.size();
    uint32_t rectCount = Rects.size();
    pfn_CmdClearAttachments(commandBuffer,
        attachmentCount,
        Attachments.data(),
        rectCount,
        Rects.data());
}
void CmdResolveImage(CommandBuffer commandBuffer, 
    Image srcImage, 
    ImageLayout srcImageLayout, 
    Image dstImage, 
    ImageLayout dstImageLayout, 
    detail::span<const ImageResolve> Regions) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t regionCount = Regions.size();
    pfn_CmdResolveImage(commandBuffer,
        srcImage,
        srcImageLayout,
        dstImage,
        dstImageLayout,
        regionCount,
        Regions.data());
}
void CmdSetEvent(CommandBuffer commandBuffer, 
    Event event, 
    PipelineStageFlags stageMask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetEvent(commandBuffer,
        event,
        stageMask);
}
void CmdResetEvent(CommandBuffer commandBuffer, 
    Event event, 
    PipelineStageFlags stageMask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdResetEvent(commandBuffer,
        event,
        stageMask);
}
void CmdWaitEvents(CommandBuffer commandBuffer, 
    detail::span<const Event> Events, 
    PipelineStageFlags srcStageMask, 
    PipelineStageFlags dstStageMask, 
    detail::span<const MemoryBarrier> MemoryBarriers, 
    detail::span<const BufferMemoryBarrier> BufferMemoryBarriers, 
    detail::span<const ImageMemoryBarrier> ImageMemoryBarriers) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t eventCount = Events.size();
    uint32_t memoryBarrierCount = MemoryBarriers.size();
    uint32_t bufferMemoryBarrierCount = BufferMemoryBarriers.size();
    uint32_t imageMemoryBarrierCount = ImageMemoryBarriers.size();
    pfn_CmdWaitEvents(commandBuffer,
        eventCount,
        Events.data(),
        srcStageMask,
        dstStageMask,
        memoryBarrierCount,
        MemoryBarriers.data(),
        bufferMemoryBarrierCount,
        BufferMemoryBarriers.data(),
        imageMemoryBarrierCount,
        ImageMemoryBarriers.data());
}
void CmdPipelineBarrier(CommandBuffer commandBuffer, 
    PipelineStageFlags srcStageMask, 
    PipelineStageFlags dstStageMask, 
    DependencyFlags dependencyFlags, 
    detail::span<const MemoryBarrier> MemoryBarriers, 
    detail::span<const BufferMemoryBarrier> BufferMemoryBarriers, 
    detail::span<const ImageMemoryBarrier> ImageMemoryBarriers) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t memoryBarrierCount = MemoryBarriers.size();
    uint32_t bufferMemoryBarrierCount = BufferMemoryBarriers.size();
    uint32_t imageMemoryBarrierCount = ImageMemoryBarriers.size();
    pfn_CmdPipelineBarrier(commandBuffer,
        srcStageMask,
        dstStageMask,
        dependencyFlags,
        memoryBarrierCount,
        MemoryBarriers.data(),
        bufferMemoryBarrierCount,
        BufferMemoryBarriers.data(),
        imageMemoryBarrierCount,
        ImageMemoryBarriers.data());
}
void CmdBeginQuery(CommandBuffer commandBuffer, 
    QueryPool queryPool, 
    uint32_t query, 
    QueryControlFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginQuery(commandBuffer,
        queryPool,
        query,
        flags);
}
void CmdEndQuery(CommandBuffer commandBuffer, 
    QueryPool queryPool, 
    uint32_t query) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndQuery(commandBuffer,
        queryPool,
        query);
}
void CmdResetQueryPool(CommandBuffer commandBuffer, 
    QueryPool queryPool, 
    uint32_t firstQuery, 
    uint32_t queryCount) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdResetQueryPool(commandBuffer,
        queryPool,
        firstQuery,
        queryCount);
}
void CmdWriteTimestamp(CommandBuffer commandBuffer, 
    PipelineStageFlagBits pipelineStage, 
    QueryPool queryPool, 
    uint32_t query) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdWriteTimestamp(commandBuffer,
        pipelineStage,
        queryPool,
        query);
}
void CmdCopyQueryPoolResults(CommandBuffer commandBuffer, 
    QueryPool queryPool, 
    uint32_t firstQuery, 
    uint32_t queryCount, 
    Buffer dstBuffer, 
    DeviceSize dstOffset, 
    DeviceSize stride, 
    QueryResultFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyQueryPoolResults(commandBuffer,
        queryPool,
        firstQuery,
        queryCount,
        dstBuffer,
        dstOffset,
        stride,
        flags);
}
void CmdPushConstants(CommandBuffer commandBuffer, 
    PipelineLayout layout, 
    ShaderStageFlags stageFlags, 
    uint32_t offset, 
    detail::span<const std::byte> Values) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t size = Values.size();
    pfn_CmdPushConstants(commandBuffer,
        layout,
        stageFlags,
        offset,
        size,
        Values.data());
}
void CmdBeginRenderPass(CommandBuffer commandBuffer, 
    const RenderPassBeginInfo&  pRenderPassBegin, 
    SubpassContents contents) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginRenderPass(commandBuffer,
        &pRenderPassBegin,
        contents);
}
void CmdNextSubpass(CommandBuffer commandBuffer, 
    SubpassContents contents) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdNextSubpass(commandBuffer,
        contents);
}
void CmdEndRenderPass(CommandBuffer commandBuffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndRenderPass(commandBuffer);
}
void CmdExecuteCommands(CommandBuffer commandBuffer, 
    detail::span<const CommandBuffer> CommandBuffers) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t commandBufferCount = CommandBuffers.size();
    pfn_CmdExecuteCommands(commandBuffer,
        commandBufferCount,
        CommandBuffers.data());
}
[[nodiscard]] Result BindBufferMemory2(detail::span<const BindBufferMemoryInfo> BindInfos) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindInfoCount = BindInfos.size();
    return pfn_BindBufferMemory2(device,
        bindInfoCount,
        BindInfos.data());
}
[[nodiscard]] Result BindImageMemory2(detail::span<const BindImageMemoryInfo> BindInfos) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindInfoCount = BindInfos.size();
    return pfn_BindImageMemory2(device,
        bindInfoCount,
        BindInfos.data());
}
[[nodiscard]] PeerMemoryFeatureFlags GetDeviceGroupPeerMemoryFeatures(uint32_t heapIndex, 
    uint32_t localDeviceIndex, 
    uint32_t remoteDeviceIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PeerMemoryFeatureFlags pPeerMemoryFeatures;
    pfn_GetDeviceGroupPeerMemoryFeatures(device,
        heapIndex,
        localDeviceIndex,
        remoteDeviceIndex,
        &pPeerMemoryFeatures);
    return pPeerMemoryFeatures;
}
void CmdSetDeviceMask(CommandBuffer commandBuffer, 
    uint32_t deviceMask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDeviceMask(commandBuffer,
        deviceMask);
}
void CmdDispatchBase(CommandBuffer commandBuffer, 
    uint32_t baseGroupX, 
    uint32_t baseGroupY, 
    uint32_t baseGroupZ, 
    uint32_t groupCountX, 
    uint32_t groupCountY, 
    uint32_t groupCountZ) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDispatchBase(commandBuffer,
        baseGroupX,
        baseGroupY,
        baseGroupZ,
        groupCountX,
        groupCountY,
        groupCountZ);
}
[[nodiscard]] MemoryRequirements2 GetBufferMemoryRequirements2(const BufferMemoryRequirementsInfo2&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryRequirements2 pMemoryRequirements;
    pfn_GetBufferMemoryRequirements2(device,
        &pInfo,
        &pMemoryRequirements);
    return pMemoryRequirements;
}
[[nodiscard]] MemoryRequirements2 GetImageMemoryRequirements2(const ImageMemoryRequirementsInfo2&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryRequirements2 pMemoryRequirements;
    pfn_GetImageMemoryRequirements2(device,
        &pInfo,
        &pMemoryRequirements);
    return pMemoryRequirements;
}
[[nodiscard]] std::vector<SparseImageMemoryRequirements2> GetImageSparseMemoryRequirements2(const ImageSparseMemoryRequirementsInfo2&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pSparseMemoryRequirementCount = 0;
    pfn_GetImageSparseMemoryRequirements2(device,
        &pInfo,
        &pSparseMemoryRequirementCount,
        nullptr);
    std::vector<SparseImageMemoryRequirements2> pSparseMemoryRequirements(pSparseMemoryRequirementCount);
pfn_GetImageSparseMemoryRequirements2(device,
        &pInfo,
        &pSparseMemoryRequirementCount,
        pSparseMemoryRequirements.data());
    return pSparseMemoryRequirements;
}
void TrimCommandPool(CommandPool commandPool, 
    CommandPoolTrimFlags flags = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_TrimCommandPool(device,
        commandPool,
        flags);
}
[[nodiscard]] Queue GetDeviceQueue2(const DeviceQueueInfo2&  pQueueInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Queue pQueue;
    pfn_GetDeviceQueue2(device,
        &pQueueInfo,
        &pQueue);
    return pQueue;
}
[[nodiscard]] expected<SamplerYcbcrConversion> CreateSamplerYcbcrConversion(const SamplerYcbcrConversionCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SamplerYcbcrConversion pYcbcrConversion;
        Result result = pfn_CreateSamplerYcbcrConversion(device,
        &pCreateInfo,
        pAllocator,
        &pYcbcrConversion);
    return expected<SamplerYcbcrConversion>(pYcbcrConversion, result);
}
void DestroySamplerYcbcrConversion(SamplerYcbcrConversion ycbcrConversion = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroySamplerYcbcrConversion(device,
        ycbcrConversion,
        pAllocator);
}
[[nodiscard]] expected<DescriptorUpdateTemplate> CreateDescriptorUpdateTemplate(const DescriptorUpdateTemplateCreateInfo&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DescriptorUpdateTemplate pDescriptorUpdateTemplate;
        Result result = pfn_CreateDescriptorUpdateTemplate(device,
        &pCreateInfo,
        pAllocator,
        &pDescriptorUpdateTemplate);
    return expected<DescriptorUpdateTemplate>(pDescriptorUpdateTemplate, result);
}
void DestroyDescriptorUpdateTemplate(DescriptorUpdateTemplate descriptorUpdateTemplate = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDescriptorUpdateTemplate(device,
        descriptorUpdateTemplate,
        pAllocator);
}
void UpdateDescriptorSetWithTemplate(DescriptorSet descriptorSet, 
    DescriptorUpdateTemplate descriptorUpdateTemplate, 
    const void* pData) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_UpdateDescriptorSetWithTemplate(device,
        descriptorSet,
        descriptorUpdateTemplate,
        pData);
}
[[nodiscard]] DescriptorSetLayoutSupport GetDescriptorSetLayoutSupport(const DescriptorSetLayoutCreateInfo&  pCreateInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DescriptorSetLayoutSupport pSupport;
    pfn_GetDescriptorSetLayoutSupport(device,
        &pCreateInfo,
        &pSupport);
    return pSupport;
}
void CmdDrawIndirectCount(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    Buffer countBuffer, 
    DeviceSize countBufferOffset, 
    uint32_t maxDrawCount, 
    uint32_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawIndirectCount(commandBuffer,
        buffer,
        offset,
        countBuffer,
        countBufferOffset,
        maxDrawCount,
        stride);
}
void CmdDrawIndexedIndirectCount(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    Buffer countBuffer, 
    DeviceSize countBufferOffset, 
    uint32_t maxDrawCount, 
    uint32_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawIndexedIndirectCount(commandBuffer,
        buffer,
        offset,
        countBuffer,
        countBufferOffset,
        maxDrawCount,
        stride);
}
[[nodiscard]] expected<RenderPass> CreateRenderPass2(const RenderPassCreateInfo2&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    RenderPass pRenderPass;
        Result result = pfn_CreateRenderPass2(device,
        &pCreateInfo,
        pAllocator,
        &pRenderPass);
    return expected<RenderPass>(pRenderPass, result);
}
void CmdBeginRenderPass2(CommandBuffer commandBuffer, 
    const RenderPassBeginInfo&  pRenderPassBegin, 
    const SubpassBeginInfo&  pSubpassBeginInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginRenderPass2(commandBuffer,
        &pRenderPassBegin,
        &pSubpassBeginInfo);
}
void CmdNextSubpass2(CommandBuffer commandBuffer, 
    const SubpassBeginInfo&  pSubpassBeginInfo, 
    const SubpassEndInfo&  pSubpassEndInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdNextSubpass2(commandBuffer,
        &pSubpassBeginInfo,
        &pSubpassEndInfo);
}
void CmdEndRenderPass2(CommandBuffer commandBuffer, 
    const SubpassEndInfo&  pSubpassEndInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndRenderPass2(commandBuffer,
        &pSubpassEndInfo);
}
void ResetQueryPool(QueryPool queryPool, 
    uint32_t firstQuery, 
    uint32_t queryCount) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_ResetQueryPool(device,
        queryPool,
        firstQuery,
        queryCount);
}
[[nodiscard]] expected<uint64_t> GetSemaphoreCounterValue(Semaphore semaphore) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint64_t pValue;
        Result result = pfn_GetSemaphoreCounterValue(device,
        semaphore,
        &pValue);
    return expected<uint64_t>(pValue, result);
}
[[nodiscard]] Result WaitSemaphores(const SemaphoreWaitInfo&  pWaitInfo, 
    uint64_t timeout) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_WaitSemaphores(device,
        &pWaitInfo,
        timeout);
}
[[nodiscard]] Result SignalSemaphore(const SemaphoreSignalInfo&  pSignalInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_SignalSemaphore(device,
        &pSignalInfo);
}
[[nodiscard]] uint64_t GetBufferOpaqueCaptureAddress(const BufferDeviceAddressInfo&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetBufferOpaqueCaptureAddress(device,
        &pInfo);
}
[[nodiscard]] DeviceAddress GetBufferDeviceAddress(const BufferDeviceAddressInfo&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetBufferDeviceAddress(device,
        &pInfo);
}
[[nodiscard]] uint64_t GetDeviceMemoryOpaqueCaptureAddress(const DeviceMemoryOpaqueCaptureAddressInfo&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetDeviceMemoryOpaqueCaptureAddress(device,
        &pInfo);
}
[[nodiscard]] expected<SwapchainKHR> CreateSwapchainKHR(const SwapchainCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    SwapchainKHR pSwapchain;
        Result result = pfn_CreateSwapchainKHR(device,
        &pCreateInfo,
        pAllocator,
        &pSwapchain);
    return expected<SwapchainKHR>(pSwapchain, result);
}
void DestroySwapchainKHR(SwapchainKHR swapchain = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroySwapchainKHR(device,
        swapchain,
        pAllocator);
}
[[nodiscard]] expected<std::vector<Image>> GetSwapchainImagesKHR(SwapchainKHR swapchain) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pSwapchainImageCount = 0;
        Result result = pfn_GetSwapchainImagesKHR(device,
        swapchain,
        &pSwapchainImageCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<Image>{}, result);
    std::vector<Image> pSwapchainImages(pSwapchainImageCount);
    result = pfn_GetSwapchainImagesKHR(device,
        swapchain,
        &pSwapchainImageCount,
        pSwapchainImages.data());
    return expected(std::move(pSwapchainImages), result);
}
[[nodiscard]] expected<uint32_t> AcquireNextImageKHR(SwapchainKHR swapchain, 
    uint64_t timeout, 
    Semaphore semaphore = {}, 
    Fence fence = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pImageIndex;
        Result result = pfn_AcquireNextImageKHR(device,
        swapchain,
        timeout,
        semaphore,
        fence,
        &pImageIndex);
    return expected<uint32_t>(pImageIndex, result);
}
[[nodiscard]] Result QueuePresentKHR(Queue queue, 
    const PresentInfoKHR&  pPresentInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_QueuePresentKHR(queue,
        &pPresentInfo);
}
[[nodiscard]] expected<DeviceGroupPresentCapabilitiesKHR> GetDeviceGroupPresentCapabilitiesKHR() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities;
        Result result = pfn_GetDeviceGroupPresentCapabilitiesKHR(device,
        &pDeviceGroupPresentCapabilities);
    return expected<DeviceGroupPresentCapabilitiesKHR>(pDeviceGroupPresentCapabilities, result);
}
[[nodiscard]] expected<DeviceGroupPresentModeFlagsKHR> GetDeviceGroupSurfacePresentModesKHR(SurfaceKHR surface) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeviceGroupPresentModeFlagsKHR pModes;
        Result result = pfn_GetDeviceGroupSurfacePresentModesKHR(device,
        surface,
        &pModes);
    return expected<DeviceGroupPresentModeFlagsKHR>(pModes, result);
}
[[nodiscard]] expected<uint32_t> AcquireNextImage2KHR(const AcquireNextImageInfoKHR&  pAcquireInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pImageIndex;
        Result result = pfn_AcquireNextImage2KHR(device,
        &pAcquireInfo,
        &pImageIndex);
    return expected<uint32_t>(pImageIndex, result);
}
[[nodiscard]] Result CreateSharedSwapchainsKHR(detail::span<const SwapchainCreateInfoKHR> CreateInfos, 
    const AllocationCallbacks* pAllocator, 
    detail::span<SwapchainKHR> Swapchains) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t swapchainCount = CreateInfos.size();
    return pfn_CreateSharedSwapchainsKHR(device,
        swapchainCount,
        CreateInfos.data(),
        pAllocator,
        Swapchains.data());
}
[[nodiscard]] Result DebugMarkerSetObjectNameEXT(const DebugMarkerObjectNameInfoEXT&  pNameInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_DebugMarkerSetObjectNameEXT(device,
        &pNameInfo);
}
[[nodiscard]] Result DebugMarkerSetObjectTagEXT(const DebugMarkerObjectTagInfoEXT&  pTagInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_DebugMarkerSetObjectTagEXT(device,
        &pTagInfo);
}
void CmdDebugMarkerBeginEXT(CommandBuffer commandBuffer, 
    const DebugMarkerMarkerInfoEXT&  pMarkerInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDebugMarkerBeginEXT(commandBuffer,
        &pMarkerInfo);
}
void CmdDebugMarkerEndEXT(CommandBuffer commandBuffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDebugMarkerEndEXT(commandBuffer);
}
void CmdDebugMarkerInsertEXT(CommandBuffer commandBuffer, 
    const DebugMarkerMarkerInfoEXT&  pMarkerInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDebugMarkerInsertEXT(commandBuffer,
        &pMarkerInfo);
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
[[nodiscard]] expected<VideoSessionKHR> CreateVideoSessionKHR(const VideoSessionCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    VideoSessionKHR pVideoSession;
        Result result = pfn_CreateVideoSessionKHR(device,
        &pCreateInfo,
        pAllocator,
        &pVideoSession);
    return expected<VideoSessionKHR>(pVideoSession, result);
}
void DestroyVideoSessionKHR(VideoSessionKHR videoSession, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyVideoSessionKHR(device,
        videoSession,
        pAllocator);
}
[[nodiscard]] expected<VideoSessionParametersKHR> CreateVideoSessionParametersKHR(const VideoSessionParametersCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    VideoSessionParametersKHR pVideoSessionParameters;
        Result result = pfn_CreateVideoSessionParametersKHR(device,
        &pCreateInfo,
        pAllocator,
        &pVideoSessionParameters);
    return expected<VideoSessionParametersKHR>(pVideoSessionParameters, result);
}
[[nodiscard]] Result UpdateVideoSessionParametersKHR(VideoSessionParametersKHR videoSessionParameters, 
    const VideoSessionParametersUpdateInfoKHR&  pUpdateInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_UpdateVideoSessionParametersKHR(device,
        videoSessionParameters,
        &pUpdateInfo);
}
void DestroyVideoSessionParametersKHR(VideoSessionParametersKHR videoSessionParameters, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyVideoSessionParametersKHR(device,
        videoSessionParameters,
        pAllocator);
}
[[nodiscard]] Result GetVideoSessionMemoryRequirementsKHR(VideoSessionKHR videoSession, 
    uint32_t&  pVideoSessionMemoryRequirementsCount, 
    VideoGetMemoryPropertiesKHR* pVideoSessionMemoryRequirements = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetVideoSessionMemoryRequirementsKHR(device,
        videoSession,
        &pVideoSessionMemoryRequirementsCount,
        pVideoSessionMemoryRequirements);
}
[[nodiscard]] Result BindVideoSessionMemoryKHR(VideoSessionKHR videoSession, 
    detail::span<const VideoBindMemoryKHR> VideoSessionBindMemories) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t videoSessionBindMemoryCount = VideoSessionBindMemories.size();
    return pfn_BindVideoSessionMemoryKHR(device,
        videoSession,
        videoSessionBindMemoryCount,
        VideoSessionBindMemories.data());
}
void CmdBeginVideoCodingKHR(CommandBuffer commandBuffer, 
    const VideoBeginCodingInfoKHR&  pBeginInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginVideoCodingKHR(commandBuffer,
        &pBeginInfo);
}
void CmdControlVideoCodingKHR(CommandBuffer commandBuffer, 
    const VideoCodingControlInfoKHR&  pCodingControlInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdControlVideoCodingKHR(commandBuffer,
        &pCodingControlInfo);
}
void CmdEndVideoCodingKHR(CommandBuffer commandBuffer, 
    const VideoEndCodingInfoKHR&  pEndCodingInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndVideoCodingKHR(commandBuffer,
        &pEndCodingInfo);
}
void CmdDecodeVideoKHR(CommandBuffer commandBuffer, 
    const VideoDecodeInfoKHR&  pFrameInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDecodeVideoKHR(commandBuffer,
        &pFrameInfo);
}
void CmdEncodeVideoKHR(CommandBuffer commandBuffer, 
    const VideoEncodeInfoKHR&  pEncodeInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEncodeVideoKHR(commandBuffer,
        &pEncodeInfo);
}
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
void CmdBindTransformFeedbackBuffersEXT(CommandBuffer commandBuffer, 
    uint32_t firstBinding, 
    detail::span<const Buffer> Buffers, 
    detail::span<const DeviceSize> Offsets, 
    detail::span<const DeviceSize> Sizes = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindingCount = Buffers.size();
    pfn_CmdBindTransformFeedbackBuffersEXT(commandBuffer,
        firstBinding,
        bindingCount,
        Buffers.data(),
        Offsets.data(),
        Sizes.data());
}
void CmdBeginTransformFeedbackEXT(CommandBuffer commandBuffer, 
    uint32_t firstCounterBuffer, 
    detail::span<const Buffer> CounterBuffers, 
    detail::span<const DeviceSize> CounterBufferOffsets = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t counterBufferCount = CounterBuffers.size();
    pfn_CmdBeginTransformFeedbackEXT(commandBuffer,
        firstCounterBuffer,
        counterBufferCount,
        CounterBuffers.data(),
        CounterBufferOffsets.data());
}
void CmdEndTransformFeedbackEXT(CommandBuffer commandBuffer, 
    uint32_t firstCounterBuffer, 
    detail::span<const Buffer> CounterBuffers, 
    detail::span<const DeviceSize> CounterBufferOffsets = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t counterBufferCount = CounterBuffers.size();
    pfn_CmdEndTransformFeedbackEXT(commandBuffer,
        firstCounterBuffer,
        counterBufferCount,
        CounterBuffers.data(),
        CounterBufferOffsets.data());
}
void CmdBeginQueryIndexedEXT(CommandBuffer commandBuffer, 
    QueryPool queryPool, 
    uint32_t query, 
    QueryControlFlags flags, 
    uint32_t index) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginQueryIndexedEXT(commandBuffer,
        queryPool,
        query,
        flags,
        index);
}
void CmdEndQueryIndexedEXT(CommandBuffer commandBuffer, 
    QueryPool queryPool, 
    uint32_t query, 
    uint32_t index) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndQueryIndexedEXT(commandBuffer,
        queryPool,
        query,
        index);
}
void CmdDrawIndirectByteCountEXT(CommandBuffer commandBuffer, 
    uint32_t instanceCount, 
    uint32_t firstInstance, 
    Buffer counterBuffer, 
    DeviceSize counterBufferOffset, 
    uint32_t counterOffset, 
    uint32_t vertexStride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawIndirectByteCountEXT(commandBuffer,
        instanceCount,
        firstInstance,
        counterBuffer,
        counterBufferOffset,
        counterOffset,
        vertexStride);
}
[[nodiscard]] uint32_t GetImageViewHandleNVX(const ImageViewHandleInfoNVX&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetImageViewHandleNVX(device,
        &pInfo);
}
[[nodiscard]] expected<ImageViewAddressPropertiesNVX> GetImageViewAddressNVX(ImageView imageView) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ImageViewAddressPropertiesNVX pProperties;
        Result result = pfn_GetImageViewAddressNVX(device,
        imageView,
        &pProperties);
    return expected<ImageViewAddressPropertiesNVX>(pProperties, result);
}
[[nodiscard]] expected<std::vector<void*>> GetShaderInfoAMD(Pipeline pipeline, 
    ShaderStageFlagBits shaderStage, 
    ShaderInfoTypeAMD infoType) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t pInfoSize = 0;
        Result result = pfn_GetShaderInfoAMD(device,
        pipeline,
        shaderStage,
        infoType,
        &pInfoSize,
        nullptr);
    if (result < Result::Success) return expected(std::vector<void*>{}, result);
    std::vector<void*> pInfo(pInfoSize);
    result = pfn_GetShaderInfoAMD(device,
        pipeline,
        shaderStage,
        infoType,
        &pInfoSize,
        pInfo.data());
    return expected(std::move(pInfo), result);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<HANDLE> GetMemoryWin32HandleNV(DeviceMemory memory, 
    ExternalMemoryHandleTypeFlagsNV handleType) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    HANDLE pHandle;
        Result result = pfn_GetMemoryWin32HandleNV(device,
        memory,
        handleType,
        &pHandle);
    return expected<HANDLE>(pHandle, result);
}
[[nodiscard]] expected<HANDLE> GetMemoryWin32HandleKHR(const MemoryGetWin32HandleInfoKHR&  pGetWin32HandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    HANDLE pHandle;
        Result result = pfn_GetMemoryWin32HandleKHR(device,
        &pGetWin32HandleInfo,
        &pHandle);
    return expected<HANDLE>(pHandle, result);
}
[[nodiscard]] expected<MemoryWin32HandlePropertiesKHR> GetMemoryWin32HandlePropertiesKHR(ExternalMemoryHandleTypeFlagBits handleType, 
    HANDLE handle) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties;
        Result result = pfn_GetMemoryWin32HandlePropertiesKHR(device,
        handleType,
        handle,
        &pMemoryWin32HandleProperties);
    return expected<MemoryWin32HandlePropertiesKHR>(pMemoryWin32HandleProperties, result);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<int> GetMemoryFdKHR(const MemoryGetFdInfoKHR&  pGetFdInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    int pFd;
        Result result = pfn_GetMemoryFdKHR(device,
        &pGetFdInfo,
        &pFd);
    return expected<int>(pFd, result);
}
[[nodiscard]] expected<MemoryFdPropertiesKHR> GetMemoryFdPropertiesKHR(ExternalMemoryHandleTypeFlagBits handleType, 
    int fd) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryFdPropertiesKHR pMemoryFdProperties;
        Result result = pfn_GetMemoryFdPropertiesKHR(device,
        handleType,
        fd,
        &pMemoryFdProperties);
    return expected<MemoryFdPropertiesKHR>(pMemoryFdProperties, result);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<HANDLE> GetSemaphoreWin32HandleKHR(const SemaphoreGetWin32HandleInfoKHR&  pGetWin32HandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    HANDLE pHandle;
        Result result = pfn_GetSemaphoreWin32HandleKHR(device,
        &pGetWin32HandleInfo,
        &pHandle);
    return expected<HANDLE>(pHandle, result);
}
[[nodiscard]] Result ImportSemaphoreWin32HandleKHR(const ImportSemaphoreWin32HandleInfoKHR&  pImportSemaphoreWin32HandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ImportSemaphoreWin32HandleKHR(device,
        &pImportSemaphoreWin32HandleInfo);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<int> GetSemaphoreFdKHR(const SemaphoreGetFdInfoKHR&  pGetFdInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    int pFd;
        Result result = pfn_GetSemaphoreFdKHR(device,
        &pGetFdInfo,
        &pFd);
    return expected<int>(pFd, result);
}
[[nodiscard]] Result ImportSemaphoreFdKHR(const ImportSemaphoreFdInfoKHR&  pImportSemaphoreFdInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ImportSemaphoreFdKHR(device,
        &pImportSemaphoreFdInfo);
}
void CmdPushDescriptorSetKHR(CommandBuffer commandBuffer, 
    PipelineBindPoint pipelineBindPoint, 
    PipelineLayout layout, 
    uint32_t set, 
    detail::span<const WriteDescriptorSet> DescriptorWrites) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t descriptorWriteCount = DescriptorWrites.size();
    pfn_CmdPushDescriptorSetKHR(commandBuffer,
        pipelineBindPoint,
        layout,
        set,
        descriptorWriteCount,
        DescriptorWrites.data());
}
void CmdPushDescriptorSetWithTemplateKHR(CommandBuffer commandBuffer, 
    DescriptorUpdateTemplate descriptorUpdateTemplate, 
    PipelineLayout layout, 
    uint32_t set, 
    const void* pData) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdPushDescriptorSetWithTemplateKHR(commandBuffer,
        descriptorUpdateTemplate,
        layout,
        set,
        pData);
}
void CmdBeginConditionalRenderingEXT(CommandBuffer commandBuffer, 
    const ConditionalRenderingBeginInfoEXT&  pConditionalRenderingBegin) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginConditionalRenderingEXT(commandBuffer,
        &pConditionalRenderingBegin);
}
void CmdEndConditionalRenderingEXT(CommandBuffer commandBuffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndConditionalRenderingEXT(commandBuffer);
}
void CmdSetViewportWScalingNV(CommandBuffer commandBuffer, 
    uint32_t firstViewport, 
    detail::span<const ViewportWScalingNV> ViewportWScalings) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t viewportCount = ViewportWScalings.size();
    pfn_CmdSetViewportWScalingNV(commandBuffer,
        firstViewport,
        viewportCount,
        ViewportWScalings.data());
}
[[nodiscard]] Result DisplayPowerControlEXT(DisplayKHR display, 
    const DisplayPowerInfoEXT&  pDisplayPowerInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_DisplayPowerControlEXT(device,
        display,
        &pDisplayPowerInfo);
}
[[nodiscard]] expected<Fence> RegisterDeviceEventEXT(const DeviceEventInfoEXT&  pDeviceEventInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Fence pFence;
        Result result = pfn_RegisterDeviceEventEXT(device,
        &pDeviceEventInfo,
        pAllocator,
        &pFence);
    return expected<Fence>(pFence, result);
}
[[nodiscard]] expected<Fence> RegisterDisplayEventEXT(DisplayKHR display, 
    const DisplayEventInfoEXT&  pDisplayEventInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    Fence pFence;
        Result result = pfn_RegisterDisplayEventEXT(device,
        display,
        &pDisplayEventInfo,
        pAllocator,
        &pFence);
    return expected<Fence>(pFence, result);
}
[[nodiscard]] expected<uint64_t> GetSwapchainCounterEXT(SwapchainKHR swapchain, 
    SurfaceCounterFlagBitsEXT counter) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint64_t pCounterValue;
        Result result = pfn_GetSwapchainCounterEXT(device,
        swapchain,
        counter,
        &pCounterValue);
    return expected<uint64_t>(pCounterValue, result);
}
[[nodiscard]] expected<RefreshCycleDurationGOOGLE> GetRefreshCycleDurationGOOGLE(SwapchainKHR swapchain) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    RefreshCycleDurationGOOGLE pDisplayTimingProperties;
        Result result = pfn_GetRefreshCycleDurationGOOGLE(device,
        swapchain,
        &pDisplayTimingProperties);
    return expected<RefreshCycleDurationGOOGLE>(pDisplayTimingProperties, result);
}
[[nodiscard]] expected<std::vector<PastPresentationTimingGOOGLE>> GetPastPresentationTimingGOOGLE(SwapchainKHR swapchain) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pPresentationTimingCount = 0;
        Result result = pfn_GetPastPresentationTimingGOOGLE(device,
        swapchain,
        &pPresentationTimingCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PastPresentationTimingGOOGLE>{}, result);
    std::vector<PastPresentationTimingGOOGLE> pPresentationTimings(pPresentationTimingCount);
    result = pfn_GetPastPresentationTimingGOOGLE(device,
        swapchain,
        &pPresentationTimingCount,
        pPresentationTimings.data());
    return expected(std::move(pPresentationTimings), result);
}
void CmdSetDiscardRectangleEXT(CommandBuffer commandBuffer, 
    uint32_t firstDiscardRectangle, 
    detail::span<const Rect2D> DiscardRectangles) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t discardRectangleCount = DiscardRectangles.size();
    pfn_CmdSetDiscardRectangleEXT(commandBuffer,
        firstDiscardRectangle,
        discardRectangleCount,
        DiscardRectangles.data());
}
void SetHdrMetadataEXT(detail::span<const SwapchainKHR> Swapchains, 
    detail::span<const HdrMetadataEXT> Metadata) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t swapchainCount = Swapchains.size();
    pfn_SetHdrMetadataEXT(device,
        swapchainCount,
        Swapchains.data(),
        Metadata.data());
}
[[nodiscard]] Result GetSwapchainStatusKHR(SwapchainKHR swapchain) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetSwapchainStatusKHR(device,
        swapchain);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<HANDLE> GetFenceWin32HandleKHR(const FenceGetWin32HandleInfoKHR&  pGetWin32HandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    HANDLE pHandle;
        Result result = pfn_GetFenceWin32HandleKHR(device,
        &pGetWin32HandleInfo,
        &pHandle);
    return expected<HANDLE>(pHandle, result);
}
[[nodiscard]] Result ImportFenceWin32HandleKHR(const ImportFenceWin32HandleInfoKHR&  pImportFenceWin32HandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ImportFenceWin32HandleKHR(device,
        &pImportFenceWin32HandleInfo);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<int> GetFenceFdKHR(const FenceGetFdInfoKHR&  pGetFdInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    int pFd;
        Result result = pfn_GetFenceFdKHR(device,
        &pGetFdInfo,
        &pFd);
    return expected<int>(pFd, result);
}
[[nodiscard]] Result ImportFenceFdKHR(const ImportFenceFdInfoKHR&  pImportFenceFdInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ImportFenceFdKHR(device,
        &pImportFenceFdInfo);
}
[[nodiscard]] Result AcquireProfilingLockKHR(const AcquireProfilingLockInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_AcquireProfilingLockKHR(device,
        &pInfo);
}
void ReleaseProfilingLockKHR() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_ReleaseProfilingLockKHR(device);
}
[[nodiscard]] Result SetDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT&  pNameInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_SetDebugUtilsObjectNameEXT(device,
        &pNameInfo);
}
[[nodiscard]] Result SetDebugUtilsObjectTagEXT(const DebugUtilsObjectTagInfoEXT&  pTagInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_SetDebugUtilsObjectTagEXT(device,
        &pTagInfo);
}
void QueueBeginDebugUtilsLabelEXT(Queue queue, 
    const DebugUtilsLabelEXT&  pLabelInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_QueueBeginDebugUtilsLabelEXT(queue,
        &pLabelInfo);
}
void QueueEndDebugUtilsLabelEXT(Queue queue) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_QueueEndDebugUtilsLabelEXT(queue);
}
void QueueInsertDebugUtilsLabelEXT(Queue queue, 
    const DebugUtilsLabelEXT&  pLabelInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_QueueInsertDebugUtilsLabelEXT(queue,
        &pLabelInfo);
}
void CmdBeginDebugUtilsLabelEXT(CommandBuffer commandBuffer, 
    const DebugUtilsLabelEXT&  pLabelInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBeginDebugUtilsLabelEXT(commandBuffer,
        &pLabelInfo);
}
void CmdEndDebugUtilsLabelEXT(CommandBuffer commandBuffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdEndDebugUtilsLabelEXT(commandBuffer);
}
void CmdInsertDebugUtilsLabelEXT(CommandBuffer commandBuffer, 
    const DebugUtilsLabelEXT&  pLabelInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdInsertDebugUtilsLabelEXT(commandBuffer,
        &pLabelInfo);
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
[[nodiscard]] expected<AndroidHardwareBufferPropertiesANDROID> GetAndroidHardwareBufferPropertiesANDROID(const AHardwareBuffer&  buffer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    AndroidHardwareBufferPropertiesANDROID pProperties;
        Result result = pfn_GetAndroidHardwareBufferPropertiesANDROID(device,
        &buffer,
        &pProperties);
    return expected<AndroidHardwareBufferPropertiesANDROID>(pProperties, result);
}
[[nodiscard]] expected<AHardwareBuffer*> GetMemoryAndroidHardwareBufferANDROID(const MemoryGetAndroidHardwareBufferInfoANDROID&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    AHardwareBuffer* pBuffer;
        Result result = pfn_GetMemoryAndroidHardwareBufferANDROID(device,
        &pInfo,
        &pBuffer);
    return expected<AHardwareBuffer*>(pBuffer, result);
}
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
void CmdSetSampleLocationsEXT(CommandBuffer commandBuffer, 
    const SampleLocationsInfoEXT&  pSampleLocationsInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetSampleLocationsEXT(commandBuffer,
        &pSampleLocationsInfo);
}
void DestroyAccelerationStructureKHR(AccelerationStructureKHR accelerationStructure = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyAccelerationStructureKHR(device,
        accelerationStructure,
        pAllocator);
}
void CmdCopyAccelerationStructureKHR(CommandBuffer commandBuffer, 
    const CopyAccelerationStructureInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyAccelerationStructureKHR(commandBuffer,
        &pInfo);
}
[[nodiscard]] Result CopyAccelerationStructureKHR(DeferredOperationKHR deferredOperation, 
    const CopyAccelerationStructureInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CopyAccelerationStructureKHR(device,
        deferredOperation,
        &pInfo);
}
void CmdCopyAccelerationStructureToMemoryKHR(CommandBuffer commandBuffer, 
    const CopyAccelerationStructureToMemoryInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyAccelerationStructureToMemoryKHR(commandBuffer,
        &pInfo);
}
[[nodiscard]] Result CopyAccelerationStructureToMemoryKHR(DeferredOperationKHR deferredOperation, 
    const CopyAccelerationStructureToMemoryInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CopyAccelerationStructureToMemoryKHR(device,
        deferredOperation,
        &pInfo);
}
void CmdCopyMemoryToAccelerationStructureKHR(CommandBuffer commandBuffer, 
    const CopyMemoryToAccelerationStructureInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyMemoryToAccelerationStructureKHR(commandBuffer,
        &pInfo);
}
[[nodiscard]] Result CopyMemoryToAccelerationStructureKHR(DeferredOperationKHR deferredOperation, 
    const CopyMemoryToAccelerationStructureInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CopyMemoryToAccelerationStructureKHR(device,
        deferredOperation,
        &pInfo);
}
void CmdWriteAccelerationStructuresPropertiesKHR(CommandBuffer commandBuffer, 
    detail::span<const AccelerationStructureKHR> AccelerationStructures, 
    QueryType queryType, 
    QueryPool queryPool, 
    uint32_t firstQuery) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t accelerationStructureCount = AccelerationStructures.size();
    pfn_CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer,
        accelerationStructureCount,
        AccelerationStructures.data(),
        queryType,
        queryPool,
        firstQuery);
}
[[nodiscard]] Result WriteAccelerationStructuresPropertiesKHR(detail::span<const AccelerationStructureKHR> AccelerationStructures, 
    QueryType queryType, 
    detail::span<std::byte> Data, 
    size_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t accelerationStructureCount = AccelerationStructures.size();
    size_t dataSize = Data.size();
    return pfn_WriteAccelerationStructuresPropertiesKHR(device,
        accelerationStructureCount,
        AccelerationStructures.data(),
        queryType,
        dataSize,
        Data.data(),
        stride);
}
[[nodiscard]] AccelerationStructureCompatibilityKHR GetDeviceAccelerationStructureCompatibilityKHR(const AccelerationStructureVersionInfoKHR&  pVersionInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    AccelerationStructureCompatibilityKHR pCompatibility;
    pfn_GetDeviceAccelerationStructureCompatibilityKHR(device,
        &pVersionInfo,
        &pCompatibility);
    return pCompatibility;
}
[[nodiscard]] expected<AccelerationStructureKHR> CreateAccelerationStructureKHR(const AccelerationStructureCreateInfoKHR&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    AccelerationStructureKHR pAccelerationStructure;
        Result result = pfn_CreateAccelerationStructureKHR(device,
        &pCreateInfo,
        pAllocator,
        &pAccelerationStructure);
    return expected<AccelerationStructureKHR>(pAccelerationStructure, result);
}
void CmdBuildAccelerationStructuresKHR(CommandBuffer commandBuffer, 
    detail::span<const AccelerationStructureBuildGeometryInfoKHR> Infos, 
    detail::span<const AccelerationStructureBuildRangeInfoKHR*> pBuildRangeInfos) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t infoCount = Infos.size();
    pfn_CmdBuildAccelerationStructuresKHR(commandBuffer,
        infoCount,
        Infos.data(),
        pBuildRangeInfos.data());
}
void CmdBuildAccelerationStructuresIndirectKHR(CommandBuffer commandBuffer, 
    detail::span<const AccelerationStructureBuildGeometryInfoKHR> Infos, 
    detail::span<const DeviceAddress> IndirectDeviceAddresses, 
    detail::span<const uint32_t> IndirectStrides, 
    detail::span<const uint32_t*> pMaxPrimitiveCounts) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t infoCount = Infos.size();
    pfn_CmdBuildAccelerationStructuresIndirectKHR(commandBuffer,
        infoCount,
        Infos.data(),
        IndirectDeviceAddresses.data(),
        IndirectStrides.data(),
        pMaxPrimitiveCounts.data());
}
[[nodiscard]] Result BuildAccelerationStructuresKHR(DeferredOperationKHR deferredOperation, 
    detail::span<const AccelerationStructureBuildGeometryInfoKHR> Infos, 
    detail::span<const AccelerationStructureBuildRangeInfoKHR*> pBuildRangeInfos) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t infoCount = Infos.size();
    return pfn_BuildAccelerationStructuresKHR(device,
        deferredOperation,
        infoCount,
        Infos.data(),
        pBuildRangeInfos.data());
}
[[nodiscard]] DeviceAddress GetAccelerationStructureDeviceAddressKHR(const AccelerationStructureDeviceAddressInfoKHR&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetAccelerationStructureDeviceAddressKHR(device,
        &pInfo);
}
[[nodiscard]] AccelerationStructureBuildSizesInfoKHR GetAccelerationStructureBuildSizesKHR(AccelerationStructureBuildTypeKHR buildType, 
    const AccelerationStructureBuildGeometryInfoKHR&  pBuildInfo, 
    const uint32_t* pMaxPrimitiveCounts = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    AccelerationStructureBuildSizesInfoKHR pSizeInfo;
    pfn_GetAccelerationStructureBuildSizesKHR(device,
        buildType,
        &pBuildInfo,
        pMaxPrimitiveCounts,
        &pSizeInfo);
    return pSizeInfo;
}
void CmdTraceRaysKHR(CommandBuffer commandBuffer, 
    const StridedDeviceAddressRegionKHR&  pRaygenShaderBindingTable, 
    const StridedDeviceAddressRegionKHR&  pMissShaderBindingTable, 
    const StridedDeviceAddressRegionKHR&  pHitShaderBindingTable, 
    const StridedDeviceAddressRegionKHR&  pCallableShaderBindingTable, 
    uint32_t width, 
    uint32_t height, 
    uint32_t depth) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdTraceRaysKHR(commandBuffer,
        &pRaygenShaderBindingTable,
        &pMissShaderBindingTable,
        &pHitShaderBindingTable,
        &pCallableShaderBindingTable,
        width,
        height,
        depth);
}
[[nodiscard]] Result GetRayTracingShaderGroupHandlesKHR(Pipeline pipeline, 
    uint32_t firstGroup, 
    uint32_t groupCount, 
    detail::span<std::byte> Data) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t dataSize = Data.size();
    return pfn_GetRayTracingShaderGroupHandlesKHR(device,
        pipeline,
        firstGroup,
        groupCount,
        dataSize,
        Data.data());
}
[[nodiscard]] Result GetRayTracingCaptureReplayShaderGroupHandlesKHR(Pipeline pipeline, 
    uint32_t firstGroup, 
    uint32_t groupCount, 
    detail::span<std::byte> Data) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t dataSize = Data.size();
    return pfn_GetRayTracingCaptureReplayShaderGroupHandlesKHR(device,
        pipeline,
        firstGroup,
        groupCount,
        dataSize,
        Data.data());
}
[[nodiscard]] Result CreateRayTracingPipelinesKHR(DeferredOperationKHR deferredOperation, 
    PipelineCache pipelineCache, 
    detail::span<const RayTracingPipelineCreateInfoKHR> CreateInfos, 
    const AllocationCallbacks* pAllocator, 
    detail::span<Pipeline> Pipelines) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t createInfoCount = CreateInfos.size();
    return pfn_CreateRayTracingPipelinesKHR(device,
        deferredOperation,
        pipelineCache,
        createInfoCount,
        CreateInfos.data(),
        pAllocator,
        Pipelines.data());
}
void CmdTraceRaysIndirectKHR(CommandBuffer commandBuffer, 
    const StridedDeviceAddressRegionKHR&  pRaygenShaderBindingTable, 
    const StridedDeviceAddressRegionKHR&  pMissShaderBindingTable, 
    const StridedDeviceAddressRegionKHR&  pHitShaderBindingTable, 
    const StridedDeviceAddressRegionKHR&  pCallableShaderBindingTable, 
    DeviceAddress indirectDeviceAddress) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdTraceRaysIndirectKHR(commandBuffer,
        &pRaygenShaderBindingTable,
        &pMissShaderBindingTable,
        &pHitShaderBindingTable,
        &pCallableShaderBindingTable,
        indirectDeviceAddress);
}
[[nodiscard]] DeviceSize GetRayTracingShaderGroupStackSizeKHR(Pipeline pipeline, 
    uint32_t group, 
    ShaderGroupShaderKHR groupShader) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetRayTracingShaderGroupStackSizeKHR(device,
        pipeline,
        group,
        groupShader);
}
void CmdSetRayTracingPipelineStackSizeKHR(CommandBuffer commandBuffer, 
    uint32_t pipelineStackSize) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetRayTracingPipelineStackSizeKHR(commandBuffer,
        pipelineStackSize);
}
[[nodiscard]] expected<ImageDrmFormatModifierPropertiesEXT> GetImageDrmFormatModifierPropertiesEXT(Image image) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ImageDrmFormatModifierPropertiesEXT pProperties;
        Result result = pfn_GetImageDrmFormatModifierPropertiesEXT(device,
        image,
        &pProperties);
    return expected<ImageDrmFormatModifierPropertiesEXT>(pProperties, result);
}
[[nodiscard]] expected<ValidationCacheEXT> CreateValidationCacheEXT(const ValidationCacheCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    ValidationCacheEXT pValidationCache;
        Result result = pfn_CreateValidationCacheEXT(device,
        &pCreateInfo,
        pAllocator,
        &pValidationCache);
    return expected<ValidationCacheEXT>(pValidationCache, result);
}
void DestroyValidationCacheEXT(ValidationCacheEXT validationCache = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyValidationCacheEXT(device,
        validationCache,
        pAllocator);
}
[[nodiscard]] expected<std::vector<void*>> GetValidationCacheDataEXT(ValidationCacheEXT validationCache) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t pDataSize = 0;
        Result result = pfn_GetValidationCacheDataEXT(device,
        validationCache,
        &pDataSize,
        nullptr);
    if (result < Result::Success) return expected(std::vector<void*>{}, result);
    std::vector<void*> pData(pDataSize);
    result = pfn_GetValidationCacheDataEXT(device,
        validationCache,
        &pDataSize,
        pData.data());
    return expected(std::move(pData), result);
}
[[nodiscard]] Result MergeValidationCachesEXT(ValidationCacheEXT dstCache, 
    detail::span<const ValidationCacheEXT> SrcCaches) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t srcCacheCount = SrcCaches.size();
    return pfn_MergeValidationCachesEXT(device,
        dstCache,
        srcCacheCount,
        SrcCaches.data());
}
void CmdBindShadingRateImageNV(CommandBuffer commandBuffer, 
    ImageView imageView, 
    ImageLayout imageLayout) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBindShadingRateImageNV(commandBuffer,
        imageView,
        imageLayout);
}
void CmdSetViewportShadingRatePaletteNV(CommandBuffer commandBuffer, 
    uint32_t firstViewport, 
    detail::span<const ShadingRatePaletteNV> ShadingRatePalettes) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t viewportCount = ShadingRatePalettes.size();
    pfn_CmdSetViewportShadingRatePaletteNV(commandBuffer,
        firstViewport,
        viewportCount,
        ShadingRatePalettes.data());
}
void CmdSetCoarseSampleOrderNV(CommandBuffer commandBuffer, 
    CoarseSampleOrderTypeNV sampleOrderType, 
    detail::span<const CoarseSampleOrderCustomNV> CustomSampleOrders) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t customSampleOrderCount = CustomSampleOrders.size();
    pfn_CmdSetCoarseSampleOrderNV(commandBuffer,
        sampleOrderType,
        customSampleOrderCount,
        CustomSampleOrders.data());
}
[[nodiscard]] Result CompileDeferredNV(Pipeline pipeline, 
    uint32_t shader) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CompileDeferredNV(device,
        pipeline,
        shader);
}
[[nodiscard]] expected<AccelerationStructureNV> CreateAccelerationStructureNV(const AccelerationStructureCreateInfoNV&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    AccelerationStructureNV pAccelerationStructure;
        Result result = pfn_CreateAccelerationStructureNV(device,
        &pCreateInfo,
        pAllocator,
        &pAccelerationStructure);
    return expected<AccelerationStructureNV>(pAccelerationStructure, result);
}
void DestroyAccelerationStructureNV(AccelerationStructureNV accelerationStructure = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyAccelerationStructureNV(device,
        accelerationStructure,
        pAllocator);
}
[[nodiscard]] MemoryRequirements2KHR GetAccelerationStructureMemoryRequirementsNV(const AccelerationStructureMemoryRequirementsInfoNV&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryRequirements2KHR pMemoryRequirements;
    pfn_GetAccelerationStructureMemoryRequirementsNV(device,
        &pInfo,
        &pMemoryRequirements);
    return pMemoryRequirements;
}
[[nodiscard]] Result BindAccelerationStructureMemoryNV(detail::span<const BindAccelerationStructureMemoryInfoNV> BindInfos) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindInfoCount = BindInfos.size();
    return pfn_BindAccelerationStructureMemoryNV(device,
        bindInfoCount,
        BindInfos.data());
}
void CmdCopyAccelerationStructureNV(CommandBuffer commandBuffer, 
    AccelerationStructureNV dst, 
    AccelerationStructureNV src, 
    CopyAccelerationStructureModeKHR mode) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyAccelerationStructureNV(commandBuffer,
        dst,
        src,
        mode);
}
void CmdWriteAccelerationStructuresPropertiesNV(CommandBuffer commandBuffer, 
    detail::span<const AccelerationStructureNV> AccelerationStructures, 
    QueryType queryType, 
    QueryPool queryPool, 
    uint32_t firstQuery) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t accelerationStructureCount = AccelerationStructures.size();
    pfn_CmdWriteAccelerationStructuresPropertiesNV(commandBuffer,
        accelerationStructureCount,
        AccelerationStructures.data(),
        queryType,
        queryPool,
        firstQuery);
}
void CmdBuildAccelerationStructureNV(CommandBuffer commandBuffer, 
    const AccelerationStructureInfoNV&  pInfo, 
    Buffer instanceData, 
    DeviceSize instanceOffset, 
    Bool32 update, 
    AccelerationStructureNV dst, 
    AccelerationStructureNV src, 
    Buffer scratch, 
    DeviceSize scratchOffset) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBuildAccelerationStructureNV(commandBuffer,
        &pInfo,
        instanceData,
        instanceOffset,
        update,
        dst,
        src,
        scratch,
        scratchOffset);
}
void CmdTraceRaysNV(CommandBuffer commandBuffer, 
    Buffer raygenShaderBindingTableBuffer, 
    DeviceSize raygenShaderBindingOffset, 
    Buffer missShaderBindingTableBuffer, 
    DeviceSize missShaderBindingOffset, 
    DeviceSize missShaderBindingStride, 
    Buffer hitShaderBindingTableBuffer, 
    DeviceSize hitShaderBindingOffset, 
    DeviceSize hitShaderBindingStride, 
    Buffer callableShaderBindingTableBuffer, 
    DeviceSize callableShaderBindingOffset, 
    DeviceSize callableShaderBindingStride, 
    uint32_t width, 
    uint32_t height, 
    uint32_t depth) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdTraceRaysNV(commandBuffer,
        raygenShaderBindingTableBuffer,
        raygenShaderBindingOffset,
        missShaderBindingTableBuffer,
        missShaderBindingOffset,
        missShaderBindingStride,
        hitShaderBindingTableBuffer,
        hitShaderBindingOffset,
        hitShaderBindingStride,
        callableShaderBindingTableBuffer,
        callableShaderBindingOffset,
        callableShaderBindingStride,
        width,
        height,
        depth);
}
[[nodiscard]] Result GetAccelerationStructureHandleNV(AccelerationStructureNV accelerationStructure, 
    detail::span<std::byte> Data) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    size_t dataSize = Data.size();
    return pfn_GetAccelerationStructureHandleNV(device,
        accelerationStructure,
        dataSize,
        Data.data());
}
[[nodiscard]] Result CreateRayTracingPipelinesNV(PipelineCache pipelineCache, 
    detail::span<const RayTracingPipelineCreateInfoNV> CreateInfos, 
    const AllocationCallbacks* pAllocator, 
    detail::span<Pipeline> Pipelines) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t createInfoCount = CreateInfos.size();
    return pfn_CreateRayTracingPipelinesNV(device,
        pipelineCache,
        createInfoCount,
        CreateInfos.data(),
        pAllocator,
        Pipelines.data());
}
[[nodiscard]] expected<MemoryHostPointerPropertiesEXT> GetMemoryHostPointerPropertiesEXT(ExternalMemoryHandleTypeFlagBits handleType, 
    const void* pHostPointer) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryHostPointerPropertiesEXT pMemoryHostPointerProperties;
        Result result = pfn_GetMemoryHostPointerPropertiesEXT(device,
        handleType,
        pHostPointer,
        &pMemoryHostPointerProperties);
    return expected<MemoryHostPointerPropertiesEXT>(pMemoryHostPointerProperties, result);
}
void CmdWriteBufferMarkerAMD(CommandBuffer commandBuffer, 
    PipelineStageFlagBits pipelineStage, 
    Buffer dstBuffer, 
    DeviceSize dstOffset, 
    uint32_t marker) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdWriteBufferMarkerAMD(commandBuffer,
        pipelineStage,
        dstBuffer,
        dstOffset,
        marker);
}
[[nodiscard]] expected<uint64_t> GetCalibratedTimestampsEXT(detail::span<const CalibratedTimestampInfoEXT> TimestampInfos, 
    detail::span<uint64_t> Timestamps) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t timestampCount = TimestampInfos.size();
    uint64_t pMaxDeviation;
        Result result = pfn_GetCalibratedTimestampsEXT(device,
        timestampCount,
        TimestampInfos.data(),
        Timestamps.data(),
        &pMaxDeviation);
    return expected<uint64_t>(pMaxDeviation, result);
}
void CmdDrawMeshTasksNV(CommandBuffer commandBuffer, 
    uint32_t taskCount, 
    uint32_t firstTask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawMeshTasksNV(commandBuffer,
        taskCount,
        firstTask);
}
void CmdDrawMeshTasksIndirectNV(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    uint32_t drawCount, 
    uint32_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawMeshTasksIndirectNV(commandBuffer,
        buffer,
        offset,
        drawCount,
        stride);
}
void CmdDrawMeshTasksIndirectCountNV(CommandBuffer commandBuffer, 
    Buffer buffer, 
    DeviceSize offset, 
    Buffer countBuffer, 
    DeviceSize countBufferOffset, 
    uint32_t maxDrawCount, 
    uint32_t stride) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdDrawMeshTasksIndirectCountNV(commandBuffer,
        buffer,
        offset,
        countBuffer,
        countBufferOffset,
        maxDrawCount,
        stride);
}
void CmdSetExclusiveScissorNV(CommandBuffer commandBuffer, 
    uint32_t firstExclusiveScissor, 
    detail::span<const Rect2D> ExclusiveScissors) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t exclusiveScissorCount = ExclusiveScissors.size();
    pfn_CmdSetExclusiveScissorNV(commandBuffer,
        firstExclusiveScissor,
        exclusiveScissorCount,
        ExclusiveScissors.data());
}
void CmdSetCheckpointNV(CommandBuffer commandBuffer, 
    const void* pCheckpointMarker) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetCheckpointNV(commandBuffer,
        pCheckpointMarker);
}
[[nodiscard]] std::vector<CheckpointDataNV> GetQueueCheckpointDataNV(Queue queue) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pCheckpointDataCount = 0;
    pfn_GetQueueCheckpointDataNV(queue,
        &pCheckpointDataCount,
        nullptr);
    std::vector<CheckpointDataNV> pCheckpointData(pCheckpointDataCount);
pfn_GetQueueCheckpointDataNV(queue,
        &pCheckpointDataCount,
        pCheckpointData.data());
    return pCheckpointData;
}
[[nodiscard]] Result InitializePerformanceApiINTEL(const InitializePerformanceApiInfoINTEL&  pInitializeInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_InitializePerformanceApiINTEL(device,
        &pInitializeInfo);
}
void UninitializePerformanceApiINTEL() const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_UninitializePerformanceApiINTEL(device);
}
[[nodiscard]] Result CmdSetPerformanceMarkerINTEL(CommandBuffer commandBuffer, 
    const PerformanceMarkerInfoINTEL&  pMarkerInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CmdSetPerformanceMarkerINTEL(commandBuffer,
        &pMarkerInfo);
}
[[nodiscard]] Result CmdSetPerformanceStreamMarkerINTEL(CommandBuffer commandBuffer, 
    const PerformanceStreamMarkerInfoINTEL&  pMarkerInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CmdSetPerformanceStreamMarkerINTEL(commandBuffer,
        &pMarkerInfo);
}
[[nodiscard]] Result CmdSetPerformanceOverrideINTEL(CommandBuffer commandBuffer, 
    const PerformanceOverrideInfoINTEL&  pOverrideInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_CmdSetPerformanceOverrideINTEL(commandBuffer,
        &pOverrideInfo);
}
[[nodiscard]] expected<PerformanceConfigurationINTEL> AcquirePerformanceConfigurationINTEL(const PerformanceConfigurationAcquireInfoINTEL&  pAcquireInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PerformanceConfigurationINTEL pConfiguration;
        Result result = pfn_AcquirePerformanceConfigurationINTEL(device,
        &pAcquireInfo,
        &pConfiguration);
    return expected<PerformanceConfigurationINTEL>(pConfiguration, result);
}
[[nodiscard]] Result ReleasePerformanceConfigurationINTEL(PerformanceConfigurationINTEL configuration = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ReleasePerformanceConfigurationINTEL(device,
        configuration);
}
[[nodiscard]] Result QueueSetPerformanceConfigurationINTEL(Queue queue, 
    PerformanceConfigurationINTEL configuration) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_QueueSetPerformanceConfigurationINTEL(queue,
        configuration);
}
[[nodiscard]] expected<PerformanceValueINTEL> GetPerformanceParameterINTEL(PerformanceParameterTypeINTEL parameter) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PerformanceValueINTEL pValue;
        Result result = pfn_GetPerformanceParameterINTEL(device,
        parameter,
        &pValue);
    return expected<PerformanceValueINTEL>(pValue, result);
}
void SetLocalDimmingAMD(SwapchainKHR swapChain, 
    Bool32 localDimmingEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_SetLocalDimmingAMD(device,
        swapChain,
        localDimmingEnable);
}
void CmdSetFragmentShadingRateKHR(CommandBuffer commandBuffer, 
    const Extent2D&  pFragmentSize, 
    const FragmentShadingRateCombinerOpKHR combinerOps[2]) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetFragmentShadingRateKHR(commandBuffer,
        &pFragmentSize,
        combinerOps);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] Result AcquireFullScreenExclusiveModeEXT(SwapchainKHR swapchain) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_AcquireFullScreenExclusiveModeEXT(device,
        swapchain);
}
[[nodiscard]] Result ReleaseFullScreenExclusiveModeEXT(SwapchainKHR swapchain) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ReleaseFullScreenExclusiveModeEXT(device,
        swapchain);
}
[[nodiscard]] expected<DeviceGroupPresentModeFlagsKHR> GetDeviceGroupSurfacePresentModes2EXT(const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeviceGroupPresentModeFlagsKHR pModes;
        Result result = pfn_GetDeviceGroupSurfacePresentModes2EXT(device,
        &pSurfaceInfo,
        &pModes);
    return expected<DeviceGroupPresentModeFlagsKHR>(pModes, result);
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
void CmdSetLineStippleEXT(CommandBuffer commandBuffer, 
    uint32_t lineStippleFactor, 
    uint16_t lineStipplePattern) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetLineStippleEXT(commandBuffer,
        lineStippleFactor,
        lineStipplePattern);
}
void CmdSetCullModeEXT(CommandBuffer commandBuffer, 
    CullModeFlags cullMode = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetCullModeEXT(commandBuffer,
        cullMode);
}
void CmdSetFrontFaceEXT(CommandBuffer commandBuffer, 
    FrontFace frontFace) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetFrontFaceEXT(commandBuffer,
        frontFace);
}
void CmdSetPrimitiveTopologyEXT(CommandBuffer commandBuffer, 
    PrimitiveTopology primitiveTopology) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetPrimitiveTopologyEXT(commandBuffer,
        primitiveTopology);
}
void CmdSetViewportWithCountEXT(CommandBuffer commandBuffer, 
    detail::span<const Viewport> Viewports) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t viewportCount = Viewports.size();
    pfn_CmdSetViewportWithCountEXT(commandBuffer,
        viewportCount,
        Viewports.data());
}
void CmdSetScissorWithCountEXT(CommandBuffer commandBuffer, 
    detail::span<const Rect2D> Scissors) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t scissorCount = Scissors.size();
    pfn_CmdSetScissorWithCountEXT(commandBuffer,
        scissorCount,
        Scissors.data());
}
void CmdBindVertexBuffers2EXT(CommandBuffer commandBuffer, 
    uint32_t firstBinding, 
    detail::span<const Buffer> Buffers, 
    detail::span<const DeviceSize> Offsets, 
    detail::span<const DeviceSize> Sizes = {}, 
    detail::span<const DeviceSize> Strides = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t bindingCount = Buffers.size();
    pfn_CmdBindVertexBuffers2EXT(commandBuffer,
        firstBinding,
        bindingCount,
        Buffers.data(),
        Offsets.data(),
        Sizes.data(),
        Strides.data());
}
void CmdSetDepthTestEnableEXT(CommandBuffer commandBuffer, 
    Bool32 depthTestEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthTestEnableEXT(commandBuffer,
        depthTestEnable);
}
void CmdSetDepthWriteEnableEXT(CommandBuffer commandBuffer, 
    Bool32 depthWriteEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthWriteEnableEXT(commandBuffer,
        depthWriteEnable);
}
void CmdSetDepthCompareOpEXT(CommandBuffer commandBuffer, 
    CompareOp depthCompareOp) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthCompareOpEXT(commandBuffer,
        depthCompareOp);
}
void CmdSetDepthBoundsTestEnableEXT(CommandBuffer commandBuffer, 
    Bool32 depthBoundsTestEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthBoundsTestEnableEXT(commandBuffer,
        depthBoundsTestEnable);
}
void CmdSetStencilTestEnableEXT(CommandBuffer commandBuffer, 
    Bool32 stencilTestEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetStencilTestEnableEXT(commandBuffer,
        stencilTestEnable);
}
void CmdSetStencilOpEXT(CommandBuffer commandBuffer, 
    StencilFaceFlags faceMask, 
    StencilOp failOp, 
    StencilOp passOp, 
    StencilOp depthFailOp, 
    CompareOp compareOp) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetStencilOpEXT(commandBuffer,
        faceMask,
        failOp,
        passOp,
        depthFailOp,
        compareOp);
}
[[nodiscard]] expected<DeferredOperationKHR> CreateDeferredOperationKHR(const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    DeferredOperationKHR pDeferredOperation;
        Result result = pfn_CreateDeferredOperationKHR(device,
        pAllocator,
        &pDeferredOperation);
    return expected<DeferredOperationKHR>(pDeferredOperation, result);
}
void DestroyDeferredOperationKHR(DeferredOperationKHR operation = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyDeferredOperationKHR(device,
        operation,
        pAllocator);
}
[[nodiscard]] uint32_t GetDeferredOperationMaxConcurrencyKHR(DeferredOperationKHR operation) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetDeferredOperationMaxConcurrencyKHR(device,
        operation);
}
[[nodiscard]] Result GetDeferredOperationResultKHR(DeferredOperationKHR operation) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_GetDeferredOperationResultKHR(device,
        operation);
}
[[nodiscard]] Result DeferredOperationJoinKHR(DeferredOperationKHR operation) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_DeferredOperationJoinKHR(device,
        operation);
}
[[nodiscard]] expected<std::vector<PipelineExecutablePropertiesKHR>> GetPipelineExecutablePropertiesKHR(const PipelineInfoKHR&  pPipelineInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pExecutableCount = 0;
        Result result = pfn_GetPipelineExecutablePropertiesKHR(device,
        &pPipelineInfo,
        &pExecutableCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PipelineExecutablePropertiesKHR>{}, result);
    std::vector<PipelineExecutablePropertiesKHR> pProperties(pExecutableCount);
    result = pfn_GetPipelineExecutablePropertiesKHR(device,
        &pPipelineInfo,
        &pExecutableCount,
        pProperties.data());
    return expected(std::move(pProperties), result);
}
[[nodiscard]] expected<std::vector<PipelineExecutableStatisticKHR>> GetPipelineExecutableStatisticsKHR(const PipelineExecutableInfoKHR&  pExecutableInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pStatisticCount = 0;
        Result result = pfn_GetPipelineExecutableStatisticsKHR(device,
        &pExecutableInfo,
        &pStatisticCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PipelineExecutableStatisticKHR>{}, result);
    std::vector<PipelineExecutableStatisticKHR> pStatistics(pStatisticCount);
    result = pfn_GetPipelineExecutableStatisticsKHR(device,
        &pExecutableInfo,
        &pStatisticCount,
        pStatistics.data());
    return expected(std::move(pStatistics), result);
}
[[nodiscard]] expected<std::vector<PipelineExecutableInternalRepresentationKHR>> GetPipelineExecutableInternalRepresentationsKHR(const PipelineExecutableInfoKHR&  pExecutableInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pInternalRepresentationCount = 0;
        Result result = pfn_GetPipelineExecutableInternalRepresentationsKHR(device,
        &pExecutableInfo,
        &pInternalRepresentationCount,
        nullptr);
    if (result < Result::Success) return expected(std::vector<PipelineExecutableInternalRepresentationKHR>{}, result);
    std::vector<PipelineExecutableInternalRepresentationKHR> pInternalRepresentations(pInternalRepresentationCount);
    result = pfn_GetPipelineExecutableInternalRepresentationsKHR(device,
        &pExecutableInfo,
        &pInternalRepresentationCount,
        pInternalRepresentations.data());
    return expected(std::move(pInternalRepresentations), result);
}
void CmdExecuteGeneratedCommandsNV(CommandBuffer commandBuffer, 
    Bool32 isPreprocessed, 
    const GeneratedCommandsInfoNV&  pGeneratedCommandsInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdExecuteGeneratedCommandsNV(commandBuffer,
        isPreprocessed,
        &pGeneratedCommandsInfo);
}
void CmdPreprocessGeneratedCommandsNV(CommandBuffer commandBuffer, 
    const GeneratedCommandsInfoNV&  pGeneratedCommandsInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdPreprocessGeneratedCommandsNV(commandBuffer,
        &pGeneratedCommandsInfo);
}
void CmdBindPipelineShaderGroupNV(CommandBuffer commandBuffer, 
    PipelineBindPoint pipelineBindPoint, 
    Pipeline pipeline, 
    uint32_t groupIndex) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBindPipelineShaderGroupNV(commandBuffer,
        pipelineBindPoint,
        pipeline,
        groupIndex);
}
[[nodiscard]] MemoryRequirements2 GetGeneratedCommandsMemoryRequirementsNV(const GeneratedCommandsMemoryRequirementsInfoNV&  pInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryRequirements2 pMemoryRequirements;
    pfn_GetGeneratedCommandsMemoryRequirementsNV(device,
        &pInfo,
        &pMemoryRequirements);
    return pMemoryRequirements;
}
[[nodiscard]] expected<IndirectCommandsLayoutNV> CreateIndirectCommandsLayoutNV(const IndirectCommandsLayoutCreateInfoNV&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    IndirectCommandsLayoutNV pIndirectCommandsLayout;
        Result result = pfn_CreateIndirectCommandsLayoutNV(device,
        &pCreateInfo,
        pAllocator,
        &pIndirectCommandsLayout);
    return expected<IndirectCommandsLayoutNV>(pIndirectCommandsLayout, result);
}
void DestroyIndirectCommandsLayoutNV(IndirectCommandsLayoutNV indirectCommandsLayout = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyIndirectCommandsLayoutNV(device,
        indirectCommandsLayout,
        pAllocator);
}
[[nodiscard]] expected<PrivateDataSlotEXT> CreatePrivateDataSlotEXT(const PrivateDataSlotCreateInfoEXT&  pCreateInfo, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    PrivateDataSlotEXT pPrivateDataSlot;
        Result result = pfn_CreatePrivateDataSlotEXT(device,
        &pCreateInfo,
        pAllocator,
        &pPrivateDataSlot);
    return expected<PrivateDataSlotEXT>(pPrivateDataSlot, result);
}
void DestroyPrivateDataSlotEXT(PrivateDataSlotEXT privateDataSlot = {}, 
    const AllocationCallbacks* pAllocator = nullptr) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_DestroyPrivateDataSlotEXT(device,
        privateDataSlot,
        pAllocator);
}
[[nodiscard]] Result SetPrivateDataEXT(ObjectType objectType, 
    uint64_t objectHandle, 
    PrivateDataSlotEXT privateDataSlot, 
    uint64_t data) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_SetPrivateDataEXT(device,
        objectType,
        objectHandle,
        privateDataSlot,
        data);
}
[[nodiscard]] uint64_t GetPrivateDataEXT(ObjectType objectType, 
    uint64_t objectHandle, 
    PrivateDataSlotEXT privateDataSlot) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint64_t pData;
    pfn_GetPrivateDataEXT(device,
        objectType,
        objectHandle,
        privateDataSlot,
        &pData);
    return pData;
}
void CmdSetEvent2KHR(CommandBuffer commandBuffer, 
    Event event, 
    const DependencyInfoKHR&  pDependencyInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetEvent2KHR(commandBuffer,
        event,
        &pDependencyInfo);
}
void CmdResetEvent2KHR(CommandBuffer commandBuffer, 
    Event event, 
    PipelineStageFlags2KHR stageMask) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdResetEvent2KHR(commandBuffer,
        event,
        stageMask);
}
void CmdWaitEvents2KHR(CommandBuffer commandBuffer, 
    detail::span<const Event> Events, 
    detail::span<const DependencyInfoKHR> DependencyInfos) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t eventCount = Events.size();
    pfn_CmdWaitEvents2KHR(commandBuffer,
        eventCount,
        Events.data(),
        DependencyInfos.data());
}
void CmdPipelineBarrier2KHR(CommandBuffer commandBuffer, 
    const DependencyInfoKHR&  pDependencyInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdPipelineBarrier2KHR(commandBuffer,
        &pDependencyInfo);
}
[[nodiscard]] Result QueueSubmit2KHR(Queue queue, 
    detail::span<const SubmitInfo2KHR> Submits, 
    Fence fence = {}) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t submitCount = Submits.size();
    return pfn_QueueSubmit2KHR(queue,
        submitCount,
        Submits.data(),
        fence);
}
void CmdWriteTimestamp2KHR(CommandBuffer commandBuffer, 
    PipelineStageFlags2KHR stage, 
    QueryPool queryPool, 
    uint32_t query) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdWriteTimestamp2KHR(commandBuffer,
        stage,
        queryPool,
        query);
}
void CmdWriteBufferMarker2AMD(CommandBuffer commandBuffer, 
    PipelineStageFlags2KHR stage, 
    Buffer dstBuffer, 
    DeviceSize dstOffset, 
    uint32_t marker) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdWriteBufferMarker2AMD(commandBuffer,
        stage,
        dstBuffer,
        dstOffset,
        marker);
}
[[nodiscard]] std::vector<CheckpointData2NV> GetQueueCheckpointData2NV(Queue queue) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t pCheckpointDataCount = 0;
    pfn_GetQueueCheckpointData2NV(queue,
        &pCheckpointDataCount,
        nullptr);
    std::vector<CheckpointData2NV> pCheckpointData(pCheckpointDataCount);
pfn_GetQueueCheckpointData2NV(queue,
        &pCheckpointDataCount,
        pCheckpointData.data());
    return pCheckpointData;
}
void CmdSetFragmentShadingRateEnumNV(CommandBuffer commandBuffer, 
    FragmentShadingRateNV shadingRate, 
    const FragmentShadingRateCombinerOpKHR combinerOps[2]) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetFragmentShadingRateEnumNV(commandBuffer,
        shadingRate,
        combinerOps);
}
void CmdCopyBuffer2KHR(CommandBuffer commandBuffer, 
    const CopyBufferInfo2KHR&  pCopyBufferInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyBuffer2KHR(commandBuffer,
        &pCopyBufferInfo);
}
void CmdCopyImage2KHR(CommandBuffer commandBuffer, 
    const CopyImageInfo2KHR&  pCopyImageInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyImage2KHR(commandBuffer,
        &pCopyImageInfo);
}
void CmdBlitImage2KHR(CommandBuffer commandBuffer, 
    const BlitImageInfo2KHR&  pBlitImageInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdBlitImage2KHR(commandBuffer,
        &pBlitImageInfo);
}
void CmdCopyBufferToImage2KHR(CommandBuffer commandBuffer, 
    const CopyBufferToImageInfo2KHR&  pCopyBufferToImageInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyBufferToImage2KHR(commandBuffer,
        &pCopyBufferToImageInfo);
}
void CmdCopyImageToBuffer2KHR(CommandBuffer commandBuffer, 
    const CopyImageToBufferInfo2KHR&  pCopyImageToBufferInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdCopyImageToBuffer2KHR(commandBuffer,
        &pCopyImageToBufferInfo);
}
void CmdResolveImage2KHR(CommandBuffer commandBuffer, 
    const ResolveImageInfo2KHR&  pResolveImageInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdResolveImage2KHR(commandBuffer,
        &pResolveImageInfo);
}
void CmdSetVertexInputEXT(CommandBuffer commandBuffer, 
    detail::span<const VertexInputBindingDescription2EXT> VertexBindingDescriptions, 
    detail::span<const VertexInputAttributeDescription2EXT> VertexAttributeDescriptions) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t vertexBindingDescriptionCount = VertexBindingDescriptions.size();
    uint32_t vertexAttributeDescriptionCount = VertexAttributeDescriptions.size();
    pfn_CmdSetVertexInputEXT(commandBuffer,
        vertexBindingDescriptionCount,
        VertexBindingDescriptions.data(),
        vertexAttributeDescriptionCount,
        VertexAttributeDescriptions.data());
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
[[nodiscard]] expected<zx_handle_t> GetMemoryZirconHandleFUCHSIA(const MemoryGetZirconHandleInfoFUCHSIA&  pGetZirconHandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    zx_handle_t pZirconHandle;
        Result result = pfn_GetMemoryZirconHandleFUCHSIA(device,
        &pGetZirconHandleInfo,
        &pZirconHandle);
    return expected<zx_handle_t>(pZirconHandle, result);
}
[[nodiscard]] expected<MemoryZirconHandlePropertiesFUCHSIA> GetMemoryZirconHandlePropertiesFUCHSIA(ExternalMemoryHandleTypeFlagBits handleType, 
    zx_handle_t zirconHandle) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    MemoryZirconHandlePropertiesFUCHSIA pMemoryZirconHandleProperties;
        Result result = pfn_GetMemoryZirconHandlePropertiesFUCHSIA(device,
        handleType,
        zirconHandle,
        &pMemoryZirconHandleProperties);
    return expected<MemoryZirconHandlePropertiesFUCHSIA>(pMemoryZirconHandleProperties, result);
}
[[nodiscard]] expected<zx_handle_t> GetSemaphoreZirconHandleFUCHSIA(const SemaphoreGetZirconHandleInfoFUCHSIA&  pGetZirconHandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    zx_handle_t pZirconHandle;
        Result result = pfn_GetSemaphoreZirconHandleFUCHSIA(device,
        &pGetZirconHandleInfo,
        &pZirconHandle);
    return expected<zx_handle_t>(pZirconHandle, result);
}
[[nodiscard]] Result ImportSemaphoreZirconHandleFUCHSIA(const ImportSemaphoreZirconHandleInfoFUCHSIA&  pImportSemaphoreZirconHandleInfo) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    return pfn_ImportSemaphoreZirconHandleFUCHSIA(device,
        &pImportSemaphoreZirconHandleInfo);
}
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
void CmdSetPatchControlPointsEXT(CommandBuffer commandBuffer, 
    uint32_t patchControlPoints) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetPatchControlPointsEXT(commandBuffer,
        patchControlPoints);
}
void CmdSetRasterizerDiscardEnableEXT(CommandBuffer commandBuffer, 
    Bool32 rasterizerDiscardEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetRasterizerDiscardEnableEXT(commandBuffer,
        rasterizerDiscardEnable);
}
void CmdSetDepthBiasEnableEXT(CommandBuffer commandBuffer, 
    Bool32 depthBiasEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetDepthBiasEnableEXT(commandBuffer,
        depthBiasEnable);
}
void CmdSetLogicOpEXT(CommandBuffer commandBuffer, 
    LogicOp logicOp) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetLogicOpEXT(commandBuffer,
        logicOp);
}
void CmdSetPrimitiveRestartEnableEXT(CommandBuffer commandBuffer, 
    Bool32 primitiveRestartEnable) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    pfn_CmdSetPrimitiveRestartEnableEXT(commandBuffer,
        primitiveRestartEnable);
}
void CmdSetColorWriteEnableEXT(CommandBuffer commandBuffer, 
    detail::span<const Bool32> ColorWriteEnables) const {
    VK_MODULE_LEAK_SANITIZER_SUPPRESSION_CODE
    uint32_t attachmentCount = ColorWriteEnables.size();
    pfn_CmdSetColorWriteEnableEXT(commandBuffer,
        attachmentCount,
        ColorWriteEnables.data());
}
DeviceFunctions() noexcept {}
explicit DeviceFunctions(InstanceFunctions const& instance_functions, Device device) noexcept 
    :device(device) {
    detail::PFN_GetDeviceProcAddr get_device_proc_addr = instance_functions.pfn_GetDeviceProcAddr;
    pfn_DestroyDevice = reinterpret_cast<detail::PFN_DestroyDevice>(get_device_proc_addr(device,"vkDestroyDevice"));
    pfn_GetDeviceQueue = reinterpret_cast<detail::PFN_GetDeviceQueue>(get_device_proc_addr(device,"vkGetDeviceQueue"));
    pfn_QueueSubmit = reinterpret_cast<detail::PFN_QueueSubmit>(get_device_proc_addr(device,"vkQueueSubmit"));
    pfn_QueueWaitIdle = reinterpret_cast<detail::PFN_QueueWaitIdle>(get_device_proc_addr(device,"vkQueueWaitIdle"));
    pfn_DeviceWaitIdle = reinterpret_cast<detail::PFN_DeviceWaitIdle>(get_device_proc_addr(device,"vkDeviceWaitIdle"));
    pfn_AllocateMemory = reinterpret_cast<detail::PFN_AllocateMemory>(get_device_proc_addr(device,"vkAllocateMemory"));
    pfn_FreeMemory = reinterpret_cast<detail::PFN_FreeMemory>(get_device_proc_addr(device,"vkFreeMemory"));
    pfn_MapMemory = reinterpret_cast<detail::PFN_MapMemory>(get_device_proc_addr(device,"vkMapMemory"));
    pfn_UnmapMemory = reinterpret_cast<detail::PFN_UnmapMemory>(get_device_proc_addr(device,"vkUnmapMemory"));
    pfn_FlushMappedMemoryRanges = reinterpret_cast<detail::PFN_FlushMappedMemoryRanges>(get_device_proc_addr(device,"vkFlushMappedMemoryRanges"));
    pfn_InvalidateMappedMemoryRanges = reinterpret_cast<detail::PFN_InvalidateMappedMemoryRanges>(get_device_proc_addr(device,"vkInvalidateMappedMemoryRanges"));
    pfn_GetDeviceMemoryCommitment = reinterpret_cast<detail::PFN_GetDeviceMemoryCommitment>(get_device_proc_addr(device,"vkGetDeviceMemoryCommitment"));
    pfn_GetBufferMemoryRequirements = reinterpret_cast<detail::PFN_GetBufferMemoryRequirements>(get_device_proc_addr(device,"vkGetBufferMemoryRequirements"));
    pfn_BindBufferMemory = reinterpret_cast<detail::PFN_BindBufferMemory>(get_device_proc_addr(device,"vkBindBufferMemory"));
    pfn_GetImageMemoryRequirements = reinterpret_cast<detail::PFN_GetImageMemoryRequirements>(get_device_proc_addr(device,"vkGetImageMemoryRequirements"));
    pfn_BindImageMemory = reinterpret_cast<detail::PFN_BindImageMemory>(get_device_proc_addr(device,"vkBindImageMemory"));
    pfn_GetImageSparseMemoryRequirements = reinterpret_cast<detail::PFN_GetImageSparseMemoryRequirements>(get_device_proc_addr(device,"vkGetImageSparseMemoryRequirements"));
    pfn_QueueBindSparse = reinterpret_cast<detail::PFN_QueueBindSparse>(get_device_proc_addr(device,"vkQueueBindSparse"));
    pfn_CreateFence = reinterpret_cast<detail::PFN_CreateFence>(get_device_proc_addr(device,"vkCreateFence"));
    pfn_DestroyFence = reinterpret_cast<detail::PFN_DestroyFence>(get_device_proc_addr(device,"vkDestroyFence"));
    pfn_ResetFences = reinterpret_cast<detail::PFN_ResetFences>(get_device_proc_addr(device,"vkResetFences"));
    pfn_GetFenceStatus = reinterpret_cast<detail::PFN_GetFenceStatus>(get_device_proc_addr(device,"vkGetFenceStatus"));
    pfn_WaitForFences = reinterpret_cast<detail::PFN_WaitForFences>(get_device_proc_addr(device,"vkWaitForFences"));
    pfn_CreateSemaphore = reinterpret_cast<detail::PFN_CreateSemaphore>(get_device_proc_addr(device,"vkCreateSemaphore"));
    pfn_DestroySemaphore = reinterpret_cast<detail::PFN_DestroySemaphore>(get_device_proc_addr(device,"vkDestroySemaphore"));
    pfn_CreateEvent = reinterpret_cast<detail::PFN_CreateEvent>(get_device_proc_addr(device,"vkCreateEvent"));
    pfn_DestroyEvent = reinterpret_cast<detail::PFN_DestroyEvent>(get_device_proc_addr(device,"vkDestroyEvent"));
    pfn_GetEventStatus = reinterpret_cast<detail::PFN_GetEventStatus>(get_device_proc_addr(device,"vkGetEventStatus"));
    pfn_SetEvent = reinterpret_cast<detail::PFN_SetEvent>(get_device_proc_addr(device,"vkSetEvent"));
    pfn_ResetEvent = reinterpret_cast<detail::PFN_ResetEvent>(get_device_proc_addr(device,"vkResetEvent"));
    pfn_CreateQueryPool = reinterpret_cast<detail::PFN_CreateQueryPool>(get_device_proc_addr(device,"vkCreateQueryPool"));
    pfn_DestroyQueryPool = reinterpret_cast<detail::PFN_DestroyQueryPool>(get_device_proc_addr(device,"vkDestroyQueryPool"));
    pfn_GetQueryPoolResults = reinterpret_cast<detail::PFN_GetQueryPoolResults>(get_device_proc_addr(device,"vkGetQueryPoolResults"));
    pfn_CreateBuffer = reinterpret_cast<detail::PFN_CreateBuffer>(get_device_proc_addr(device,"vkCreateBuffer"));
    pfn_DestroyBuffer = reinterpret_cast<detail::PFN_DestroyBuffer>(get_device_proc_addr(device,"vkDestroyBuffer"));
    pfn_CreateBufferView = reinterpret_cast<detail::PFN_CreateBufferView>(get_device_proc_addr(device,"vkCreateBufferView"));
    pfn_DestroyBufferView = reinterpret_cast<detail::PFN_DestroyBufferView>(get_device_proc_addr(device,"vkDestroyBufferView"));
    pfn_CreateImage = reinterpret_cast<detail::PFN_CreateImage>(get_device_proc_addr(device,"vkCreateImage"));
    pfn_DestroyImage = reinterpret_cast<detail::PFN_DestroyImage>(get_device_proc_addr(device,"vkDestroyImage"));
    pfn_GetImageSubresourceLayout = reinterpret_cast<detail::PFN_GetImageSubresourceLayout>(get_device_proc_addr(device,"vkGetImageSubresourceLayout"));
    pfn_CreateImageView = reinterpret_cast<detail::PFN_CreateImageView>(get_device_proc_addr(device,"vkCreateImageView"));
    pfn_DestroyImageView = reinterpret_cast<detail::PFN_DestroyImageView>(get_device_proc_addr(device,"vkDestroyImageView"));
    pfn_CreateShaderModule = reinterpret_cast<detail::PFN_CreateShaderModule>(get_device_proc_addr(device,"vkCreateShaderModule"));
    pfn_DestroyShaderModule = reinterpret_cast<detail::PFN_DestroyShaderModule>(get_device_proc_addr(device,"vkDestroyShaderModule"));
    pfn_CreatePipelineCache = reinterpret_cast<detail::PFN_CreatePipelineCache>(get_device_proc_addr(device,"vkCreatePipelineCache"));
    pfn_DestroyPipelineCache = reinterpret_cast<detail::PFN_DestroyPipelineCache>(get_device_proc_addr(device,"vkDestroyPipelineCache"));
    pfn_GetPipelineCacheData = reinterpret_cast<detail::PFN_GetPipelineCacheData>(get_device_proc_addr(device,"vkGetPipelineCacheData"));
    pfn_MergePipelineCaches = reinterpret_cast<detail::PFN_MergePipelineCaches>(get_device_proc_addr(device,"vkMergePipelineCaches"));
    pfn_CreateGraphicsPipelines = reinterpret_cast<detail::PFN_CreateGraphicsPipelines>(get_device_proc_addr(device,"vkCreateGraphicsPipelines"));
    pfn_CreateComputePipelines = reinterpret_cast<detail::PFN_CreateComputePipelines>(get_device_proc_addr(device,"vkCreateComputePipelines"));
    pfn_DestroyPipeline = reinterpret_cast<detail::PFN_DestroyPipeline>(get_device_proc_addr(device,"vkDestroyPipeline"));
    pfn_CreatePipelineLayout = reinterpret_cast<detail::PFN_CreatePipelineLayout>(get_device_proc_addr(device,"vkCreatePipelineLayout"));
    pfn_DestroyPipelineLayout = reinterpret_cast<detail::PFN_DestroyPipelineLayout>(get_device_proc_addr(device,"vkDestroyPipelineLayout"));
    pfn_CreateSampler = reinterpret_cast<detail::PFN_CreateSampler>(get_device_proc_addr(device,"vkCreateSampler"));
    pfn_DestroySampler = reinterpret_cast<detail::PFN_DestroySampler>(get_device_proc_addr(device,"vkDestroySampler"));
    pfn_CreateDescriptorSetLayout = reinterpret_cast<detail::PFN_CreateDescriptorSetLayout>(get_device_proc_addr(device,"vkCreateDescriptorSetLayout"));
    pfn_DestroyDescriptorSetLayout = reinterpret_cast<detail::PFN_DestroyDescriptorSetLayout>(get_device_proc_addr(device,"vkDestroyDescriptorSetLayout"));
    pfn_CreateDescriptorPool = reinterpret_cast<detail::PFN_CreateDescriptorPool>(get_device_proc_addr(device,"vkCreateDescriptorPool"));
    pfn_DestroyDescriptorPool = reinterpret_cast<detail::PFN_DestroyDescriptorPool>(get_device_proc_addr(device,"vkDestroyDescriptorPool"));
    pfn_ResetDescriptorPool = reinterpret_cast<detail::PFN_ResetDescriptorPool>(get_device_proc_addr(device,"vkResetDescriptorPool"));
    pfn_AllocateDescriptorSets = reinterpret_cast<detail::PFN_AllocateDescriptorSets>(get_device_proc_addr(device,"vkAllocateDescriptorSets"));
    pfn_FreeDescriptorSets = reinterpret_cast<detail::PFN_FreeDescriptorSets>(get_device_proc_addr(device,"vkFreeDescriptorSets"));
    pfn_UpdateDescriptorSets = reinterpret_cast<detail::PFN_UpdateDescriptorSets>(get_device_proc_addr(device,"vkUpdateDescriptorSets"));
    pfn_CreateFramebuffer = reinterpret_cast<detail::PFN_CreateFramebuffer>(get_device_proc_addr(device,"vkCreateFramebuffer"));
    pfn_DestroyFramebuffer = reinterpret_cast<detail::PFN_DestroyFramebuffer>(get_device_proc_addr(device,"vkDestroyFramebuffer"));
    pfn_CreateRenderPass = reinterpret_cast<detail::PFN_CreateRenderPass>(get_device_proc_addr(device,"vkCreateRenderPass"));
    pfn_DestroyRenderPass = reinterpret_cast<detail::PFN_DestroyRenderPass>(get_device_proc_addr(device,"vkDestroyRenderPass"));
    pfn_GetRenderAreaGranularity = reinterpret_cast<detail::PFN_GetRenderAreaGranularity>(get_device_proc_addr(device,"vkGetRenderAreaGranularity"));
    pfn_CreateCommandPool = reinterpret_cast<detail::PFN_CreateCommandPool>(get_device_proc_addr(device,"vkCreateCommandPool"));
    pfn_DestroyCommandPool = reinterpret_cast<detail::PFN_DestroyCommandPool>(get_device_proc_addr(device,"vkDestroyCommandPool"));
    pfn_ResetCommandPool = reinterpret_cast<detail::PFN_ResetCommandPool>(get_device_proc_addr(device,"vkResetCommandPool"));
    pfn_AllocateCommandBuffers = reinterpret_cast<detail::PFN_AllocateCommandBuffers>(get_device_proc_addr(device,"vkAllocateCommandBuffers"));
    pfn_FreeCommandBuffers = reinterpret_cast<detail::PFN_FreeCommandBuffers>(get_device_proc_addr(device,"vkFreeCommandBuffers"));
    pfn_BeginCommandBuffer = reinterpret_cast<detail::PFN_BeginCommandBuffer>(get_device_proc_addr(device,"vkBeginCommandBuffer"));
    pfn_EndCommandBuffer = reinterpret_cast<detail::PFN_EndCommandBuffer>(get_device_proc_addr(device,"vkEndCommandBuffer"));
    pfn_ResetCommandBuffer = reinterpret_cast<detail::PFN_ResetCommandBuffer>(get_device_proc_addr(device,"vkResetCommandBuffer"));
    pfn_CmdBindPipeline = reinterpret_cast<detail::PFN_CmdBindPipeline>(get_device_proc_addr(device,"vkCmdBindPipeline"));
    pfn_CmdSetViewport = reinterpret_cast<detail::PFN_CmdSetViewport>(get_device_proc_addr(device,"vkCmdSetViewport"));
    pfn_CmdSetScissor = reinterpret_cast<detail::PFN_CmdSetScissor>(get_device_proc_addr(device,"vkCmdSetScissor"));
    pfn_CmdSetLineWidth = reinterpret_cast<detail::PFN_CmdSetLineWidth>(get_device_proc_addr(device,"vkCmdSetLineWidth"));
    pfn_CmdSetDepthBias = reinterpret_cast<detail::PFN_CmdSetDepthBias>(get_device_proc_addr(device,"vkCmdSetDepthBias"));
    pfn_CmdSetBlendConstants = reinterpret_cast<detail::PFN_CmdSetBlendConstants>(get_device_proc_addr(device,"vkCmdSetBlendConstants"));
    pfn_CmdSetDepthBounds = reinterpret_cast<detail::PFN_CmdSetDepthBounds>(get_device_proc_addr(device,"vkCmdSetDepthBounds"));
    pfn_CmdSetStencilCompareMask = reinterpret_cast<detail::PFN_CmdSetStencilCompareMask>(get_device_proc_addr(device,"vkCmdSetStencilCompareMask"));
    pfn_CmdSetStencilWriteMask = reinterpret_cast<detail::PFN_CmdSetStencilWriteMask>(get_device_proc_addr(device,"vkCmdSetStencilWriteMask"));
    pfn_CmdSetStencilReference = reinterpret_cast<detail::PFN_CmdSetStencilReference>(get_device_proc_addr(device,"vkCmdSetStencilReference"));
    pfn_CmdBindDescriptorSets = reinterpret_cast<detail::PFN_CmdBindDescriptorSets>(get_device_proc_addr(device,"vkCmdBindDescriptorSets"));
    pfn_CmdBindIndexBuffer = reinterpret_cast<detail::PFN_CmdBindIndexBuffer>(get_device_proc_addr(device,"vkCmdBindIndexBuffer"));
    pfn_CmdBindVertexBuffers = reinterpret_cast<detail::PFN_CmdBindVertexBuffers>(get_device_proc_addr(device,"vkCmdBindVertexBuffers"));
    pfn_CmdDraw = reinterpret_cast<detail::PFN_CmdDraw>(get_device_proc_addr(device,"vkCmdDraw"));
    pfn_CmdDrawIndexed = reinterpret_cast<detail::PFN_CmdDrawIndexed>(get_device_proc_addr(device,"vkCmdDrawIndexed"));
    pfn_CmdDrawIndirect = reinterpret_cast<detail::PFN_CmdDrawIndirect>(get_device_proc_addr(device,"vkCmdDrawIndirect"));
    pfn_CmdDrawIndexedIndirect = reinterpret_cast<detail::PFN_CmdDrawIndexedIndirect>(get_device_proc_addr(device,"vkCmdDrawIndexedIndirect"));
    pfn_CmdDispatch = reinterpret_cast<detail::PFN_CmdDispatch>(get_device_proc_addr(device,"vkCmdDispatch"));
    pfn_CmdDispatchIndirect = reinterpret_cast<detail::PFN_CmdDispatchIndirect>(get_device_proc_addr(device,"vkCmdDispatchIndirect"));
    pfn_CmdCopyBuffer = reinterpret_cast<detail::PFN_CmdCopyBuffer>(get_device_proc_addr(device,"vkCmdCopyBuffer"));
    pfn_CmdCopyImage = reinterpret_cast<detail::PFN_CmdCopyImage>(get_device_proc_addr(device,"vkCmdCopyImage"));
    pfn_CmdBlitImage = reinterpret_cast<detail::PFN_CmdBlitImage>(get_device_proc_addr(device,"vkCmdBlitImage"));
    pfn_CmdCopyBufferToImage = reinterpret_cast<detail::PFN_CmdCopyBufferToImage>(get_device_proc_addr(device,"vkCmdCopyBufferToImage"));
    pfn_CmdCopyImageToBuffer = reinterpret_cast<detail::PFN_CmdCopyImageToBuffer>(get_device_proc_addr(device,"vkCmdCopyImageToBuffer"));
    pfn_CmdUpdateBuffer = reinterpret_cast<detail::PFN_CmdUpdateBuffer>(get_device_proc_addr(device,"vkCmdUpdateBuffer"));
    pfn_CmdFillBuffer = reinterpret_cast<detail::PFN_CmdFillBuffer>(get_device_proc_addr(device,"vkCmdFillBuffer"));
    pfn_CmdClearColorImage = reinterpret_cast<detail::PFN_CmdClearColorImage>(get_device_proc_addr(device,"vkCmdClearColorImage"));
    pfn_CmdClearDepthStencilImage = reinterpret_cast<detail::PFN_CmdClearDepthStencilImage>(get_device_proc_addr(device,"vkCmdClearDepthStencilImage"));
    pfn_CmdClearAttachments = reinterpret_cast<detail::PFN_CmdClearAttachments>(get_device_proc_addr(device,"vkCmdClearAttachments"));
    pfn_CmdResolveImage = reinterpret_cast<detail::PFN_CmdResolveImage>(get_device_proc_addr(device,"vkCmdResolveImage"));
    pfn_CmdSetEvent = reinterpret_cast<detail::PFN_CmdSetEvent>(get_device_proc_addr(device,"vkCmdSetEvent"));
    pfn_CmdResetEvent = reinterpret_cast<detail::PFN_CmdResetEvent>(get_device_proc_addr(device,"vkCmdResetEvent"));
    pfn_CmdWaitEvents = reinterpret_cast<detail::PFN_CmdWaitEvents>(get_device_proc_addr(device,"vkCmdWaitEvents"));
    pfn_CmdPipelineBarrier = reinterpret_cast<detail::PFN_CmdPipelineBarrier>(get_device_proc_addr(device,"vkCmdPipelineBarrier"));
    pfn_CmdBeginQuery = reinterpret_cast<detail::PFN_CmdBeginQuery>(get_device_proc_addr(device,"vkCmdBeginQuery"));
    pfn_CmdEndQuery = reinterpret_cast<detail::PFN_CmdEndQuery>(get_device_proc_addr(device,"vkCmdEndQuery"));
    pfn_CmdResetQueryPool = reinterpret_cast<detail::PFN_CmdResetQueryPool>(get_device_proc_addr(device,"vkCmdResetQueryPool"));
    pfn_CmdWriteTimestamp = reinterpret_cast<detail::PFN_CmdWriteTimestamp>(get_device_proc_addr(device,"vkCmdWriteTimestamp"));
    pfn_CmdCopyQueryPoolResults = reinterpret_cast<detail::PFN_CmdCopyQueryPoolResults>(get_device_proc_addr(device,"vkCmdCopyQueryPoolResults"));
    pfn_CmdPushConstants = reinterpret_cast<detail::PFN_CmdPushConstants>(get_device_proc_addr(device,"vkCmdPushConstants"));
    pfn_CmdBeginRenderPass = reinterpret_cast<detail::PFN_CmdBeginRenderPass>(get_device_proc_addr(device,"vkCmdBeginRenderPass"));
    pfn_CmdNextSubpass = reinterpret_cast<detail::PFN_CmdNextSubpass>(get_device_proc_addr(device,"vkCmdNextSubpass"));
    pfn_CmdEndRenderPass = reinterpret_cast<detail::PFN_CmdEndRenderPass>(get_device_proc_addr(device,"vkCmdEndRenderPass"));
    pfn_CmdExecuteCommands = reinterpret_cast<detail::PFN_CmdExecuteCommands>(get_device_proc_addr(device,"vkCmdExecuteCommands"));
    pfn_BindBufferMemory2 = reinterpret_cast<detail::PFN_BindBufferMemory2>(get_device_proc_addr(device,"vkBindBufferMemory2"));
    pfn_BindImageMemory2 = reinterpret_cast<detail::PFN_BindImageMemory2>(get_device_proc_addr(device,"vkBindImageMemory2"));
    pfn_GetDeviceGroupPeerMemoryFeatures = reinterpret_cast<detail::PFN_GetDeviceGroupPeerMemoryFeatures>(get_device_proc_addr(device,"vkGetDeviceGroupPeerMemoryFeatures"));
    pfn_CmdSetDeviceMask = reinterpret_cast<detail::PFN_CmdSetDeviceMask>(get_device_proc_addr(device,"vkCmdSetDeviceMask"));
    pfn_CmdDispatchBase = reinterpret_cast<detail::PFN_CmdDispatchBase>(get_device_proc_addr(device,"vkCmdDispatchBase"));
    pfn_GetBufferMemoryRequirements2 = reinterpret_cast<detail::PFN_GetBufferMemoryRequirements2>(get_device_proc_addr(device,"vkGetBufferMemoryRequirements2"));
    pfn_GetImageMemoryRequirements2 = reinterpret_cast<detail::PFN_GetImageMemoryRequirements2>(get_device_proc_addr(device,"vkGetImageMemoryRequirements2"));
    pfn_GetImageSparseMemoryRequirements2 = reinterpret_cast<detail::PFN_GetImageSparseMemoryRequirements2>(get_device_proc_addr(device,"vkGetImageSparseMemoryRequirements2"));
    pfn_TrimCommandPool = reinterpret_cast<detail::PFN_TrimCommandPool>(get_device_proc_addr(device,"vkTrimCommandPool"));
    pfn_GetDeviceQueue2 = reinterpret_cast<detail::PFN_GetDeviceQueue2>(get_device_proc_addr(device,"vkGetDeviceQueue2"));
    pfn_CreateSamplerYcbcrConversion = reinterpret_cast<detail::PFN_CreateSamplerYcbcrConversion>(get_device_proc_addr(device,"vkCreateSamplerYcbcrConversion"));
    pfn_DestroySamplerYcbcrConversion = reinterpret_cast<detail::PFN_DestroySamplerYcbcrConversion>(get_device_proc_addr(device,"vkDestroySamplerYcbcrConversion"));
    pfn_CreateDescriptorUpdateTemplate = reinterpret_cast<detail::PFN_CreateDescriptorUpdateTemplate>(get_device_proc_addr(device,"vkCreateDescriptorUpdateTemplate"));
    pfn_DestroyDescriptorUpdateTemplate = reinterpret_cast<detail::PFN_DestroyDescriptorUpdateTemplate>(get_device_proc_addr(device,"vkDestroyDescriptorUpdateTemplate"));
    pfn_UpdateDescriptorSetWithTemplate = reinterpret_cast<detail::PFN_UpdateDescriptorSetWithTemplate>(get_device_proc_addr(device,"vkUpdateDescriptorSetWithTemplate"));
    pfn_GetDescriptorSetLayoutSupport = reinterpret_cast<detail::PFN_GetDescriptorSetLayoutSupport>(get_device_proc_addr(device,"vkGetDescriptorSetLayoutSupport"));
    pfn_CmdDrawIndirectCount = reinterpret_cast<detail::PFN_CmdDrawIndirectCount>(get_device_proc_addr(device,"vkCmdDrawIndirectCount"));
    pfn_CmdDrawIndexedIndirectCount = reinterpret_cast<detail::PFN_CmdDrawIndexedIndirectCount>(get_device_proc_addr(device,"vkCmdDrawIndexedIndirectCount"));
    pfn_CreateRenderPass2 = reinterpret_cast<detail::PFN_CreateRenderPass2>(get_device_proc_addr(device,"vkCreateRenderPass2"));
    pfn_CmdBeginRenderPass2 = reinterpret_cast<detail::PFN_CmdBeginRenderPass2>(get_device_proc_addr(device,"vkCmdBeginRenderPass2"));
    pfn_CmdNextSubpass2 = reinterpret_cast<detail::PFN_CmdNextSubpass2>(get_device_proc_addr(device,"vkCmdNextSubpass2"));
    pfn_CmdEndRenderPass2 = reinterpret_cast<detail::PFN_CmdEndRenderPass2>(get_device_proc_addr(device,"vkCmdEndRenderPass2"));
    pfn_ResetQueryPool = reinterpret_cast<detail::PFN_ResetQueryPool>(get_device_proc_addr(device,"vkResetQueryPool"));
    pfn_GetSemaphoreCounterValue = reinterpret_cast<detail::PFN_GetSemaphoreCounterValue>(get_device_proc_addr(device,"vkGetSemaphoreCounterValue"));
    pfn_WaitSemaphores = reinterpret_cast<detail::PFN_WaitSemaphores>(get_device_proc_addr(device,"vkWaitSemaphores"));
    pfn_SignalSemaphore = reinterpret_cast<detail::PFN_SignalSemaphore>(get_device_proc_addr(device,"vkSignalSemaphore"));
    pfn_GetBufferOpaqueCaptureAddress = reinterpret_cast<detail::PFN_GetBufferOpaqueCaptureAddress>(get_device_proc_addr(device,"vkGetBufferOpaqueCaptureAddress"));
    pfn_GetBufferDeviceAddress = reinterpret_cast<detail::PFN_GetBufferDeviceAddress>(get_device_proc_addr(device,"vkGetBufferDeviceAddress"));
    pfn_GetDeviceMemoryOpaqueCaptureAddress = reinterpret_cast<detail::PFN_GetDeviceMemoryOpaqueCaptureAddress>(get_device_proc_addr(device,"vkGetDeviceMemoryOpaqueCaptureAddress"));
    pfn_CreateSwapchainKHR = reinterpret_cast<detail::PFN_CreateSwapchainKHR>(get_device_proc_addr(device,"vkCreateSwapchainKHR"));
    pfn_DestroySwapchainKHR = reinterpret_cast<detail::PFN_DestroySwapchainKHR>(get_device_proc_addr(device,"vkDestroySwapchainKHR"));
    pfn_GetSwapchainImagesKHR = reinterpret_cast<detail::PFN_GetSwapchainImagesKHR>(get_device_proc_addr(device,"vkGetSwapchainImagesKHR"));
    pfn_AcquireNextImageKHR = reinterpret_cast<detail::PFN_AcquireNextImageKHR>(get_device_proc_addr(device,"vkAcquireNextImageKHR"));
    pfn_QueuePresentKHR = reinterpret_cast<detail::PFN_QueuePresentKHR>(get_device_proc_addr(device,"vkQueuePresentKHR"));
    pfn_GetDeviceGroupPresentCapabilitiesKHR = reinterpret_cast<detail::PFN_GetDeviceGroupPresentCapabilitiesKHR>(get_device_proc_addr(device,"vkGetDeviceGroupPresentCapabilitiesKHR"));
    pfn_GetDeviceGroupSurfacePresentModesKHR = reinterpret_cast<detail::PFN_GetDeviceGroupSurfacePresentModesKHR>(get_device_proc_addr(device,"vkGetDeviceGroupSurfacePresentModesKHR"));
    pfn_AcquireNextImage2KHR = reinterpret_cast<detail::PFN_AcquireNextImage2KHR>(get_device_proc_addr(device,"vkAcquireNextImage2KHR"));
    pfn_CreateSharedSwapchainsKHR = reinterpret_cast<detail::PFN_CreateSharedSwapchainsKHR>(get_device_proc_addr(device,"vkCreateSharedSwapchainsKHR"));
    pfn_DebugMarkerSetObjectNameEXT = reinterpret_cast<detail::PFN_DebugMarkerSetObjectNameEXT>(get_device_proc_addr(device,"vkDebugMarkerSetObjectNameEXT"));
    pfn_DebugMarkerSetObjectTagEXT = reinterpret_cast<detail::PFN_DebugMarkerSetObjectTagEXT>(get_device_proc_addr(device,"vkDebugMarkerSetObjectTagEXT"));
    pfn_CmdDebugMarkerBeginEXT = reinterpret_cast<detail::PFN_CmdDebugMarkerBeginEXT>(get_device_proc_addr(device,"vkCmdDebugMarkerBeginEXT"));
    pfn_CmdDebugMarkerEndEXT = reinterpret_cast<detail::PFN_CmdDebugMarkerEndEXT>(get_device_proc_addr(device,"vkCmdDebugMarkerEndEXT"));
    pfn_CmdDebugMarkerInsertEXT = reinterpret_cast<detail::PFN_CmdDebugMarkerInsertEXT>(get_device_proc_addr(device,"vkCmdDebugMarkerInsertEXT"));
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    pfn_CreateVideoSessionKHR = reinterpret_cast<detail::PFN_CreateVideoSessionKHR>(get_device_proc_addr(device,"vkCreateVideoSessionKHR"));
    pfn_DestroyVideoSessionKHR = reinterpret_cast<detail::PFN_DestroyVideoSessionKHR>(get_device_proc_addr(device,"vkDestroyVideoSessionKHR"));
    pfn_CreateVideoSessionParametersKHR = reinterpret_cast<detail::PFN_CreateVideoSessionParametersKHR>(get_device_proc_addr(device,"vkCreateVideoSessionParametersKHR"));
    pfn_UpdateVideoSessionParametersKHR = reinterpret_cast<detail::PFN_UpdateVideoSessionParametersKHR>(get_device_proc_addr(device,"vkUpdateVideoSessionParametersKHR"));
    pfn_DestroyVideoSessionParametersKHR = reinterpret_cast<detail::PFN_DestroyVideoSessionParametersKHR>(get_device_proc_addr(device,"vkDestroyVideoSessionParametersKHR"));
    pfn_GetVideoSessionMemoryRequirementsKHR = reinterpret_cast<detail::PFN_GetVideoSessionMemoryRequirementsKHR>(get_device_proc_addr(device,"vkGetVideoSessionMemoryRequirementsKHR"));
    pfn_BindVideoSessionMemoryKHR = reinterpret_cast<detail::PFN_BindVideoSessionMemoryKHR>(get_device_proc_addr(device,"vkBindVideoSessionMemoryKHR"));
    pfn_CmdBeginVideoCodingKHR = reinterpret_cast<detail::PFN_CmdBeginVideoCodingKHR>(get_device_proc_addr(device,"vkCmdBeginVideoCodingKHR"));
    pfn_CmdControlVideoCodingKHR = reinterpret_cast<detail::PFN_CmdControlVideoCodingKHR>(get_device_proc_addr(device,"vkCmdControlVideoCodingKHR"));
    pfn_CmdEndVideoCodingKHR = reinterpret_cast<detail::PFN_CmdEndVideoCodingKHR>(get_device_proc_addr(device,"vkCmdEndVideoCodingKHR"));
    pfn_CmdDecodeVideoKHR = reinterpret_cast<detail::PFN_CmdDecodeVideoKHR>(get_device_proc_addr(device,"vkCmdDecodeVideoKHR"));
    pfn_CmdEncodeVideoKHR = reinterpret_cast<detail::PFN_CmdEncodeVideoKHR>(get_device_proc_addr(device,"vkCmdEncodeVideoKHR"));
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
    pfn_CmdBindTransformFeedbackBuffersEXT = reinterpret_cast<detail::PFN_CmdBindTransformFeedbackBuffersEXT>(get_device_proc_addr(device,"vkCmdBindTransformFeedbackBuffersEXT"));
    pfn_CmdBeginTransformFeedbackEXT = reinterpret_cast<detail::PFN_CmdBeginTransformFeedbackEXT>(get_device_proc_addr(device,"vkCmdBeginTransformFeedbackEXT"));
    pfn_CmdEndTransformFeedbackEXT = reinterpret_cast<detail::PFN_CmdEndTransformFeedbackEXT>(get_device_proc_addr(device,"vkCmdEndTransformFeedbackEXT"));
    pfn_CmdBeginQueryIndexedEXT = reinterpret_cast<detail::PFN_CmdBeginQueryIndexedEXT>(get_device_proc_addr(device,"vkCmdBeginQueryIndexedEXT"));
    pfn_CmdEndQueryIndexedEXT = reinterpret_cast<detail::PFN_CmdEndQueryIndexedEXT>(get_device_proc_addr(device,"vkCmdEndQueryIndexedEXT"));
    pfn_CmdDrawIndirectByteCountEXT = reinterpret_cast<detail::PFN_CmdDrawIndirectByteCountEXT>(get_device_proc_addr(device,"vkCmdDrawIndirectByteCountEXT"));
    pfn_GetImageViewHandleNVX = reinterpret_cast<detail::PFN_GetImageViewHandleNVX>(get_device_proc_addr(device,"vkGetImageViewHandleNVX"));
    pfn_GetImageViewAddressNVX = reinterpret_cast<detail::PFN_GetImageViewAddressNVX>(get_device_proc_addr(device,"vkGetImageViewAddressNVX"));
    pfn_GetShaderInfoAMD = reinterpret_cast<detail::PFN_GetShaderInfoAMD>(get_device_proc_addr(device,"vkGetShaderInfoAMD"));
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetMemoryWin32HandleNV = reinterpret_cast<detail::PFN_GetMemoryWin32HandleNV>(get_device_proc_addr(device,"vkGetMemoryWin32HandleNV"));
    pfn_GetMemoryWin32HandleKHR = reinterpret_cast<detail::PFN_GetMemoryWin32HandleKHR>(get_device_proc_addr(device,"vkGetMemoryWin32HandleKHR"));
    pfn_GetMemoryWin32HandlePropertiesKHR = reinterpret_cast<detail::PFN_GetMemoryWin32HandlePropertiesKHR>(get_device_proc_addr(device,"vkGetMemoryWin32HandlePropertiesKHR"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetMemoryFdKHR = reinterpret_cast<detail::PFN_GetMemoryFdKHR>(get_device_proc_addr(device,"vkGetMemoryFdKHR"));
    pfn_GetMemoryFdPropertiesKHR = reinterpret_cast<detail::PFN_GetMemoryFdPropertiesKHR>(get_device_proc_addr(device,"vkGetMemoryFdPropertiesKHR"));
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetSemaphoreWin32HandleKHR = reinterpret_cast<detail::PFN_GetSemaphoreWin32HandleKHR>(get_device_proc_addr(device,"vkGetSemaphoreWin32HandleKHR"));
    pfn_ImportSemaphoreWin32HandleKHR = reinterpret_cast<detail::PFN_ImportSemaphoreWin32HandleKHR>(get_device_proc_addr(device,"vkImportSemaphoreWin32HandleKHR"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetSemaphoreFdKHR = reinterpret_cast<detail::PFN_GetSemaphoreFdKHR>(get_device_proc_addr(device,"vkGetSemaphoreFdKHR"));
    pfn_ImportSemaphoreFdKHR = reinterpret_cast<detail::PFN_ImportSemaphoreFdKHR>(get_device_proc_addr(device,"vkImportSemaphoreFdKHR"));
    pfn_CmdPushDescriptorSetKHR = reinterpret_cast<detail::PFN_CmdPushDescriptorSetKHR>(get_device_proc_addr(device,"vkCmdPushDescriptorSetKHR"));
    pfn_CmdPushDescriptorSetWithTemplateKHR = reinterpret_cast<detail::PFN_CmdPushDescriptorSetWithTemplateKHR>(get_device_proc_addr(device,"vkCmdPushDescriptorSetWithTemplateKHR"));
    pfn_CmdBeginConditionalRenderingEXT = reinterpret_cast<detail::PFN_CmdBeginConditionalRenderingEXT>(get_device_proc_addr(device,"vkCmdBeginConditionalRenderingEXT"));
    pfn_CmdEndConditionalRenderingEXT = reinterpret_cast<detail::PFN_CmdEndConditionalRenderingEXT>(get_device_proc_addr(device,"vkCmdEndConditionalRenderingEXT"));
    pfn_CmdSetViewportWScalingNV = reinterpret_cast<detail::PFN_CmdSetViewportWScalingNV>(get_device_proc_addr(device,"vkCmdSetViewportWScalingNV"));
    pfn_DisplayPowerControlEXT = reinterpret_cast<detail::PFN_DisplayPowerControlEXT>(get_device_proc_addr(device,"vkDisplayPowerControlEXT"));
    pfn_RegisterDeviceEventEXT = reinterpret_cast<detail::PFN_RegisterDeviceEventEXT>(get_device_proc_addr(device,"vkRegisterDeviceEventEXT"));
    pfn_RegisterDisplayEventEXT = reinterpret_cast<detail::PFN_RegisterDisplayEventEXT>(get_device_proc_addr(device,"vkRegisterDisplayEventEXT"));
    pfn_GetSwapchainCounterEXT = reinterpret_cast<detail::PFN_GetSwapchainCounterEXT>(get_device_proc_addr(device,"vkGetSwapchainCounterEXT"));
    pfn_GetRefreshCycleDurationGOOGLE = reinterpret_cast<detail::PFN_GetRefreshCycleDurationGOOGLE>(get_device_proc_addr(device,"vkGetRefreshCycleDurationGOOGLE"));
    pfn_GetPastPresentationTimingGOOGLE = reinterpret_cast<detail::PFN_GetPastPresentationTimingGOOGLE>(get_device_proc_addr(device,"vkGetPastPresentationTimingGOOGLE"));
    pfn_CmdSetDiscardRectangleEXT = reinterpret_cast<detail::PFN_CmdSetDiscardRectangleEXT>(get_device_proc_addr(device,"vkCmdSetDiscardRectangleEXT"));
    pfn_SetHdrMetadataEXT = reinterpret_cast<detail::PFN_SetHdrMetadataEXT>(get_device_proc_addr(device,"vkSetHdrMetadataEXT"));
    pfn_GetSwapchainStatusKHR = reinterpret_cast<detail::PFN_GetSwapchainStatusKHR>(get_device_proc_addr(device,"vkGetSwapchainStatusKHR"));
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetFenceWin32HandleKHR = reinterpret_cast<detail::PFN_GetFenceWin32HandleKHR>(get_device_proc_addr(device,"vkGetFenceWin32HandleKHR"));
    pfn_ImportFenceWin32HandleKHR = reinterpret_cast<detail::PFN_ImportFenceWin32HandleKHR>(get_device_proc_addr(device,"vkImportFenceWin32HandleKHR"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_GetFenceFdKHR = reinterpret_cast<detail::PFN_GetFenceFdKHR>(get_device_proc_addr(device,"vkGetFenceFdKHR"));
    pfn_ImportFenceFdKHR = reinterpret_cast<detail::PFN_ImportFenceFdKHR>(get_device_proc_addr(device,"vkImportFenceFdKHR"));
    pfn_AcquireProfilingLockKHR = reinterpret_cast<detail::PFN_AcquireProfilingLockKHR>(get_device_proc_addr(device,"vkAcquireProfilingLockKHR"));
    pfn_ReleaseProfilingLockKHR = reinterpret_cast<detail::PFN_ReleaseProfilingLockKHR>(get_device_proc_addr(device,"vkReleaseProfilingLockKHR"));
    pfn_SetDebugUtilsObjectNameEXT = reinterpret_cast<detail::PFN_SetDebugUtilsObjectNameEXT>(get_device_proc_addr(device,"vkSetDebugUtilsObjectNameEXT"));
    pfn_SetDebugUtilsObjectTagEXT = reinterpret_cast<detail::PFN_SetDebugUtilsObjectTagEXT>(get_device_proc_addr(device,"vkSetDebugUtilsObjectTagEXT"));
    pfn_QueueBeginDebugUtilsLabelEXT = reinterpret_cast<detail::PFN_QueueBeginDebugUtilsLabelEXT>(get_device_proc_addr(device,"vkQueueBeginDebugUtilsLabelEXT"));
    pfn_QueueEndDebugUtilsLabelEXT = reinterpret_cast<detail::PFN_QueueEndDebugUtilsLabelEXT>(get_device_proc_addr(device,"vkQueueEndDebugUtilsLabelEXT"));
    pfn_QueueInsertDebugUtilsLabelEXT = reinterpret_cast<detail::PFN_QueueInsertDebugUtilsLabelEXT>(get_device_proc_addr(device,"vkQueueInsertDebugUtilsLabelEXT"));
    pfn_CmdBeginDebugUtilsLabelEXT = reinterpret_cast<detail::PFN_CmdBeginDebugUtilsLabelEXT>(get_device_proc_addr(device,"vkCmdBeginDebugUtilsLabelEXT"));
    pfn_CmdEndDebugUtilsLabelEXT = reinterpret_cast<detail::PFN_CmdEndDebugUtilsLabelEXT>(get_device_proc_addr(device,"vkCmdEndDebugUtilsLabelEXT"));
    pfn_CmdInsertDebugUtilsLabelEXT = reinterpret_cast<detail::PFN_CmdInsertDebugUtilsLabelEXT>(get_device_proc_addr(device,"vkCmdInsertDebugUtilsLabelEXT"));
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    pfn_GetAndroidHardwareBufferPropertiesANDROID = reinterpret_cast<detail::PFN_GetAndroidHardwareBufferPropertiesANDROID>(get_device_proc_addr(device,"vkGetAndroidHardwareBufferPropertiesANDROID"));
    pfn_GetMemoryAndroidHardwareBufferANDROID = reinterpret_cast<detail::PFN_GetMemoryAndroidHardwareBufferANDROID>(get_device_proc_addr(device,"vkGetMemoryAndroidHardwareBufferANDROID"));
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
    pfn_CmdSetSampleLocationsEXT = reinterpret_cast<detail::PFN_CmdSetSampleLocationsEXT>(get_device_proc_addr(device,"vkCmdSetSampleLocationsEXT"));
    pfn_DestroyAccelerationStructureKHR = reinterpret_cast<detail::PFN_DestroyAccelerationStructureKHR>(get_device_proc_addr(device,"vkDestroyAccelerationStructureKHR"));
    pfn_CmdCopyAccelerationStructureKHR = reinterpret_cast<detail::PFN_CmdCopyAccelerationStructureKHR>(get_device_proc_addr(device,"vkCmdCopyAccelerationStructureKHR"));
    pfn_CopyAccelerationStructureKHR = reinterpret_cast<detail::PFN_CopyAccelerationStructureKHR>(get_device_proc_addr(device,"vkCopyAccelerationStructureKHR"));
    pfn_CmdCopyAccelerationStructureToMemoryKHR = reinterpret_cast<detail::PFN_CmdCopyAccelerationStructureToMemoryKHR>(get_device_proc_addr(device,"vkCmdCopyAccelerationStructureToMemoryKHR"));
    pfn_CopyAccelerationStructureToMemoryKHR = reinterpret_cast<detail::PFN_CopyAccelerationStructureToMemoryKHR>(get_device_proc_addr(device,"vkCopyAccelerationStructureToMemoryKHR"));
    pfn_CmdCopyMemoryToAccelerationStructureKHR = reinterpret_cast<detail::PFN_CmdCopyMemoryToAccelerationStructureKHR>(get_device_proc_addr(device,"vkCmdCopyMemoryToAccelerationStructureKHR"));
    pfn_CopyMemoryToAccelerationStructureKHR = reinterpret_cast<detail::PFN_CopyMemoryToAccelerationStructureKHR>(get_device_proc_addr(device,"vkCopyMemoryToAccelerationStructureKHR"));
    pfn_CmdWriteAccelerationStructuresPropertiesKHR = reinterpret_cast<detail::PFN_CmdWriteAccelerationStructuresPropertiesKHR>(get_device_proc_addr(device,"vkCmdWriteAccelerationStructuresPropertiesKHR"));
    pfn_WriteAccelerationStructuresPropertiesKHR = reinterpret_cast<detail::PFN_WriteAccelerationStructuresPropertiesKHR>(get_device_proc_addr(device,"vkWriteAccelerationStructuresPropertiesKHR"));
    pfn_GetDeviceAccelerationStructureCompatibilityKHR = reinterpret_cast<detail::PFN_GetDeviceAccelerationStructureCompatibilityKHR>(get_device_proc_addr(device,"vkGetDeviceAccelerationStructureCompatibilityKHR"));
    pfn_CreateAccelerationStructureKHR = reinterpret_cast<detail::PFN_CreateAccelerationStructureKHR>(get_device_proc_addr(device,"vkCreateAccelerationStructureKHR"));
    pfn_CmdBuildAccelerationStructuresKHR = reinterpret_cast<detail::PFN_CmdBuildAccelerationStructuresKHR>(get_device_proc_addr(device,"vkCmdBuildAccelerationStructuresKHR"));
    pfn_CmdBuildAccelerationStructuresIndirectKHR = reinterpret_cast<detail::PFN_CmdBuildAccelerationStructuresIndirectKHR>(get_device_proc_addr(device,"vkCmdBuildAccelerationStructuresIndirectKHR"));
    pfn_BuildAccelerationStructuresKHR = reinterpret_cast<detail::PFN_BuildAccelerationStructuresKHR>(get_device_proc_addr(device,"vkBuildAccelerationStructuresKHR"));
    pfn_GetAccelerationStructureDeviceAddressKHR = reinterpret_cast<detail::PFN_GetAccelerationStructureDeviceAddressKHR>(get_device_proc_addr(device,"vkGetAccelerationStructureDeviceAddressKHR"));
    pfn_GetAccelerationStructureBuildSizesKHR = reinterpret_cast<detail::PFN_GetAccelerationStructureBuildSizesKHR>(get_device_proc_addr(device,"vkGetAccelerationStructureBuildSizesKHR"));
    pfn_CmdTraceRaysKHR = reinterpret_cast<detail::PFN_CmdTraceRaysKHR>(get_device_proc_addr(device,"vkCmdTraceRaysKHR"));
    pfn_GetRayTracingShaderGroupHandlesKHR = reinterpret_cast<detail::PFN_GetRayTracingShaderGroupHandlesKHR>(get_device_proc_addr(device,"vkGetRayTracingShaderGroupHandlesKHR"));
    pfn_GetRayTracingCaptureReplayShaderGroupHandlesKHR = reinterpret_cast<detail::PFN_GetRayTracingCaptureReplayShaderGroupHandlesKHR>(get_device_proc_addr(device,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"));
    pfn_CreateRayTracingPipelinesKHR = reinterpret_cast<detail::PFN_CreateRayTracingPipelinesKHR>(get_device_proc_addr(device,"vkCreateRayTracingPipelinesKHR"));
    pfn_CmdTraceRaysIndirectKHR = reinterpret_cast<detail::PFN_CmdTraceRaysIndirectKHR>(get_device_proc_addr(device,"vkCmdTraceRaysIndirectKHR"));
    pfn_GetRayTracingShaderGroupStackSizeKHR = reinterpret_cast<detail::PFN_GetRayTracingShaderGroupStackSizeKHR>(get_device_proc_addr(device,"vkGetRayTracingShaderGroupStackSizeKHR"));
    pfn_CmdSetRayTracingPipelineStackSizeKHR = reinterpret_cast<detail::PFN_CmdSetRayTracingPipelineStackSizeKHR>(get_device_proc_addr(device,"vkCmdSetRayTracingPipelineStackSizeKHR"));
    pfn_GetImageDrmFormatModifierPropertiesEXT = reinterpret_cast<detail::PFN_GetImageDrmFormatModifierPropertiesEXT>(get_device_proc_addr(device,"vkGetImageDrmFormatModifierPropertiesEXT"));
    pfn_CreateValidationCacheEXT = reinterpret_cast<detail::PFN_CreateValidationCacheEXT>(get_device_proc_addr(device,"vkCreateValidationCacheEXT"));
    pfn_DestroyValidationCacheEXT = reinterpret_cast<detail::PFN_DestroyValidationCacheEXT>(get_device_proc_addr(device,"vkDestroyValidationCacheEXT"));
    pfn_GetValidationCacheDataEXT = reinterpret_cast<detail::PFN_GetValidationCacheDataEXT>(get_device_proc_addr(device,"vkGetValidationCacheDataEXT"));
    pfn_MergeValidationCachesEXT = reinterpret_cast<detail::PFN_MergeValidationCachesEXT>(get_device_proc_addr(device,"vkMergeValidationCachesEXT"));
    pfn_CmdBindShadingRateImageNV = reinterpret_cast<detail::PFN_CmdBindShadingRateImageNV>(get_device_proc_addr(device,"vkCmdBindShadingRateImageNV"));
    pfn_CmdSetViewportShadingRatePaletteNV = reinterpret_cast<detail::PFN_CmdSetViewportShadingRatePaletteNV>(get_device_proc_addr(device,"vkCmdSetViewportShadingRatePaletteNV"));
    pfn_CmdSetCoarseSampleOrderNV = reinterpret_cast<detail::PFN_CmdSetCoarseSampleOrderNV>(get_device_proc_addr(device,"vkCmdSetCoarseSampleOrderNV"));
    pfn_CompileDeferredNV = reinterpret_cast<detail::PFN_CompileDeferredNV>(get_device_proc_addr(device,"vkCompileDeferredNV"));
    pfn_CreateAccelerationStructureNV = reinterpret_cast<detail::PFN_CreateAccelerationStructureNV>(get_device_proc_addr(device,"vkCreateAccelerationStructureNV"));
    pfn_DestroyAccelerationStructureNV = reinterpret_cast<detail::PFN_DestroyAccelerationStructureNV>(get_device_proc_addr(device,"vkDestroyAccelerationStructureNV"));
    pfn_GetAccelerationStructureMemoryRequirementsNV = reinterpret_cast<detail::PFN_GetAccelerationStructureMemoryRequirementsNV>(get_device_proc_addr(device,"vkGetAccelerationStructureMemoryRequirementsNV"));
    pfn_BindAccelerationStructureMemoryNV = reinterpret_cast<detail::PFN_BindAccelerationStructureMemoryNV>(get_device_proc_addr(device,"vkBindAccelerationStructureMemoryNV"));
    pfn_CmdCopyAccelerationStructureNV = reinterpret_cast<detail::PFN_CmdCopyAccelerationStructureNV>(get_device_proc_addr(device,"vkCmdCopyAccelerationStructureNV"));
    pfn_CmdWriteAccelerationStructuresPropertiesNV = reinterpret_cast<detail::PFN_CmdWriteAccelerationStructuresPropertiesNV>(get_device_proc_addr(device,"vkCmdWriteAccelerationStructuresPropertiesNV"));
    pfn_CmdBuildAccelerationStructureNV = reinterpret_cast<detail::PFN_CmdBuildAccelerationStructureNV>(get_device_proc_addr(device,"vkCmdBuildAccelerationStructureNV"));
    pfn_CmdTraceRaysNV = reinterpret_cast<detail::PFN_CmdTraceRaysNV>(get_device_proc_addr(device,"vkCmdTraceRaysNV"));
    pfn_GetAccelerationStructureHandleNV = reinterpret_cast<detail::PFN_GetAccelerationStructureHandleNV>(get_device_proc_addr(device,"vkGetAccelerationStructureHandleNV"));
    pfn_CreateRayTracingPipelinesNV = reinterpret_cast<detail::PFN_CreateRayTracingPipelinesNV>(get_device_proc_addr(device,"vkCreateRayTracingPipelinesNV"));
    pfn_GetMemoryHostPointerPropertiesEXT = reinterpret_cast<detail::PFN_GetMemoryHostPointerPropertiesEXT>(get_device_proc_addr(device,"vkGetMemoryHostPointerPropertiesEXT"));
    pfn_CmdWriteBufferMarkerAMD = reinterpret_cast<detail::PFN_CmdWriteBufferMarkerAMD>(get_device_proc_addr(device,"vkCmdWriteBufferMarkerAMD"));
    pfn_GetCalibratedTimestampsEXT = reinterpret_cast<detail::PFN_GetCalibratedTimestampsEXT>(get_device_proc_addr(device,"vkGetCalibratedTimestampsEXT"));
    pfn_CmdDrawMeshTasksNV = reinterpret_cast<detail::PFN_CmdDrawMeshTasksNV>(get_device_proc_addr(device,"vkCmdDrawMeshTasksNV"));
    pfn_CmdDrawMeshTasksIndirectNV = reinterpret_cast<detail::PFN_CmdDrawMeshTasksIndirectNV>(get_device_proc_addr(device,"vkCmdDrawMeshTasksIndirectNV"));
    pfn_CmdDrawMeshTasksIndirectCountNV = reinterpret_cast<detail::PFN_CmdDrawMeshTasksIndirectCountNV>(get_device_proc_addr(device,"vkCmdDrawMeshTasksIndirectCountNV"));
    pfn_CmdSetExclusiveScissorNV = reinterpret_cast<detail::PFN_CmdSetExclusiveScissorNV>(get_device_proc_addr(device,"vkCmdSetExclusiveScissorNV"));
    pfn_CmdSetCheckpointNV = reinterpret_cast<detail::PFN_CmdSetCheckpointNV>(get_device_proc_addr(device,"vkCmdSetCheckpointNV"));
    pfn_GetQueueCheckpointDataNV = reinterpret_cast<detail::PFN_GetQueueCheckpointDataNV>(get_device_proc_addr(device,"vkGetQueueCheckpointDataNV"));
    pfn_InitializePerformanceApiINTEL = reinterpret_cast<detail::PFN_InitializePerformanceApiINTEL>(get_device_proc_addr(device,"vkInitializePerformanceApiINTEL"));
    pfn_UninitializePerformanceApiINTEL = reinterpret_cast<detail::PFN_UninitializePerformanceApiINTEL>(get_device_proc_addr(device,"vkUninitializePerformanceApiINTEL"));
    pfn_CmdSetPerformanceMarkerINTEL = reinterpret_cast<detail::PFN_CmdSetPerformanceMarkerINTEL>(get_device_proc_addr(device,"vkCmdSetPerformanceMarkerINTEL"));
    pfn_CmdSetPerformanceStreamMarkerINTEL = reinterpret_cast<detail::PFN_CmdSetPerformanceStreamMarkerINTEL>(get_device_proc_addr(device,"vkCmdSetPerformanceStreamMarkerINTEL"));
    pfn_CmdSetPerformanceOverrideINTEL = reinterpret_cast<detail::PFN_CmdSetPerformanceOverrideINTEL>(get_device_proc_addr(device,"vkCmdSetPerformanceOverrideINTEL"));
    pfn_AcquirePerformanceConfigurationINTEL = reinterpret_cast<detail::PFN_AcquirePerformanceConfigurationINTEL>(get_device_proc_addr(device,"vkAcquirePerformanceConfigurationINTEL"));
    pfn_ReleasePerformanceConfigurationINTEL = reinterpret_cast<detail::PFN_ReleasePerformanceConfigurationINTEL>(get_device_proc_addr(device,"vkReleasePerformanceConfigurationINTEL"));
    pfn_QueueSetPerformanceConfigurationINTEL = reinterpret_cast<detail::PFN_QueueSetPerformanceConfigurationINTEL>(get_device_proc_addr(device,"vkQueueSetPerformanceConfigurationINTEL"));
    pfn_GetPerformanceParameterINTEL = reinterpret_cast<detail::PFN_GetPerformanceParameterINTEL>(get_device_proc_addr(device,"vkGetPerformanceParameterINTEL"));
    pfn_SetLocalDimmingAMD = reinterpret_cast<detail::PFN_SetLocalDimmingAMD>(get_device_proc_addr(device,"vkSetLocalDimmingAMD"));
    pfn_CmdSetFragmentShadingRateKHR = reinterpret_cast<detail::PFN_CmdSetFragmentShadingRateKHR>(get_device_proc_addr(device,"vkCmdSetFragmentShadingRateKHR"));
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_AcquireFullScreenExclusiveModeEXT = reinterpret_cast<detail::PFN_AcquireFullScreenExclusiveModeEXT>(get_device_proc_addr(device,"vkAcquireFullScreenExclusiveModeEXT"));
    pfn_ReleaseFullScreenExclusiveModeEXT = reinterpret_cast<detail::PFN_ReleaseFullScreenExclusiveModeEXT>(get_device_proc_addr(device,"vkReleaseFullScreenExclusiveModeEXT"));
    pfn_GetDeviceGroupSurfacePresentModes2EXT = reinterpret_cast<detail::PFN_GetDeviceGroupSurfacePresentModes2EXT>(get_device_proc_addr(device,"vkGetDeviceGroupSurfacePresentModes2EXT"));
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
    pfn_CmdSetLineStippleEXT = reinterpret_cast<detail::PFN_CmdSetLineStippleEXT>(get_device_proc_addr(device,"vkCmdSetLineStippleEXT"));
    pfn_CmdSetCullModeEXT = reinterpret_cast<detail::PFN_CmdSetCullModeEXT>(get_device_proc_addr(device,"vkCmdSetCullModeEXT"));
    pfn_CmdSetFrontFaceEXT = reinterpret_cast<detail::PFN_CmdSetFrontFaceEXT>(get_device_proc_addr(device,"vkCmdSetFrontFaceEXT"));
    pfn_CmdSetPrimitiveTopologyEXT = reinterpret_cast<detail::PFN_CmdSetPrimitiveTopologyEXT>(get_device_proc_addr(device,"vkCmdSetPrimitiveTopologyEXT"));
    pfn_CmdSetViewportWithCountEXT = reinterpret_cast<detail::PFN_CmdSetViewportWithCountEXT>(get_device_proc_addr(device,"vkCmdSetViewportWithCountEXT"));
    pfn_CmdSetScissorWithCountEXT = reinterpret_cast<detail::PFN_CmdSetScissorWithCountEXT>(get_device_proc_addr(device,"vkCmdSetScissorWithCountEXT"));
    pfn_CmdBindVertexBuffers2EXT = reinterpret_cast<detail::PFN_CmdBindVertexBuffers2EXT>(get_device_proc_addr(device,"vkCmdBindVertexBuffers2EXT"));
    pfn_CmdSetDepthTestEnableEXT = reinterpret_cast<detail::PFN_CmdSetDepthTestEnableEXT>(get_device_proc_addr(device,"vkCmdSetDepthTestEnableEXT"));
    pfn_CmdSetDepthWriteEnableEXT = reinterpret_cast<detail::PFN_CmdSetDepthWriteEnableEXT>(get_device_proc_addr(device,"vkCmdSetDepthWriteEnableEXT"));
    pfn_CmdSetDepthCompareOpEXT = reinterpret_cast<detail::PFN_CmdSetDepthCompareOpEXT>(get_device_proc_addr(device,"vkCmdSetDepthCompareOpEXT"));
    pfn_CmdSetDepthBoundsTestEnableEXT = reinterpret_cast<detail::PFN_CmdSetDepthBoundsTestEnableEXT>(get_device_proc_addr(device,"vkCmdSetDepthBoundsTestEnableEXT"));
    pfn_CmdSetStencilTestEnableEXT = reinterpret_cast<detail::PFN_CmdSetStencilTestEnableEXT>(get_device_proc_addr(device,"vkCmdSetStencilTestEnableEXT"));
    pfn_CmdSetStencilOpEXT = reinterpret_cast<detail::PFN_CmdSetStencilOpEXT>(get_device_proc_addr(device,"vkCmdSetStencilOpEXT"));
    pfn_CreateDeferredOperationKHR = reinterpret_cast<detail::PFN_CreateDeferredOperationKHR>(get_device_proc_addr(device,"vkCreateDeferredOperationKHR"));
    pfn_DestroyDeferredOperationKHR = reinterpret_cast<detail::PFN_DestroyDeferredOperationKHR>(get_device_proc_addr(device,"vkDestroyDeferredOperationKHR"));
    pfn_GetDeferredOperationMaxConcurrencyKHR = reinterpret_cast<detail::PFN_GetDeferredOperationMaxConcurrencyKHR>(get_device_proc_addr(device,"vkGetDeferredOperationMaxConcurrencyKHR"));
    pfn_GetDeferredOperationResultKHR = reinterpret_cast<detail::PFN_GetDeferredOperationResultKHR>(get_device_proc_addr(device,"vkGetDeferredOperationResultKHR"));
    pfn_DeferredOperationJoinKHR = reinterpret_cast<detail::PFN_DeferredOperationJoinKHR>(get_device_proc_addr(device,"vkDeferredOperationJoinKHR"));
    pfn_GetPipelineExecutablePropertiesKHR = reinterpret_cast<detail::PFN_GetPipelineExecutablePropertiesKHR>(get_device_proc_addr(device,"vkGetPipelineExecutablePropertiesKHR"));
    pfn_GetPipelineExecutableStatisticsKHR = reinterpret_cast<detail::PFN_GetPipelineExecutableStatisticsKHR>(get_device_proc_addr(device,"vkGetPipelineExecutableStatisticsKHR"));
    pfn_GetPipelineExecutableInternalRepresentationsKHR = reinterpret_cast<detail::PFN_GetPipelineExecutableInternalRepresentationsKHR>(get_device_proc_addr(device,"vkGetPipelineExecutableInternalRepresentationsKHR"));
    pfn_CmdExecuteGeneratedCommandsNV = reinterpret_cast<detail::PFN_CmdExecuteGeneratedCommandsNV>(get_device_proc_addr(device,"vkCmdExecuteGeneratedCommandsNV"));
    pfn_CmdPreprocessGeneratedCommandsNV = reinterpret_cast<detail::PFN_CmdPreprocessGeneratedCommandsNV>(get_device_proc_addr(device,"vkCmdPreprocessGeneratedCommandsNV"));
    pfn_CmdBindPipelineShaderGroupNV = reinterpret_cast<detail::PFN_CmdBindPipelineShaderGroupNV>(get_device_proc_addr(device,"vkCmdBindPipelineShaderGroupNV"));
    pfn_GetGeneratedCommandsMemoryRequirementsNV = reinterpret_cast<detail::PFN_GetGeneratedCommandsMemoryRequirementsNV>(get_device_proc_addr(device,"vkGetGeneratedCommandsMemoryRequirementsNV"));
    pfn_CreateIndirectCommandsLayoutNV = reinterpret_cast<detail::PFN_CreateIndirectCommandsLayoutNV>(get_device_proc_addr(device,"vkCreateIndirectCommandsLayoutNV"));
    pfn_DestroyIndirectCommandsLayoutNV = reinterpret_cast<detail::PFN_DestroyIndirectCommandsLayoutNV>(get_device_proc_addr(device,"vkDestroyIndirectCommandsLayoutNV"));
    pfn_CreatePrivateDataSlotEXT = reinterpret_cast<detail::PFN_CreatePrivateDataSlotEXT>(get_device_proc_addr(device,"vkCreatePrivateDataSlotEXT"));
    pfn_DestroyPrivateDataSlotEXT = reinterpret_cast<detail::PFN_DestroyPrivateDataSlotEXT>(get_device_proc_addr(device,"vkDestroyPrivateDataSlotEXT"));
    pfn_SetPrivateDataEXT = reinterpret_cast<detail::PFN_SetPrivateDataEXT>(get_device_proc_addr(device,"vkSetPrivateDataEXT"));
    pfn_GetPrivateDataEXT = reinterpret_cast<detail::PFN_GetPrivateDataEXT>(get_device_proc_addr(device,"vkGetPrivateDataEXT"));
    pfn_CmdSetEvent2KHR = reinterpret_cast<detail::PFN_CmdSetEvent2KHR>(get_device_proc_addr(device,"vkCmdSetEvent2KHR"));
    pfn_CmdResetEvent2KHR = reinterpret_cast<detail::PFN_CmdResetEvent2KHR>(get_device_proc_addr(device,"vkCmdResetEvent2KHR"));
    pfn_CmdWaitEvents2KHR = reinterpret_cast<detail::PFN_CmdWaitEvents2KHR>(get_device_proc_addr(device,"vkCmdWaitEvents2KHR"));
    pfn_CmdPipelineBarrier2KHR = reinterpret_cast<detail::PFN_CmdPipelineBarrier2KHR>(get_device_proc_addr(device,"vkCmdPipelineBarrier2KHR"));
    pfn_QueueSubmit2KHR = reinterpret_cast<detail::PFN_QueueSubmit2KHR>(get_device_proc_addr(device,"vkQueueSubmit2KHR"));
    pfn_CmdWriteTimestamp2KHR = reinterpret_cast<detail::PFN_CmdWriteTimestamp2KHR>(get_device_proc_addr(device,"vkCmdWriteTimestamp2KHR"));
    pfn_CmdWriteBufferMarker2AMD = reinterpret_cast<detail::PFN_CmdWriteBufferMarker2AMD>(get_device_proc_addr(device,"vkCmdWriteBufferMarker2AMD"));
    pfn_GetQueueCheckpointData2NV = reinterpret_cast<detail::PFN_GetQueueCheckpointData2NV>(get_device_proc_addr(device,"vkGetQueueCheckpointData2NV"));
    pfn_CmdSetFragmentShadingRateEnumNV = reinterpret_cast<detail::PFN_CmdSetFragmentShadingRateEnumNV>(get_device_proc_addr(device,"vkCmdSetFragmentShadingRateEnumNV"));
    pfn_CmdCopyBuffer2KHR = reinterpret_cast<detail::PFN_CmdCopyBuffer2KHR>(get_device_proc_addr(device,"vkCmdCopyBuffer2KHR"));
    pfn_CmdCopyImage2KHR = reinterpret_cast<detail::PFN_CmdCopyImage2KHR>(get_device_proc_addr(device,"vkCmdCopyImage2KHR"));
    pfn_CmdBlitImage2KHR = reinterpret_cast<detail::PFN_CmdBlitImage2KHR>(get_device_proc_addr(device,"vkCmdBlitImage2KHR"));
    pfn_CmdCopyBufferToImage2KHR = reinterpret_cast<detail::PFN_CmdCopyBufferToImage2KHR>(get_device_proc_addr(device,"vkCmdCopyBufferToImage2KHR"));
    pfn_CmdCopyImageToBuffer2KHR = reinterpret_cast<detail::PFN_CmdCopyImageToBuffer2KHR>(get_device_proc_addr(device,"vkCmdCopyImageToBuffer2KHR"));
    pfn_CmdResolveImage2KHR = reinterpret_cast<detail::PFN_CmdResolveImage2KHR>(get_device_proc_addr(device,"vkCmdResolveImage2KHR"));
    pfn_CmdSetVertexInputEXT = reinterpret_cast<detail::PFN_CmdSetVertexInputEXT>(get_device_proc_addr(device,"vkCmdSetVertexInputEXT"));
#if defined(VK_USE_PLATFORM_FUCHSIA)
    pfn_GetMemoryZirconHandleFUCHSIA = reinterpret_cast<detail::PFN_GetMemoryZirconHandleFUCHSIA>(get_device_proc_addr(device,"vkGetMemoryZirconHandleFUCHSIA"));
    pfn_GetMemoryZirconHandlePropertiesFUCHSIA = reinterpret_cast<detail::PFN_GetMemoryZirconHandlePropertiesFUCHSIA>(get_device_proc_addr(device,"vkGetMemoryZirconHandlePropertiesFUCHSIA"));
    pfn_GetSemaphoreZirconHandleFUCHSIA = reinterpret_cast<detail::PFN_GetSemaphoreZirconHandleFUCHSIA>(get_device_proc_addr(device,"vkGetSemaphoreZirconHandleFUCHSIA"));
    pfn_ImportSemaphoreZirconHandleFUCHSIA = reinterpret_cast<detail::PFN_ImportSemaphoreZirconHandleFUCHSIA>(get_device_proc_addr(device,"vkImportSemaphoreZirconHandleFUCHSIA"));
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
    pfn_CmdSetPatchControlPointsEXT = reinterpret_cast<detail::PFN_CmdSetPatchControlPointsEXT>(get_device_proc_addr(device,"vkCmdSetPatchControlPointsEXT"));
    pfn_CmdSetRasterizerDiscardEnableEXT = reinterpret_cast<detail::PFN_CmdSetRasterizerDiscardEnableEXT>(get_device_proc_addr(device,"vkCmdSetRasterizerDiscardEnableEXT"));
    pfn_CmdSetDepthBiasEnableEXT = reinterpret_cast<detail::PFN_CmdSetDepthBiasEnableEXT>(get_device_proc_addr(device,"vkCmdSetDepthBiasEnableEXT"));
    pfn_CmdSetLogicOpEXT = reinterpret_cast<detail::PFN_CmdSetLogicOpEXT>(get_device_proc_addr(device,"vkCmdSetLogicOpEXT"));
    pfn_CmdSetPrimitiveRestartEnableEXT = reinterpret_cast<detail::PFN_CmdSetPrimitiveRestartEnableEXT>(get_device_proc_addr(device,"vkCmdSetPrimitiveRestartEnableEXT"));
    pfn_CmdSetColorWriteEnableEXT = reinterpret_cast<detail::PFN_CmdSetColorWriteEnableEXT>(get_device_proc_addr(device,"vkCmdSetColorWriteEnableEXT"));
}
};
    struct PhysicalDeviceFunctions {
    InstanceFunctions const* instance_functions;
    PhysicalDevice physicaldevice;
    PhysicalDeviceFunctions() noexcept {}
    PhysicalDeviceFunctions(InstanceFunctions const& instance_functions, PhysicalDevice const physicaldevice) noexcept:
    instance_functions{&instance_functions}, physicaldevice{physicaldevice} {}[[nodiscard]] PhysicalDeviceProperties GetProperties() const {
    return instance_functions->GetPhysicalDeviceProperties(physicaldevice); }
[[nodiscard]] std::vector<QueueFamilyProperties> GetQueueFamilyProperties() const {
    return instance_functions->GetPhysicalDeviceQueueFamilyProperties(physicaldevice); }
[[nodiscard]] PhysicalDeviceMemoryProperties GetMemoryProperties() const {
    return instance_functions->GetPhysicalDeviceMemoryProperties(physicaldevice); }
[[nodiscard]] PhysicalDeviceFeatures GetFeatures() const {
    return instance_functions->GetPhysicalDeviceFeatures(physicaldevice); }
[[nodiscard]] FormatProperties GetFormatProperties(Format format) const {
    return instance_functions->GetPhysicalDeviceFormatProperties(physicaldevice, format); }
[[nodiscard]] expected<ImageFormatProperties> GetImageFormatProperties(Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags = {}) const {
    return instance_functions->GetPhysicalDeviceImageFormatProperties(physicaldevice, format, type, tiling, usage, flags); }
[[nodiscard]] expected<Device> CreateDevice(const DeviceCreateInfo&  pCreateInfo, const AllocationCallbacks* pAllocator = nullptr) const {
    return instance_functions->CreateDevice(physicaldevice, pCreateInfo, pAllocator); }
[[nodiscard]] expected<std::vector<ExtensionProperties>> EnumerateDeviceExtensionProperties(const char* pLayerName = nullptr) const {
    return instance_functions->EnumerateDeviceExtensionProperties(physicaldevice, pLayerName); }
[[nodiscard]] std::vector<SparseImageFormatProperties> GetSparseImageFormatProperties(Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling) const {
    return instance_functions->GetPhysicalDeviceSparseImageFormatProperties(physicaldevice, format, type, samples, usage, tiling); }
[[nodiscard]] expected<std::vector<DisplayPropertiesKHR>> GetDisplayPropertiesKHR() const {
    return instance_functions->GetPhysicalDeviceDisplayPropertiesKHR(physicaldevice); }
[[nodiscard]] expected<std::vector<DisplayPlanePropertiesKHR>> GetDisplayPlanePropertiesKHR() const {
    return instance_functions->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicaldevice); }
[[nodiscard]] expected<std::vector<DisplayKHR>> GetDisplayPlaneSupportedDisplaysKHR(uint32_t planeIndex) const {
    return instance_functions->GetDisplayPlaneSupportedDisplaysKHR(physicaldevice, planeIndex); }
[[nodiscard]] expected<std::vector<DisplayModePropertiesKHR>> GetDisplayModePropertiesKHR(DisplayKHR display) const {
    return instance_functions->GetDisplayModePropertiesKHR(physicaldevice, display); }
[[nodiscard]] expected<DisplayModeKHR> CreateDisplayModeKHR(DisplayKHR display, const DisplayModeCreateInfoKHR&  pCreateInfo, const AllocationCallbacks* pAllocator = nullptr) const {
    return instance_functions->CreateDisplayModeKHR(physicaldevice, display, pCreateInfo, pAllocator); }
[[nodiscard]] expected<DisplayPlaneCapabilitiesKHR> GetDisplayPlaneCapabilitiesKHR(DisplayModeKHR mode, uint32_t planeIndex) const {
    return instance_functions->GetDisplayPlaneCapabilitiesKHR(physicaldevice, mode, planeIndex); }
[[nodiscard]] expected<Bool32> GetSurfaceSupportKHR(uint32_t queueFamilyIndex, SurfaceKHR surface) const {
    return instance_functions->GetPhysicalDeviceSurfaceSupportKHR(physicaldevice, queueFamilyIndex, surface); }
[[nodiscard]] expected<SurfaceCapabilitiesKHR> GetSurfaceCapabilitiesKHR(SurfaceKHR surface) const {
    return instance_functions->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicaldevice, surface); }
[[nodiscard]] expected<std::vector<SurfaceFormatKHR>> GetSurfaceFormatsKHR(SurfaceKHR surface) const {
    return instance_functions->GetPhysicalDeviceSurfaceFormatsKHR(physicaldevice, surface); }
[[nodiscard]] expected<std::vector<PresentModeKHR>> GetSurfacePresentModesKHR(SurfaceKHR surface) const {
    return instance_functions->GetPhysicalDeviceSurfacePresentModesKHR(physicaldevice, surface); }
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
[[nodiscard]] expected<wl_display> GetWaylandPresentationSupportKHR(uint32_t queueFamilyIndex) const {
    return instance_functions->GetPhysicalDeviceWaylandPresentationSupportKHR(physicaldevice, queueFamilyIndex); }
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] Bool32 GetWin32PresentationSupportKHR(uint32_t queueFamilyIndex) const {
    return instance_functions->GetPhysicalDeviceWin32PresentationSupportKHR(physicaldevice, queueFamilyIndex); }
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_XLIB_KHR)
[[nodiscard]] Bool32 GetXlibPresentationSupportKHR(uint32_t queueFamilyIndex, Display&  dpy, VisualID visualID) const {
    return instance_functions->GetPhysicalDeviceXlibPresentationSupportKHR(physicaldevice, queueFamilyIndex, dpy, visualID); }
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
[[nodiscard]] Bool32 GetXcbPresentationSupportKHR(uint32_t queueFamilyIndex, xcb_connection_t&  connection, xcb_visualid_t visual_id) const {
    return instance_functions->GetPhysicalDeviceXcbPresentationSupportKHR(physicaldevice, queueFamilyIndex, connection, visual_id); }
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
[[nodiscard]] expected<IDirectFB> GetDirectFBPresentationSupportEXT(uint32_t queueFamilyIndex) const {
    return instance_functions->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicaldevice, queueFamilyIndex); }
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
[[nodiscard]] expected<_screen_window> GetScreenPresentationSupportQNX(uint32_t queueFamilyIndex) const {
    return instance_functions->GetPhysicalDeviceScreenPresentationSupportQNX(physicaldevice, queueFamilyIndex); }
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
[[nodiscard]] expected<ExternalImageFormatPropertiesNV> GetExternalImageFormatPropertiesNV(Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags = {}, ExternalMemoryHandleTypeFlagsNV externalHandleType = {}) const {
    return instance_functions->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicaldevice, format, type, tiling, usage, flags, externalHandleType); }
[[nodiscard]] PhysicalDeviceFeatures2 GetFeatures2() const {
    return instance_functions->GetPhysicalDeviceFeatures2(physicaldevice); }
[[nodiscard]] PhysicalDeviceProperties2 GetProperties2() const {
    return instance_functions->GetPhysicalDeviceProperties2(physicaldevice); }
[[nodiscard]] FormatProperties2 GetFormatProperties2(Format format) const {
    return instance_functions->GetPhysicalDeviceFormatProperties2(physicaldevice, format); }
[[nodiscard]] expected<ImageFormatProperties2> GetImageFormatProperties2(const PhysicalDeviceImageFormatInfo2&  pImageFormatInfo) const {
    return instance_functions->GetPhysicalDeviceImageFormatProperties2(physicaldevice, pImageFormatInfo); }
[[nodiscard]] std::vector<QueueFamilyProperties2> GetQueueFamilyProperties2() const {
    return instance_functions->GetPhysicalDeviceQueueFamilyProperties2(physicaldevice); }
[[nodiscard]] PhysicalDeviceMemoryProperties2 GetMemoryProperties2() const {
    return instance_functions->GetPhysicalDeviceMemoryProperties2(physicaldevice); }
[[nodiscard]] std::vector<SparseImageFormatProperties2> GetSparseImageFormatProperties2(const PhysicalDeviceSparseImageFormatInfo2&  pFormatInfo) const {
    return instance_functions->GetPhysicalDeviceSparseImageFormatProperties2(physicaldevice, pFormatInfo); }
[[nodiscard]] ExternalBufferProperties GetExternalBufferProperties(const PhysicalDeviceExternalBufferInfo&  pExternalBufferInfo) const {
    return instance_functions->GetPhysicalDeviceExternalBufferProperties(physicaldevice, pExternalBufferInfo); }
[[nodiscard]] ExternalSemaphoreProperties GetExternalSemaphoreProperties(const PhysicalDeviceExternalSemaphoreInfo&  pExternalSemaphoreInfo) const {
    return instance_functions->GetPhysicalDeviceExternalSemaphoreProperties(physicaldevice, pExternalSemaphoreInfo); }
[[nodiscard]] ExternalFenceProperties GetExternalFenceProperties(const PhysicalDeviceExternalFenceInfo&  pExternalFenceInfo) const {
    return instance_functions->GetPhysicalDeviceExternalFenceProperties(physicaldevice, pExternalFenceInfo); }
[[nodiscard]] Result ReleaseDisplayEXT(DisplayKHR display) const {
    return instance_functions->ReleaseDisplayEXT(physicaldevice, display); }
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
[[nodiscard]] Result AcquireXlibDisplayEXT(Display&  dpy, DisplayKHR display) const {
    return instance_functions->AcquireXlibDisplayEXT(physicaldevice, dpy, display); }
[[nodiscard]] expected<DisplayKHR> GetRandROutputDisplayEXT(Display&  dpy, RROutput rrOutput) const {
    return instance_functions->GetRandROutputDisplayEXT(physicaldevice, dpy, rrOutput); }
#endif // defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] Result AcquireWinrtDisplayNV(DisplayKHR display) const {
    return instance_functions->AcquireWinrtDisplayNV(physicaldevice, display); }
[[nodiscard]] expected<DisplayKHR> GetWinrtDisplayNV(uint32_t deviceRelativeId) const {
    return instance_functions->GetWinrtDisplayNV(physicaldevice, deviceRelativeId); }
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<SurfaceCapabilities2EXT> GetSurfaceCapabilities2EXT(SurfaceKHR surface) const {
    return instance_functions->GetPhysicalDeviceSurfaceCapabilities2EXT(physicaldevice, surface); }
[[nodiscard]] expected<std::vector<Rect2D>> GetPresentRectanglesKHR(SurfaceKHR surface) const {
    return instance_functions->GetPhysicalDevicePresentRectanglesKHR(physicaldevice, surface); }
[[nodiscard]] MultisamplePropertiesEXT GetMultisamplePropertiesEXT(SampleCountFlagBits samples) const {
    return instance_functions->GetPhysicalDeviceMultisamplePropertiesEXT(physicaldevice, samples); }
[[nodiscard]] expected<SurfaceCapabilities2KHR> GetSurfaceCapabilities2KHR(const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    return instance_functions->GetPhysicalDeviceSurfaceCapabilities2KHR(physicaldevice, pSurfaceInfo); }
[[nodiscard]] expected<std::vector<SurfaceFormat2KHR>> GetSurfaceFormats2KHR(const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    return instance_functions->GetPhysicalDeviceSurfaceFormats2KHR(physicaldevice, pSurfaceInfo); }
[[nodiscard]] expected<std::vector<DisplayProperties2KHR>> GetDisplayProperties2KHR() const {
    return instance_functions->GetPhysicalDeviceDisplayProperties2KHR(physicaldevice); }
[[nodiscard]] expected<std::vector<DisplayPlaneProperties2KHR>> GetDisplayPlaneProperties2KHR() const {
    return instance_functions->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicaldevice); }
[[nodiscard]] expected<std::vector<DisplayModeProperties2KHR>> GetDisplayModeProperties2KHR(DisplayKHR display) const {
    return instance_functions->GetDisplayModeProperties2KHR(physicaldevice, display); }
[[nodiscard]] expected<DisplayPlaneCapabilities2KHR> GetDisplayPlaneCapabilities2KHR(const DisplayPlaneInfo2KHR&  pDisplayPlaneInfo) const {
    return instance_functions->GetDisplayPlaneCapabilities2KHR(physicaldevice, pDisplayPlaneInfo); }
[[nodiscard]] expected<std::vector<TimeDomainEXT>> GetCalibrateableTimeDomainsEXT() const {
    return instance_functions->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicaldevice); }
[[nodiscard]] expected<std::vector<CooperativeMatrixPropertiesNV>> GetCooperativeMatrixPropertiesNV() const {
    return instance_functions->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicaldevice); }
#if defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] expected<std::vector<PresentModeKHR>> GetSurfacePresentModes2EXT(const PhysicalDeviceSurfaceInfo2KHR&  pSurfaceInfo) const {
    return instance_functions->GetPhysicalDeviceSurfacePresentModes2EXT(physicaldevice, pSurfaceInfo); }
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
[[nodiscard]] Result EnumerateQueueFamilyPerformanceQueryCountersKHR(uint32_t queueFamilyIndex, uint32_t&  pCounterCount, PerformanceCounterKHR* pCounters = nullptr, PerformanceCounterDescriptionKHR* pCounterDescriptions = nullptr) const {
    return instance_functions->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicaldevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions); }
[[nodiscard]] uint32_t GetQueueFamilyPerformanceQueryPassesKHR(const QueryPoolPerformanceCreateInfoKHR&  pPerformanceQueryCreateInfo) const {
    return instance_functions->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicaldevice, pPerformanceQueryCreateInfo); }
[[nodiscard]] expected<std::vector<FramebufferMixedSamplesCombinationNV>> GetSupportedFramebufferMixedSamplesCombinationsNV() const {
    return instance_functions->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicaldevice); }
[[nodiscard]] expected<std::vector<PhysicalDeviceToolPropertiesEXT>> GetToolPropertiesEXT() const {
    return instance_functions->GetPhysicalDeviceToolPropertiesEXT(physicaldevice); }
[[nodiscard]] expected<std::vector<PhysicalDeviceFragmentShadingRateKHR>> GetFragmentShadingRatesKHR() const {
    return instance_functions->GetPhysicalDeviceFragmentShadingRatesKHR(physicaldevice); }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
[[nodiscard]] expected<VideoCapabilitiesKHR> GetVideoCapabilitiesKHR(const VideoProfileKHR&  pVideoProfile) const {
    return instance_functions->GetPhysicalDeviceVideoCapabilitiesKHR(physicaldevice, pVideoProfile); }
[[nodiscard]] Result GetVideoFormatPropertiesKHR(const PhysicalDeviceVideoFormatInfoKHR&  pVideoFormatInfo, uint32_t&  pVideoFormatPropertyCount, VideoFormatPropertiesKHR* pVideoFormatProperties = nullptr) const {
    return instance_functions->GetPhysicalDeviceVideoFormatPropertiesKHR(physicaldevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties); }
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
};
    struct QueueFunctions {
    DeviceFunctions const* device_functions;
    Queue queue;
    QueueFunctions() noexcept {}
    QueueFunctions(DeviceFunctions const& device_functions, Queue const queue) noexcept:
    device_functions{&device_functions}, queue{queue} {}[[nodiscard]] Result Submit(detail::span<const SubmitInfo> Submits, Fence fence = {}) const {
    return device_functions->QueueSubmit(queue, Submits, fence); }
[[nodiscard]] Result WaitIdle() const {
    return device_functions->QueueWaitIdle(queue); }
[[nodiscard]] Result BindSparse(detail::span<const BindSparseInfo> BindInfo, Fence fence = {}) const {
    return device_functions->QueueBindSparse(queue, BindInfo, fence); }
[[nodiscard]] Result PresentKHR(const PresentInfoKHR&  pPresentInfo) const {
    return device_functions->QueuePresentKHR(queue, pPresentInfo); }
void BeginDebugUtilsLabelEXT(const DebugUtilsLabelEXT&  pLabelInfo) const {
    device_functions->QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo); }
void EndDebugUtilsLabelEXT() const {
    device_functions->QueueEndDebugUtilsLabelEXT(queue); }
void InsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT&  pLabelInfo) const {
    device_functions->QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo); }
[[nodiscard]] std::vector<CheckpointDataNV> GetCheckpointDataNV() const {
    return device_functions->GetQueueCheckpointDataNV(queue); }
[[nodiscard]] Result SetPerformanceConfigurationINTEL(PerformanceConfigurationINTEL configuration) const {
    return device_functions->QueueSetPerformanceConfigurationINTEL(queue, configuration); }
[[nodiscard]] Result Submit2KHR(detail::span<const SubmitInfo2KHR> Submits, Fence fence = {}) const {
    return device_functions->QueueSubmit2KHR(queue, Submits, fence); }
[[nodiscard]] std::vector<CheckpointData2NV> GetCheckpointData2NV() const {
    return device_functions->GetQueueCheckpointData2NV(queue); }
};
    struct CommandBufferFunctions {
    DeviceFunctions const* device_functions;
    CommandBuffer commandbuffer;
    CommandBufferFunctions() noexcept {}
    CommandBufferFunctions(DeviceFunctions const& device_functions, CommandBuffer const commandbuffer) noexcept:
    device_functions{&device_functions}, commandbuffer{commandbuffer} {}[[nodiscard]] Result Begin(const CommandBufferBeginInfo&  pBeginInfo) const {
    return device_functions->BeginCommandBuffer(commandbuffer, pBeginInfo); }
[[nodiscard]] Result End() const {
    return device_functions->EndCommandBuffer(commandbuffer); }
[[nodiscard]] Result Reset(CommandBufferResetFlags flags = {}) const {
    return device_functions->ResetCommandBuffer(commandbuffer, flags); }
CommandBufferFunctions const& BindPipeline(PipelineBindPoint pipelineBindPoint, Pipeline pipeline) const {
    device_functions->CmdBindPipeline(commandbuffer, pipelineBindPoint, pipeline);
    return *this; }
CommandBufferFunctions const& SetViewport(uint32_t firstViewport, detail::span<const Viewport> Viewports) const {
    device_functions->CmdSetViewport(commandbuffer, firstViewport, Viewports);
    return *this; }
CommandBufferFunctions const& SetScissor(uint32_t firstScissor, detail::span<const Rect2D> Scissors) const {
    device_functions->CmdSetScissor(commandbuffer, firstScissor, Scissors);
    return *this; }
CommandBufferFunctions const& SetLineWidth(float lineWidth) const {
    device_functions->CmdSetLineWidth(commandbuffer, lineWidth);
    return *this; }
CommandBufferFunctions const& SetDepthBias(float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) const {
    device_functions->CmdSetDepthBias(commandbuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
    return *this; }
CommandBufferFunctions const& SetBlendConstants(const float blendConstants[4]) const {
    device_functions->CmdSetBlendConstants(commandbuffer, blendConstants);
    return *this; }
CommandBufferFunctions const& SetDepthBounds(float minDepthBounds, float maxDepthBounds) const {
    device_functions->CmdSetDepthBounds(commandbuffer, minDepthBounds, maxDepthBounds);
    return *this; }
CommandBufferFunctions const& SetStencilCompareMask(StencilFaceFlags faceMask, uint32_t compareMask) const {
    device_functions->CmdSetStencilCompareMask(commandbuffer, faceMask, compareMask);
    return *this; }
CommandBufferFunctions const& SetStencilWriteMask(StencilFaceFlags faceMask, uint32_t writeMask) const {
    device_functions->CmdSetStencilWriteMask(commandbuffer, faceMask, writeMask);
    return *this; }
CommandBufferFunctions const& SetStencilReference(StencilFaceFlags faceMask, uint32_t reference) const {
    device_functions->CmdSetStencilReference(commandbuffer, faceMask, reference);
    return *this; }
CommandBufferFunctions const& BindDescriptorSets(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, detail::span<const DescriptorSet> DescriptorSets, detail::span<const uint32_t> DynamicOffsets) const {
    device_functions->CmdBindDescriptorSets(commandbuffer, pipelineBindPoint, layout, firstSet, DescriptorSets, DynamicOffsets);
    return *this; }
CommandBufferFunctions const& BindIndexBuffer(Buffer buffer, DeviceSize offset, IndexType indexType) const {
    device_functions->CmdBindIndexBuffer(commandbuffer, buffer, offset, indexType);
    return *this; }
CommandBufferFunctions const& BindVertexBuffers(uint32_t firstBinding, detail::span<const Buffer> Buffers, detail::span<const DeviceSize> Offsets) const {
    device_functions->CmdBindVertexBuffers(commandbuffer, firstBinding, Buffers, Offsets);
    return *this; }
CommandBufferFunctions const& Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {
    device_functions->CmdDraw(commandbuffer, vertexCount, instanceCount, firstVertex, firstInstance);
    return *this; }
CommandBufferFunctions const& DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const {
    device_functions->CmdDrawIndexed(commandbuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
    return *this; }
CommandBufferFunctions const& DrawIndirect(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const {
    device_functions->CmdDrawIndirect(commandbuffer, buffer, offset, drawCount, stride);
    return *this; }
CommandBufferFunctions const& DrawIndexedIndirect(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const {
    device_functions->CmdDrawIndexedIndirect(commandbuffer, buffer, offset, drawCount, stride);
    return *this; }
CommandBufferFunctions const& Dispatch(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const {
    device_functions->CmdDispatch(commandbuffer, groupCountX, groupCountY, groupCountZ);
    return *this; }
CommandBufferFunctions const& DispatchIndirect(Buffer buffer, DeviceSize offset) const {
    device_functions->CmdDispatchIndirect(commandbuffer, buffer, offset);
    return *this; }
CommandBufferFunctions const& CopyBuffer(Buffer srcBuffer, Buffer dstBuffer, detail::span<const BufferCopy> Regions) const {
    device_functions->CmdCopyBuffer(commandbuffer, srcBuffer, dstBuffer, Regions);
    return *this; }
CommandBufferFunctions const& CopyImage(Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, detail::span<const ImageCopy> Regions) const {
    device_functions->CmdCopyImage(commandbuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, Regions);
    return *this; }
CommandBufferFunctions const& BlitImage(Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, detail::span<const ImageBlit> Regions, Filter filter) const {
    device_functions->CmdBlitImage(commandbuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, Regions, filter);
    return *this; }
CommandBufferFunctions const& CopyBufferToImage(Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, detail::span<const BufferImageCopy> Regions) const {
    device_functions->CmdCopyBufferToImage(commandbuffer, srcBuffer, dstImage, dstImageLayout, Regions);
    return *this; }
CommandBufferFunctions const& CopyImageToBuffer(Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, detail::span<const BufferImageCopy> Regions) const {
    device_functions->CmdCopyImageToBuffer(commandbuffer, srcImage, srcImageLayout, dstBuffer, Regions);
    return *this; }
CommandBufferFunctions const& UpdateBuffer(Buffer dstBuffer, DeviceSize dstOffset, detail::span<const std::byte> Data) const {
    device_functions->CmdUpdateBuffer(commandbuffer, dstBuffer, dstOffset, Data);
    return *this; }
CommandBufferFunctions const& FillBuffer(Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data) const {
    device_functions->CmdFillBuffer(commandbuffer, dstBuffer, dstOffset, size, data);
    return *this; }
CommandBufferFunctions const& ClearColorImage(Image image, ImageLayout imageLayout, const ClearColorValue&  pColor, detail::span<const ImageSubresourceRange> Ranges) const {
    device_functions->CmdClearColorImage(commandbuffer, image, imageLayout, pColor, Ranges);
    return *this; }
CommandBufferFunctions const& ClearDepthStencilImage(Image image, ImageLayout imageLayout, const ClearDepthStencilValue&  pDepthStencil, detail::span<const ImageSubresourceRange> Ranges) const {
    device_functions->CmdClearDepthStencilImage(commandbuffer, image, imageLayout, pDepthStencil, Ranges);
    return *this; }
CommandBufferFunctions const& ClearAttachments(detail::span<const ClearAttachment> Attachments, detail::span<const ClearRect> Rects) const {
    device_functions->CmdClearAttachments(commandbuffer, Attachments, Rects);
    return *this; }
CommandBufferFunctions const& ResolveImage(Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, detail::span<const ImageResolve> Regions) const {
    device_functions->CmdResolveImage(commandbuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, Regions);
    return *this; }
CommandBufferFunctions const& SetEvent(Event event, PipelineStageFlags stageMask) const {
    device_functions->CmdSetEvent(commandbuffer, event, stageMask);
    return *this; }
CommandBufferFunctions const& ResetEvent(Event event, PipelineStageFlags stageMask) const {
    device_functions->CmdResetEvent(commandbuffer, event, stageMask);
    return *this; }
CommandBufferFunctions const& WaitEvents(detail::span<const Event> Events, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, detail::span<const MemoryBarrier> MemoryBarriers, detail::span<const BufferMemoryBarrier> BufferMemoryBarriers, detail::span<const ImageMemoryBarrier> ImageMemoryBarriers) const {
    device_functions->CmdWaitEvents(commandbuffer, Events, srcStageMask, dstStageMask, MemoryBarriers, BufferMemoryBarriers, ImageMemoryBarriers);
    return *this; }
CommandBufferFunctions const& PipelineBarrier(PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, detail::span<const MemoryBarrier> MemoryBarriers, detail::span<const BufferMemoryBarrier> BufferMemoryBarriers, detail::span<const ImageMemoryBarrier> ImageMemoryBarriers) const {
    device_functions->CmdPipelineBarrier(commandbuffer, srcStageMask, dstStageMask, dependencyFlags, MemoryBarriers, BufferMemoryBarriers, ImageMemoryBarriers);
    return *this; }
CommandBufferFunctions const& BeginQuery(QueryPool queryPool, uint32_t query, QueryControlFlags flags = {}) const {
    device_functions->CmdBeginQuery(commandbuffer, queryPool, query, flags);
    return *this; }
CommandBufferFunctions const& EndQuery(QueryPool queryPool, uint32_t query) const {
    device_functions->CmdEndQuery(commandbuffer, queryPool, query);
    return *this; }
CommandBufferFunctions const& BeginConditionalRenderingEXT(const ConditionalRenderingBeginInfoEXT&  pConditionalRenderingBegin) const {
    device_functions->CmdBeginConditionalRenderingEXT(commandbuffer, pConditionalRenderingBegin);
    return *this; }
CommandBufferFunctions const& EndConditionalRenderingEXT() const {
    device_functions->CmdEndConditionalRenderingEXT(commandbuffer);
    return *this; }
CommandBufferFunctions const& ResetQueryPool(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const {
    device_functions->CmdResetQueryPool(commandbuffer, queryPool, firstQuery, queryCount);
    return *this; }
CommandBufferFunctions const& WriteTimestamp(PipelineStageFlagBits pipelineStage, QueryPool queryPool, uint32_t query) const {
    device_functions->CmdWriteTimestamp(commandbuffer, pipelineStage, queryPool, query);
    return *this; }
CommandBufferFunctions const& CopyQueryPoolResults(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags = {}) const {
    device_functions->CmdCopyQueryPoolResults(commandbuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
    return *this; }
CommandBufferFunctions const& PushConstants(PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, detail::span<const std::byte> Values) const {
    device_functions->CmdPushConstants(commandbuffer, layout, stageFlags, offset, Values);
    return *this; }
CommandBufferFunctions const& BeginRenderPass(const RenderPassBeginInfo&  pRenderPassBegin, SubpassContents contents) const {
    device_functions->CmdBeginRenderPass(commandbuffer, pRenderPassBegin, contents);
    return *this; }
CommandBufferFunctions const& NextSubpass(SubpassContents contents) const {
    device_functions->CmdNextSubpass(commandbuffer, contents);
    return *this; }
CommandBufferFunctions const& EndRenderPass() const {
    device_functions->CmdEndRenderPass(commandbuffer);
    return *this; }
CommandBufferFunctions const& ExecuteCommands(detail::span<const CommandBuffer> CommandBuffers) const {
    device_functions->CmdExecuteCommands(commandbuffer, CommandBuffers);
    return *this; }
CommandBufferFunctions const& DebugMarkerBeginEXT(const DebugMarkerMarkerInfoEXT&  pMarkerInfo) const {
    device_functions->CmdDebugMarkerBeginEXT(commandbuffer, pMarkerInfo);
    return *this; }
CommandBufferFunctions const& DebugMarkerEndEXT() const {
    device_functions->CmdDebugMarkerEndEXT(commandbuffer);
    return *this; }
CommandBufferFunctions const& DebugMarkerInsertEXT(const DebugMarkerMarkerInfoEXT&  pMarkerInfo) const {
    device_functions->CmdDebugMarkerInsertEXT(commandbuffer, pMarkerInfo);
    return *this; }
CommandBufferFunctions const& ExecuteGeneratedCommandsNV(Bool32 isPreprocessed, const GeneratedCommandsInfoNV&  pGeneratedCommandsInfo) const {
    device_functions->CmdExecuteGeneratedCommandsNV(commandbuffer, isPreprocessed, pGeneratedCommandsInfo);
    return *this; }
CommandBufferFunctions const& PreprocessGeneratedCommandsNV(const GeneratedCommandsInfoNV&  pGeneratedCommandsInfo) const {
    device_functions->CmdPreprocessGeneratedCommandsNV(commandbuffer, pGeneratedCommandsInfo);
    return *this; }
CommandBufferFunctions const& BindPipelineShaderGroupNV(PipelineBindPoint pipelineBindPoint, Pipeline pipeline, uint32_t groupIndex) const {
    device_functions->CmdBindPipelineShaderGroupNV(commandbuffer, pipelineBindPoint, pipeline, groupIndex);
    return *this; }
CommandBufferFunctions const& PushDescriptorSetKHR(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, detail::span<const WriteDescriptorSet> DescriptorWrites) const {
    device_functions->CmdPushDescriptorSetKHR(commandbuffer, pipelineBindPoint, layout, set, DescriptorWrites);
    return *this; }
CommandBufferFunctions const& SetDeviceMask(uint32_t deviceMask) const {
    device_functions->CmdSetDeviceMask(commandbuffer, deviceMask);
    return *this; }
CommandBufferFunctions const& DispatchBase(uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const {
    device_functions->CmdDispatchBase(commandbuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    return *this; }
CommandBufferFunctions const& PushDescriptorSetWithTemplateKHR(DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData) const {
    device_functions->CmdPushDescriptorSetWithTemplateKHR(commandbuffer, descriptorUpdateTemplate, layout, set, pData);
    return *this; }
CommandBufferFunctions const& SetViewportWScalingNV(uint32_t firstViewport, detail::span<const ViewportWScalingNV> ViewportWScalings) const {
    device_functions->CmdSetViewportWScalingNV(commandbuffer, firstViewport, ViewportWScalings);
    return *this; }
CommandBufferFunctions const& SetDiscardRectangleEXT(uint32_t firstDiscardRectangle, detail::span<const Rect2D> DiscardRectangles) const {
    device_functions->CmdSetDiscardRectangleEXT(commandbuffer, firstDiscardRectangle, DiscardRectangles);
    return *this; }
CommandBufferFunctions const& SetSampleLocationsEXT(const SampleLocationsInfoEXT&  pSampleLocationsInfo) const {
    device_functions->CmdSetSampleLocationsEXT(commandbuffer, pSampleLocationsInfo);
    return *this; }
CommandBufferFunctions const& BeginDebugUtilsLabelEXT(const DebugUtilsLabelEXT&  pLabelInfo) const {
    device_functions->CmdBeginDebugUtilsLabelEXT(commandbuffer, pLabelInfo);
    return *this; }
CommandBufferFunctions const& EndDebugUtilsLabelEXT() const {
    device_functions->CmdEndDebugUtilsLabelEXT(commandbuffer);
    return *this; }
CommandBufferFunctions const& InsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT&  pLabelInfo) const {
    device_functions->CmdInsertDebugUtilsLabelEXT(commandbuffer, pLabelInfo);
    return *this; }
CommandBufferFunctions const& WriteBufferMarkerAMD(PipelineStageFlagBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker) const {
    device_functions->CmdWriteBufferMarkerAMD(commandbuffer, pipelineStage, dstBuffer, dstOffset, marker);
    return *this; }
CommandBufferFunctions const& BeginRenderPass2(const RenderPassBeginInfo&  pRenderPassBegin, const SubpassBeginInfo&  pSubpassBeginInfo) const {
    device_functions->CmdBeginRenderPass2(commandbuffer, pRenderPassBegin, pSubpassBeginInfo);
    return *this; }
CommandBufferFunctions const& NextSubpass2(const SubpassBeginInfo&  pSubpassBeginInfo, const SubpassEndInfo&  pSubpassEndInfo) const {
    device_functions->CmdNextSubpass2(commandbuffer, pSubpassBeginInfo, pSubpassEndInfo);
    return *this; }
CommandBufferFunctions const& EndRenderPass2(const SubpassEndInfo&  pSubpassEndInfo) const {
    device_functions->CmdEndRenderPass2(commandbuffer, pSubpassEndInfo);
    return *this; }
CommandBufferFunctions const& DrawIndirectCount(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const {
    device_functions->CmdDrawIndirectCount(commandbuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    return *this; }
CommandBufferFunctions const& DrawIndexedIndirectCount(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const {
    device_functions->CmdDrawIndexedIndirectCount(commandbuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    return *this; }
CommandBufferFunctions const& SetCheckpointNV(const void* pCheckpointMarker) const {
    device_functions->CmdSetCheckpointNV(commandbuffer, pCheckpointMarker);
    return *this; }
CommandBufferFunctions const& BindTransformFeedbackBuffersEXT(uint32_t firstBinding, detail::span<const Buffer> Buffers, detail::span<const DeviceSize> Offsets, detail::span<const DeviceSize> Sizes = {}) const {
    device_functions->CmdBindTransformFeedbackBuffersEXT(commandbuffer, firstBinding, Buffers, Offsets, Sizes);
    return *this; }
CommandBufferFunctions const& BeginTransformFeedbackEXT(uint32_t firstCounterBuffer, detail::span<const Buffer> CounterBuffers, detail::span<const DeviceSize> CounterBufferOffsets = {}) const {
    device_functions->CmdBeginTransformFeedbackEXT(commandbuffer, firstCounterBuffer, CounterBuffers, CounterBufferOffsets);
    return *this; }
CommandBufferFunctions const& EndTransformFeedbackEXT(uint32_t firstCounterBuffer, detail::span<const Buffer> CounterBuffers, detail::span<const DeviceSize> CounterBufferOffsets = {}) const {
    device_functions->CmdEndTransformFeedbackEXT(commandbuffer, firstCounterBuffer, CounterBuffers, CounterBufferOffsets);
    return *this; }
CommandBufferFunctions const& BeginQueryIndexedEXT(QueryPool queryPool, uint32_t query, QueryControlFlags flags, uint32_t index) const {
    device_functions->CmdBeginQueryIndexedEXT(commandbuffer, queryPool, query, flags, index);
    return *this; }
CommandBufferFunctions const& EndQueryIndexedEXT(QueryPool queryPool, uint32_t query, uint32_t index) const {
    device_functions->CmdEndQueryIndexedEXT(commandbuffer, queryPool, query, index);
    return *this; }
CommandBufferFunctions const& DrawIndirectByteCountEXT(uint32_t instanceCount, uint32_t firstInstance, Buffer counterBuffer, DeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) const {
    device_functions->CmdDrawIndirectByteCountEXT(commandbuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
    return *this; }
CommandBufferFunctions const& SetExclusiveScissorNV(uint32_t firstExclusiveScissor, detail::span<const Rect2D> ExclusiveScissors) const {
    device_functions->CmdSetExclusiveScissorNV(commandbuffer, firstExclusiveScissor, ExclusiveScissors);
    return *this; }
CommandBufferFunctions const& BindShadingRateImageNV(ImageView imageView, ImageLayout imageLayout) const {
    device_functions->CmdBindShadingRateImageNV(commandbuffer, imageView, imageLayout);
    return *this; }
CommandBufferFunctions const& SetViewportShadingRatePaletteNV(uint32_t firstViewport, detail::span<const ShadingRatePaletteNV> ShadingRatePalettes) const {
    device_functions->CmdSetViewportShadingRatePaletteNV(commandbuffer, firstViewport, ShadingRatePalettes);
    return *this; }
CommandBufferFunctions const& SetCoarseSampleOrderNV(CoarseSampleOrderTypeNV sampleOrderType, detail::span<const CoarseSampleOrderCustomNV> CustomSampleOrders) const {
    device_functions->CmdSetCoarseSampleOrderNV(commandbuffer, sampleOrderType, CustomSampleOrders);
    return *this; }
CommandBufferFunctions const& DrawMeshTasksNV(uint32_t taskCount, uint32_t firstTask) const {
    device_functions->CmdDrawMeshTasksNV(commandbuffer, taskCount, firstTask);
    return *this; }
CommandBufferFunctions const& DrawMeshTasksIndirectNV(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const {
    device_functions->CmdDrawMeshTasksIndirectNV(commandbuffer, buffer, offset, drawCount, stride);
    return *this; }
CommandBufferFunctions const& DrawMeshTasksIndirectCountNV(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const {
    device_functions->CmdDrawMeshTasksIndirectCountNV(commandbuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    return *this; }
CommandBufferFunctions const& CopyAccelerationStructureNV(AccelerationStructureNV dst, AccelerationStructureNV src, CopyAccelerationStructureModeKHR mode) const {
    device_functions->CmdCopyAccelerationStructureNV(commandbuffer, dst, src, mode);
    return *this; }
CommandBufferFunctions const& CopyAccelerationStructureKHR(const CopyAccelerationStructureInfoKHR&  pInfo) const {
    device_functions->CmdCopyAccelerationStructureKHR(commandbuffer, pInfo);
    return *this; }
CommandBufferFunctions const& CopyAccelerationStructureToMemoryKHR(const CopyAccelerationStructureToMemoryInfoKHR&  pInfo) const {
    device_functions->CmdCopyAccelerationStructureToMemoryKHR(commandbuffer, pInfo);
    return *this; }
CommandBufferFunctions const& CopyMemoryToAccelerationStructureKHR(const CopyMemoryToAccelerationStructureInfoKHR&  pInfo) const {
    device_functions->CmdCopyMemoryToAccelerationStructureKHR(commandbuffer, pInfo);
    return *this; }
CommandBufferFunctions const& WriteAccelerationStructuresPropertiesKHR(detail::span<const AccelerationStructureKHR> AccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery) const {
    device_functions->CmdWriteAccelerationStructuresPropertiesKHR(commandbuffer, AccelerationStructures, queryType, queryPool, firstQuery);
    return *this; }
CommandBufferFunctions const& WriteAccelerationStructuresPropertiesNV(detail::span<const AccelerationStructureNV> AccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery) const {
    device_functions->CmdWriteAccelerationStructuresPropertiesNV(commandbuffer, AccelerationStructures, queryType, queryPool, firstQuery);
    return *this; }
CommandBufferFunctions const& BuildAccelerationStructureNV(const AccelerationStructureInfoNV&  pInfo, Buffer instanceData, DeviceSize instanceOffset, Bool32 update, AccelerationStructureNV dst, AccelerationStructureNV src, Buffer scratch, DeviceSize scratchOffset) const {
    device_functions->CmdBuildAccelerationStructureNV(commandbuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
    return *this; }
CommandBufferFunctions const& TraceRaysKHR(const StridedDeviceAddressRegionKHR&  pRaygenShaderBindingTable, const StridedDeviceAddressRegionKHR&  pMissShaderBindingTable, const StridedDeviceAddressRegionKHR&  pHitShaderBindingTable, const StridedDeviceAddressRegionKHR&  pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) const {
    device_functions->CmdTraceRaysKHR(commandbuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
    return *this; }
CommandBufferFunctions const& TraceRaysNV(Buffer raygenShaderBindingTableBuffer, DeviceSize raygenShaderBindingOffset, Buffer missShaderBindingTableBuffer, DeviceSize missShaderBindingOffset, DeviceSize missShaderBindingStride, Buffer hitShaderBindingTableBuffer, DeviceSize hitShaderBindingOffset, DeviceSize hitShaderBindingStride, Buffer callableShaderBindingTableBuffer, DeviceSize callableShaderBindingOffset, DeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) const {
    device_functions->CmdTraceRaysNV(commandbuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
    return *this; }
CommandBufferFunctions const& TraceRaysIndirectKHR(const StridedDeviceAddressRegionKHR&  pRaygenShaderBindingTable, const StridedDeviceAddressRegionKHR&  pMissShaderBindingTable, const StridedDeviceAddressRegionKHR&  pHitShaderBindingTable, const StridedDeviceAddressRegionKHR&  pCallableShaderBindingTable, DeviceAddress indirectDeviceAddress) const {
    device_functions->CmdTraceRaysIndirectKHR(commandbuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
    return *this; }
CommandBufferFunctions const& SetRayTracingPipelineStackSizeKHR(uint32_t pipelineStackSize) const {
    device_functions->CmdSetRayTracingPipelineStackSizeKHR(commandbuffer, pipelineStackSize);
    return *this; }
[[nodiscard]] Result SetPerformanceMarkerINTEL(const PerformanceMarkerInfoINTEL&  pMarkerInfo) const {
    return device_functions->CmdSetPerformanceMarkerINTEL(commandbuffer, pMarkerInfo); }
[[nodiscard]] Result SetPerformanceStreamMarkerINTEL(const PerformanceStreamMarkerInfoINTEL&  pMarkerInfo) const {
    return device_functions->CmdSetPerformanceStreamMarkerINTEL(commandbuffer, pMarkerInfo); }
[[nodiscard]] Result SetPerformanceOverrideINTEL(const PerformanceOverrideInfoINTEL&  pOverrideInfo) const {
    return device_functions->CmdSetPerformanceOverrideINTEL(commandbuffer, pOverrideInfo); }
CommandBufferFunctions const& SetLineStippleEXT(uint32_t lineStippleFactor, uint16_t lineStipplePattern) const {
    device_functions->CmdSetLineStippleEXT(commandbuffer, lineStippleFactor, lineStipplePattern);
    return *this; }
CommandBufferFunctions const& BuildAccelerationStructuresKHR(detail::span<const AccelerationStructureBuildGeometryInfoKHR> Infos, detail::span<const AccelerationStructureBuildRangeInfoKHR*> pBuildRangeInfos) const {
    device_functions->CmdBuildAccelerationStructuresKHR(commandbuffer, Infos, pBuildRangeInfos);
    return *this; }
CommandBufferFunctions const& BuildAccelerationStructuresIndirectKHR(detail::span<const AccelerationStructureBuildGeometryInfoKHR> Infos, detail::span<const DeviceAddress> IndirectDeviceAddresses, detail::span<const uint32_t> IndirectStrides, detail::span<const uint32_t*> pMaxPrimitiveCounts) const {
    device_functions->CmdBuildAccelerationStructuresIndirectKHR(commandbuffer, Infos, IndirectDeviceAddresses, IndirectStrides, pMaxPrimitiveCounts);
    return *this; }
CommandBufferFunctions const& SetCullModeEXT(CullModeFlags cullMode = {}) const {
    device_functions->CmdSetCullModeEXT(commandbuffer, cullMode);
    return *this; }
CommandBufferFunctions const& SetFrontFaceEXT(FrontFace frontFace) const {
    device_functions->CmdSetFrontFaceEXT(commandbuffer, frontFace);
    return *this; }
CommandBufferFunctions const& SetPrimitiveTopologyEXT(PrimitiveTopology primitiveTopology) const {
    device_functions->CmdSetPrimitiveTopologyEXT(commandbuffer, primitiveTopology);
    return *this; }
CommandBufferFunctions const& SetViewportWithCountEXT(detail::span<const Viewport> Viewports) const {
    device_functions->CmdSetViewportWithCountEXT(commandbuffer, Viewports);
    return *this; }
CommandBufferFunctions const& SetScissorWithCountEXT(detail::span<const Rect2D> Scissors) const {
    device_functions->CmdSetScissorWithCountEXT(commandbuffer, Scissors);
    return *this; }
CommandBufferFunctions const& BindVertexBuffers2EXT(uint32_t firstBinding, detail::span<const Buffer> Buffers, detail::span<const DeviceSize> Offsets, detail::span<const DeviceSize> Sizes = {}, detail::span<const DeviceSize> Strides = {}) const {
    device_functions->CmdBindVertexBuffers2EXT(commandbuffer, firstBinding, Buffers, Offsets, Sizes, Strides);
    return *this; }
CommandBufferFunctions const& SetDepthTestEnableEXT(Bool32 depthTestEnable) const {
    device_functions->CmdSetDepthTestEnableEXT(commandbuffer, depthTestEnable);
    return *this; }
CommandBufferFunctions const& SetDepthWriteEnableEXT(Bool32 depthWriteEnable) const {
    device_functions->CmdSetDepthWriteEnableEXT(commandbuffer, depthWriteEnable);
    return *this; }
CommandBufferFunctions const& SetDepthCompareOpEXT(CompareOp depthCompareOp) const {
    device_functions->CmdSetDepthCompareOpEXT(commandbuffer, depthCompareOp);
    return *this; }
CommandBufferFunctions const& SetDepthBoundsTestEnableEXT(Bool32 depthBoundsTestEnable) const {
    device_functions->CmdSetDepthBoundsTestEnableEXT(commandbuffer, depthBoundsTestEnable);
    return *this; }
CommandBufferFunctions const& SetStencilTestEnableEXT(Bool32 stencilTestEnable) const {
    device_functions->CmdSetStencilTestEnableEXT(commandbuffer, stencilTestEnable);
    return *this; }
CommandBufferFunctions const& SetStencilOpEXT(StencilFaceFlags faceMask, StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp) const {
    device_functions->CmdSetStencilOpEXT(commandbuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
    return *this; }
CommandBufferFunctions const& SetPatchControlPointsEXT(uint32_t patchControlPoints) const {
    device_functions->CmdSetPatchControlPointsEXT(commandbuffer, patchControlPoints);
    return *this; }
CommandBufferFunctions const& SetRasterizerDiscardEnableEXT(Bool32 rasterizerDiscardEnable) const {
    device_functions->CmdSetRasterizerDiscardEnableEXT(commandbuffer, rasterizerDiscardEnable);
    return *this; }
CommandBufferFunctions const& SetDepthBiasEnableEXT(Bool32 depthBiasEnable) const {
    device_functions->CmdSetDepthBiasEnableEXT(commandbuffer, depthBiasEnable);
    return *this; }
CommandBufferFunctions const& SetLogicOpEXT(LogicOp logicOp) const {
    device_functions->CmdSetLogicOpEXT(commandbuffer, logicOp);
    return *this; }
CommandBufferFunctions const& SetPrimitiveRestartEnableEXT(Bool32 primitiveRestartEnable) const {
    device_functions->CmdSetPrimitiveRestartEnableEXT(commandbuffer, primitiveRestartEnable);
    return *this; }
CommandBufferFunctions const& CopyBuffer2KHR(const CopyBufferInfo2KHR&  pCopyBufferInfo) const {
    device_functions->CmdCopyBuffer2KHR(commandbuffer, pCopyBufferInfo);
    return *this; }
CommandBufferFunctions const& CopyImage2KHR(const CopyImageInfo2KHR&  pCopyImageInfo) const {
    device_functions->CmdCopyImage2KHR(commandbuffer, pCopyImageInfo);
    return *this; }
CommandBufferFunctions const& BlitImage2KHR(const BlitImageInfo2KHR&  pBlitImageInfo) const {
    device_functions->CmdBlitImage2KHR(commandbuffer, pBlitImageInfo);
    return *this; }
CommandBufferFunctions const& CopyBufferToImage2KHR(const CopyBufferToImageInfo2KHR&  pCopyBufferToImageInfo) const {
    device_functions->CmdCopyBufferToImage2KHR(commandbuffer, pCopyBufferToImageInfo);
    return *this; }
CommandBufferFunctions const& CopyImageToBuffer2KHR(const CopyImageToBufferInfo2KHR&  pCopyImageToBufferInfo) const {
    device_functions->CmdCopyImageToBuffer2KHR(commandbuffer, pCopyImageToBufferInfo);
    return *this; }
CommandBufferFunctions const& ResolveImage2KHR(const ResolveImageInfo2KHR&  pResolveImageInfo) const {
    device_functions->CmdResolveImage2KHR(commandbuffer, pResolveImageInfo);
    return *this; }
CommandBufferFunctions const& SetFragmentShadingRateKHR(const Extent2D&  pFragmentSize, const FragmentShadingRateCombinerOpKHR combinerOps[2]) const {
    device_functions->CmdSetFragmentShadingRateKHR(commandbuffer, pFragmentSize, combinerOps);
    return *this; }
CommandBufferFunctions const& SetFragmentShadingRateEnumNV(FragmentShadingRateNV shadingRate, const FragmentShadingRateCombinerOpKHR combinerOps[2]) const {
    device_functions->CmdSetFragmentShadingRateEnumNV(commandbuffer, shadingRate, combinerOps);
    return *this; }
CommandBufferFunctions const& SetVertexInputEXT(detail::span<const VertexInputBindingDescription2EXT> VertexBindingDescriptions, detail::span<const VertexInputAttributeDescription2EXT> VertexAttributeDescriptions) const {
    device_functions->CmdSetVertexInputEXT(commandbuffer, VertexBindingDescriptions, VertexAttributeDescriptions);
    return *this; }
CommandBufferFunctions const& SetColorWriteEnableEXT(detail::span<const Bool32> ColorWriteEnables) const {
    device_functions->CmdSetColorWriteEnableEXT(commandbuffer, ColorWriteEnables);
    return *this; }
CommandBufferFunctions const& SetEvent2KHR(Event event, const DependencyInfoKHR&  pDependencyInfo) const {
    device_functions->CmdSetEvent2KHR(commandbuffer, event, pDependencyInfo);
    return *this; }
CommandBufferFunctions const& ResetEvent2KHR(Event event, PipelineStageFlags2KHR stageMask) const {
    device_functions->CmdResetEvent2KHR(commandbuffer, event, stageMask);
    return *this; }
CommandBufferFunctions const& WaitEvents2KHR(detail::span<const Event> Events, detail::span<const DependencyInfoKHR> DependencyInfos) const {
    device_functions->CmdWaitEvents2KHR(commandbuffer, Events, DependencyInfos);
    return *this; }
CommandBufferFunctions const& PipelineBarrier2KHR(const DependencyInfoKHR&  pDependencyInfo) const {
    device_functions->CmdPipelineBarrier2KHR(commandbuffer, pDependencyInfo);
    return *this; }
CommandBufferFunctions const& WriteTimestamp2KHR(PipelineStageFlags2KHR stage, QueryPool queryPool, uint32_t query) const {
    device_functions->CmdWriteTimestamp2KHR(commandbuffer, stage, queryPool, query);
    return *this; }
CommandBufferFunctions const& WriteBufferMarker2AMD(PipelineStageFlags2KHR stage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker) const {
    device_functions->CmdWriteBufferMarker2AMD(commandbuffer, stage, dstBuffer, dstOffset, marker);
    return *this; }
#if defined(VK_ENABLE_BETA_EXTENSIONS)
CommandBufferFunctions const& DecodeVideoKHR(const VideoDecodeInfoKHR&  pFrameInfo) const {
    device_functions->CmdDecodeVideoKHR(commandbuffer, pFrameInfo);
    return *this; }
CommandBufferFunctions const& BeginVideoCodingKHR(const VideoBeginCodingInfoKHR&  pBeginInfo) const {
    device_functions->CmdBeginVideoCodingKHR(commandbuffer, pBeginInfo);
    return *this; }
CommandBufferFunctions const& ControlVideoCodingKHR(const VideoCodingControlInfoKHR&  pCodingControlInfo) const {
    device_functions->CmdControlVideoCodingKHR(commandbuffer, pCodingControlInfo);
    return *this; }
CommandBufferFunctions const& EndVideoCodingKHR(const VideoEndCodingInfoKHR&  pEndCodingInfo) const {
    device_functions->CmdEndVideoCodingKHR(commandbuffer, pEndCodingInfo);
    return *this; }
CommandBufferFunctions const& EncodeVideoKHR(const VideoEncodeInfoKHR&  pEncodeInfo) const {
    device_functions->CmdEncodeVideoKHR(commandbuffer, pEncodeInfo);
    return *this; }
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
};
#if defined(_MSC_VER)
#pragma warning( push )
#pragma warning( disable : 4065 )
#endif // defined(_MSC_VER)
inline const char * to_string(AttachmentLoadOp val) {
    switch(val) {
        case(AttachmentLoadOp::Load): return "Load";
        case(AttachmentLoadOp::Clear): return "Clear";
        case(AttachmentLoadOp::DontCare): return "DontCare";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(AttachmentStoreOp val) {
    switch(val) {
        case(AttachmentStoreOp::Store): return "Store";
        case(AttachmentStoreOp::DontCare): return "DontCare";
        case(AttachmentStoreOp::NoneQCOM): return "NoneQCOM";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(BlendFactor val) {
    switch(val) {
        case(BlendFactor::Zero): return "Zero";
        case(BlendFactor::One): return "One";
        case(BlendFactor::SrcColor): return "SrcColor";
        case(BlendFactor::OneMinusSrcColor): return "OneMinusSrcColor";
        case(BlendFactor::DstColor): return "DstColor";
        case(BlendFactor::OneMinusDstColor): return "OneMinusDstColor";
        case(BlendFactor::SrcAlpha): return "SrcAlpha";
        case(BlendFactor::OneMinusSrcAlpha): return "OneMinusSrcAlpha";
        case(BlendFactor::DstAlpha): return "DstAlpha";
        case(BlendFactor::OneMinusDstAlpha): return "OneMinusDstAlpha";
        case(BlendFactor::ConstantColor): return "ConstantColor";
        case(BlendFactor::OneMinusConstantColor): return "OneMinusConstantColor";
        case(BlendFactor::ConstantAlpha): return "ConstantAlpha";
        case(BlendFactor::OneMinusConstantAlpha): return "OneMinusConstantAlpha";
        case(BlendFactor::SrcAlphaSaturate): return "SrcAlphaSaturate";
        case(BlendFactor::Src1Color): return "Src1Color";
        case(BlendFactor::OneMinusSrc1Color): return "OneMinusSrc1Color";
        case(BlendFactor::Src1Alpha): return "Src1Alpha";
        case(BlendFactor::OneMinusSrc1Alpha): return "OneMinusSrc1Alpha";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(BlendOp val) {
    switch(val) {
        case(BlendOp::Add): return "Add";
        case(BlendOp::Subtract): return "Subtract";
        case(BlendOp::ReverseSubtract): return "ReverseSubtract";
        case(BlendOp::Min): return "Min";
        case(BlendOp::Max): return "Max";
        case(BlendOp::ZeroEXT): return "ZeroEXT";
        case(BlendOp::SrcEXT): return "SrcEXT";
        case(BlendOp::DstEXT): return "DstEXT";
        case(BlendOp::SrcOverEXT): return "SrcOverEXT";
        case(BlendOp::DstOverEXT): return "DstOverEXT";
        case(BlendOp::SrcInEXT): return "SrcInEXT";
        case(BlendOp::DstInEXT): return "DstInEXT";
        case(BlendOp::SrcOutEXT): return "SrcOutEXT";
        case(BlendOp::DstOutEXT): return "DstOutEXT";
        case(BlendOp::SrcAtopEXT): return "SrcAtopEXT";
        case(BlendOp::DstAtopEXT): return "DstAtopEXT";
        case(BlendOp::XorEXT): return "XorEXT";
        case(BlendOp::MultiplyEXT): return "MultiplyEXT";
        case(BlendOp::ScreenEXT): return "ScreenEXT";
        case(BlendOp::OverlayEXT): return "OverlayEXT";
        case(BlendOp::DarkenEXT): return "DarkenEXT";
        case(BlendOp::LightenEXT): return "LightenEXT";
        case(BlendOp::ColordodgeEXT): return "ColordodgeEXT";
        case(BlendOp::ColorburnEXT): return "ColorburnEXT";
        case(BlendOp::HardlightEXT): return "HardlightEXT";
        case(BlendOp::SoftlightEXT): return "SoftlightEXT";
        case(BlendOp::DifferenceEXT): return "DifferenceEXT";
        case(BlendOp::ExclusionEXT): return "ExclusionEXT";
        case(BlendOp::InvertEXT): return "InvertEXT";
        case(BlendOp::InvertRgbEXT): return "InvertRgbEXT";
        case(BlendOp::LineardodgeEXT): return "LineardodgeEXT";
        case(BlendOp::LinearburnEXT): return "LinearburnEXT";
        case(BlendOp::VividlightEXT): return "VividlightEXT";
        case(BlendOp::LinearlightEXT): return "LinearlightEXT";
        case(BlendOp::PinlightEXT): return "PinlightEXT";
        case(BlendOp::HardmixEXT): return "HardmixEXT";
        case(BlendOp::HslHueEXT): return "HslHueEXT";
        case(BlendOp::HslSaturationEXT): return "HslSaturationEXT";
        case(BlendOp::HslColorEXT): return "HslColorEXT";
        case(BlendOp::HslLuminosityEXT): return "HslLuminosityEXT";
        case(BlendOp::PlusEXT): return "PlusEXT";
        case(BlendOp::PlusClampedEXT): return "PlusClampedEXT";
        case(BlendOp::PlusClampedAlphaEXT): return "PlusClampedAlphaEXT";
        case(BlendOp::PlusDarkerEXT): return "PlusDarkerEXT";
        case(BlendOp::MinusEXT): return "MinusEXT";
        case(BlendOp::MinusClampedEXT): return "MinusClampedEXT";
        case(BlendOp::ContrastEXT): return "ContrastEXT";
        case(BlendOp::InvertOvgEXT): return "InvertOvgEXT";
        case(BlendOp::RedEXT): return "RedEXT";
        case(BlendOp::GreenEXT): return "GreenEXT";
        case(BlendOp::BlueEXT): return "BlueEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(BorderColor val) {
    switch(val) {
        case(BorderColor::FloatTransparentBlack): return "FloatTransparentBlack";
        case(BorderColor::IntTransparentBlack): return "IntTransparentBlack";
        case(BorderColor::FloatOpaqueBlack): return "FloatOpaqueBlack";
        case(BorderColor::IntOpaqueBlack): return "IntOpaqueBlack";
        case(BorderColor::FloatOpaqueWhite): return "FloatOpaqueWhite";
        case(BorderColor::IntOpaqueWhite): return "IntOpaqueWhite";
        case(BorderColor::FloatCustomEXT): return "FloatCustomEXT";
        case(BorderColor::IntCustomEXT): return "IntCustomEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PipelineCacheHeaderVersion val) {
    switch(val) {
        case(PipelineCacheHeaderVersion::One): return "One";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ComponentSwizzle val) {
    switch(val) {
        case(ComponentSwizzle::Identity): return "Identity";
        case(ComponentSwizzle::Zero): return "Zero";
        case(ComponentSwizzle::One): return "One";
        case(ComponentSwizzle::R): return "R";
        case(ComponentSwizzle::G): return "G";
        case(ComponentSwizzle::B): return "B";
        case(ComponentSwizzle::A): return "A";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(CommandBufferLevel val) {
    switch(val) {
        case(CommandBufferLevel::Primary): return "Primary";
        case(CommandBufferLevel::Secondary): return "Secondary";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(CompareOp val) {
    switch(val) {
        case(CompareOp::Never): return "Never";
        case(CompareOp::Less): return "Less";
        case(CompareOp::Equal): return "Equal";
        case(CompareOp::LessOrEqual): return "LessOrEqual";
        case(CompareOp::Greater): return "Greater";
        case(CompareOp::NotEqual): return "NotEqual";
        case(CompareOp::GreaterOrEqual): return "GreaterOrEqual";
        case(CompareOp::Always): return "Always";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DescriptorType val) {
    switch(val) {
        case(DescriptorType::Sampler): return "Sampler";
        case(DescriptorType::CombinedImageSampler): return "CombinedImageSampler";
        case(DescriptorType::SampledImage): return "SampledImage";
        case(DescriptorType::StorageImage): return "StorageImage";
        case(DescriptorType::UniformTexelBuffer): return "UniformTexelBuffer";
        case(DescriptorType::StorageTexelBuffer): return "StorageTexelBuffer";
        case(DescriptorType::UniformBuffer): return "UniformBuffer";
        case(DescriptorType::StorageBuffer): return "StorageBuffer";
        case(DescriptorType::UniformBufferDynamic): return "UniformBufferDynamic";
        case(DescriptorType::StorageBufferDynamic): return "StorageBufferDynamic";
        case(DescriptorType::InputAttachment): return "InputAttachment";
        case(DescriptorType::InlineUniformBlockEXT): return "InlineUniformBlockEXT";
        case(DescriptorType::AccelerationStructureKHR): return "AccelerationStructureKHR";
        case(DescriptorType::AccelerationStructureNV): return "AccelerationStructureNV";
        case(DescriptorType::MutableVALVE): return "MutableVALVE";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DynamicState val) {
    switch(val) {
        case(DynamicState::Viewport): return "Viewport";
        case(DynamicState::Scissor): return "Scissor";
        case(DynamicState::LineWidth): return "LineWidth";
        case(DynamicState::DepthBias): return "DepthBias";
        case(DynamicState::BlendConstants): return "BlendConstants";
        case(DynamicState::DepthBounds): return "DepthBounds";
        case(DynamicState::StencilCompareMask): return "StencilCompareMask";
        case(DynamicState::StencilWriteMask): return "StencilWriteMask";
        case(DynamicState::StencilReference): return "StencilReference";
        case(DynamicState::ViewportWScalingNV): return "ViewportWScalingNV";
        case(DynamicState::DiscardRectangleEXT): return "DiscardRectangleEXT";
        case(DynamicState::SampleLocationsEXT): return "SampleLocationsEXT";
        case(DynamicState::RayTracingPipelineStackSizeKHR): return "RayTracingPipelineStackSizeKHR";
        case(DynamicState::ViewportShadingRatePaletteNV): return "ViewportShadingRatePaletteNV";
        case(DynamicState::ViewportCoarseSampleOrderNV): return "ViewportCoarseSampleOrderNV";
        case(DynamicState::ExclusiveScissorNV): return "ExclusiveScissorNV";
        case(DynamicState::FragmentShadingRateKHR): return "FragmentShadingRateKHR";
        case(DynamicState::LineStippleEXT): return "LineStippleEXT";
        case(DynamicState::CullModeEXT): return "CullModeEXT";
        case(DynamicState::FrontFaceEXT): return "FrontFaceEXT";
        case(DynamicState::PrimitiveTopologyEXT): return "PrimitiveTopologyEXT";
        case(DynamicState::ViewportWithCountEXT): return "ViewportWithCountEXT";
        case(DynamicState::ScissorWithCountEXT): return "ScissorWithCountEXT";
        case(DynamicState::VertexInputBindingStrideEXT): return "VertexInputBindingStrideEXT";
        case(DynamicState::DepthTestEnableEXT): return "DepthTestEnableEXT";
        case(DynamicState::DepthWriteEnableEXT): return "DepthWriteEnableEXT";
        case(DynamicState::DepthCompareOpEXT): return "DepthCompareOpEXT";
        case(DynamicState::DepthBoundsTestEnableEXT): return "DepthBoundsTestEnableEXT";
        case(DynamicState::StencilTestEnableEXT): return "StencilTestEnableEXT";
        case(DynamicState::StencilOpEXT): return "StencilOpEXT";
        case(DynamicState::VertexInputEXT): return "VertexInputEXT";
        case(DynamicState::PatchControlPointsEXT): return "PatchControlPointsEXT";
        case(DynamicState::RasterizerDiscardEnableEXT): return "RasterizerDiscardEnableEXT";
        case(DynamicState::DepthBiasEnableEXT): return "DepthBiasEnableEXT";
        case(DynamicState::LogicOpEXT): return "LogicOpEXT";
        case(DynamicState::PrimitiveRestartEnableEXT): return "PrimitiveRestartEnableEXT";
        case(DynamicState::ColorWriteEnableEXT): return "ColorWriteEnableEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PolygonMode val) {
    switch(val) {
        case(PolygonMode::Fill): return "Fill";
        case(PolygonMode::Line): return "Line";
        case(PolygonMode::Point): return "Point";
        case(PolygonMode::FillRectangleNV): return "FillRectangleNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(Format val) {
    switch(val) {
        case(Format::Undefined): return "Undefined";
        case(Format::R4G4UnormPack8): return "R4G4UnormPack8";
        case(Format::R4G4B4A4UnormPack16): return "R4G4B4A4UnormPack16";
        case(Format::B4G4R4A4UnormPack16): return "B4G4R4A4UnormPack16";
        case(Format::R5G6B5UnormPack16): return "R5G6B5UnormPack16";
        case(Format::B5G6R5UnormPack16): return "B5G6R5UnormPack16";
        case(Format::R5G5B5A1UnormPack16): return "R5G5B5A1UnormPack16";
        case(Format::B5G5R5A1UnormPack16): return "B5G5R5A1UnormPack16";
        case(Format::A1R5G5B5UnormPack16): return "A1R5G5B5UnormPack16";
        case(Format::R8Unorm): return "R8Unorm";
        case(Format::R8Snorm): return "R8Snorm";
        case(Format::R8Uscaled): return "R8Uscaled";
        case(Format::R8Sscaled): return "R8Sscaled";
        case(Format::R8Uint): return "R8Uint";
        case(Format::R8Sint): return "R8Sint";
        case(Format::R8Srgb): return "R8Srgb";
        case(Format::R8G8Unorm): return "R8G8Unorm";
        case(Format::R8G8Snorm): return "R8G8Snorm";
        case(Format::R8G8Uscaled): return "R8G8Uscaled";
        case(Format::R8G8Sscaled): return "R8G8Sscaled";
        case(Format::R8G8Uint): return "R8G8Uint";
        case(Format::R8G8Sint): return "R8G8Sint";
        case(Format::R8G8Srgb): return "R8G8Srgb";
        case(Format::R8G8B8Unorm): return "R8G8B8Unorm";
        case(Format::R8G8B8Snorm): return "R8G8B8Snorm";
        case(Format::R8G8B8Uscaled): return "R8G8B8Uscaled";
        case(Format::R8G8B8Sscaled): return "R8G8B8Sscaled";
        case(Format::R8G8B8Uint): return "R8G8B8Uint";
        case(Format::R8G8B8Sint): return "R8G8B8Sint";
        case(Format::R8G8B8Srgb): return "R8G8B8Srgb";
        case(Format::B8G8R8Unorm): return "B8G8R8Unorm";
        case(Format::B8G8R8Snorm): return "B8G8R8Snorm";
        case(Format::B8G8R8Uscaled): return "B8G8R8Uscaled";
        case(Format::B8G8R8Sscaled): return "B8G8R8Sscaled";
        case(Format::B8G8R8Uint): return "B8G8R8Uint";
        case(Format::B8G8R8Sint): return "B8G8R8Sint";
        case(Format::B8G8R8Srgb): return "B8G8R8Srgb";
        case(Format::R8G8B8A8Unorm): return "R8G8B8A8Unorm";
        case(Format::R8G8B8A8Snorm): return "R8G8B8A8Snorm";
        case(Format::R8G8B8A8Uscaled): return "R8G8B8A8Uscaled";
        case(Format::R8G8B8A8Sscaled): return "R8G8B8A8Sscaled";
        case(Format::R8G8B8A8Uint): return "R8G8B8A8Uint";
        case(Format::R8G8B8A8Sint): return "R8G8B8A8Sint";
        case(Format::R8G8B8A8Srgb): return "R8G8B8A8Srgb";
        case(Format::B8G8R8A8Unorm): return "B8G8R8A8Unorm";
        case(Format::B8G8R8A8Snorm): return "B8G8R8A8Snorm";
        case(Format::B8G8R8A8Uscaled): return "B8G8R8A8Uscaled";
        case(Format::B8G8R8A8Sscaled): return "B8G8R8A8Sscaled";
        case(Format::B8G8R8A8Uint): return "B8G8R8A8Uint";
        case(Format::B8G8R8A8Sint): return "B8G8R8A8Sint";
        case(Format::B8G8R8A8Srgb): return "B8G8R8A8Srgb";
        case(Format::A8B8G8R8UnormPack32): return "A8B8G8R8UnormPack32";
        case(Format::A8B8G8R8SnormPack32): return "A8B8G8R8SnormPack32";
        case(Format::A8B8G8R8UscaledPack32): return "A8B8G8R8UscaledPack32";
        case(Format::A8B8G8R8SscaledPack32): return "A8B8G8R8SscaledPack32";
        case(Format::A8B8G8R8UintPack32): return "A8B8G8R8UintPack32";
        case(Format::A8B8G8R8SintPack32): return "A8B8G8R8SintPack32";
        case(Format::A8B8G8R8SrgbPack32): return "A8B8G8R8SrgbPack32";
        case(Format::A2R10G10B10UnormPack32): return "A2R10G10B10UnormPack32";
        case(Format::A2R10G10B10SnormPack32): return "A2R10G10B10SnormPack32";
        case(Format::A2R10G10B10UscaledPack32): return "A2R10G10B10UscaledPack32";
        case(Format::A2R10G10B10SscaledPack32): return "A2R10G10B10SscaledPack32";
        case(Format::A2R10G10B10UintPack32): return "A2R10G10B10UintPack32";
        case(Format::A2R10G10B10SintPack32): return "A2R10G10B10SintPack32";
        case(Format::A2B10G10R10UnormPack32): return "A2B10G10R10UnormPack32";
        case(Format::A2B10G10R10SnormPack32): return "A2B10G10R10SnormPack32";
        case(Format::A2B10G10R10UscaledPack32): return "A2B10G10R10UscaledPack32";
        case(Format::A2B10G10R10SscaledPack32): return "A2B10G10R10SscaledPack32";
        case(Format::A2B10G10R10UintPack32): return "A2B10G10R10UintPack32";
        case(Format::A2B10G10R10SintPack32): return "A2B10G10R10SintPack32";
        case(Format::R16Unorm): return "R16Unorm";
        case(Format::R16Snorm): return "R16Snorm";
        case(Format::R16Uscaled): return "R16Uscaled";
        case(Format::R16Sscaled): return "R16Sscaled";
        case(Format::R16Uint): return "R16Uint";
        case(Format::R16Sint): return "R16Sint";
        case(Format::R16Sfloat): return "R16Sfloat";
        case(Format::R16G16Unorm): return "R16G16Unorm";
        case(Format::R16G16Snorm): return "R16G16Snorm";
        case(Format::R16G16Uscaled): return "R16G16Uscaled";
        case(Format::R16G16Sscaled): return "R16G16Sscaled";
        case(Format::R16G16Uint): return "R16G16Uint";
        case(Format::R16G16Sint): return "R16G16Sint";
        case(Format::R16G16Sfloat): return "R16G16Sfloat";
        case(Format::R16G16B16Unorm): return "R16G16B16Unorm";
        case(Format::R16G16B16Snorm): return "R16G16B16Snorm";
        case(Format::R16G16B16Uscaled): return "R16G16B16Uscaled";
        case(Format::R16G16B16Sscaled): return "R16G16B16Sscaled";
        case(Format::R16G16B16Uint): return "R16G16B16Uint";
        case(Format::R16G16B16Sint): return "R16G16B16Sint";
        case(Format::R16G16B16Sfloat): return "R16G16B16Sfloat";
        case(Format::R16G16B16A16Unorm): return "R16G16B16A16Unorm";
        case(Format::R16G16B16A16Snorm): return "R16G16B16A16Snorm";
        case(Format::R16G16B16A16Uscaled): return "R16G16B16A16Uscaled";
        case(Format::R16G16B16A16Sscaled): return "R16G16B16A16Sscaled";
        case(Format::R16G16B16A16Uint): return "R16G16B16A16Uint";
        case(Format::R16G16B16A16Sint): return "R16G16B16A16Sint";
        case(Format::R16G16B16A16Sfloat): return "R16G16B16A16Sfloat";
        case(Format::R32Uint): return "R32Uint";
        case(Format::R32Sint): return "R32Sint";
        case(Format::R32Sfloat): return "R32Sfloat";
        case(Format::R32G32Uint): return "R32G32Uint";
        case(Format::R32G32Sint): return "R32G32Sint";
        case(Format::R32G32Sfloat): return "R32G32Sfloat";
        case(Format::R32G32B32Uint): return "R32G32B32Uint";
        case(Format::R32G32B32Sint): return "R32G32B32Sint";
        case(Format::R32G32B32Sfloat): return "R32G32B32Sfloat";
        case(Format::R32G32B32A32Uint): return "R32G32B32A32Uint";
        case(Format::R32G32B32A32Sint): return "R32G32B32A32Sint";
        case(Format::R32G32B32A32Sfloat): return "R32G32B32A32Sfloat";
        case(Format::R64Uint): return "R64Uint";
        case(Format::R64Sint): return "R64Sint";
        case(Format::R64Sfloat): return "R64Sfloat";
        case(Format::R64G64Uint): return "R64G64Uint";
        case(Format::R64G64Sint): return "R64G64Sint";
        case(Format::R64G64Sfloat): return "R64G64Sfloat";
        case(Format::R64G64B64Uint): return "R64G64B64Uint";
        case(Format::R64G64B64Sint): return "R64G64B64Sint";
        case(Format::R64G64B64Sfloat): return "R64G64B64Sfloat";
        case(Format::R64G64B64A64Uint): return "R64G64B64A64Uint";
        case(Format::R64G64B64A64Sint): return "R64G64B64A64Sint";
        case(Format::R64G64B64A64Sfloat): return "R64G64B64A64Sfloat";
        case(Format::B10G11R11UfloatPack32): return "B10G11R11UfloatPack32";
        case(Format::E5B9G9R9UfloatPack32): return "E5B9G9R9UfloatPack32";
        case(Format::D16Unorm): return "D16Unorm";
        case(Format::X8D24UnormPack32): return "X8D24UnormPack32";
        case(Format::D32Sfloat): return "D32Sfloat";
        case(Format::S8Uint): return "S8Uint";
        case(Format::D16UnormS8Uint): return "D16UnormS8Uint";
        case(Format::D24UnormS8Uint): return "D24UnormS8Uint";
        case(Format::D32SfloatS8Uint): return "D32SfloatS8Uint";
        case(Format::Bc1RgbUnormBlock): return "Bc1RgbUnormBlock";
        case(Format::Bc1RgbSrgbBlock): return "Bc1RgbSrgbBlock";
        case(Format::Bc1RgbaUnormBlock): return "Bc1RgbaUnormBlock";
        case(Format::Bc1RgbaSrgbBlock): return "Bc1RgbaSrgbBlock";
        case(Format::Bc2UnormBlock): return "Bc2UnormBlock";
        case(Format::Bc2SrgbBlock): return "Bc2SrgbBlock";
        case(Format::Bc3UnormBlock): return "Bc3UnormBlock";
        case(Format::Bc3SrgbBlock): return "Bc3SrgbBlock";
        case(Format::Bc4UnormBlock): return "Bc4UnormBlock";
        case(Format::Bc4SnormBlock): return "Bc4SnormBlock";
        case(Format::Bc5UnormBlock): return "Bc5UnormBlock";
        case(Format::Bc5SnormBlock): return "Bc5SnormBlock";
        case(Format::Bc6HUfloatBlock): return "Bc6HUfloatBlock";
        case(Format::Bc6HSfloatBlock): return "Bc6HSfloatBlock";
        case(Format::Bc7UnormBlock): return "Bc7UnormBlock";
        case(Format::Bc7SrgbBlock): return "Bc7SrgbBlock";
        case(Format::Etc2R8G8B8UnormBlock): return "Etc2R8G8B8UnormBlock";
        case(Format::Etc2R8G8B8SrgbBlock): return "Etc2R8G8B8SrgbBlock";
        case(Format::Etc2R8G8B8A1UnormBlock): return "Etc2R8G8B8A1UnormBlock";
        case(Format::Etc2R8G8B8A1SrgbBlock): return "Etc2R8G8B8A1SrgbBlock";
        case(Format::Etc2R8G8B8A8UnormBlock): return "Etc2R8G8B8A8UnormBlock";
        case(Format::Etc2R8G8B8A8SrgbBlock): return "Etc2R8G8B8A8SrgbBlock";
        case(Format::EacR11UnormBlock): return "EacR11UnormBlock";
        case(Format::EacR11SnormBlock): return "EacR11SnormBlock";
        case(Format::EacR11G11UnormBlock): return "EacR11G11UnormBlock";
        case(Format::EacR11G11SnormBlock): return "EacR11G11SnormBlock";
        case(Format::Astc4X4UnormBlock): return "Astc4X4UnormBlock";
        case(Format::Astc4X4SrgbBlock): return "Astc4X4SrgbBlock";
        case(Format::Astc5X4UnormBlock): return "Astc5X4UnormBlock";
        case(Format::Astc5X4SrgbBlock): return "Astc5X4SrgbBlock";
        case(Format::Astc5X5UnormBlock): return "Astc5X5UnormBlock";
        case(Format::Astc5X5SrgbBlock): return "Astc5X5SrgbBlock";
        case(Format::Astc6X5UnormBlock): return "Astc6X5UnormBlock";
        case(Format::Astc6X5SrgbBlock): return "Astc6X5SrgbBlock";
        case(Format::Astc6X6UnormBlock): return "Astc6X6UnormBlock";
        case(Format::Astc6X6SrgbBlock): return "Astc6X6SrgbBlock";
        case(Format::Astc8X5UnormBlock): return "Astc8X5UnormBlock";
        case(Format::Astc8X5SrgbBlock): return "Astc8X5SrgbBlock";
        case(Format::Astc8X6UnormBlock): return "Astc8X6UnormBlock";
        case(Format::Astc8X6SrgbBlock): return "Astc8X6SrgbBlock";
        case(Format::Astc8X8UnormBlock): return "Astc8X8UnormBlock";
        case(Format::Astc8X8SrgbBlock): return "Astc8X8SrgbBlock";
        case(Format::Astc10X5UnormBlock): return "Astc10X5UnormBlock";
        case(Format::Astc10X5SrgbBlock): return "Astc10X5SrgbBlock";
        case(Format::Astc10X6UnormBlock): return "Astc10X6UnormBlock";
        case(Format::Astc10X6SrgbBlock): return "Astc10X6SrgbBlock";
        case(Format::Astc10X8UnormBlock): return "Astc10X8UnormBlock";
        case(Format::Astc10X8SrgbBlock): return "Astc10X8SrgbBlock";
        case(Format::Astc10X10UnormBlock): return "Astc10X10UnormBlock";
        case(Format::Astc10X10SrgbBlock): return "Astc10X10SrgbBlock";
        case(Format::Astc12X10UnormBlock): return "Astc12X10UnormBlock";
        case(Format::Astc12X10SrgbBlock): return "Astc12X10SrgbBlock";
        case(Format::Astc12X12UnormBlock): return "Astc12X12UnormBlock";
        case(Format::Astc12X12SrgbBlock): return "Astc12X12SrgbBlock";
        case(Format::Pvrtc12BppUnormBlockIMG): return "Pvrtc12BppUnormBlockIMG";
        case(Format::Pvrtc14BppUnormBlockIMG): return "Pvrtc14BppUnormBlockIMG";
        case(Format::Pvrtc22BppUnormBlockIMG): return "Pvrtc22BppUnormBlockIMG";
        case(Format::Pvrtc24BppUnormBlockIMG): return "Pvrtc24BppUnormBlockIMG";
        case(Format::Pvrtc12BppSrgbBlockIMG): return "Pvrtc12BppSrgbBlockIMG";
        case(Format::Pvrtc14BppSrgbBlockIMG): return "Pvrtc14BppSrgbBlockIMG";
        case(Format::Pvrtc22BppSrgbBlockIMG): return "Pvrtc22BppSrgbBlockIMG";
        case(Format::Pvrtc24BppSrgbBlockIMG): return "Pvrtc24BppSrgbBlockIMG";
        case(Format::Astc4X4SfloatBlockEXT): return "Astc4X4SfloatBlockEXT";
        case(Format::Astc5X4SfloatBlockEXT): return "Astc5X4SfloatBlockEXT";
        case(Format::Astc5X5SfloatBlockEXT): return "Astc5X5SfloatBlockEXT";
        case(Format::Astc6X5SfloatBlockEXT): return "Astc6X5SfloatBlockEXT";
        case(Format::Astc6X6SfloatBlockEXT): return "Astc6X6SfloatBlockEXT";
        case(Format::Astc8X5SfloatBlockEXT): return "Astc8X5SfloatBlockEXT";
        case(Format::Astc8X6SfloatBlockEXT): return "Astc8X6SfloatBlockEXT";
        case(Format::Astc8X8SfloatBlockEXT): return "Astc8X8SfloatBlockEXT";
        case(Format::Astc10X5SfloatBlockEXT): return "Astc10X5SfloatBlockEXT";
        case(Format::Astc10X6SfloatBlockEXT): return "Astc10X6SfloatBlockEXT";
        case(Format::Astc10X8SfloatBlockEXT): return "Astc10X8SfloatBlockEXT";
        case(Format::Astc10X10SfloatBlockEXT): return "Astc10X10SfloatBlockEXT";
        case(Format::Astc12X10SfloatBlockEXT): return "Astc12X10SfloatBlockEXT";
        case(Format::Astc12X12SfloatBlockEXT): return "Astc12X12SfloatBlockEXT";
        case(Format::G8B8R82Plane444UnormEXT): return "G8B8R82Plane444UnormEXT";
        case(Format::G10X6B10X6R10X62Plane444Unorm3Pack16EXT): return "G10X6B10X6R10X62Plane444Unorm3Pack16EXT";
        case(Format::G12X4B12X4R12X42Plane444Unorm3Pack16EXT): return "G12X4B12X4R12X42Plane444Unorm3Pack16EXT";
        case(Format::G16B16R162Plane444UnormEXT): return "G16B16R162Plane444UnormEXT";
        case(Format::A4R4G4B4UnormPack16EXT): return "A4R4G4B4UnormPack16EXT";
        case(Format::A4B4G4R4UnormPack16EXT): return "A4B4G4R4UnormPack16EXT";
        case(Format::G8B8G8R8422Unorm): return "G8B8G8R8422Unorm";
        case(Format::B8G8R8G8422Unorm): return "B8G8R8G8422Unorm";
        case(Format::G8B8R83Plane420Unorm): return "G8B8R83Plane420Unorm";
        case(Format::G8B8R82Plane420Unorm): return "G8B8R82Plane420Unorm";
        case(Format::G8B8R83Plane422Unorm): return "G8B8R83Plane422Unorm";
        case(Format::G8B8R82Plane422Unorm): return "G8B8R82Plane422Unorm";
        case(Format::G8B8R83Plane444Unorm): return "G8B8R83Plane444Unorm";
        case(Format::R10X6UnormPack16): return "R10X6UnormPack16";
        case(Format::R10X6G10X6Unorm2Pack16): return "R10X6G10X6Unorm2Pack16";
        case(Format::R10X6G10X6B10X6A10X6Unorm4Pack16): return "R10X6G10X6B10X6A10X6Unorm4Pack16";
        case(Format::G10X6B10X6G10X6R10X6422Unorm4Pack16): return "G10X6B10X6G10X6R10X6422Unorm4Pack16";
        case(Format::B10X6G10X6R10X6G10X6422Unorm4Pack16): return "B10X6G10X6R10X6G10X6422Unorm4Pack16";
        case(Format::G10X6B10X6R10X63Plane420Unorm3Pack16): return "G10X6B10X6R10X63Plane420Unorm3Pack16";
        case(Format::G10X6B10X6R10X62Plane420Unorm3Pack16): return "G10X6B10X6R10X62Plane420Unorm3Pack16";
        case(Format::G10X6B10X6R10X63Plane422Unorm3Pack16): return "G10X6B10X6R10X63Plane422Unorm3Pack16";
        case(Format::G10X6B10X6R10X62Plane422Unorm3Pack16): return "G10X6B10X6R10X62Plane422Unorm3Pack16";
        case(Format::G10X6B10X6R10X63Plane444Unorm3Pack16): return "G10X6B10X6R10X63Plane444Unorm3Pack16";
        case(Format::R12X4UnormPack16): return "R12X4UnormPack16";
        case(Format::R12X4G12X4Unorm2Pack16): return "R12X4G12X4Unorm2Pack16";
        case(Format::R12X4G12X4B12X4A12X4Unorm4Pack16): return "R12X4G12X4B12X4A12X4Unorm4Pack16";
        case(Format::G12X4B12X4G12X4R12X4422Unorm4Pack16): return "G12X4B12X4G12X4R12X4422Unorm4Pack16";
        case(Format::B12X4G12X4R12X4G12X4422Unorm4Pack16): return "B12X4G12X4R12X4G12X4422Unorm4Pack16";
        case(Format::G12X4B12X4R12X43Plane420Unorm3Pack16): return "G12X4B12X4R12X43Plane420Unorm3Pack16";
        case(Format::G12X4B12X4R12X42Plane420Unorm3Pack16): return "G12X4B12X4R12X42Plane420Unorm3Pack16";
        case(Format::G12X4B12X4R12X43Plane422Unorm3Pack16): return "G12X4B12X4R12X43Plane422Unorm3Pack16";
        case(Format::G12X4B12X4R12X42Plane422Unorm3Pack16): return "G12X4B12X4R12X42Plane422Unorm3Pack16";
        case(Format::G12X4B12X4R12X43Plane444Unorm3Pack16): return "G12X4B12X4R12X43Plane444Unorm3Pack16";
        case(Format::G16B16G16R16422Unorm): return "G16B16G16R16422Unorm";
        case(Format::B16G16R16G16422Unorm): return "B16G16R16G16422Unorm";
        case(Format::G16B16R163Plane420Unorm): return "G16B16R163Plane420Unorm";
        case(Format::G16B16R162Plane420Unorm): return "G16B16R162Plane420Unorm";
        case(Format::G16B16R163Plane422Unorm): return "G16B16R163Plane422Unorm";
        case(Format::G16B16R162Plane422Unorm): return "G16B16R162Plane422Unorm";
        case(Format::G16B16R163Plane444Unorm): return "G16B16R163Plane444Unorm";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(FrontFace val) {
    switch(val) {
        case(FrontFace::CounterClockwise): return "CounterClockwise";
        case(FrontFace::Clockwise): return "Clockwise";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ImageLayout val) {
    switch(val) {
        case(ImageLayout::Undefined): return "Undefined";
        case(ImageLayout::General): return "General";
        case(ImageLayout::ColorAttachmentOptimal): return "ColorAttachmentOptimal";
        case(ImageLayout::DepthStencilAttachmentOptimal): return "DepthStencilAttachmentOptimal";
        case(ImageLayout::DepthStencilReadOnlyOptimal): return "DepthStencilReadOnlyOptimal";
        case(ImageLayout::ShaderReadOnlyOptimal): return "ShaderReadOnlyOptimal";
        case(ImageLayout::TransferSrcOptimal): return "TransferSrcOptimal";
        case(ImageLayout::TransferDstOptimal): return "TransferDstOptimal";
        case(ImageLayout::Preinitialized): return "Preinitialized";
        case(ImageLayout::PresentSrcKHR): return "PresentSrcKHR";
        case(ImageLayout::VideoDecodeDstKHR): return "VideoDecodeDstKHR";
        case(ImageLayout::VideoDecodeSrcKHR): return "VideoDecodeSrcKHR";
        case(ImageLayout::VideoDecodeDpbKHR): return "VideoDecodeDpbKHR";
        case(ImageLayout::VideoEncodeDstKHR): return "VideoEncodeDstKHR";
        case(ImageLayout::VideoEncodeSrcKHR): return "VideoEncodeSrcKHR";
        case(ImageLayout::VideoEncodeDpbKHR): return "VideoEncodeDpbKHR";
        case(ImageLayout::SharedPresentKHR): return "SharedPresentKHR";
        case(ImageLayout::ShadingRateOptimalNV): return "ShadingRateOptimalNV";
        case(ImageLayout::FragmentDensityMapOptimalEXT): return "FragmentDensityMapOptimalEXT";
        case(ImageLayout::ReadOnlyOptimalKHR): return "ReadOnlyOptimalKHR";
        case(ImageLayout::AttachmentOptimalKHR): return "AttachmentOptimalKHR";
        case(ImageLayout::DepthReadOnlyStencilAttachmentOptimal): return "DepthReadOnlyStencilAttachmentOptimal";
        case(ImageLayout::DepthAttachmentStencilReadOnlyOptimal): return "DepthAttachmentStencilReadOnlyOptimal";
        case(ImageLayout::DepthAttachmentOptimal): return "DepthAttachmentOptimal";
        case(ImageLayout::DepthReadOnlyOptimal): return "DepthReadOnlyOptimal";
        case(ImageLayout::StencilAttachmentOptimal): return "StencilAttachmentOptimal";
        case(ImageLayout::StencilReadOnlyOptimal): return "StencilReadOnlyOptimal";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ImageTiling val) {
    switch(val) {
        case(ImageTiling::Optimal): return "Optimal";
        case(ImageTiling::Linear): return "Linear";
        case(ImageTiling::DrmFormatModifierEXT): return "DrmFormatModifierEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ImageType val) {
    switch(val) {
        case(ImageType::e1D): return "e1D";
        case(ImageType::e2D): return "e2D";
        case(ImageType::e3D): return "e3D";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ImageViewType val) {
    switch(val) {
        case(ImageViewType::e1D): return "e1D";
        case(ImageViewType::e2D): return "e2D";
        case(ImageViewType::e3D): return "e3D";
        case(ImageViewType::Cube): return "Cube";
        case(ImageViewType::e1DArray): return "e1DArray";
        case(ImageViewType::e2DArray): return "e2DArray";
        case(ImageViewType::CubeArray): return "CubeArray";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SharingMode val) {
    switch(val) {
        case(SharingMode::Exclusive): return "Exclusive";
        case(SharingMode::Concurrent): return "Concurrent";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(IndexType val) {
    switch(val) {
        case(IndexType::Uint16): return "Uint16";
        case(IndexType::Uint32): return "Uint32";
        case(IndexType::NoneKHR): return "NoneKHR";
        case(IndexType::Uint8EXT): return "Uint8EXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(LogicOp val) {
    switch(val) {
        case(LogicOp::Clear): return "Clear";
        case(LogicOp::And): return "And";
        case(LogicOp::AndReverse): return "AndReverse";
        case(LogicOp::Copy): return "Copy";
        case(LogicOp::AndInverted): return "AndInverted";
        case(LogicOp::NoOp): return "NoOp";
        case(LogicOp::Xor): return "Xor";
        case(LogicOp::Or): return "Or";
        case(LogicOp::Nor): return "Nor";
        case(LogicOp::Equivalent): return "Equivalent";
        case(LogicOp::Invert): return "Invert";
        case(LogicOp::OrReverse): return "OrReverse";
        case(LogicOp::CopyInverted): return "CopyInverted";
        case(LogicOp::OrInverted): return "OrInverted";
        case(LogicOp::Nand): return "Nand";
        case(LogicOp::Set): return "Set";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PhysicalDeviceType val) {
    switch(val) {
        case(PhysicalDeviceType::Other): return "Other";
        case(PhysicalDeviceType::IntegratedGpu): return "IntegratedGpu";
        case(PhysicalDeviceType::DiscreteGpu): return "DiscreteGpu";
        case(PhysicalDeviceType::VirtualGpu): return "VirtualGpu";
        case(PhysicalDeviceType::Cpu): return "Cpu";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PipelineBindPoint val) {
    switch(val) {
        case(PipelineBindPoint::Graphics): return "Graphics";
        case(PipelineBindPoint::Compute): return "Compute";
        case(PipelineBindPoint::RayTracingKHR): return "RayTracingKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PrimitiveTopology val) {
    switch(val) {
        case(PrimitiveTopology::PointList): return "PointList";
        case(PrimitiveTopology::LineList): return "LineList";
        case(PrimitiveTopology::LineStrip): return "LineStrip";
        case(PrimitiveTopology::TriangleList): return "TriangleList";
        case(PrimitiveTopology::TriangleStrip): return "TriangleStrip";
        case(PrimitiveTopology::TriangleFan): return "TriangleFan";
        case(PrimitiveTopology::LineListWithAdjacency): return "LineListWithAdjacency";
        case(PrimitiveTopology::LineStripWithAdjacency): return "LineStripWithAdjacency";
        case(PrimitiveTopology::TriangleListWithAdjacency): return "TriangleListWithAdjacency";
        case(PrimitiveTopology::TriangleStripWithAdjacency): return "TriangleStripWithAdjacency";
        case(PrimitiveTopology::PatchList): return "PatchList";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(QueryType val) {
    switch(val) {
        case(QueryType::Occlusion): return "Occlusion";
        case(QueryType::PipelineStatistics): return "PipelineStatistics";
        case(QueryType::Timestamp): return "Timestamp";
        case(QueryType::ResultStatusOnlyKHR): return "ResultStatusOnlyKHR";
        case(QueryType::VideoEncodeBitstreamBufferRangeKHR): return "VideoEncodeBitstreamBufferRangeKHR";
        case(QueryType::TransformFeedbackStreamEXT): return "TransformFeedbackStreamEXT";
        case(QueryType::PerformanceQueryKHR): return "PerformanceQueryKHR";
        case(QueryType::AccelerationStructureCompactedSizeKHR): return "AccelerationStructureCompactedSizeKHR";
        case(QueryType::AccelerationStructureSerializationSizeKHR): return "AccelerationStructureSerializationSizeKHR";
        case(QueryType::AccelerationStructureCompactedSizeNV): return "AccelerationStructureCompactedSizeNV";
        case(QueryType::PerformanceQueryINTEL): return "PerformanceQueryINTEL";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SubpassContents val) {
    switch(val) {
        case(SubpassContents::Inline): return "Inline";
        case(SubpassContents::SecondaryCommandBuffers): return "SecondaryCommandBuffers";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(Result val) {
    switch(val) {
        case(Result::Success): return "Success";
        case(Result::NotReady): return "NotReady";
        case(Result::Timeout): return "Timeout";
        case(Result::EventSet): return "EventSet";
        case(Result::EventReset): return "EventReset";
        case(Result::Incomplete): return "Incomplete";
        case(Result::ErrorOutOfHostMemory): return "ErrorOutOfHostMemory";
        case(Result::ErrorOutOfDeviceMemory): return "ErrorOutOfDeviceMemory";
        case(Result::ErrorInitializationFailed): return "ErrorInitializationFailed";
        case(Result::ErrorDeviceLost): return "ErrorDeviceLost";
        case(Result::ErrorMemoryMapFailed): return "ErrorMemoryMapFailed";
        case(Result::ErrorLayerNotPresent): return "ErrorLayerNotPresent";
        case(Result::ErrorExtensionNotPresent): return "ErrorExtensionNotPresent";
        case(Result::ErrorFeatureNotPresent): return "ErrorFeatureNotPresent";
        case(Result::ErrorIncompatibleDriver): return "ErrorIncompatibleDriver";
        case(Result::ErrorTooManyObjects): return "ErrorTooManyObjects";
        case(Result::ErrorFormatNotSupported): return "ErrorFormatNotSupported";
        case(Result::ErrorFragmentedPool): return "ErrorFragmentedPool";
        case(Result::ErrorUnknown): return "ErrorUnknown";
        case(Result::ErrorSurfaceLostKHR): return "ErrorSurfaceLostKHR";
        case(Result::ErrorNativeWindowInUseKHR): return "ErrorNativeWindowInUseKHR";
        case(Result::SuboptimalKHR): return "SuboptimalKHR";
        case(Result::ErrorOutOfDateKHR): return "ErrorOutOfDateKHR";
        case(Result::ErrorIncompatibleDisplayKHR): return "ErrorIncompatibleDisplayKHR";
        case(Result::ErrorValidationFailedEXT): return "ErrorValidationFailedEXT";
        case(Result::ErrorInvalidShaderNV): return "ErrorInvalidShaderNV";
        case(Result::ErrorInvalidDrmFormatModifierPlaneLayoutEXT): return "ErrorInvalidDrmFormatModifierPlaneLayoutEXT";
        case(Result::ErrorNotPermittedEXT): return "ErrorNotPermittedEXT";
        case(Result::ErrorFullScreenExclusiveModeLostEXT): return "ErrorFullScreenExclusiveModeLostEXT";
        case(Result::ThreadIdleKHR): return "ThreadIdleKHR";
        case(Result::ThreadDoneKHR): return "ThreadDoneKHR";
        case(Result::OperationDeferredKHR): return "OperationDeferredKHR";
        case(Result::OperationNotDeferredKHR): return "OperationNotDeferredKHR";
        case(Result::PipelineCompileRequiredEXT): return "PipelineCompileRequiredEXT";
        case(Result::ErrorOutOfPoolMemory): return "ErrorOutOfPoolMemory";
        case(Result::ErrorInvalidExternalHandle): return "ErrorInvalidExternalHandle";
        case(Result::ErrorFragmentation): return "ErrorFragmentation";
        case(Result::ErrorInvalidOpaqueCaptureAddress): return "ErrorInvalidOpaqueCaptureAddress";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(StencilOp val) {
    switch(val) {
        case(StencilOp::Keep): return "Keep";
        case(StencilOp::Zero): return "Zero";
        case(StencilOp::Replace): return "Replace";
        case(StencilOp::IncrementAndClamp): return "IncrementAndClamp";
        case(StencilOp::DecrementAndClamp): return "DecrementAndClamp";
        case(StencilOp::Invert): return "Invert";
        case(StencilOp::IncrementAndWrap): return "IncrementAndWrap";
        case(StencilOp::DecrementAndWrap): return "DecrementAndWrap";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(StructureType val) {
    switch(val) {
        case(StructureType::ApplicationInfo): return "ApplicationInfo";
        case(StructureType::InstanceCreateInfo): return "InstanceCreateInfo";
        case(StructureType::DeviceQueueCreateInfo): return "DeviceQueueCreateInfo";
        case(StructureType::DeviceCreateInfo): return "DeviceCreateInfo";
        case(StructureType::SubmitInfo): return "SubmitInfo";
        case(StructureType::MemoryAllocateInfo): return "MemoryAllocateInfo";
        case(StructureType::MappedMemoryRange): return "MappedMemoryRange";
        case(StructureType::BindSparseInfo): return "BindSparseInfo";
        case(StructureType::FenceCreateInfo): return "FenceCreateInfo";
        case(StructureType::SemaphoreCreateInfo): return "SemaphoreCreateInfo";
        case(StructureType::EventCreateInfo): return "EventCreateInfo";
        case(StructureType::QueryPoolCreateInfo): return "QueryPoolCreateInfo";
        case(StructureType::BufferCreateInfo): return "BufferCreateInfo";
        case(StructureType::BufferViewCreateInfo): return "BufferViewCreateInfo";
        case(StructureType::ImageCreateInfo): return "ImageCreateInfo";
        case(StructureType::ImageViewCreateInfo): return "ImageViewCreateInfo";
        case(StructureType::ShaderModuleCreateInfo): return "ShaderModuleCreateInfo";
        case(StructureType::PipelineCacheCreateInfo): return "PipelineCacheCreateInfo";
        case(StructureType::PipelineShaderStageCreateInfo): return "PipelineShaderStageCreateInfo";
        case(StructureType::PipelineVertexInputStateCreateInfo): return "PipelineVertexInputStateCreateInfo";
        case(StructureType::PipelineInputAssemblyStateCreateInfo): return "PipelineInputAssemblyStateCreateInfo";
        case(StructureType::PipelineTessellationStateCreateInfo): return "PipelineTessellationStateCreateInfo";
        case(StructureType::PipelineViewportStateCreateInfo): return "PipelineViewportStateCreateInfo";
        case(StructureType::PipelineRasterizationStateCreateInfo): return "PipelineRasterizationStateCreateInfo";
        case(StructureType::PipelineMultisampleStateCreateInfo): return "PipelineMultisampleStateCreateInfo";
        case(StructureType::PipelineDepthStencilStateCreateInfo): return "PipelineDepthStencilStateCreateInfo";
        case(StructureType::PipelineColorBlendStateCreateInfo): return "PipelineColorBlendStateCreateInfo";
        case(StructureType::PipelineDynamicStateCreateInfo): return "PipelineDynamicStateCreateInfo";
        case(StructureType::GraphicsPipelineCreateInfo): return "GraphicsPipelineCreateInfo";
        case(StructureType::ComputePipelineCreateInfo): return "ComputePipelineCreateInfo";
        case(StructureType::PipelineLayoutCreateInfo): return "PipelineLayoutCreateInfo";
        case(StructureType::SamplerCreateInfo): return "SamplerCreateInfo";
        case(StructureType::DescriptorSetLayoutCreateInfo): return "DescriptorSetLayoutCreateInfo";
        case(StructureType::DescriptorPoolCreateInfo): return "DescriptorPoolCreateInfo";
        case(StructureType::DescriptorSetAllocateInfo): return "DescriptorSetAllocateInfo";
        case(StructureType::WriteDescriptorSet): return "WriteDescriptorSet";
        case(StructureType::CopyDescriptorSet): return "CopyDescriptorSet";
        case(StructureType::FramebufferCreateInfo): return "FramebufferCreateInfo";
        case(StructureType::RenderPassCreateInfo): return "RenderPassCreateInfo";
        case(StructureType::CommandPoolCreateInfo): return "CommandPoolCreateInfo";
        case(StructureType::CommandBufferAllocateInfo): return "CommandBufferAllocateInfo";
        case(StructureType::CommandBufferInheritanceInfo): return "CommandBufferInheritanceInfo";
        case(StructureType::CommandBufferBeginInfo): return "CommandBufferBeginInfo";
        case(StructureType::RenderPassBeginInfo): return "RenderPassBeginInfo";
        case(StructureType::BufferMemoryBarrier): return "BufferMemoryBarrier";
        case(StructureType::ImageMemoryBarrier): return "ImageMemoryBarrier";
        case(StructureType::MemoryBarrier): return "MemoryBarrier";
        case(StructureType::LoaderInstanceCreateInfo): return "LoaderInstanceCreateInfo";
        case(StructureType::LoaderDeviceCreateInfo): return "LoaderDeviceCreateInfo";
        case(StructureType::SwapchainCreateInfoKHR): return "SwapchainCreateInfoKHR";
        case(StructureType::PresentInfoKHR): return "PresentInfoKHR";
        case(StructureType::DeviceGroupPresentCapabilitiesKHR): return "DeviceGroupPresentCapabilitiesKHR";
        case(StructureType::ImageSwapchainCreateInfoKHR): return "ImageSwapchainCreateInfoKHR";
        case(StructureType::BindImageMemorySwapchainInfoKHR): return "BindImageMemorySwapchainInfoKHR";
        case(StructureType::AcquireNextImageInfoKHR): return "AcquireNextImageInfoKHR";
        case(StructureType::DeviceGroupPresentInfoKHR): return "DeviceGroupPresentInfoKHR";
        case(StructureType::DeviceGroupSwapchainCreateInfoKHR): return "DeviceGroupSwapchainCreateInfoKHR";
        case(StructureType::DisplayModeCreateInfoKHR): return "DisplayModeCreateInfoKHR";
        case(StructureType::DisplaySurfaceCreateInfoKHR): return "DisplaySurfaceCreateInfoKHR";
        case(StructureType::DisplayPresentInfoKHR): return "DisplayPresentInfoKHR";
        case(StructureType::XlibSurfaceCreateInfoKHR): return "XlibSurfaceCreateInfoKHR";
        case(StructureType::XcbSurfaceCreateInfoKHR): return "XcbSurfaceCreateInfoKHR";
        case(StructureType::WaylandSurfaceCreateInfoKHR): return "WaylandSurfaceCreateInfoKHR";
        case(StructureType::AndroidSurfaceCreateInfoKHR): return "AndroidSurfaceCreateInfoKHR";
        case(StructureType::Win32SurfaceCreateInfoKHR): return "Win32SurfaceCreateInfoKHR";
        case(StructureType::DebugReportCallbackCreateInfoEXT): return "DebugReportCallbackCreateInfoEXT";
        case(StructureType::PipelineRasterizationStateRasterizationOrderAMD): return "PipelineRasterizationStateRasterizationOrderAMD";
        case(StructureType::DebugMarkerObjectNameInfoEXT): return "DebugMarkerObjectNameInfoEXT";
        case(StructureType::DebugMarkerObjectTagInfoEXT): return "DebugMarkerObjectTagInfoEXT";
        case(StructureType::DebugMarkerMarkerInfoEXT): return "DebugMarkerMarkerInfoEXT";
        case(StructureType::VideoProfileKHR): return "VideoProfileKHR";
        case(StructureType::VideoCapabilitiesKHR): return "VideoCapabilitiesKHR";
        case(StructureType::VideoPictureResourceKHR): return "VideoPictureResourceKHR";
        case(StructureType::VideoGetMemoryPropertiesKHR): return "VideoGetMemoryPropertiesKHR";
        case(StructureType::VideoBindMemoryKHR): return "VideoBindMemoryKHR";
        case(StructureType::VideoSessionCreateInfoKHR): return "VideoSessionCreateInfoKHR";
        case(StructureType::VideoSessionParametersCreateInfoKHR): return "VideoSessionParametersCreateInfoKHR";
        case(StructureType::VideoSessionParametersUpdateInfoKHR): return "VideoSessionParametersUpdateInfoKHR";
        case(StructureType::VideoBeginCodingInfoKHR): return "VideoBeginCodingInfoKHR";
        case(StructureType::VideoEndCodingInfoKHR): return "VideoEndCodingInfoKHR";
        case(StructureType::VideoCodingControlInfoKHR): return "VideoCodingControlInfoKHR";
        case(StructureType::VideoReferenceSlotKHR): return "VideoReferenceSlotKHR";
        case(StructureType::VideoQueueFamilyProperties2KHR): return "VideoQueueFamilyProperties2KHR";
        case(StructureType::VideoProfilesKHR): return "VideoProfilesKHR";
        case(StructureType::PhysicalDeviceVideoFormatInfoKHR): return "PhysicalDeviceVideoFormatInfoKHR";
        case(StructureType::VideoFormatPropertiesKHR): return "VideoFormatPropertiesKHR";
        case(StructureType::VideoDecodeInfoKHR): return "VideoDecodeInfoKHR";
        case(StructureType::VideoEncodeInfoKHR): return "VideoEncodeInfoKHR";
        case(StructureType::VideoEncodeRateControlInfoKHR): return "VideoEncodeRateControlInfoKHR";
        case(StructureType::DedicatedAllocationImageCreateInfoNV): return "DedicatedAllocationImageCreateInfoNV";
        case(StructureType::DedicatedAllocationBufferCreateInfoNV): return "DedicatedAllocationBufferCreateInfoNV";
        case(StructureType::DedicatedAllocationMemoryAllocateInfoNV): return "DedicatedAllocationMemoryAllocateInfoNV";
        case(StructureType::PhysicalDeviceTransformFeedbackFeaturesEXT): return "PhysicalDeviceTransformFeedbackFeaturesEXT";
        case(StructureType::PhysicalDeviceTransformFeedbackPropertiesEXT): return "PhysicalDeviceTransformFeedbackPropertiesEXT";
        case(StructureType::PipelineRasterizationStateStreamCreateInfoEXT): return "PipelineRasterizationStateStreamCreateInfoEXT";
        case(StructureType::ImageViewHandleInfoNVX): return "ImageViewHandleInfoNVX";
        case(StructureType::ImageViewAddressPropertiesNVX): return "ImageViewAddressPropertiesNVX";
        case(StructureType::VideoEncodeH264CapabilitiesEXT): return "VideoEncodeH264CapabilitiesEXT";
        case(StructureType::VideoEncodeH264SessionCreateInfoEXT): return "VideoEncodeH264SessionCreateInfoEXT";
        case(StructureType::VideoEncodeH264SessionParametersCreateInfoEXT): return "VideoEncodeH264SessionParametersCreateInfoEXT";
        case(StructureType::VideoEncodeH264SessionParametersAddInfoEXT): return "VideoEncodeH264SessionParametersAddInfoEXT";
        case(StructureType::VideoEncodeH264VclFrameInfoEXT): return "VideoEncodeH264VclFrameInfoEXT";
        case(StructureType::VideoEncodeH264DpbSlotInfoEXT): return "VideoEncodeH264DpbSlotInfoEXT";
        case(StructureType::VideoEncodeH264NaluSliceEXT): return "VideoEncodeH264NaluSliceEXT";
        case(StructureType::VideoEncodeH264EmitPictureParametersEXT): return "VideoEncodeH264EmitPictureParametersEXT";
        case(StructureType::VideoEncodeH264ProfileEXT): return "VideoEncodeH264ProfileEXT";
        case(StructureType::VideoDecodeH264CapabilitiesEXT): return "VideoDecodeH264CapabilitiesEXT";
        case(StructureType::VideoDecodeH264SessionCreateInfoEXT): return "VideoDecodeH264SessionCreateInfoEXT";
        case(StructureType::VideoDecodeH264PictureInfoEXT): return "VideoDecodeH264PictureInfoEXT";
        case(StructureType::VideoDecodeH264MvcEXT): return "VideoDecodeH264MvcEXT";
        case(StructureType::VideoDecodeH264ProfileEXT): return "VideoDecodeH264ProfileEXT";
        case(StructureType::VideoDecodeH264SessionParametersCreateInfoEXT): return "VideoDecodeH264SessionParametersCreateInfoEXT";
        case(StructureType::VideoDecodeH264SessionParametersAddInfoEXT): return "VideoDecodeH264SessionParametersAddInfoEXT";
        case(StructureType::VideoDecodeH264DpbSlotInfoEXT): return "VideoDecodeH264DpbSlotInfoEXT";
        case(StructureType::TextureLodGatherFormatPropertiesAMD): return "TextureLodGatherFormatPropertiesAMD";
        case(StructureType::StreamDescriptorSurfaceCreateInfoGGP): return "StreamDescriptorSurfaceCreateInfoGGP";
        case(StructureType::PhysicalDeviceCornerSampledImageFeaturesNV): return "PhysicalDeviceCornerSampledImageFeaturesNV";
        case(StructureType::ExternalMemoryImageCreateInfoNV): return "ExternalMemoryImageCreateInfoNV";
        case(StructureType::ExportMemoryAllocateInfoNV): return "ExportMemoryAllocateInfoNV";
        case(StructureType::ImportMemoryWin32HandleInfoNV): return "ImportMemoryWin32HandleInfoNV";
        case(StructureType::ExportMemoryWin32HandleInfoNV): return "ExportMemoryWin32HandleInfoNV";
        case(StructureType::Win32KeyedMutexAcquireReleaseInfoNV): return "Win32KeyedMutexAcquireReleaseInfoNV";
        case(StructureType::ValidationFlagsEXT): return "ValidationFlagsEXT";
        case(StructureType::ViSurfaceCreateInfoNN): return "ViSurfaceCreateInfoNN";
        case(StructureType::PhysicalDeviceTextureCompressionAstcHdrFeaturesEXT): return "PhysicalDeviceTextureCompressionAstcHdrFeaturesEXT";
        case(StructureType::ImageViewAstcDecodeModeEXT): return "ImageViewAstcDecodeModeEXT";
        case(StructureType::PhysicalDeviceAstcDecodeFeaturesEXT): return "PhysicalDeviceAstcDecodeFeaturesEXT";
        case(StructureType::ImportMemoryWin32HandleInfoKHR): return "ImportMemoryWin32HandleInfoKHR";
        case(StructureType::ExportMemoryWin32HandleInfoKHR): return "ExportMemoryWin32HandleInfoKHR";
        case(StructureType::MemoryWin32HandlePropertiesKHR): return "MemoryWin32HandlePropertiesKHR";
        case(StructureType::MemoryGetWin32HandleInfoKHR): return "MemoryGetWin32HandleInfoKHR";
        case(StructureType::ImportMemoryFdInfoKHR): return "ImportMemoryFdInfoKHR";
        case(StructureType::MemoryFdPropertiesKHR): return "MemoryFdPropertiesKHR";
        case(StructureType::MemoryGetFdInfoKHR): return "MemoryGetFdInfoKHR";
        case(StructureType::Win32KeyedMutexAcquireReleaseInfoKHR): return "Win32KeyedMutexAcquireReleaseInfoKHR";
        case(StructureType::ImportSemaphoreWin32HandleInfoKHR): return "ImportSemaphoreWin32HandleInfoKHR";
        case(StructureType::ExportSemaphoreWin32HandleInfoKHR): return "ExportSemaphoreWin32HandleInfoKHR";
        case(StructureType::D3D12FenceSubmitInfoKHR): return "D3D12FenceSubmitInfoKHR";
        case(StructureType::SemaphoreGetWin32HandleInfoKHR): return "SemaphoreGetWin32HandleInfoKHR";
        case(StructureType::ImportSemaphoreFdInfoKHR): return "ImportSemaphoreFdInfoKHR";
        case(StructureType::SemaphoreGetFdInfoKHR): return "SemaphoreGetFdInfoKHR";
        case(StructureType::PhysicalDevicePushDescriptorPropertiesKHR): return "PhysicalDevicePushDescriptorPropertiesKHR";
        case(StructureType::CommandBufferInheritanceConditionalRenderingInfoEXT): return "CommandBufferInheritanceConditionalRenderingInfoEXT";
        case(StructureType::PhysicalDeviceConditionalRenderingFeaturesEXT): return "PhysicalDeviceConditionalRenderingFeaturesEXT";
        case(StructureType::ConditionalRenderingBeginInfoEXT): return "ConditionalRenderingBeginInfoEXT";
        case(StructureType::PresentRegionsKHR): return "PresentRegionsKHR";
        case(StructureType::PipelineViewportWScalingStateCreateInfoNV): return "PipelineViewportWScalingStateCreateInfoNV";
        case(StructureType::SurfaceCapabilities2EXT): return "SurfaceCapabilities2EXT";
        case(StructureType::DisplayPowerInfoEXT): return "DisplayPowerInfoEXT";
        case(StructureType::DeviceEventInfoEXT): return "DeviceEventInfoEXT";
        case(StructureType::DisplayEventInfoEXT): return "DisplayEventInfoEXT";
        case(StructureType::SwapchainCounterCreateInfoEXT): return "SwapchainCounterCreateInfoEXT";
        case(StructureType::PresentTimesInfoGOOGLE): return "PresentTimesInfoGOOGLE";
        case(StructureType::PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX): return "PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX";
        case(StructureType::PipelineViewportSwizzleStateCreateInfoNV): return "PipelineViewportSwizzleStateCreateInfoNV";
        case(StructureType::PhysicalDeviceDiscardRectanglePropertiesEXT): return "PhysicalDeviceDiscardRectanglePropertiesEXT";
        case(StructureType::PipelineDiscardRectangleStateCreateInfoEXT): return "PipelineDiscardRectangleStateCreateInfoEXT";
        case(StructureType::PhysicalDeviceConservativeRasterizationPropertiesEXT): return "PhysicalDeviceConservativeRasterizationPropertiesEXT";
        case(StructureType::PipelineRasterizationConservativeStateCreateInfoEXT): return "PipelineRasterizationConservativeStateCreateInfoEXT";
        case(StructureType::PhysicalDeviceDepthClipEnableFeaturesEXT): return "PhysicalDeviceDepthClipEnableFeaturesEXT";
        case(StructureType::PipelineRasterizationDepthClipStateCreateInfoEXT): return "PipelineRasterizationDepthClipStateCreateInfoEXT";
        case(StructureType::HdrMetadataEXT): return "HdrMetadataEXT";
        case(StructureType::SharedPresentSurfaceCapabilitiesKHR): return "SharedPresentSurfaceCapabilitiesKHR";
        case(StructureType::ImportFenceWin32HandleInfoKHR): return "ImportFenceWin32HandleInfoKHR";
        case(StructureType::ExportFenceWin32HandleInfoKHR): return "ExportFenceWin32HandleInfoKHR";
        case(StructureType::FenceGetWin32HandleInfoKHR): return "FenceGetWin32HandleInfoKHR";
        case(StructureType::ImportFenceFdInfoKHR): return "ImportFenceFdInfoKHR";
        case(StructureType::FenceGetFdInfoKHR): return "FenceGetFdInfoKHR";
        case(StructureType::PhysicalDevicePerformanceQueryFeaturesKHR): return "PhysicalDevicePerformanceQueryFeaturesKHR";
        case(StructureType::PhysicalDevicePerformanceQueryPropertiesKHR): return "PhysicalDevicePerformanceQueryPropertiesKHR";
        case(StructureType::QueryPoolPerformanceCreateInfoKHR): return "QueryPoolPerformanceCreateInfoKHR";
        case(StructureType::PerformanceQuerySubmitInfoKHR): return "PerformanceQuerySubmitInfoKHR";
        case(StructureType::AcquireProfilingLockInfoKHR): return "AcquireProfilingLockInfoKHR";
        case(StructureType::PerformanceCounterKHR): return "PerformanceCounterKHR";
        case(StructureType::PerformanceCounterDescriptionKHR): return "PerformanceCounterDescriptionKHR";
        case(StructureType::PhysicalDeviceSurfaceInfo2KHR): return "PhysicalDeviceSurfaceInfo2KHR";
        case(StructureType::SurfaceCapabilities2KHR): return "SurfaceCapabilities2KHR";
        case(StructureType::SurfaceFormat2KHR): return "SurfaceFormat2KHR";
        case(StructureType::DisplayProperties2KHR): return "DisplayProperties2KHR";
        case(StructureType::DisplayPlaneProperties2KHR): return "DisplayPlaneProperties2KHR";
        case(StructureType::DisplayModeProperties2KHR): return "DisplayModeProperties2KHR";
        case(StructureType::DisplayPlaneInfo2KHR): return "DisplayPlaneInfo2KHR";
        case(StructureType::DisplayPlaneCapabilities2KHR): return "DisplayPlaneCapabilities2KHR";
        case(StructureType::IosSurfaceCreateInfoMVK): return "IosSurfaceCreateInfoMVK";
        case(StructureType::MacosSurfaceCreateInfoMVK): return "MacosSurfaceCreateInfoMVK";
        case(StructureType::DebugUtilsObjectNameInfoEXT): return "DebugUtilsObjectNameInfoEXT";
        case(StructureType::DebugUtilsObjectTagInfoEXT): return "DebugUtilsObjectTagInfoEXT";
        case(StructureType::DebugUtilsLabelEXT): return "DebugUtilsLabelEXT";
        case(StructureType::DebugUtilsMessengerCallbackDataEXT): return "DebugUtilsMessengerCallbackDataEXT";
        case(StructureType::DebugUtilsMessengerCreateInfoEXT): return "DebugUtilsMessengerCreateInfoEXT";
        case(StructureType::AndroidHardwareBufferUsageANDROID): return "AndroidHardwareBufferUsageANDROID";
        case(StructureType::AndroidHardwareBufferPropertiesANDROID): return "AndroidHardwareBufferPropertiesANDROID";
        case(StructureType::AndroidHardwareBufferFormatPropertiesANDROID): return "AndroidHardwareBufferFormatPropertiesANDROID";
        case(StructureType::ImportAndroidHardwareBufferInfoANDROID): return "ImportAndroidHardwareBufferInfoANDROID";
        case(StructureType::MemoryGetAndroidHardwareBufferInfoANDROID): return "MemoryGetAndroidHardwareBufferInfoANDROID";
        case(StructureType::ExternalFormatANDROID): return "ExternalFormatANDROID";
        case(StructureType::PhysicalDeviceInlineUniformBlockFeaturesEXT): return "PhysicalDeviceInlineUniformBlockFeaturesEXT";
        case(StructureType::PhysicalDeviceInlineUniformBlockPropertiesEXT): return "PhysicalDeviceInlineUniformBlockPropertiesEXT";
        case(StructureType::WriteDescriptorSetInlineUniformBlockEXT): return "WriteDescriptorSetInlineUniformBlockEXT";
        case(StructureType::DescriptorPoolInlineUniformBlockCreateInfoEXT): return "DescriptorPoolInlineUniformBlockCreateInfoEXT";
        case(StructureType::SampleLocationsInfoEXT): return "SampleLocationsInfoEXT";
        case(StructureType::RenderPassSampleLocationsBeginInfoEXT): return "RenderPassSampleLocationsBeginInfoEXT";
        case(StructureType::PipelineSampleLocationsStateCreateInfoEXT): return "PipelineSampleLocationsStateCreateInfoEXT";
        case(StructureType::PhysicalDeviceSampleLocationsPropertiesEXT): return "PhysicalDeviceSampleLocationsPropertiesEXT";
        case(StructureType::MultisamplePropertiesEXT): return "MultisamplePropertiesEXT";
        case(StructureType::PhysicalDeviceBlendOperationAdvancedFeaturesEXT): return "PhysicalDeviceBlendOperationAdvancedFeaturesEXT";
        case(StructureType::PhysicalDeviceBlendOperationAdvancedPropertiesEXT): return "PhysicalDeviceBlendOperationAdvancedPropertiesEXT";
        case(StructureType::PipelineColorBlendAdvancedStateCreateInfoEXT): return "PipelineColorBlendAdvancedStateCreateInfoEXT";
        case(StructureType::PipelineCoverageToColorStateCreateInfoNV): return "PipelineCoverageToColorStateCreateInfoNV";
        case(StructureType::WriteDescriptorSetAccelerationStructureKHR): return "WriteDescriptorSetAccelerationStructureKHR";
        case(StructureType::AccelerationStructureBuildGeometryInfoKHR): return "AccelerationStructureBuildGeometryInfoKHR";
        case(StructureType::AccelerationStructureDeviceAddressInfoKHR): return "AccelerationStructureDeviceAddressInfoKHR";
        case(StructureType::AccelerationStructureGeometryAabbsDataKHR): return "AccelerationStructureGeometryAabbsDataKHR";
        case(StructureType::AccelerationStructureGeometryInstancesDataKHR): return "AccelerationStructureGeometryInstancesDataKHR";
        case(StructureType::AccelerationStructureGeometryTrianglesDataKHR): return "AccelerationStructureGeometryTrianglesDataKHR";
        case(StructureType::AccelerationStructureGeometryKHR): return "AccelerationStructureGeometryKHR";
        case(StructureType::AccelerationStructureVersionInfoKHR): return "AccelerationStructureVersionInfoKHR";
        case(StructureType::CopyAccelerationStructureInfoKHR): return "CopyAccelerationStructureInfoKHR";
        case(StructureType::CopyAccelerationStructureToMemoryInfoKHR): return "CopyAccelerationStructureToMemoryInfoKHR";
        case(StructureType::CopyMemoryToAccelerationStructureInfoKHR): return "CopyMemoryToAccelerationStructureInfoKHR";
        case(StructureType::PhysicalDeviceAccelerationStructureFeaturesKHR): return "PhysicalDeviceAccelerationStructureFeaturesKHR";
        case(StructureType::PhysicalDeviceAccelerationStructurePropertiesKHR): return "PhysicalDeviceAccelerationStructurePropertiesKHR";
        case(StructureType::AccelerationStructureCreateInfoKHR): return "AccelerationStructureCreateInfoKHR";
        case(StructureType::AccelerationStructureBuildSizesInfoKHR): return "AccelerationStructureBuildSizesInfoKHR";
        case(StructureType::PhysicalDeviceRayTracingPipelineFeaturesKHR): return "PhysicalDeviceRayTracingPipelineFeaturesKHR";
        case(StructureType::PhysicalDeviceRayTracingPipelinePropertiesKHR): return "PhysicalDeviceRayTracingPipelinePropertiesKHR";
        case(StructureType::RayTracingPipelineCreateInfoKHR): return "RayTracingPipelineCreateInfoKHR";
        case(StructureType::RayTracingShaderGroupCreateInfoKHR): return "RayTracingShaderGroupCreateInfoKHR";
        case(StructureType::RayTracingPipelineInterfaceCreateInfoKHR): return "RayTracingPipelineInterfaceCreateInfoKHR";
        case(StructureType::PhysicalDeviceRayQueryFeaturesKHR): return "PhysicalDeviceRayQueryFeaturesKHR";
        case(StructureType::PipelineCoverageModulationStateCreateInfoNV): return "PipelineCoverageModulationStateCreateInfoNV";
        case(StructureType::PhysicalDeviceShaderSmBuiltinsFeaturesNV): return "PhysicalDeviceShaderSmBuiltinsFeaturesNV";
        case(StructureType::PhysicalDeviceShaderSmBuiltinsPropertiesNV): return "PhysicalDeviceShaderSmBuiltinsPropertiesNV";
        case(StructureType::DrmFormatModifierPropertiesListEXT): return "DrmFormatModifierPropertiesListEXT";
        case(StructureType::PhysicalDeviceImageDrmFormatModifierInfoEXT): return "PhysicalDeviceImageDrmFormatModifierInfoEXT";
        case(StructureType::ImageDrmFormatModifierListCreateInfoEXT): return "ImageDrmFormatModifierListCreateInfoEXT";
        case(StructureType::ImageDrmFormatModifierExplicitCreateInfoEXT): return "ImageDrmFormatModifierExplicitCreateInfoEXT";
        case(StructureType::ImageDrmFormatModifierPropertiesEXT): return "ImageDrmFormatModifierPropertiesEXT";
        case(StructureType::ValidationCacheCreateInfoEXT): return "ValidationCacheCreateInfoEXT";
        case(StructureType::ShaderModuleValidationCacheCreateInfoEXT): return "ShaderModuleValidationCacheCreateInfoEXT";
        case(StructureType::PhysicalDevicePortabilitySubsetFeaturesKHR): return "PhysicalDevicePortabilitySubsetFeaturesKHR";
        case(StructureType::PhysicalDevicePortabilitySubsetPropertiesKHR): return "PhysicalDevicePortabilitySubsetPropertiesKHR";
        case(StructureType::PipelineViewportShadingRateImageStateCreateInfoNV): return "PipelineViewportShadingRateImageStateCreateInfoNV";
        case(StructureType::PhysicalDeviceShadingRateImageFeaturesNV): return "PhysicalDeviceShadingRateImageFeaturesNV";
        case(StructureType::PhysicalDeviceShadingRateImagePropertiesNV): return "PhysicalDeviceShadingRateImagePropertiesNV";
        case(StructureType::PipelineViewportCoarseSampleOrderStateCreateInfoNV): return "PipelineViewportCoarseSampleOrderStateCreateInfoNV";
        case(StructureType::RayTracingPipelineCreateInfoNV): return "RayTracingPipelineCreateInfoNV";
        case(StructureType::AccelerationStructureCreateInfoNV): return "AccelerationStructureCreateInfoNV";
        case(StructureType::GeometryNV): return "GeometryNV";
        case(StructureType::GeometryTrianglesNV): return "GeometryTrianglesNV";
        case(StructureType::GeometryAabbNV): return "GeometryAabbNV";
        case(StructureType::BindAccelerationStructureMemoryInfoNV): return "BindAccelerationStructureMemoryInfoNV";
        case(StructureType::WriteDescriptorSetAccelerationStructureNV): return "WriteDescriptorSetAccelerationStructureNV";
        case(StructureType::AccelerationStructureMemoryRequirementsInfoNV): return "AccelerationStructureMemoryRequirementsInfoNV";
        case(StructureType::PhysicalDeviceRayTracingPropertiesNV): return "PhysicalDeviceRayTracingPropertiesNV";
        case(StructureType::RayTracingShaderGroupCreateInfoNV): return "RayTracingShaderGroupCreateInfoNV";
        case(StructureType::AccelerationStructureInfoNV): return "AccelerationStructureInfoNV";
        case(StructureType::PhysicalDeviceRepresentativeFragmentTestFeaturesNV): return "PhysicalDeviceRepresentativeFragmentTestFeaturesNV";
        case(StructureType::PipelineRepresentativeFragmentTestStateCreateInfoNV): return "PipelineRepresentativeFragmentTestStateCreateInfoNV";
        case(StructureType::PhysicalDeviceImageViewImageFormatInfoEXT): return "PhysicalDeviceImageViewImageFormatInfoEXT";
        case(StructureType::FilterCubicImageViewImageFormatPropertiesEXT): return "FilterCubicImageViewImageFormatPropertiesEXT";
        case(StructureType::DeviceQueueGlobalPriorityCreateInfoEXT): return "DeviceQueueGlobalPriorityCreateInfoEXT";
        case(StructureType::ImportMemoryHostPointerInfoEXT): return "ImportMemoryHostPointerInfoEXT";
        case(StructureType::MemoryHostPointerPropertiesEXT): return "MemoryHostPointerPropertiesEXT";
        case(StructureType::PhysicalDeviceExternalMemoryHostPropertiesEXT): return "PhysicalDeviceExternalMemoryHostPropertiesEXT";
        case(StructureType::PhysicalDeviceShaderClockFeaturesKHR): return "PhysicalDeviceShaderClockFeaturesKHR";
        case(StructureType::PipelineCompilerControlCreateInfoAMD): return "PipelineCompilerControlCreateInfoAMD";
        case(StructureType::CalibratedTimestampInfoEXT): return "CalibratedTimestampInfoEXT";
        case(StructureType::PhysicalDeviceShaderCorePropertiesAMD): return "PhysicalDeviceShaderCorePropertiesAMD";
        case(StructureType::VideoDecodeH265CapabilitiesEXT): return "VideoDecodeH265CapabilitiesEXT";
        case(StructureType::VideoDecodeH265SessionCreateInfoEXT): return "VideoDecodeH265SessionCreateInfoEXT";
        case(StructureType::VideoDecodeH265SessionParametersCreateInfoEXT): return "VideoDecodeH265SessionParametersCreateInfoEXT";
        case(StructureType::VideoDecodeH265SessionParametersAddInfoEXT): return "VideoDecodeH265SessionParametersAddInfoEXT";
        case(StructureType::VideoDecodeH265ProfileEXT): return "VideoDecodeH265ProfileEXT";
        case(StructureType::VideoDecodeH265PictureInfoEXT): return "VideoDecodeH265PictureInfoEXT";
        case(StructureType::VideoDecodeH265DpbSlotInfoEXT): return "VideoDecodeH265DpbSlotInfoEXT";
        case(StructureType::DeviceMemoryOverallocationCreateInfoAMD): return "DeviceMemoryOverallocationCreateInfoAMD";
        case(StructureType::PhysicalDeviceVertexAttributeDivisorPropertiesEXT): return "PhysicalDeviceVertexAttributeDivisorPropertiesEXT";
        case(StructureType::PipelineVertexInputDivisorStateCreateInfoEXT): return "PipelineVertexInputDivisorStateCreateInfoEXT";
        case(StructureType::PhysicalDeviceVertexAttributeDivisorFeaturesEXT): return "PhysicalDeviceVertexAttributeDivisorFeaturesEXT";
        case(StructureType::PresentFrameTokenGGP): return "PresentFrameTokenGGP";
        case(StructureType::PipelineCreationFeedbackCreateInfoEXT): return "PipelineCreationFeedbackCreateInfoEXT";
        case(StructureType::PhysicalDeviceComputeShaderDerivativesFeaturesNV): return "PhysicalDeviceComputeShaderDerivativesFeaturesNV";
        case(StructureType::PhysicalDeviceMeshShaderFeaturesNV): return "PhysicalDeviceMeshShaderFeaturesNV";
        case(StructureType::PhysicalDeviceMeshShaderPropertiesNV): return "PhysicalDeviceMeshShaderPropertiesNV";
        case(StructureType::PhysicalDeviceFragmentShaderBarycentricFeaturesNV): return "PhysicalDeviceFragmentShaderBarycentricFeaturesNV";
        case(StructureType::PhysicalDeviceShaderImageFootprintFeaturesNV): return "PhysicalDeviceShaderImageFootprintFeaturesNV";
        case(StructureType::PipelineViewportExclusiveScissorStateCreateInfoNV): return "PipelineViewportExclusiveScissorStateCreateInfoNV";
        case(StructureType::PhysicalDeviceExclusiveScissorFeaturesNV): return "PhysicalDeviceExclusiveScissorFeaturesNV";
        case(StructureType::CheckpointDataNV): return "CheckpointDataNV";
        case(StructureType::QueueFamilyCheckpointPropertiesNV): return "QueueFamilyCheckpointPropertiesNV";
        case(StructureType::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL): return "PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL";
        case(StructureType::QueryPoolPerformanceQueryCreateInfoINTEL): return "QueryPoolPerformanceQueryCreateInfoINTEL";
        case(StructureType::InitializePerformanceApiInfoINTEL): return "InitializePerformanceApiInfoINTEL";
        case(StructureType::PerformanceMarkerInfoINTEL): return "PerformanceMarkerInfoINTEL";
        case(StructureType::PerformanceStreamMarkerInfoINTEL): return "PerformanceStreamMarkerInfoINTEL";
        case(StructureType::PerformanceOverrideInfoINTEL): return "PerformanceOverrideInfoINTEL";
        case(StructureType::PerformanceConfigurationAcquireInfoINTEL): return "PerformanceConfigurationAcquireInfoINTEL";
        case(StructureType::PhysicalDevicePciBusInfoPropertiesEXT): return "PhysicalDevicePciBusInfoPropertiesEXT";
        case(StructureType::DisplayNativeHdrSurfaceCapabilitiesAMD): return "DisplayNativeHdrSurfaceCapabilitiesAMD";
        case(StructureType::SwapchainDisplayNativeHdrCreateInfoAMD): return "SwapchainDisplayNativeHdrCreateInfoAMD";
        case(StructureType::ImagepipeSurfaceCreateInfoFUCHSIA): return "ImagepipeSurfaceCreateInfoFUCHSIA";
        case(StructureType::PhysicalDeviceShaderTerminateInvocationFeaturesKHR): return "PhysicalDeviceShaderTerminateInvocationFeaturesKHR";
        case(StructureType::MetalSurfaceCreateInfoEXT): return "MetalSurfaceCreateInfoEXT";
        case(StructureType::PhysicalDeviceFragmentDensityMapFeaturesEXT): return "PhysicalDeviceFragmentDensityMapFeaturesEXT";
        case(StructureType::PhysicalDeviceFragmentDensityMapPropertiesEXT): return "PhysicalDeviceFragmentDensityMapPropertiesEXT";
        case(StructureType::RenderPassFragmentDensityMapCreateInfoEXT): return "RenderPassFragmentDensityMapCreateInfoEXT";
        case(StructureType::PhysicalDeviceSubgroupSizeControlPropertiesEXT): return "PhysicalDeviceSubgroupSizeControlPropertiesEXT";
        case(StructureType::PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT): return "PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT";
        case(StructureType::PhysicalDeviceSubgroupSizeControlFeaturesEXT): return "PhysicalDeviceSubgroupSizeControlFeaturesEXT";
        case(StructureType::FragmentShadingRateAttachmentInfoKHR): return "FragmentShadingRateAttachmentInfoKHR";
        case(StructureType::PipelineFragmentShadingRateStateCreateInfoKHR): return "PipelineFragmentShadingRateStateCreateInfoKHR";
        case(StructureType::PhysicalDeviceFragmentShadingRatePropertiesKHR): return "PhysicalDeviceFragmentShadingRatePropertiesKHR";
        case(StructureType::PhysicalDeviceFragmentShadingRateFeaturesKHR): return "PhysicalDeviceFragmentShadingRateFeaturesKHR";
        case(StructureType::PhysicalDeviceFragmentShadingRateKHR): return "PhysicalDeviceFragmentShadingRateKHR";
        case(StructureType::PhysicalDeviceShaderCoreProperties2AMD): return "PhysicalDeviceShaderCoreProperties2AMD";
        case(StructureType::PhysicalDeviceCoherentMemoryFeaturesAMD): return "PhysicalDeviceCoherentMemoryFeaturesAMD";
        case(StructureType::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT): return "PhysicalDeviceShaderImageAtomicInt64FeaturesEXT";
        case(StructureType::PhysicalDeviceMemoryBudgetPropertiesEXT): return "PhysicalDeviceMemoryBudgetPropertiesEXT";
        case(StructureType::PhysicalDeviceMemoryPriorityFeaturesEXT): return "PhysicalDeviceMemoryPriorityFeaturesEXT";
        case(StructureType::MemoryPriorityAllocateInfoEXT): return "MemoryPriorityAllocateInfoEXT";
        case(StructureType::SurfaceProtectedCapabilitiesKHR): return "SurfaceProtectedCapabilitiesKHR";
        case(StructureType::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV): return "PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV";
        case(StructureType::PhysicalDeviceBufferDeviceAddressFeaturesEXT): return "PhysicalDeviceBufferDeviceAddressFeaturesEXT";
        case(StructureType::BufferDeviceAddressCreateInfoEXT): return "BufferDeviceAddressCreateInfoEXT";
        case(StructureType::PhysicalDeviceToolPropertiesEXT): return "PhysicalDeviceToolPropertiesEXT";
        case(StructureType::ValidationFeaturesEXT): return "ValidationFeaturesEXT";
        case(StructureType::PhysicalDeviceCooperativeMatrixFeaturesNV): return "PhysicalDeviceCooperativeMatrixFeaturesNV";
        case(StructureType::CooperativeMatrixPropertiesNV): return "CooperativeMatrixPropertiesNV";
        case(StructureType::PhysicalDeviceCooperativeMatrixPropertiesNV): return "PhysicalDeviceCooperativeMatrixPropertiesNV";
        case(StructureType::PhysicalDeviceCoverageReductionModeFeaturesNV): return "PhysicalDeviceCoverageReductionModeFeaturesNV";
        case(StructureType::PipelineCoverageReductionStateCreateInfoNV): return "PipelineCoverageReductionStateCreateInfoNV";
        case(StructureType::FramebufferMixedSamplesCombinationNV): return "FramebufferMixedSamplesCombinationNV";
        case(StructureType::PhysicalDeviceFragmentShaderInterlockFeaturesEXT): return "PhysicalDeviceFragmentShaderInterlockFeaturesEXT";
        case(StructureType::PhysicalDeviceYcbcrImageArraysFeaturesEXT): return "PhysicalDeviceYcbcrImageArraysFeaturesEXT";
        case(StructureType::SurfaceFullScreenExclusiveInfoEXT): return "SurfaceFullScreenExclusiveInfoEXT";
        case(StructureType::SurfaceCapabilitiesFullScreenExclusiveEXT): return "SurfaceCapabilitiesFullScreenExclusiveEXT";
        case(StructureType::SurfaceFullScreenExclusiveWin32InfoEXT): return "SurfaceFullScreenExclusiveWin32InfoEXT";
        case(StructureType::HeadlessSurfaceCreateInfoEXT): return "HeadlessSurfaceCreateInfoEXT";
        case(StructureType::PhysicalDeviceLineRasterizationFeaturesEXT): return "PhysicalDeviceLineRasterizationFeaturesEXT";
        case(StructureType::PipelineRasterizationLineStateCreateInfoEXT): return "PipelineRasterizationLineStateCreateInfoEXT";
        case(StructureType::PhysicalDeviceLineRasterizationPropertiesEXT): return "PhysicalDeviceLineRasterizationPropertiesEXT";
        case(StructureType::PhysicalDeviceShaderAtomicFloatFeaturesEXT): return "PhysicalDeviceShaderAtomicFloatFeaturesEXT";
        case(StructureType::PhysicalDeviceIndexTypeUint8FeaturesEXT): return "PhysicalDeviceIndexTypeUint8FeaturesEXT";
        case(StructureType::PhysicalDeviceExtendedDynamicStateFeaturesEXT): return "PhysicalDeviceExtendedDynamicStateFeaturesEXT";
        case(StructureType::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR): return "PhysicalDevicePipelineExecutablePropertiesFeaturesKHR";
        case(StructureType::PipelineInfoKHR): return "PipelineInfoKHR";
        case(StructureType::PipelineExecutablePropertiesKHR): return "PipelineExecutablePropertiesKHR";
        case(StructureType::PipelineExecutableInfoKHR): return "PipelineExecutableInfoKHR";
        case(StructureType::PipelineExecutableStatisticKHR): return "PipelineExecutableStatisticKHR";
        case(StructureType::PipelineExecutableInternalRepresentationKHR): return "PipelineExecutableInternalRepresentationKHR";
        case(StructureType::PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT): return "PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT";
        case(StructureType::PhysicalDeviceDeviceGeneratedCommandsPropertiesNV): return "PhysicalDeviceDeviceGeneratedCommandsPropertiesNV";
        case(StructureType::GraphicsShaderGroupCreateInfoNV): return "GraphicsShaderGroupCreateInfoNV";
        case(StructureType::GraphicsPipelineShaderGroupsCreateInfoNV): return "GraphicsPipelineShaderGroupsCreateInfoNV";
        case(StructureType::IndirectCommandsLayoutTokenNV): return "IndirectCommandsLayoutTokenNV";
        case(StructureType::IndirectCommandsLayoutCreateInfoNV): return "IndirectCommandsLayoutCreateInfoNV";
        case(StructureType::GeneratedCommandsInfoNV): return "GeneratedCommandsInfoNV";
        case(StructureType::GeneratedCommandsMemoryRequirementsInfoNV): return "GeneratedCommandsMemoryRequirementsInfoNV";
        case(StructureType::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV): return "PhysicalDeviceDeviceGeneratedCommandsFeaturesNV";
        case(StructureType::PhysicalDeviceInheritedViewportScissorFeaturesNV): return "PhysicalDeviceInheritedViewportScissorFeaturesNV";
        case(StructureType::CommandBufferInheritanceViewportScissorInfoNV): return "CommandBufferInheritanceViewportScissorInfoNV";
        case(StructureType::PhysicalDeviceTexelBufferAlignmentFeaturesEXT): return "PhysicalDeviceTexelBufferAlignmentFeaturesEXT";
        case(StructureType::PhysicalDeviceTexelBufferAlignmentPropertiesEXT): return "PhysicalDeviceTexelBufferAlignmentPropertiesEXT";
        case(StructureType::CommandBufferInheritanceRenderPassTransformInfoQCOM): return "CommandBufferInheritanceRenderPassTransformInfoQCOM";
        case(StructureType::RenderPassTransformBeginInfoQCOM): return "RenderPassTransformBeginInfoQCOM";
        case(StructureType::PhysicalDeviceDeviceMemoryReportFeaturesEXT): return "PhysicalDeviceDeviceMemoryReportFeaturesEXT";
        case(StructureType::DeviceDeviceMemoryReportCreateInfoEXT): return "DeviceDeviceMemoryReportCreateInfoEXT";
        case(StructureType::DeviceMemoryReportCallbackDataEXT): return "DeviceMemoryReportCallbackDataEXT";
        case(StructureType::PhysicalDeviceRobustness2FeaturesEXT): return "PhysicalDeviceRobustness2FeaturesEXT";
        case(StructureType::PhysicalDeviceRobustness2PropertiesEXT): return "PhysicalDeviceRobustness2PropertiesEXT";
        case(StructureType::SamplerCustomBorderColorCreateInfoEXT): return "SamplerCustomBorderColorCreateInfoEXT";
        case(StructureType::PhysicalDeviceCustomBorderColorPropertiesEXT): return "PhysicalDeviceCustomBorderColorPropertiesEXT";
        case(StructureType::PhysicalDeviceCustomBorderColorFeaturesEXT): return "PhysicalDeviceCustomBorderColorFeaturesEXT";
        case(StructureType::PipelineLibraryCreateInfoKHR): return "PipelineLibraryCreateInfoKHR";
        case(StructureType::PhysicalDevicePrivateDataFeaturesEXT): return "PhysicalDevicePrivateDataFeaturesEXT";
        case(StructureType::DevicePrivateDataCreateInfoEXT): return "DevicePrivateDataCreateInfoEXT";
        case(StructureType::PrivateDataSlotCreateInfoEXT): return "PrivateDataSlotCreateInfoEXT";
        case(StructureType::PhysicalDevicePipelineCreationCacheControlFeaturesEXT): return "PhysicalDevicePipelineCreationCacheControlFeaturesEXT";
        case(StructureType::PhysicalDeviceDiagnosticsConfigFeaturesNV): return "PhysicalDeviceDiagnosticsConfigFeaturesNV";
        case(StructureType::DeviceDiagnosticsConfigCreateInfoNV): return "DeviceDiagnosticsConfigCreateInfoNV";
        case(StructureType::MemoryBarrier2KHR): return "MemoryBarrier2KHR";
        case(StructureType::BufferMemoryBarrier2KHR): return "BufferMemoryBarrier2KHR";
        case(StructureType::ImageMemoryBarrier2KHR): return "ImageMemoryBarrier2KHR";
        case(StructureType::DependencyInfoKHR): return "DependencyInfoKHR";
        case(StructureType::SubmitInfo2KHR): return "SubmitInfo2KHR";
        case(StructureType::SemaphoreSubmitInfoKHR): return "SemaphoreSubmitInfoKHR";
        case(StructureType::CommandBufferSubmitInfoKHR): return "CommandBufferSubmitInfoKHR";
        case(StructureType::PhysicalDeviceSynchronization2FeaturesKHR): return "PhysicalDeviceSynchronization2FeaturesKHR";
        case(StructureType::QueueFamilyCheckpointProperties2NV): return "QueueFamilyCheckpointProperties2NV";
        case(StructureType::CheckpointData2NV): return "CheckpointData2NV";
        case(StructureType::PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR): return "PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR";
        case(StructureType::PhysicalDeviceFragmentShadingRateEnumsPropertiesNV): return "PhysicalDeviceFragmentShadingRateEnumsPropertiesNV";
        case(StructureType::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV): return "PhysicalDeviceFragmentShadingRateEnumsFeaturesNV";
        case(StructureType::PipelineFragmentShadingRateEnumStateCreateInfoNV): return "PipelineFragmentShadingRateEnumStateCreateInfoNV";
        case(StructureType::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT): return "PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT";
        case(StructureType::PhysicalDeviceFragmentDensityMap2FeaturesEXT): return "PhysicalDeviceFragmentDensityMap2FeaturesEXT";
        case(StructureType::PhysicalDeviceFragmentDensityMap2PropertiesEXT): return "PhysicalDeviceFragmentDensityMap2PropertiesEXT";
        case(StructureType::CopyCommandTransformInfoQCOM): return "CopyCommandTransformInfoQCOM";
        case(StructureType::PhysicalDeviceImageRobustnessFeaturesEXT): return "PhysicalDeviceImageRobustnessFeaturesEXT";
        case(StructureType::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR): return "PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR";
        case(StructureType::CopyBufferInfo2KHR): return "CopyBufferInfo2KHR";
        case(StructureType::CopyImageInfo2KHR): return "CopyImageInfo2KHR";
        case(StructureType::CopyBufferToImageInfo2KHR): return "CopyBufferToImageInfo2KHR";
        case(StructureType::CopyImageToBufferInfo2KHR): return "CopyImageToBufferInfo2KHR";
        case(StructureType::BlitImageInfo2KHR): return "BlitImageInfo2KHR";
        case(StructureType::ResolveImageInfo2KHR): return "ResolveImageInfo2KHR";
        case(StructureType::BufferCopy2KHR): return "BufferCopy2KHR";
        case(StructureType::ImageCopy2KHR): return "ImageCopy2KHR";
        case(StructureType::ImageBlit2KHR): return "ImageBlit2KHR";
        case(StructureType::BufferImageCopy2KHR): return "BufferImageCopy2KHR";
        case(StructureType::ImageResolve2KHR): return "ImageResolve2KHR";
        case(StructureType::PhysicalDevice4444FormatsFeaturesEXT): return "PhysicalDevice4444FormatsFeaturesEXT";
        case(StructureType::DirectfbSurfaceCreateInfoEXT): return "DirectfbSurfaceCreateInfoEXT";
        case(StructureType::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE): return "PhysicalDeviceMutableDescriptorTypeFeaturesVALVE";
        case(StructureType::MutableDescriptorTypeCreateInfoVALVE): return "MutableDescriptorTypeCreateInfoVALVE";
        case(StructureType::PhysicalDeviceVertexInputDynamicStateFeaturesEXT): return "PhysicalDeviceVertexInputDynamicStateFeaturesEXT";
        case(StructureType::VertexInputBindingDescription2EXT): return "VertexInputBindingDescription2EXT";
        case(StructureType::VertexInputAttributeDescription2EXT): return "VertexInputAttributeDescription2EXT";
        case(StructureType::ImportMemoryZirconHandleInfoFUCHSIA): return "ImportMemoryZirconHandleInfoFUCHSIA";
        case(StructureType::MemoryZirconHandlePropertiesFUCHSIA): return "MemoryZirconHandlePropertiesFUCHSIA";
        case(StructureType::MemoryGetZirconHandleInfoFUCHSIA): return "MemoryGetZirconHandleInfoFUCHSIA";
        case(StructureType::ImportSemaphoreZirconHandleInfoFUCHSIA): return "ImportSemaphoreZirconHandleInfoFUCHSIA";
        case(StructureType::SemaphoreGetZirconHandleInfoFUCHSIA): return "SemaphoreGetZirconHandleInfoFUCHSIA";
        case(StructureType::PhysicalDeviceExtendedDynamicState2FeaturesEXT): return "PhysicalDeviceExtendedDynamicState2FeaturesEXT";
        case(StructureType::ScreenSurfaceCreateInfoQNX): return "ScreenSurfaceCreateInfoQNX";
        case(StructureType::PhysicalDeviceColorWriteEnableFeaturesEXT): return "PhysicalDeviceColorWriteEnableFeaturesEXT";
        case(StructureType::PipelineColorWriteCreateInfoEXT): return "PipelineColorWriteCreateInfoEXT";
        case(StructureType::PhysicalDeviceSubgroupProperties): return "PhysicalDeviceSubgroupProperties";
        case(StructureType::BindBufferMemoryInfo): return "BindBufferMemoryInfo";
        case(StructureType::BindImageMemoryInfo): return "BindImageMemoryInfo";
        case(StructureType::PhysicalDevice16BitStorageFeatures): return "PhysicalDevice16BitStorageFeatures";
        case(StructureType::MemoryDedicatedRequirements): return "MemoryDedicatedRequirements";
        case(StructureType::MemoryDedicatedAllocateInfo): return "MemoryDedicatedAllocateInfo";
        case(StructureType::MemoryAllocateFlagsInfo): return "MemoryAllocateFlagsInfo";
        case(StructureType::DeviceGroupRenderPassBeginInfo): return "DeviceGroupRenderPassBeginInfo";
        case(StructureType::DeviceGroupCommandBufferBeginInfo): return "DeviceGroupCommandBufferBeginInfo";
        case(StructureType::DeviceGroupSubmitInfo): return "DeviceGroupSubmitInfo";
        case(StructureType::DeviceGroupBindSparseInfo): return "DeviceGroupBindSparseInfo";
        case(StructureType::BindBufferMemoryDeviceGroupInfo): return "BindBufferMemoryDeviceGroupInfo";
        case(StructureType::BindImageMemoryDeviceGroupInfo): return "BindImageMemoryDeviceGroupInfo";
        case(StructureType::PhysicalDeviceGroupProperties): return "PhysicalDeviceGroupProperties";
        case(StructureType::DeviceGroupDeviceCreateInfo): return "DeviceGroupDeviceCreateInfo";
        case(StructureType::BufferMemoryRequirementsInfo2): return "BufferMemoryRequirementsInfo2";
        case(StructureType::ImageMemoryRequirementsInfo2): return "ImageMemoryRequirementsInfo2";
        case(StructureType::ImageSparseMemoryRequirementsInfo2): return "ImageSparseMemoryRequirementsInfo2";
        case(StructureType::MemoryRequirements2): return "MemoryRequirements2";
        case(StructureType::SparseImageMemoryRequirements2): return "SparseImageMemoryRequirements2";
        case(StructureType::PhysicalDeviceFeatures2): return "PhysicalDeviceFeatures2";
        case(StructureType::PhysicalDeviceProperties2): return "PhysicalDeviceProperties2";
        case(StructureType::FormatProperties2): return "FormatProperties2";
        case(StructureType::ImageFormatProperties2): return "ImageFormatProperties2";
        case(StructureType::PhysicalDeviceImageFormatInfo2): return "PhysicalDeviceImageFormatInfo2";
        case(StructureType::QueueFamilyProperties2): return "QueueFamilyProperties2";
        case(StructureType::PhysicalDeviceMemoryProperties2): return "PhysicalDeviceMemoryProperties2";
        case(StructureType::SparseImageFormatProperties2): return "SparseImageFormatProperties2";
        case(StructureType::PhysicalDeviceSparseImageFormatInfo2): return "PhysicalDeviceSparseImageFormatInfo2";
        case(StructureType::PhysicalDevicePointClippingProperties): return "PhysicalDevicePointClippingProperties";
        case(StructureType::RenderPassInputAttachmentAspectCreateInfo): return "RenderPassInputAttachmentAspectCreateInfo";
        case(StructureType::ImageViewUsageCreateInfo): return "ImageViewUsageCreateInfo";
        case(StructureType::PipelineTessellationDomainOriginStateCreateInfo): return "PipelineTessellationDomainOriginStateCreateInfo";
        case(StructureType::RenderPassMultiviewCreateInfo): return "RenderPassMultiviewCreateInfo";
        case(StructureType::PhysicalDeviceMultiviewFeatures): return "PhysicalDeviceMultiviewFeatures";
        case(StructureType::PhysicalDeviceMultiviewProperties): return "PhysicalDeviceMultiviewProperties";
        case(StructureType::PhysicalDeviceVariablePointersFeatures): return "PhysicalDeviceVariablePointersFeatures";
        case(StructureType::ProtectedSubmitInfo): return "ProtectedSubmitInfo";
        case(StructureType::PhysicalDeviceProtectedMemoryFeatures): return "PhysicalDeviceProtectedMemoryFeatures";
        case(StructureType::PhysicalDeviceProtectedMemoryProperties): return "PhysicalDeviceProtectedMemoryProperties";
        case(StructureType::DeviceQueueInfo2): return "DeviceQueueInfo2";
        case(StructureType::SamplerYcbcrConversionCreateInfo): return "SamplerYcbcrConversionCreateInfo";
        case(StructureType::SamplerYcbcrConversionInfo): return "SamplerYcbcrConversionInfo";
        case(StructureType::BindImagePlaneMemoryInfo): return "BindImagePlaneMemoryInfo";
        case(StructureType::ImagePlaneMemoryRequirementsInfo): return "ImagePlaneMemoryRequirementsInfo";
        case(StructureType::PhysicalDeviceSamplerYcbcrConversionFeatures): return "PhysicalDeviceSamplerYcbcrConversionFeatures";
        case(StructureType::SamplerYcbcrConversionImageFormatProperties): return "SamplerYcbcrConversionImageFormatProperties";
        case(StructureType::DescriptorUpdateTemplateCreateInfo): return "DescriptorUpdateTemplateCreateInfo";
        case(StructureType::PhysicalDeviceExternalImageFormatInfo): return "PhysicalDeviceExternalImageFormatInfo";
        case(StructureType::ExternalImageFormatProperties): return "ExternalImageFormatProperties";
        case(StructureType::PhysicalDeviceExternalBufferInfo): return "PhysicalDeviceExternalBufferInfo";
        case(StructureType::ExternalBufferProperties): return "ExternalBufferProperties";
        case(StructureType::PhysicalDeviceIdProperties): return "PhysicalDeviceIdProperties";
        case(StructureType::ExternalMemoryBufferCreateInfo): return "ExternalMemoryBufferCreateInfo";
        case(StructureType::ExternalMemoryImageCreateInfo): return "ExternalMemoryImageCreateInfo";
        case(StructureType::ExportMemoryAllocateInfo): return "ExportMemoryAllocateInfo";
        case(StructureType::PhysicalDeviceExternalFenceInfo): return "PhysicalDeviceExternalFenceInfo";
        case(StructureType::ExternalFenceProperties): return "ExternalFenceProperties";
        case(StructureType::ExportFenceCreateInfo): return "ExportFenceCreateInfo";
        case(StructureType::ExportSemaphoreCreateInfo): return "ExportSemaphoreCreateInfo";
        case(StructureType::PhysicalDeviceExternalSemaphoreInfo): return "PhysicalDeviceExternalSemaphoreInfo";
        case(StructureType::ExternalSemaphoreProperties): return "ExternalSemaphoreProperties";
        case(StructureType::PhysicalDeviceMaintenance3Properties): return "PhysicalDeviceMaintenance3Properties";
        case(StructureType::DescriptorSetLayoutSupport): return "DescriptorSetLayoutSupport";
        case(StructureType::PhysicalDeviceShaderDrawParametersFeatures): return "PhysicalDeviceShaderDrawParametersFeatures";
        case(StructureType::PhysicalDeviceVulkan11Features): return "PhysicalDeviceVulkan11Features";
        case(StructureType::PhysicalDeviceVulkan11Properties): return "PhysicalDeviceVulkan11Properties";
        case(StructureType::PhysicalDeviceVulkan12Features): return "PhysicalDeviceVulkan12Features";
        case(StructureType::PhysicalDeviceVulkan12Properties): return "PhysicalDeviceVulkan12Properties";
        case(StructureType::ImageFormatListCreateInfo): return "ImageFormatListCreateInfo";
        case(StructureType::AttachmentDescription2): return "AttachmentDescription2";
        case(StructureType::AttachmentReference2): return "AttachmentReference2";
        case(StructureType::SubpassDescription2): return "SubpassDescription2";
        case(StructureType::SubpassDependency2): return "SubpassDependency2";
        case(StructureType::RenderPassCreateInfo2): return "RenderPassCreateInfo2";
        case(StructureType::SubpassBeginInfo): return "SubpassBeginInfo";
        case(StructureType::SubpassEndInfo): return "SubpassEndInfo";
        case(StructureType::PhysicalDevice8BitStorageFeatures): return "PhysicalDevice8BitStorageFeatures";
        case(StructureType::PhysicalDeviceDriverProperties): return "PhysicalDeviceDriverProperties";
        case(StructureType::PhysicalDeviceShaderAtomicInt64Features): return "PhysicalDeviceShaderAtomicInt64Features";
        case(StructureType::PhysicalDeviceShaderFloat16Int8Features): return "PhysicalDeviceShaderFloat16Int8Features";
        case(StructureType::PhysicalDeviceFloatControlsProperties): return "PhysicalDeviceFloatControlsProperties";
        case(StructureType::DescriptorSetLayoutBindingFlagsCreateInfo): return "DescriptorSetLayoutBindingFlagsCreateInfo";
        case(StructureType::PhysicalDeviceDescriptorIndexingFeatures): return "PhysicalDeviceDescriptorIndexingFeatures";
        case(StructureType::PhysicalDeviceDescriptorIndexingProperties): return "PhysicalDeviceDescriptorIndexingProperties";
        case(StructureType::DescriptorSetVariableDescriptorCountAllocateInfo): return "DescriptorSetVariableDescriptorCountAllocateInfo";
        case(StructureType::DescriptorSetVariableDescriptorCountLayoutSupport): return "DescriptorSetVariableDescriptorCountLayoutSupport";
        case(StructureType::PhysicalDeviceDepthStencilResolveProperties): return "PhysicalDeviceDepthStencilResolveProperties";
        case(StructureType::SubpassDescriptionDepthStencilResolve): return "SubpassDescriptionDepthStencilResolve";
        case(StructureType::PhysicalDeviceScalarBlockLayoutFeatures): return "PhysicalDeviceScalarBlockLayoutFeatures";
        case(StructureType::ImageStencilUsageCreateInfo): return "ImageStencilUsageCreateInfo";
        case(StructureType::PhysicalDeviceSamplerFilterMinmaxProperties): return "PhysicalDeviceSamplerFilterMinmaxProperties";
        case(StructureType::SamplerReductionModeCreateInfo): return "SamplerReductionModeCreateInfo";
        case(StructureType::PhysicalDeviceVulkanMemoryModelFeatures): return "PhysicalDeviceVulkanMemoryModelFeatures";
        case(StructureType::PhysicalDeviceImagelessFramebufferFeatures): return "PhysicalDeviceImagelessFramebufferFeatures";
        case(StructureType::FramebufferAttachmentsCreateInfo): return "FramebufferAttachmentsCreateInfo";
        case(StructureType::FramebufferAttachmentImageInfo): return "FramebufferAttachmentImageInfo";
        case(StructureType::RenderPassAttachmentBeginInfo): return "RenderPassAttachmentBeginInfo";
        case(StructureType::PhysicalDeviceUniformBufferStandardLayoutFeatures): return "PhysicalDeviceUniformBufferStandardLayoutFeatures";
        case(StructureType::PhysicalDeviceShaderSubgroupExtendedTypesFeatures): return "PhysicalDeviceShaderSubgroupExtendedTypesFeatures";
        case(StructureType::PhysicalDeviceSeparateDepthStencilLayoutsFeatures): return "PhysicalDeviceSeparateDepthStencilLayoutsFeatures";
        case(StructureType::AttachmentReferenceStencilLayout): return "AttachmentReferenceStencilLayout";
        case(StructureType::AttachmentDescriptionStencilLayout): return "AttachmentDescriptionStencilLayout";
        case(StructureType::PhysicalDeviceHostQueryResetFeatures): return "PhysicalDeviceHostQueryResetFeatures";
        case(StructureType::PhysicalDeviceTimelineSemaphoreFeatures): return "PhysicalDeviceTimelineSemaphoreFeatures";
        case(StructureType::PhysicalDeviceTimelineSemaphoreProperties): return "PhysicalDeviceTimelineSemaphoreProperties";
        case(StructureType::SemaphoreTypeCreateInfo): return "SemaphoreTypeCreateInfo";
        case(StructureType::TimelineSemaphoreSubmitInfo): return "TimelineSemaphoreSubmitInfo";
        case(StructureType::SemaphoreWaitInfo): return "SemaphoreWaitInfo";
        case(StructureType::SemaphoreSignalInfo): return "SemaphoreSignalInfo";
        case(StructureType::PhysicalDeviceBufferDeviceAddressFeatures): return "PhysicalDeviceBufferDeviceAddressFeatures";
        case(StructureType::BufferDeviceAddressInfo): return "BufferDeviceAddressInfo";
        case(StructureType::BufferOpaqueCaptureAddressCreateInfo): return "BufferOpaqueCaptureAddressCreateInfo";
        case(StructureType::MemoryOpaqueCaptureAddressAllocateInfo): return "MemoryOpaqueCaptureAddressAllocateInfo";
        case(StructureType::DeviceMemoryOpaqueCaptureAddressInfo): return "DeviceMemoryOpaqueCaptureAddressInfo";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SystemAllocationScope val) {
    switch(val) {
        case(SystemAllocationScope::Command): return "Command";
        case(SystemAllocationScope::Object): return "Object";
        case(SystemAllocationScope::Cache): return "Cache";
        case(SystemAllocationScope::Device): return "Device";
        case(SystemAllocationScope::Instance): return "Instance";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(InternalAllocationType val) {
    switch(val) {
        case(InternalAllocationType::Executable): return "Executable";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SamplerAddressMode val) {
    switch(val) {
        case(SamplerAddressMode::Repeat): return "Repeat";
        case(SamplerAddressMode::MirroredRepeat): return "MirroredRepeat";
        case(SamplerAddressMode::ClampToEdge): return "ClampToEdge";
        case(SamplerAddressMode::ClampToBorder): return "ClampToBorder";
        case(SamplerAddressMode::MirrorClampToEdge): return "MirrorClampToEdge";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(Filter val) {
    switch(val) {
        case(Filter::Nearest): return "Nearest";
        case(Filter::Linear): return "Linear";
        case(Filter::CubicIMG): return "CubicIMG";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SamplerMipmapMode val) {
    switch(val) {
        case(SamplerMipmapMode::Nearest): return "Nearest";
        case(SamplerMipmapMode::Linear): return "Linear";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(VertexInputRate val) {
    switch(val) {
        case(VertexInputRate::Vertex): return "Vertex";
        case(VertexInputRate::Instance): return "Instance";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ObjectType val) {
    switch(val) {
        case(ObjectType::Unknown): return "Unknown";
        case(ObjectType::Instance): return "Instance";
        case(ObjectType::PhysicalDevice): return "PhysicalDevice";
        case(ObjectType::Device): return "Device";
        case(ObjectType::Queue): return "Queue";
        case(ObjectType::Semaphore): return "Semaphore";
        case(ObjectType::CommandBuffer): return "CommandBuffer";
        case(ObjectType::Fence): return "Fence";
        case(ObjectType::DeviceMemory): return "DeviceMemory";
        case(ObjectType::Buffer): return "Buffer";
        case(ObjectType::Image): return "Image";
        case(ObjectType::Event): return "Event";
        case(ObjectType::QueryPool): return "QueryPool";
        case(ObjectType::BufferView): return "BufferView";
        case(ObjectType::ImageView): return "ImageView";
        case(ObjectType::ShaderModule): return "ShaderModule";
        case(ObjectType::PipelineCache): return "PipelineCache";
        case(ObjectType::PipelineLayout): return "PipelineLayout";
        case(ObjectType::RenderPass): return "RenderPass";
        case(ObjectType::Pipeline): return "Pipeline";
        case(ObjectType::DescriptorSetLayout): return "DescriptorSetLayout";
        case(ObjectType::Sampler): return "Sampler";
        case(ObjectType::DescriptorPool): return "DescriptorPool";
        case(ObjectType::DescriptorSet): return "DescriptorSet";
        case(ObjectType::Framebuffer): return "Framebuffer";
        case(ObjectType::CommandPool): return "CommandPool";
        case(ObjectType::SurfaceKHR): return "SurfaceKHR";
        case(ObjectType::SwapchainKHR): return "SwapchainKHR";
        case(ObjectType::DisplayKHR): return "DisplayKHR";
        case(ObjectType::DisplayModeKHR): return "DisplayModeKHR";
        case(ObjectType::DebugReportCallbackEXT): return "DebugReportCallbackEXT";
        case(ObjectType::VideoSessionKHR): return "VideoSessionKHR";
        case(ObjectType::VideoSessionParametersKHR): return "VideoSessionParametersKHR";
        case(ObjectType::DebugUtilsMessengerEXT): return "DebugUtilsMessengerEXT";
        case(ObjectType::AccelerationStructureKHR): return "AccelerationStructureKHR";
        case(ObjectType::ValidationCacheEXT): return "ValidationCacheEXT";
        case(ObjectType::AccelerationStructureNV): return "AccelerationStructureNV";
        case(ObjectType::PerformanceConfigurationINTEL): return "PerformanceConfigurationINTEL";
        case(ObjectType::DeferredOperationKHR): return "DeferredOperationKHR";
        case(ObjectType::IndirectCommandsLayoutNV): return "IndirectCommandsLayoutNV";
        case(ObjectType::PrivateDataSlotEXT): return "PrivateDataSlotEXT";
        case(ObjectType::SamplerYcbcrConversion): return "SamplerYcbcrConversion";
        case(ObjectType::DescriptorUpdateTemplate): return "DescriptorUpdateTemplate";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(IndirectCommandsTokenTypeNV val) {
    switch(val) {
        case(IndirectCommandsTokenTypeNV::ShaderGroupNV): return "ShaderGroupNV";
        case(IndirectCommandsTokenTypeNV::StateFlagsNV): return "StateFlagsNV";
        case(IndirectCommandsTokenTypeNV::IndexBufferNV): return "IndexBufferNV";
        case(IndirectCommandsTokenTypeNV::VertexBufferNV): return "VertexBufferNV";
        case(IndirectCommandsTokenTypeNV::PushConstantNV): return "PushConstantNV";
        case(IndirectCommandsTokenTypeNV::DrawIndexedNV): return "DrawIndexedNV";
        case(IndirectCommandsTokenTypeNV::DrawNV): return "DrawNV";
        case(IndirectCommandsTokenTypeNV::DrawTasksNV): return "DrawTasksNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DescriptorUpdateTemplateType val) {
    switch(val) {
        case(DescriptorUpdateTemplateType::DescriptorSet): return "DescriptorSet";
        case(DescriptorUpdateTemplateType::PushDescriptorsKHR): return "PushDescriptorsKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ViewportCoordinateSwizzleNV val) {
    switch(val) {
        case(ViewportCoordinateSwizzleNV::PositiveXNV): return "PositiveXNV";
        case(ViewportCoordinateSwizzleNV::NegativeXNV): return "NegativeXNV";
        case(ViewportCoordinateSwizzleNV::PositiveYNV): return "PositiveYNV";
        case(ViewportCoordinateSwizzleNV::NegativeYNV): return "NegativeYNV";
        case(ViewportCoordinateSwizzleNV::PositiveZNV): return "PositiveZNV";
        case(ViewportCoordinateSwizzleNV::NegativeZNV): return "NegativeZNV";
        case(ViewportCoordinateSwizzleNV::PositiveWNV): return "PositiveWNV";
        case(ViewportCoordinateSwizzleNV::NegativeWNV): return "NegativeWNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DiscardRectangleModeEXT val) {
    switch(val) {
        case(DiscardRectangleModeEXT::InclusiveEXT): return "InclusiveEXT";
        case(DiscardRectangleModeEXT::ExclusiveEXT): return "ExclusiveEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PointClippingBehavior val) {
    switch(val) {
        case(PointClippingBehavior::AllClipPlanes): return "AllClipPlanes";
        case(PointClippingBehavior::UserClipPlanesOnly): return "UserClipPlanesOnly";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(CoverageModulationModeNV val) {
    switch(val) {
        case(CoverageModulationModeNV::NoneNV): return "NoneNV";
        case(CoverageModulationModeNV::RgbNV): return "RgbNV";
        case(CoverageModulationModeNV::AlphaNV): return "AlphaNV";
        case(CoverageModulationModeNV::RgbaNV): return "RgbaNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(CoverageReductionModeNV val) {
    switch(val) {
        case(CoverageReductionModeNV::MergeNV): return "MergeNV";
        case(CoverageReductionModeNV::TruncateNV): return "TruncateNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ValidationCacheHeaderVersionEXT val) {
    switch(val) {
        case(ValidationCacheHeaderVersionEXT::OneEXT): return "OneEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ShaderInfoTypeAMD val) {
    switch(val) {
        case(ShaderInfoTypeAMD::StatisticsAMD): return "StatisticsAMD";
        case(ShaderInfoTypeAMD::BinaryAMD): return "BinaryAMD";
        case(ShaderInfoTypeAMD::DisassemblyAMD): return "DisassemblyAMD";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(QueueGlobalPriorityEXT val) {
    switch(val) {
        case(QueueGlobalPriorityEXT::LowEXT): return "LowEXT";
        case(QueueGlobalPriorityEXT::MediumEXT): return "MediumEXT";
        case(QueueGlobalPriorityEXT::HighEXT): return "HighEXT";
        case(QueueGlobalPriorityEXT::RealtimeEXT): return "RealtimeEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(TimeDomainEXT val) {
    switch(val) {
        case(TimeDomainEXT::DeviceEXT): return "DeviceEXT";
        case(TimeDomainEXT::ClockMonotonicEXT): return "ClockMonotonicEXT";
        case(TimeDomainEXT::ClockMonotonicRawEXT): return "ClockMonotonicRawEXT";
        case(TimeDomainEXT::QueryPerformanceCounterEXT): return "QueryPerformanceCounterEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ConservativeRasterizationModeEXT val) {
    switch(val) {
        case(ConservativeRasterizationModeEXT::DisabledEXT): return "DisabledEXT";
        case(ConservativeRasterizationModeEXT::OverestimateEXT): return "OverestimateEXT";
        case(ConservativeRasterizationModeEXT::UnderestimateEXT): return "UnderestimateEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SemaphoreType val) {
    switch(val) {
        case(SemaphoreType::Binary): return "Binary";
        case(SemaphoreType::Timeline): return "Timeline";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(BuildAccelerationStructureModeKHR val) {
    switch(val) {
        case(BuildAccelerationStructureModeKHR::BuildKHR): return "BuildKHR";
        case(BuildAccelerationStructureModeKHR::UpdateKHR): return "UpdateKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(CopyAccelerationStructureModeKHR val) {
    switch(val) {
        case(CopyAccelerationStructureModeKHR::CloneKHR): return "CloneKHR";
        case(CopyAccelerationStructureModeKHR::CompactKHR): return "CompactKHR";
        case(CopyAccelerationStructureModeKHR::SerializeKHR): return "SerializeKHR";
        case(CopyAccelerationStructureModeKHR::DeserializeKHR): return "DeserializeKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(AccelerationStructureTypeKHR val) {
    switch(val) {
        case(AccelerationStructureTypeKHR::TopLevelKHR): return "TopLevelKHR";
        case(AccelerationStructureTypeKHR::BottomLevelKHR): return "BottomLevelKHR";
        case(AccelerationStructureTypeKHR::GenericKHR): return "GenericKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(GeometryTypeKHR val) {
    switch(val) {
        case(GeometryTypeKHR::TrianglesKHR): return "TrianglesKHR";
        case(GeometryTypeKHR::AabbsKHR): return "AabbsKHR";
        case(GeometryTypeKHR::InstancesKHR): return "InstancesKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(RayTracingShaderGroupTypeKHR val) {
    switch(val) {
        case(RayTracingShaderGroupTypeKHR::GeneralKHR): return "GeneralKHR";
        case(RayTracingShaderGroupTypeKHR::TrianglesHitGroupKHR): return "TrianglesHitGroupKHR";
        case(RayTracingShaderGroupTypeKHR::ProceduralHitGroupKHR): return "ProceduralHitGroupKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(AccelerationStructureMemoryRequirementsTypeNV val) {
    switch(val) {
        case(AccelerationStructureMemoryRequirementsTypeNV::ObjectNV): return "ObjectNV";
        case(AccelerationStructureMemoryRequirementsTypeNV::BuildScratchNV): return "BuildScratchNV";
        case(AccelerationStructureMemoryRequirementsTypeNV::UpdateScratchNV): return "UpdateScratchNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(AccelerationStructureBuildTypeKHR val) {
    switch(val) {
        case(AccelerationStructureBuildTypeKHR::HostKHR): return "HostKHR";
        case(AccelerationStructureBuildTypeKHR::DeviceKHR): return "DeviceKHR";
        case(AccelerationStructureBuildTypeKHR::HostOrDeviceKHR): return "HostOrDeviceKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(AccelerationStructureCompatibilityKHR val) {
    switch(val) {
        case(AccelerationStructureCompatibilityKHR::CompatibleKHR): return "CompatibleKHR";
        case(AccelerationStructureCompatibilityKHR::IncompatibleKHR): return "IncompatibleKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ShaderGroupShaderKHR val) {
    switch(val) {
        case(ShaderGroupShaderKHR::GeneralKHR): return "GeneralKHR";
        case(ShaderGroupShaderKHR::ClosestHitKHR): return "ClosestHitKHR";
        case(ShaderGroupShaderKHR::AnyHitKHR): return "AnyHitKHR";
        case(ShaderGroupShaderKHR::IntersectionKHR): return "IntersectionKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(MemoryOverallocationBehaviorAMD val) {
    switch(val) {
        case(MemoryOverallocationBehaviorAMD::DefaultAMD): return "DefaultAMD";
        case(MemoryOverallocationBehaviorAMD::AllowedAMD): return "AllowedAMD";
        case(MemoryOverallocationBehaviorAMD::DisallowedAMD): return "DisallowedAMD";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ScopeNV val) {
    switch(val) {
        case(ScopeNV::DeviceNV): return "DeviceNV";
        case(ScopeNV::WorkgroupNV): return "WorkgroupNV";
        case(ScopeNV::SubgroupNV): return "SubgroupNV";
        case(ScopeNV::QueueFamilyNV): return "QueueFamilyNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ComponentTypeNV val) {
    switch(val) {
        case(ComponentTypeNV::Float16NV): return "Float16NV";
        case(ComponentTypeNV::Float32NV): return "Float32NV";
        case(ComponentTypeNV::Float64NV): return "Float64NV";
        case(ComponentTypeNV::Sint8NV): return "Sint8NV";
        case(ComponentTypeNV::Sint16NV): return "Sint16NV";
        case(ComponentTypeNV::Sint32NV): return "Sint32NV";
        case(ComponentTypeNV::Sint64NV): return "Sint64NV";
        case(ComponentTypeNV::Uint8NV): return "Uint8NV";
        case(ComponentTypeNV::Uint16NV): return "Uint16NV";
        case(ComponentTypeNV::Uint32NV): return "Uint32NV";
        case(ComponentTypeNV::Uint64NV): return "Uint64NV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceCounterScopeKHR val) {
    switch(val) {
        case(PerformanceCounterScopeKHR::CommandBufferKHR): return "CommandBufferKHR";
        case(PerformanceCounterScopeKHR::RenderPassKHR): return "RenderPassKHR";
        case(PerformanceCounterScopeKHR::CommandKHR): return "CommandKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceCounterUnitKHR val) {
    switch(val) {
        case(PerformanceCounterUnitKHR::GenericKHR): return "GenericKHR";
        case(PerformanceCounterUnitKHR::PercentageKHR): return "PercentageKHR";
        case(PerformanceCounterUnitKHR::NanosecondsKHR): return "NanosecondsKHR";
        case(PerformanceCounterUnitKHR::BytesKHR): return "BytesKHR";
        case(PerformanceCounterUnitKHR::BytesPerSecondKHR): return "BytesPerSecondKHR";
        case(PerformanceCounterUnitKHR::KelvinKHR): return "KelvinKHR";
        case(PerformanceCounterUnitKHR::WattsKHR): return "WattsKHR";
        case(PerformanceCounterUnitKHR::VoltsKHR): return "VoltsKHR";
        case(PerformanceCounterUnitKHR::AmpsKHR): return "AmpsKHR";
        case(PerformanceCounterUnitKHR::HertzKHR): return "HertzKHR";
        case(PerformanceCounterUnitKHR::CyclesKHR): return "CyclesKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceCounterStorageKHR val) {
    switch(val) {
        case(PerformanceCounterStorageKHR::Int32KHR): return "Int32KHR";
        case(PerformanceCounterStorageKHR::Int64KHR): return "Int64KHR";
        case(PerformanceCounterStorageKHR::Uint32KHR): return "Uint32KHR";
        case(PerformanceCounterStorageKHR::Uint64KHR): return "Uint64KHR";
        case(PerformanceCounterStorageKHR::Float32KHR): return "Float32KHR";
        case(PerformanceCounterStorageKHR::Float64KHR): return "Float64KHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceConfigurationTypeINTEL val) {
    switch(val) {
        case(PerformanceConfigurationTypeINTEL::CommandQueueMetricsDiscoveryActivatedINTEL): return "CommandQueueMetricsDiscoveryActivatedINTEL";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(QueryPoolSamplingModeINTEL val) {
    switch(val) {
        case(QueryPoolSamplingModeINTEL::ManualINTEL): return "ManualINTEL";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceOverrideTypeINTEL val) {
    switch(val) {
        case(PerformanceOverrideTypeINTEL::NullHardwareINTEL): return "NullHardwareINTEL";
        case(PerformanceOverrideTypeINTEL::FlushGpuCachesINTEL): return "FlushGpuCachesINTEL";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceParameterTypeINTEL val) {
    switch(val) {
        case(PerformanceParameterTypeINTEL::HwCountersSupportedINTEL): return "HwCountersSupportedINTEL";
        case(PerformanceParameterTypeINTEL::StreamMarkerValidBitsINTEL): return "StreamMarkerValidBitsINTEL";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PerformanceValueTypeINTEL val) {
    switch(val) {
        case(PerformanceValueTypeINTEL::Uint32INTEL): return "Uint32INTEL";
        case(PerformanceValueTypeINTEL::Uint64INTEL): return "Uint64INTEL";
        case(PerformanceValueTypeINTEL::FloatINTEL): return "FloatINTEL";
        case(PerformanceValueTypeINTEL::BoolINTEL): return "BoolINTEL";
        case(PerformanceValueTypeINTEL::StringINTEL): return "StringINTEL";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(LineRasterizationModeEXT val) {
    switch(val) {
        case(LineRasterizationModeEXT::DefaultEXT): return "DefaultEXT";
        case(LineRasterizationModeEXT::RectangularEXT): return "RectangularEXT";
        case(LineRasterizationModeEXT::BresenhamEXT): return "BresenhamEXT";
        case(LineRasterizationModeEXT::RectangularSmoothEXT): return "RectangularSmoothEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(FragmentShadingRateNV val) {
    switch(val) {
        case(FragmentShadingRateNV::e1InvocationPerPixelNV): return "e1InvocationPerPixelNV";
        case(FragmentShadingRateNV::e1InvocationPer1X2PixelsNV): return "e1InvocationPer1X2PixelsNV";
        case(FragmentShadingRateNV::e1InvocationPer2X1PixelsNV): return "e1InvocationPer2X1PixelsNV";
        case(FragmentShadingRateNV::e1InvocationPer2X2PixelsNV): return "e1InvocationPer2X2PixelsNV";
        case(FragmentShadingRateNV::e1InvocationPer2X4PixelsNV): return "e1InvocationPer2X4PixelsNV";
        case(FragmentShadingRateNV::e1InvocationPer4X2PixelsNV): return "e1InvocationPer4X2PixelsNV";
        case(FragmentShadingRateNV::e1InvocationPer4X4PixelsNV): return "e1InvocationPer4X4PixelsNV";
        case(FragmentShadingRateNV::e2InvocationsPerPixelNV): return "e2InvocationsPerPixelNV";
        case(FragmentShadingRateNV::e4InvocationsPerPixelNV): return "e4InvocationsPerPixelNV";
        case(FragmentShadingRateNV::e8InvocationsPerPixelNV): return "e8InvocationsPerPixelNV";
        case(FragmentShadingRateNV::e16InvocationsPerPixelNV): return "e16InvocationsPerPixelNV";
        case(FragmentShadingRateNV::NoInvocationsNV): return "NoInvocationsNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(FragmentShadingRateTypeNV val) {
    switch(val) {
        case(FragmentShadingRateTypeNV::FragmentSizeNV): return "FragmentSizeNV";
        case(FragmentShadingRateTypeNV::EnumsNV): return "EnumsNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ColorSpaceKHR val) {
    switch(val) {
        case(ColorSpaceKHR::SrgbNonlinearKHR): return "SrgbNonlinearKHR";
        case(ColorSpaceKHR::DisplayP3NonlinearEXT): return "DisplayP3NonlinearEXT";
        case(ColorSpaceKHR::ExtendedSrgbLinearEXT): return "ExtendedSrgbLinearEXT";
        case(ColorSpaceKHR::DisplayP3LinearEXT): return "DisplayP3LinearEXT";
        case(ColorSpaceKHR::DciP3NonlinearEXT): return "DciP3NonlinearEXT";
        case(ColorSpaceKHR::Bt709LinearEXT): return "Bt709LinearEXT";
        case(ColorSpaceKHR::Bt709NonlinearEXT): return "Bt709NonlinearEXT";
        case(ColorSpaceKHR::Bt2020LinearEXT): return "Bt2020LinearEXT";
        case(ColorSpaceKHR::Hdr10St2084EXT): return "Hdr10St2084EXT";
        case(ColorSpaceKHR::DolbyvisionEXT): return "DolbyvisionEXT";
        case(ColorSpaceKHR::Hdr10HlgEXT): return "Hdr10HlgEXT";
        case(ColorSpaceKHR::AdobergbLinearEXT): return "AdobergbLinearEXT";
        case(ColorSpaceKHR::AdobergbNonlinearEXT): return "AdobergbNonlinearEXT";
        case(ColorSpaceKHR::PassThroughEXT): return "PassThroughEXT";
        case(ColorSpaceKHR::ExtendedSrgbNonlinearEXT): return "ExtendedSrgbNonlinearEXT";
        case(ColorSpaceKHR::DisplayNativeAMD): return "DisplayNativeAMD";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PresentModeKHR val) {
    switch(val) {
        case(PresentModeKHR::ImmediateKHR): return "ImmediateKHR";
        case(PresentModeKHR::MailboxKHR): return "MailboxKHR";
        case(PresentModeKHR::FifoKHR): return "FifoKHR";
        case(PresentModeKHR::FifoRelaxedKHR): return "FifoRelaxedKHR";
        case(PresentModeKHR::SharedDemandRefreshKHR): return "SharedDemandRefreshKHR";
        case(PresentModeKHR::SharedContinuousRefreshKHR): return "SharedContinuousRefreshKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DebugReportObjectTypeEXT val) {
    switch(val) {
        case(DebugReportObjectTypeEXT::UnknownEXT): return "UnknownEXT";
        case(DebugReportObjectTypeEXT::InstanceEXT): return "InstanceEXT";
        case(DebugReportObjectTypeEXT::PhysicalDeviceEXT): return "PhysicalDeviceEXT";
        case(DebugReportObjectTypeEXT::DeviceEXT): return "DeviceEXT";
        case(DebugReportObjectTypeEXT::QueueEXT): return "QueueEXT";
        case(DebugReportObjectTypeEXT::SemaphoreEXT): return "SemaphoreEXT";
        case(DebugReportObjectTypeEXT::CommandBufferEXT): return "CommandBufferEXT";
        case(DebugReportObjectTypeEXT::FenceEXT): return "FenceEXT";
        case(DebugReportObjectTypeEXT::DeviceMemoryEXT): return "DeviceMemoryEXT";
        case(DebugReportObjectTypeEXT::BufferEXT): return "BufferEXT";
        case(DebugReportObjectTypeEXT::ImageEXT): return "ImageEXT";
        case(DebugReportObjectTypeEXT::EventEXT): return "EventEXT";
        case(DebugReportObjectTypeEXT::QueryPoolEXT): return "QueryPoolEXT";
        case(DebugReportObjectTypeEXT::BufferViewEXT): return "BufferViewEXT";
        case(DebugReportObjectTypeEXT::ImageViewEXT): return "ImageViewEXT";
        case(DebugReportObjectTypeEXT::ShaderModuleEXT): return "ShaderModuleEXT";
        case(DebugReportObjectTypeEXT::PipelineCacheEXT): return "PipelineCacheEXT";
        case(DebugReportObjectTypeEXT::PipelineLayoutEXT): return "PipelineLayoutEXT";
        case(DebugReportObjectTypeEXT::RenderPassEXT): return "RenderPassEXT";
        case(DebugReportObjectTypeEXT::PipelineEXT): return "PipelineEXT";
        case(DebugReportObjectTypeEXT::DescriptorSetLayoutEXT): return "DescriptorSetLayoutEXT";
        case(DebugReportObjectTypeEXT::SamplerEXT): return "SamplerEXT";
        case(DebugReportObjectTypeEXT::DescriptorPoolEXT): return "DescriptorPoolEXT";
        case(DebugReportObjectTypeEXT::DescriptorSetEXT): return "DescriptorSetEXT";
        case(DebugReportObjectTypeEXT::FramebufferEXT): return "FramebufferEXT";
        case(DebugReportObjectTypeEXT::CommandPoolEXT): return "CommandPoolEXT";
        case(DebugReportObjectTypeEXT::SurfaceKhrEXT): return "SurfaceKhrEXT";
        case(DebugReportObjectTypeEXT::SwapchainKhrEXT): return "SwapchainKhrEXT";
        case(DebugReportObjectTypeEXT::DebugReportCallbackExtEXT): return "DebugReportCallbackExtEXT";
        case(DebugReportObjectTypeEXT::DisplayKhrEXT): return "DisplayKhrEXT";
        case(DebugReportObjectTypeEXT::DisplayModeKhrEXT): return "DisplayModeKhrEXT";
        case(DebugReportObjectTypeEXT::ValidationCacheExtEXT): return "ValidationCacheExtEXT";
        case(DebugReportObjectTypeEXT::SamplerYcbcrConversionEXT): return "SamplerYcbcrConversionEXT";
        case(DebugReportObjectTypeEXT::DescriptorUpdateTemplateEXT): return "DescriptorUpdateTemplateEXT";
        case(DebugReportObjectTypeEXT::AccelerationStructureKhrEXT): return "AccelerationStructureKhrEXT";
        case(DebugReportObjectTypeEXT::AccelerationStructureNvEXT): return "AccelerationStructureNvEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DeviceMemoryReportEventTypeEXT val) {
    switch(val) {
        case(DeviceMemoryReportEventTypeEXT::AllocateEXT): return "AllocateEXT";
        case(DeviceMemoryReportEventTypeEXT::FreeEXT): return "FreeEXT";
        case(DeviceMemoryReportEventTypeEXT::ImportEXT): return "ImportEXT";
        case(DeviceMemoryReportEventTypeEXT::UnimportEXT): return "UnimportEXT";
        case(DeviceMemoryReportEventTypeEXT::AllocationFailedEXT): return "AllocationFailedEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(RasterizationOrderAMD val) {
    switch(val) {
        case(RasterizationOrderAMD::StrictAMD): return "StrictAMD";
        case(RasterizationOrderAMD::RelaxedAMD): return "RelaxedAMD";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ValidationCheckEXT val) {
    switch(val) {
        case(ValidationCheckEXT::AllEXT): return "AllEXT";
        case(ValidationCheckEXT::ShadersEXT): return "ShadersEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ValidationFeatureEnableEXT val) {
    switch(val) {
        case(ValidationFeatureEnableEXT::GpuAssistedEXT): return "GpuAssistedEXT";
        case(ValidationFeatureEnableEXT::GpuAssistedReserveBindingSlotEXT): return "GpuAssistedReserveBindingSlotEXT";
        case(ValidationFeatureEnableEXT::BestPracticesEXT): return "BestPracticesEXT";
        case(ValidationFeatureEnableEXT::DebugPrintfEXT): return "DebugPrintfEXT";
        case(ValidationFeatureEnableEXT::SynchronizationValidationEXT): return "SynchronizationValidationEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ValidationFeatureDisableEXT val) {
    switch(val) {
        case(ValidationFeatureDisableEXT::AllEXT): return "AllEXT";
        case(ValidationFeatureDisableEXT::ShadersEXT): return "ShadersEXT";
        case(ValidationFeatureDisableEXT::ThreadSafetyEXT): return "ThreadSafetyEXT";
        case(ValidationFeatureDisableEXT::ApiParametersEXT): return "ApiParametersEXT";
        case(ValidationFeatureDisableEXT::ObjectLifetimesEXT): return "ObjectLifetimesEXT";
        case(ValidationFeatureDisableEXT::CoreChecksEXT): return "CoreChecksEXT";
        case(ValidationFeatureDisableEXT::UniqueHandlesEXT): return "UniqueHandlesEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DisplayPowerStateEXT val) {
    switch(val) {
        case(DisplayPowerStateEXT::OffEXT): return "OffEXT";
        case(DisplayPowerStateEXT::SuspendEXT): return "SuspendEXT";
        case(DisplayPowerStateEXT::OnEXT): return "OnEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DeviceEventTypeEXT val) {
    switch(val) {
        case(DeviceEventTypeEXT::DisplayHotplugEXT): return "DisplayHotplugEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DisplayEventTypeEXT val) {
    switch(val) {
        case(DisplayEventTypeEXT::FirstPixelOutEXT): return "FirstPixelOutEXT";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(TessellationDomainOrigin val) {
    switch(val) {
        case(TessellationDomainOrigin::UpperLeft): return "UpperLeft";
        case(TessellationDomainOrigin::LowerLeft): return "LowerLeft";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SamplerYcbcrModelConversion val) {
    switch(val) {
        case(SamplerYcbcrModelConversion::RgbIdentity): return "RgbIdentity";
        case(SamplerYcbcrModelConversion::YcbcrIdentity): return "YcbcrIdentity";
        case(SamplerYcbcrModelConversion::Ycbcr709): return "Ycbcr709";
        case(SamplerYcbcrModelConversion::Ycbcr601): return "Ycbcr601";
        case(SamplerYcbcrModelConversion::Ycbcr2020): return "Ycbcr2020";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SamplerYcbcrRange val) {
    switch(val) {
        case(SamplerYcbcrRange::ItuFull): return "ItuFull";
        case(SamplerYcbcrRange::ItuNarrow): return "ItuNarrow";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ChromaLocation val) {
    switch(val) {
        case(ChromaLocation::CositedEven): return "CositedEven";
        case(ChromaLocation::Midpoint): return "Midpoint";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(SamplerReductionMode val) {
    switch(val) {
        case(SamplerReductionMode::WeightedAverage): return "WeightedAverage";
        case(SamplerReductionMode::Min): return "Min";
        case(SamplerReductionMode::Max): return "Max";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(BlendOverlapEXT val) {
    switch(val) {
        case(BlendOverlapEXT::UncorrelatedEXT): return "UncorrelatedEXT";
        case(BlendOverlapEXT::DisjointEXT): return "DisjointEXT";
        case(BlendOverlapEXT::ConjointEXT): return "ConjointEXT";
        default: return "UNKNOWN";
    }
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline const char * to_string(FullScreenExclusiveEXT val) {
    switch(val) {
        case(FullScreenExclusiveEXT::DefaultEXT): return "DefaultEXT";
        case(FullScreenExclusiveEXT::AllowedEXT): return "AllowedEXT";
        case(FullScreenExclusiveEXT::DisallowedEXT): return "DisallowedEXT";
        case(FullScreenExclusiveEXT::ApplicationControlledEXT): return "ApplicationControlledEXT";
        default: return "UNKNOWN";
    }
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
inline const char * to_string(ShaderFloatControlsIndependence val) {
    switch(val) {
        case(ShaderFloatControlsIndependence::e32BitOnly): return "e32BitOnly";
        case(ShaderFloatControlsIndependence::All): return "All";
        case(ShaderFloatControlsIndependence::None): return "None";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(FragmentShadingRateCombinerOpKHR val) {
    switch(val) {
        case(FragmentShadingRateCombinerOpKHR::KeepKHR): return "KeepKHR";
        case(FragmentShadingRateCombinerOpKHR::ReplaceKHR): return "ReplaceKHR";
        case(FragmentShadingRateCombinerOpKHR::MinKHR): return "MinKHR";
        case(FragmentShadingRateCombinerOpKHR::MaxKHR): return "MaxKHR";
        case(FragmentShadingRateCombinerOpKHR::MulKHR): return "MulKHR";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(VendorId val) {
    switch(val) {
        case(VendorId::VIV): return "VIV";
        case(VendorId::VSI): return "VSI";
        case(VendorId::Kazan): return "Kazan";
        case(VendorId::Codeplay): return "Codeplay";
        case(VendorId::MESA): return "MESA";
        case(VendorId::Pocl): return "Pocl";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(DriverId val) {
    switch(val) {
        case(DriverId::AmdProprietary): return "AmdProprietary";
        case(DriverId::AmdOpenSource): return "AmdOpenSource";
        case(DriverId::MesaRadv): return "MesaRadv";
        case(DriverId::NvidiaProprietary): return "NvidiaProprietary";
        case(DriverId::IntelProprietaryWindows): return "IntelProprietaryWindows";
        case(DriverId::IntelOpenSourceMESA): return "IntelOpenSourceMESA";
        case(DriverId::ImaginationProprietary): return "ImaginationProprietary";
        case(DriverId::QualcommProprietary): return "QualcommProprietary";
        case(DriverId::ArmProprietary): return "ArmProprietary";
        case(DriverId::GoogleSwiftshader): return "GoogleSwiftshader";
        case(DriverId::GgpProprietary): return "GgpProprietary";
        case(DriverId::BroadcomProprietary): return "BroadcomProprietary";
        case(DriverId::MesaLlvmpipe): return "MesaLlvmpipe";
        case(DriverId::Moltenvk): return "Moltenvk";
        case(DriverId::CoreaviProprietary): return "CoreaviProprietary";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(ShadingRatePaletteEntryNV val) {
    switch(val) {
        case(ShadingRatePaletteEntryNV::NoInvocationsNV): return "NoInvocationsNV";
        case(ShadingRatePaletteEntryNV::e16InvocationsPerPixelNV): return "e16InvocationsPerPixelNV";
        case(ShadingRatePaletteEntryNV::e8InvocationsPerPixelNV): return "e8InvocationsPerPixelNV";
        case(ShadingRatePaletteEntryNV::e4InvocationsPerPixelNV): return "e4InvocationsPerPixelNV";
        case(ShadingRatePaletteEntryNV::e2InvocationsPerPixelNV): return "e2InvocationsPerPixelNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPerPixelNV): return "e1InvocationPerPixelNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPer2X1PixelsNV): return "e1InvocationPer2X1PixelsNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPer1X2PixelsNV): return "e1InvocationPer1X2PixelsNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPer2X2PixelsNV): return "e1InvocationPer2X2PixelsNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPer4X2PixelsNV): return "e1InvocationPer4X2PixelsNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPer2X4PixelsNV): return "e1InvocationPer2X4PixelsNV";
        case(ShadingRatePaletteEntryNV::e1InvocationPer4X4PixelsNV): return "e1InvocationPer4X4PixelsNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(CoarseSampleOrderTypeNV val) {
    switch(val) {
        case(CoarseSampleOrderTypeNV::DefaultNV): return "DefaultNV";
        case(CoarseSampleOrderTypeNV::CustomNV): return "CustomNV";
        case(CoarseSampleOrderTypeNV::PixelMajorNV): return "PixelMajorNV";
        case(CoarseSampleOrderTypeNV::SampleMajorNV): return "SampleMajorNV";
        default: return "UNKNOWN";
    }
}
inline const char * to_string(PipelineExecutableStatisticFormatKHR val) {
    switch(val) {
        case(PipelineExecutableStatisticFormatKHR::Bool32KHR): return "Bool32KHR";
        case(PipelineExecutableStatisticFormatKHR::Int64KHR): return "Int64KHR";
        case(PipelineExecutableStatisticFormatKHR::Uint64KHR): return "Uint64KHR";
        case(PipelineExecutableStatisticFormatKHR::Float64KHR): return "Float64KHR";
        default: return "UNKNOWN";
    }
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
inline const char * to_string(QueryResultStatusKHR val) {
    switch(val) {
        case(QueryResultStatusKHR::ErrorKHR): return "ErrorKHR";
        case(QueryResultStatusKHR::NotReadyKHR): return "NotReadyKHR";
        case(QueryResultStatusKHR::CompleteKHR): return "CompleteKHR";
        default: return "UNKNOWN";
    }
}
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
inline const char * to_string(PipelineCacheCreateFlagBits val) {
    switch(val) {
        case(PipelineCacheCreateFlagBits::ExternallySynchronizedBitEXT): return "ExternallySynchronizedBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PipelineCacheCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PipelineCacheCreateFlagBits::ExternallySynchronizedBitEXT) out += "ExternallySynchronizedBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(QueueFlagBits val) {
    switch(val) {
        case(QueueFlagBits::Graphics): return "Graphics";
        case(QueueFlagBits::Compute): return "Compute";
        case(QueueFlagBits::Transfer): return "Transfer";
        case(QueueFlagBits::SparseBinding): return "SparseBinding";
        case(QueueFlagBits::VideoDecodeBitKHR): return "VideoDecodeBitKHR";
        case(QueueFlagBits::VideoEncodeBitKHR): return "VideoEncodeBitKHR";
        case(QueueFlagBits::Protected): return "Protected";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(QueueFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & QueueFlagBits::Graphics) out += "Graphics | ";
    if (flag & QueueFlagBits::Compute) out += "Compute | ";
    if (flag & QueueFlagBits::Transfer) out += "Transfer | ";
    if (flag & QueueFlagBits::SparseBinding) out += "SparseBinding | ";
    if (flag & QueueFlagBits::VideoDecodeBitKHR) out += "VideoDecodeBitKHR | ";
    if (flag & QueueFlagBits::VideoEncodeBitKHR) out += "VideoEncodeBitKHR | ";
    if (flag & QueueFlagBits::Protected) out += "Protected | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(CullModeFlagBits val) {
    switch(val) {
        case(CullModeFlagBits::None): return "None";
        case(CullModeFlagBits::Front): return "Front";
        case(CullModeFlagBits::Back): return "Back";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(CullModeFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & CullModeFlagBits::None) out += "None | ";
    if (flag & CullModeFlagBits::Front) out += "Front | ";
    if (flag & CullModeFlagBits::Back) out += "Back | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(RenderPassCreateFlagBits val) {
    switch(val) {
        case(RenderPassCreateFlagBits::TransformBitQCOM): return "TransformBitQCOM";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(RenderPassCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & RenderPassCreateFlagBits::TransformBitQCOM) out += "TransformBitQCOM | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DeviceQueueCreateFlagBits val) {
    switch(val) {
        case(DeviceQueueCreateFlagBits::Protected): return "Protected";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DeviceQueueCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DeviceQueueCreateFlagBits::Protected) out += "Protected | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(MemoryPropertyFlagBits val) {
    switch(val) {
        case(MemoryPropertyFlagBits::DeviceLocal): return "DeviceLocal";
        case(MemoryPropertyFlagBits::HostVisible): return "HostVisible";
        case(MemoryPropertyFlagBits::HostCoherent): return "HostCoherent";
        case(MemoryPropertyFlagBits::HostCached): return "HostCached";
        case(MemoryPropertyFlagBits::LazilyAllocated): return "LazilyAllocated";
        case(MemoryPropertyFlagBits::DeviceCoherentBitAMD): return "DeviceCoherentBitAMD";
        case(MemoryPropertyFlagBits::DeviceUncachedBitAMD): return "DeviceUncachedBitAMD";
        case(MemoryPropertyFlagBits::Protected): return "Protected";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(MemoryPropertyFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & MemoryPropertyFlagBits::DeviceLocal) out += "DeviceLocal | ";
    if (flag & MemoryPropertyFlagBits::HostVisible) out += "HostVisible | ";
    if (flag & MemoryPropertyFlagBits::HostCoherent) out += "HostCoherent | ";
    if (flag & MemoryPropertyFlagBits::HostCached) out += "HostCached | ";
    if (flag & MemoryPropertyFlagBits::LazilyAllocated) out += "LazilyAllocated | ";
    if (flag & MemoryPropertyFlagBits::DeviceCoherentBitAMD) out += "DeviceCoherentBitAMD | ";
    if (flag & MemoryPropertyFlagBits::DeviceUncachedBitAMD) out += "DeviceUncachedBitAMD | ";
    if (flag & MemoryPropertyFlagBits::Protected) out += "Protected | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(MemoryHeapFlagBits val) {
    switch(val) {
        case(MemoryHeapFlagBits::DeviceLocal): return "DeviceLocal";
        case(MemoryHeapFlagBits::MultiInstance): return "MultiInstance";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(MemoryHeapFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & MemoryHeapFlagBits::DeviceLocal) out += "DeviceLocal | ";
    if (flag & MemoryHeapFlagBits::MultiInstance) out += "MultiInstance | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(AccessFlagBits val) {
    switch(val) {
        case(AccessFlagBits::NoneKHR): return "NoneKHR";
        case(AccessFlagBits::IndexRead): return "IndexRead";
        case(AccessFlagBits::VertexAttributeRead): return "VertexAttributeRead";
        case(AccessFlagBits::UniformRead): return "UniformRead";
        case(AccessFlagBits::InputAttachmentRead): return "InputAttachmentRead";
        case(AccessFlagBits::ShaderRead): return "ShaderRead";
        case(AccessFlagBits::ShaderWrite): return "ShaderWrite";
        case(AccessFlagBits::ColorAttachmentRead): return "ColorAttachmentRead";
        case(AccessFlagBits::ColorAttachmentWrite): return "ColorAttachmentWrite";
        case(AccessFlagBits::DepthStencilAttachmentRead): return "DepthStencilAttachmentRead";
        case(AccessFlagBits::DepthStencilAttachmentWrite): return "DepthStencilAttachmentWrite";
        case(AccessFlagBits::TransferRead): return "TransferRead";
        case(AccessFlagBits::TransferWrite): return "TransferWrite";
        case(AccessFlagBits::HostRead): return "HostRead";
        case(AccessFlagBits::HostWrite): return "HostWrite";
        case(AccessFlagBits::MemoryRead): return "MemoryRead";
        case(AccessFlagBits::MemoryWrite): return "MemoryWrite";
        case(AccessFlagBits::TransformFeedbackWriteBitEXT): return "TransformFeedbackWriteBitEXT";
        case(AccessFlagBits::TransformFeedbackCounterReadBitEXT): return "TransformFeedbackCounterReadBitEXT";
        case(AccessFlagBits::TransformFeedbackCounterWriteBitEXT): return "TransformFeedbackCounterWriteBitEXT";
        case(AccessFlagBits::ConditionalRenderingReadBitEXT): return "ConditionalRenderingReadBitEXT";
        case(AccessFlagBits::ColorAttachmentReadNoncoherentBitEXT): return "ColorAttachmentReadNoncoherentBitEXT";
        case(AccessFlagBits::AccelerationStructureReadBitKHR): return "AccelerationStructureReadBitKHR";
        case(AccessFlagBits::AccelerationStructureWriteBitKHR): return "AccelerationStructureWriteBitKHR";
        case(AccessFlagBits::ShadingRateImageReadBitNV): return "ShadingRateImageReadBitNV";
        case(AccessFlagBits::FragmentDensityMapReadBitEXT): return "FragmentDensityMapReadBitEXT";
        case(AccessFlagBits::CommandPreprocessReadBitNV): return "CommandPreprocessReadBitNV";
        case(AccessFlagBits::CommandPreprocessWriteBitNV): return "CommandPreprocessWriteBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(AccessFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & AccessFlagBits::NoneKHR) out += "NoneKHR | ";
    if (flag & AccessFlagBits::IndexRead) out += "IndexRead | ";
    if (flag & AccessFlagBits::VertexAttributeRead) out += "VertexAttributeRead | ";
    if (flag & AccessFlagBits::UniformRead) out += "UniformRead | ";
    if (flag & AccessFlagBits::InputAttachmentRead) out += "InputAttachmentRead | ";
    if (flag & AccessFlagBits::ShaderRead) out += "ShaderRead | ";
    if (flag & AccessFlagBits::ShaderWrite) out += "ShaderWrite | ";
    if (flag & AccessFlagBits::ColorAttachmentRead) out += "ColorAttachmentRead | ";
    if (flag & AccessFlagBits::ColorAttachmentWrite) out += "ColorAttachmentWrite | ";
    if (flag & AccessFlagBits::DepthStencilAttachmentRead) out += "DepthStencilAttachmentRead | ";
    if (flag & AccessFlagBits::DepthStencilAttachmentWrite) out += "DepthStencilAttachmentWrite | ";
    if (flag & AccessFlagBits::TransferRead) out += "TransferRead | ";
    if (flag & AccessFlagBits::TransferWrite) out += "TransferWrite | ";
    if (flag & AccessFlagBits::HostRead) out += "HostRead | ";
    if (flag & AccessFlagBits::HostWrite) out += "HostWrite | ";
    if (flag & AccessFlagBits::MemoryRead) out += "MemoryRead | ";
    if (flag & AccessFlagBits::MemoryWrite) out += "MemoryWrite | ";
    if (flag & AccessFlagBits::TransformFeedbackWriteBitEXT) out += "TransformFeedbackWriteBitEXT | ";
    if (flag & AccessFlagBits::TransformFeedbackCounterReadBitEXT) out += "TransformFeedbackCounterReadBitEXT | ";
    if (flag & AccessFlagBits::TransformFeedbackCounterWriteBitEXT) out += "TransformFeedbackCounterWriteBitEXT | ";
    if (flag & AccessFlagBits::ConditionalRenderingReadBitEXT) out += "ConditionalRenderingReadBitEXT | ";
    if (flag & AccessFlagBits::ColorAttachmentReadNoncoherentBitEXT) out += "ColorAttachmentReadNoncoherentBitEXT | ";
    if (flag & AccessFlagBits::AccelerationStructureReadBitKHR) out += "AccelerationStructureReadBitKHR | ";
    if (flag & AccessFlagBits::AccelerationStructureWriteBitKHR) out += "AccelerationStructureWriteBitKHR | ";
    if (flag & AccessFlagBits::ShadingRateImageReadBitNV) out += "ShadingRateImageReadBitNV | ";
    if (flag & AccessFlagBits::FragmentDensityMapReadBitEXT) out += "FragmentDensityMapReadBitEXT | ";
    if (flag & AccessFlagBits::CommandPreprocessReadBitNV) out += "CommandPreprocessReadBitNV | ";
    if (flag & AccessFlagBits::CommandPreprocessWriteBitNV) out += "CommandPreprocessWriteBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(BufferUsageFlagBits val) {
    switch(val) {
        case(BufferUsageFlagBits::TransferSrc): return "TransferSrc";
        case(BufferUsageFlagBits::TransferDst): return "TransferDst";
        case(BufferUsageFlagBits::UniformTexelBuffer): return "UniformTexelBuffer";
        case(BufferUsageFlagBits::StorageTexelBuffer): return "StorageTexelBuffer";
        case(BufferUsageFlagBits::UniformBuffer): return "UniformBuffer";
        case(BufferUsageFlagBits::StorageBuffer): return "StorageBuffer";
        case(BufferUsageFlagBits::IndexBuffer): return "IndexBuffer";
        case(BufferUsageFlagBits::VertexBuffer): return "VertexBuffer";
        case(BufferUsageFlagBits::IndirectBuffer): return "IndirectBuffer";
        case(BufferUsageFlagBits::VideoDecodeSrcBitKHR): return "VideoDecodeSrcBitKHR";
        case(BufferUsageFlagBits::VideoDecodeDstBitKHR): return "VideoDecodeDstBitKHR";
        case(BufferUsageFlagBits::VideoEncodeDstBitKHR): return "VideoEncodeDstBitKHR";
        case(BufferUsageFlagBits::VideoEncodeSrcBitKHR): return "VideoEncodeSrcBitKHR";
        case(BufferUsageFlagBits::TransformFeedbackBufferBitEXT): return "TransformFeedbackBufferBitEXT";
        case(BufferUsageFlagBits::TransformFeedbackCounterBufferBitEXT): return "TransformFeedbackCounterBufferBitEXT";
        case(BufferUsageFlagBits::ConditionalRenderingBitEXT): return "ConditionalRenderingBitEXT";
        case(BufferUsageFlagBits::AccelerationStructureBuildInputReadOnlyBitKHR): return "AccelerationStructureBuildInputReadOnlyBitKHR";
        case(BufferUsageFlagBits::AccelerationStructureStorageBitKHR): return "AccelerationStructureStorageBitKHR";
        case(BufferUsageFlagBits::ShaderBindingTableBitKHR): return "ShaderBindingTableBitKHR";
        case(BufferUsageFlagBits::ShaderDeviceAddress): return "ShaderDeviceAddress";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(BufferUsageFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & BufferUsageFlagBits::TransferSrc) out += "TransferSrc | ";
    if (flag & BufferUsageFlagBits::TransferDst) out += "TransferDst | ";
    if (flag & BufferUsageFlagBits::UniformTexelBuffer) out += "UniformTexelBuffer | ";
    if (flag & BufferUsageFlagBits::StorageTexelBuffer) out += "StorageTexelBuffer | ";
    if (flag & BufferUsageFlagBits::UniformBuffer) out += "UniformBuffer | ";
    if (flag & BufferUsageFlagBits::StorageBuffer) out += "StorageBuffer | ";
    if (flag & BufferUsageFlagBits::IndexBuffer) out += "IndexBuffer | ";
    if (flag & BufferUsageFlagBits::VertexBuffer) out += "VertexBuffer | ";
    if (flag & BufferUsageFlagBits::IndirectBuffer) out += "IndirectBuffer | ";
    if (flag & BufferUsageFlagBits::VideoDecodeSrcBitKHR) out += "VideoDecodeSrcBitKHR | ";
    if (flag & BufferUsageFlagBits::VideoDecodeDstBitKHR) out += "VideoDecodeDstBitKHR | ";
    if (flag & BufferUsageFlagBits::VideoEncodeDstBitKHR) out += "VideoEncodeDstBitKHR | ";
    if (flag & BufferUsageFlagBits::VideoEncodeSrcBitKHR) out += "VideoEncodeSrcBitKHR | ";
    if (flag & BufferUsageFlagBits::TransformFeedbackBufferBitEXT) out += "TransformFeedbackBufferBitEXT | ";
    if (flag & BufferUsageFlagBits::TransformFeedbackCounterBufferBitEXT) out += "TransformFeedbackCounterBufferBitEXT | ";
    if (flag & BufferUsageFlagBits::ConditionalRenderingBitEXT) out += "ConditionalRenderingBitEXT | ";
    if (flag & BufferUsageFlagBits::AccelerationStructureBuildInputReadOnlyBitKHR) out += "AccelerationStructureBuildInputReadOnlyBitKHR | ";
    if (flag & BufferUsageFlagBits::AccelerationStructureStorageBitKHR) out += "AccelerationStructureStorageBitKHR | ";
    if (flag & BufferUsageFlagBits::ShaderBindingTableBitKHR) out += "ShaderBindingTableBitKHR | ";
    if (flag & BufferUsageFlagBits::ShaderDeviceAddress) out += "ShaderDeviceAddress | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(BufferCreateFlagBits val) {
    switch(val) {
        case(BufferCreateFlagBits::SparseBinding): return "SparseBinding";
        case(BufferCreateFlagBits::SparseResidency): return "SparseResidency";
        case(BufferCreateFlagBits::SparseAliased): return "SparseAliased";
        case(BufferCreateFlagBits::Protected): return "Protected";
        case(BufferCreateFlagBits::DeviceAddressCaptureReplay): return "DeviceAddressCaptureReplay";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(BufferCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & BufferCreateFlagBits::SparseBinding) out += "SparseBinding | ";
    if (flag & BufferCreateFlagBits::SparseResidency) out += "SparseResidency | ";
    if (flag & BufferCreateFlagBits::SparseAliased) out += "SparseAliased | ";
    if (flag & BufferCreateFlagBits::Protected) out += "Protected | ";
    if (flag & BufferCreateFlagBits::DeviceAddressCaptureReplay) out += "DeviceAddressCaptureReplay | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ShaderStageFlagBits val) {
    switch(val) {
        case(ShaderStageFlagBits::Vertex): return "Vertex";
        case(ShaderStageFlagBits::TessellationControl): return "TessellationControl";
        case(ShaderStageFlagBits::TessellationEvaluation): return "TessellationEvaluation";
        case(ShaderStageFlagBits::Geometry): return "Geometry";
        case(ShaderStageFlagBits::Fragment): return "Fragment";
        case(ShaderStageFlagBits::Compute): return "Compute";
        case(ShaderStageFlagBits::RaygenBitKHR): return "RaygenBitKHR";
        case(ShaderStageFlagBits::AnyHitBitKHR): return "AnyHitBitKHR";
        case(ShaderStageFlagBits::ClosestHitBitKHR): return "ClosestHitBitKHR";
        case(ShaderStageFlagBits::MissBitKHR): return "MissBitKHR";
        case(ShaderStageFlagBits::IntersectionBitKHR): return "IntersectionBitKHR";
        case(ShaderStageFlagBits::CallableBitKHR): return "CallableBitKHR";
        case(ShaderStageFlagBits::TaskBitNV): return "TaskBitNV";
        case(ShaderStageFlagBits::MeshBitNV): return "MeshBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ShaderStageFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ShaderStageFlagBits::Vertex) out += "Vertex | ";
    if (flag & ShaderStageFlagBits::TessellationControl) out += "TessellationControl | ";
    if (flag & ShaderStageFlagBits::TessellationEvaluation) out += "TessellationEvaluation | ";
    if (flag & ShaderStageFlagBits::Geometry) out += "Geometry | ";
    if (flag & ShaderStageFlagBits::Fragment) out += "Fragment | ";
    if (flag & ShaderStageFlagBits::Compute) out += "Compute | ";
    if (flag & ShaderStageFlagBits::RaygenBitKHR) out += "RaygenBitKHR | ";
    if (flag & ShaderStageFlagBits::AnyHitBitKHR) out += "AnyHitBitKHR | ";
    if (flag & ShaderStageFlagBits::ClosestHitBitKHR) out += "ClosestHitBitKHR | ";
    if (flag & ShaderStageFlagBits::MissBitKHR) out += "MissBitKHR | ";
    if (flag & ShaderStageFlagBits::IntersectionBitKHR) out += "IntersectionBitKHR | ";
    if (flag & ShaderStageFlagBits::CallableBitKHR) out += "CallableBitKHR | ";
    if (flag & ShaderStageFlagBits::TaskBitNV) out += "TaskBitNV | ";
    if (flag & ShaderStageFlagBits::MeshBitNV) out += "MeshBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ImageUsageFlagBits val) {
    switch(val) {
        case(ImageUsageFlagBits::TransferSrc): return "TransferSrc";
        case(ImageUsageFlagBits::TransferDst): return "TransferDst";
        case(ImageUsageFlagBits::Sampled): return "Sampled";
        case(ImageUsageFlagBits::Storage): return "Storage";
        case(ImageUsageFlagBits::ColorAttachment): return "ColorAttachment";
        case(ImageUsageFlagBits::DepthStencilAttachment): return "DepthStencilAttachment";
        case(ImageUsageFlagBits::TransientAttachment): return "TransientAttachment";
        case(ImageUsageFlagBits::InputAttachment): return "InputAttachment";
        case(ImageUsageFlagBits::VideoDecodeDstBitKHR): return "VideoDecodeDstBitKHR";
        case(ImageUsageFlagBits::VideoDecodeSrcBitKHR): return "VideoDecodeSrcBitKHR";
        case(ImageUsageFlagBits::VideoDecodeDpbBitKHR): return "VideoDecodeDpbBitKHR";
        case(ImageUsageFlagBits::VideoEncodeDstBitKHR): return "VideoEncodeDstBitKHR";
        case(ImageUsageFlagBits::VideoEncodeSrcBitKHR): return "VideoEncodeSrcBitKHR";
        case(ImageUsageFlagBits::VideoEncodeDpbBitKHR): return "VideoEncodeDpbBitKHR";
        case(ImageUsageFlagBits::ShadingRateImageBitNV): return "ShadingRateImageBitNV";
        case(ImageUsageFlagBits::FragmentDensityMapBitEXT): return "FragmentDensityMapBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ImageUsageFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ImageUsageFlagBits::TransferSrc) out += "TransferSrc | ";
    if (flag & ImageUsageFlagBits::TransferDst) out += "TransferDst | ";
    if (flag & ImageUsageFlagBits::Sampled) out += "Sampled | ";
    if (flag & ImageUsageFlagBits::Storage) out += "Storage | ";
    if (flag & ImageUsageFlagBits::ColorAttachment) out += "ColorAttachment | ";
    if (flag & ImageUsageFlagBits::DepthStencilAttachment) out += "DepthStencilAttachment | ";
    if (flag & ImageUsageFlagBits::TransientAttachment) out += "TransientAttachment | ";
    if (flag & ImageUsageFlagBits::InputAttachment) out += "InputAttachment | ";
    if (flag & ImageUsageFlagBits::VideoDecodeDstBitKHR) out += "VideoDecodeDstBitKHR | ";
    if (flag & ImageUsageFlagBits::VideoDecodeSrcBitKHR) out += "VideoDecodeSrcBitKHR | ";
    if (flag & ImageUsageFlagBits::VideoDecodeDpbBitKHR) out += "VideoDecodeDpbBitKHR | ";
    if (flag & ImageUsageFlagBits::VideoEncodeDstBitKHR) out += "VideoEncodeDstBitKHR | ";
    if (flag & ImageUsageFlagBits::VideoEncodeSrcBitKHR) out += "VideoEncodeSrcBitKHR | ";
    if (flag & ImageUsageFlagBits::VideoEncodeDpbBitKHR) out += "VideoEncodeDpbBitKHR | ";
    if (flag & ImageUsageFlagBits::ShadingRateImageBitNV) out += "ShadingRateImageBitNV | ";
    if (flag & ImageUsageFlagBits::FragmentDensityMapBitEXT) out += "FragmentDensityMapBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ImageCreateFlagBits val) {
    switch(val) {
        case(ImageCreateFlagBits::SparseBinding): return "SparseBinding";
        case(ImageCreateFlagBits::SparseResidency): return "SparseResidency";
        case(ImageCreateFlagBits::SparseAliased): return "SparseAliased";
        case(ImageCreateFlagBits::MutableFormat): return "MutableFormat";
        case(ImageCreateFlagBits::CubeCompatible): return "CubeCompatible";
        case(ImageCreateFlagBits::CornerSampledBitNV): return "CornerSampledBitNV";
        case(ImageCreateFlagBits::SampleLocationsCompatibleDepthBitEXT): return "SampleLocationsCompatibleDepthBitEXT";
        case(ImageCreateFlagBits::SubsampledBitEXT): return "SubsampledBitEXT";
        case(ImageCreateFlagBits::Alias): return "Alias";
        case(ImageCreateFlagBits::SplitInstanceBindRegions): return "SplitInstanceBindRegions";
        case(ImageCreateFlagBits::e2DArrayCompatible): return "e2DArrayCompatible";
        case(ImageCreateFlagBits::BlockTexelViewCompatible): return "BlockTexelViewCompatible";
        case(ImageCreateFlagBits::ExtendedUsage): return "ExtendedUsage";
        case(ImageCreateFlagBits::Protected): return "Protected";
        case(ImageCreateFlagBits::Disjoint): return "Disjoint";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ImageCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ImageCreateFlagBits::SparseBinding) out += "SparseBinding | ";
    if (flag & ImageCreateFlagBits::SparseResidency) out += "SparseResidency | ";
    if (flag & ImageCreateFlagBits::SparseAliased) out += "SparseAliased | ";
    if (flag & ImageCreateFlagBits::MutableFormat) out += "MutableFormat | ";
    if (flag & ImageCreateFlagBits::CubeCompatible) out += "CubeCompatible | ";
    if (flag & ImageCreateFlagBits::CornerSampledBitNV) out += "CornerSampledBitNV | ";
    if (flag & ImageCreateFlagBits::SampleLocationsCompatibleDepthBitEXT) out += "SampleLocationsCompatibleDepthBitEXT | ";
    if (flag & ImageCreateFlagBits::SubsampledBitEXT) out += "SubsampledBitEXT | ";
    if (flag & ImageCreateFlagBits::Alias) out += "Alias | ";
    if (flag & ImageCreateFlagBits::SplitInstanceBindRegions) out += "SplitInstanceBindRegions | ";
    if (flag & ImageCreateFlagBits::e2DArrayCompatible) out += "e2DArrayCompatible | ";
    if (flag & ImageCreateFlagBits::BlockTexelViewCompatible) out += "BlockTexelViewCompatible | ";
    if (flag & ImageCreateFlagBits::ExtendedUsage) out += "ExtendedUsage | ";
    if (flag & ImageCreateFlagBits::Protected) out += "Protected | ";
    if (flag & ImageCreateFlagBits::Disjoint) out += "Disjoint | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ImageViewCreateFlagBits val) {
    switch(val) {
        case(ImageViewCreateFlagBits::FragmentDensityMapDynamicBitEXT): return "FragmentDensityMapDynamicBitEXT";
        case(ImageViewCreateFlagBits::FragmentDensityMapDeferredBitEXT): return "FragmentDensityMapDeferredBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ImageViewCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ImageViewCreateFlagBits::FragmentDensityMapDynamicBitEXT) out += "FragmentDensityMapDynamicBitEXT | ";
    if (flag & ImageViewCreateFlagBits::FragmentDensityMapDeferredBitEXT) out += "FragmentDensityMapDeferredBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SamplerCreateFlagBits val) {
    switch(val) {
        case(SamplerCreateFlagBits::SubsampledBitEXT): return "SubsampledBitEXT";
        case(SamplerCreateFlagBits::SubsampledCoarseReconstructionBitEXT): return "SubsampledCoarseReconstructionBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SamplerCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SamplerCreateFlagBits::SubsampledBitEXT) out += "SubsampledBitEXT | ";
    if (flag & SamplerCreateFlagBits::SubsampledCoarseReconstructionBitEXT) out += "SubsampledCoarseReconstructionBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PipelineCreateFlagBits val) {
    switch(val) {
        case(PipelineCreateFlagBits::DisableOptimization): return "DisableOptimization";
        case(PipelineCreateFlagBits::AllowDerivatives): return "AllowDerivatives";
        case(PipelineCreateFlagBits::Derivative): return "Derivative";
        case(PipelineCreateFlagBits::RayTracingNoNullAnyHitShadersBitKHR): return "RayTracingNoNullAnyHitShadersBitKHR";
        case(PipelineCreateFlagBits::RayTracingNoNullClosestHitShadersBitKHR): return "RayTracingNoNullClosestHitShadersBitKHR";
        case(PipelineCreateFlagBits::RayTracingNoNullMissShadersBitKHR): return "RayTracingNoNullMissShadersBitKHR";
        case(PipelineCreateFlagBits::RayTracingNoNullIntersectionShadersBitKHR): return "RayTracingNoNullIntersectionShadersBitKHR";
        case(PipelineCreateFlagBits::RayTracingSkipTrianglesBitKHR): return "RayTracingSkipTrianglesBitKHR";
        case(PipelineCreateFlagBits::RayTracingSkipAabbsBitKHR): return "RayTracingSkipAabbsBitKHR";
        case(PipelineCreateFlagBits::RayTracingShaderGroupHandleCaptureReplayBitKHR): return "RayTracingShaderGroupHandleCaptureReplayBitKHR";
        case(PipelineCreateFlagBits::DeferCompileBitNV): return "DeferCompileBitNV";
        case(PipelineCreateFlagBits::CaptureStatisticsBitKHR): return "CaptureStatisticsBitKHR";
        case(PipelineCreateFlagBits::CaptureInternalRepresentationsBitKHR): return "CaptureInternalRepresentationsBitKHR";
        case(PipelineCreateFlagBits::IndirectBindableBitNV): return "IndirectBindableBitNV";
        case(PipelineCreateFlagBits::LibraryBitKHR): return "LibraryBitKHR";
        case(PipelineCreateFlagBits::FailOnPipelineCompileRequiredBitEXT): return "FailOnPipelineCompileRequiredBitEXT";
        case(PipelineCreateFlagBits::EarlyReturnOnFailureBitEXT): return "EarlyReturnOnFailureBitEXT";
        case(PipelineCreateFlagBits::ViewIndexFromDeviceIndex): return "ViewIndexFromDeviceIndex";
        case(PipelineCreateFlagBits::DispatchBase): return "DispatchBase";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PipelineCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PipelineCreateFlagBits::DisableOptimization) out += "DisableOptimization | ";
    if (flag & PipelineCreateFlagBits::AllowDerivatives) out += "AllowDerivatives | ";
    if (flag & PipelineCreateFlagBits::Derivative) out += "Derivative | ";
    if (flag & PipelineCreateFlagBits::RayTracingNoNullAnyHitShadersBitKHR) out += "RayTracingNoNullAnyHitShadersBitKHR | ";
    if (flag & PipelineCreateFlagBits::RayTracingNoNullClosestHitShadersBitKHR) out += "RayTracingNoNullClosestHitShadersBitKHR | ";
    if (flag & PipelineCreateFlagBits::RayTracingNoNullMissShadersBitKHR) out += "RayTracingNoNullMissShadersBitKHR | ";
    if (flag & PipelineCreateFlagBits::RayTracingNoNullIntersectionShadersBitKHR) out += "RayTracingNoNullIntersectionShadersBitKHR | ";
    if (flag & PipelineCreateFlagBits::RayTracingSkipTrianglesBitKHR) out += "RayTracingSkipTrianglesBitKHR | ";
    if (flag & PipelineCreateFlagBits::RayTracingSkipAabbsBitKHR) out += "RayTracingSkipAabbsBitKHR | ";
    if (flag & PipelineCreateFlagBits::RayTracingShaderGroupHandleCaptureReplayBitKHR) out += "RayTracingShaderGroupHandleCaptureReplayBitKHR | ";
    if (flag & PipelineCreateFlagBits::DeferCompileBitNV) out += "DeferCompileBitNV | ";
    if (flag & PipelineCreateFlagBits::CaptureStatisticsBitKHR) out += "CaptureStatisticsBitKHR | ";
    if (flag & PipelineCreateFlagBits::CaptureInternalRepresentationsBitKHR) out += "CaptureInternalRepresentationsBitKHR | ";
    if (flag & PipelineCreateFlagBits::IndirectBindableBitNV) out += "IndirectBindableBitNV | ";
    if (flag & PipelineCreateFlagBits::LibraryBitKHR) out += "LibraryBitKHR | ";
    if (flag & PipelineCreateFlagBits::FailOnPipelineCompileRequiredBitEXT) out += "FailOnPipelineCompileRequiredBitEXT | ";
    if (flag & PipelineCreateFlagBits::EarlyReturnOnFailureBitEXT) out += "EarlyReturnOnFailureBitEXT | ";
    if (flag & PipelineCreateFlagBits::ViewIndexFromDeviceIndex) out += "ViewIndexFromDeviceIndex | ";
    if (flag & PipelineCreateFlagBits::DispatchBase) out += "DispatchBase | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PipelineShaderStageCreateFlagBits val) {
    switch(val) {
        case(PipelineShaderStageCreateFlagBits::AllowVaryingSubgroupSizeBitEXT): return "AllowVaryingSubgroupSizeBitEXT";
        case(PipelineShaderStageCreateFlagBits::RequireFullSubgroupsBitEXT): return "RequireFullSubgroupsBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PipelineShaderStageCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PipelineShaderStageCreateFlagBits::AllowVaryingSubgroupSizeBitEXT) out += "AllowVaryingSubgroupSizeBitEXT | ";
    if (flag & PipelineShaderStageCreateFlagBits::RequireFullSubgroupsBitEXT) out += "RequireFullSubgroupsBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ColorComponentFlagBits val) {
    switch(val) {
        case(ColorComponentFlagBits::R): return "R";
        case(ColorComponentFlagBits::G): return "G";
        case(ColorComponentFlagBits::B): return "B";
        case(ColorComponentFlagBits::A): return "A";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ColorComponentFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ColorComponentFlagBits::R) out += "R | ";
    if (flag & ColorComponentFlagBits::G) out += "G | ";
    if (flag & ColorComponentFlagBits::B) out += "B | ";
    if (flag & ColorComponentFlagBits::A) out += "A | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(FenceCreateFlagBits val) {
    switch(val) {
        case(FenceCreateFlagBits::Signaled): return "Signaled";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(FenceCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & FenceCreateFlagBits::Signaled) out += "Signaled | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(FormatFeatureFlagBits val) {
    switch(val) {
        case(FormatFeatureFlagBits::SampledImage): return "SampledImage";
        case(FormatFeatureFlagBits::StorageImage): return "StorageImage";
        case(FormatFeatureFlagBits::StorageImageAtomic): return "StorageImageAtomic";
        case(FormatFeatureFlagBits::UniformTexelBuffer): return "UniformTexelBuffer";
        case(FormatFeatureFlagBits::StorageTexelBuffer): return "StorageTexelBuffer";
        case(FormatFeatureFlagBits::StorageTexelBufferAtomic): return "StorageTexelBufferAtomic";
        case(FormatFeatureFlagBits::VertexBuffer): return "VertexBuffer";
        case(FormatFeatureFlagBits::ColorAttachment): return "ColorAttachment";
        case(FormatFeatureFlagBits::ColorAttachmentBlend): return "ColorAttachmentBlend";
        case(FormatFeatureFlagBits::DepthStencilAttachment): return "DepthStencilAttachment";
        case(FormatFeatureFlagBits::BlitSrc): return "BlitSrc";
        case(FormatFeatureFlagBits::BlitDst): return "BlitDst";
        case(FormatFeatureFlagBits::SampledImageFilterLinear): return "SampledImageFilterLinear";
        case(FormatFeatureFlagBits::SampledImageFilterCubicBitIMG): return "SampledImageFilterCubicBitIMG";
        case(FormatFeatureFlagBits::VideoDecodeOutputBitKHR): return "VideoDecodeOutputBitKHR";
        case(FormatFeatureFlagBits::VideoDecodeDpbBitKHR): return "VideoDecodeDpbBitKHR";
        case(FormatFeatureFlagBits::VideoEncodeInputBitKHR): return "VideoEncodeInputBitKHR";
        case(FormatFeatureFlagBits::VideoEncodeDpbBitKHR): return "VideoEncodeDpbBitKHR";
        case(FormatFeatureFlagBits::AccelerationStructureVertexBufferBitKHR): return "AccelerationStructureVertexBufferBitKHR";
        case(FormatFeatureFlagBits::FragmentDensityMapBitEXT): return "FragmentDensityMapBitEXT";
        case(FormatFeatureFlagBits::FragmentShadingRateAttachmentBitKHR): return "FragmentShadingRateAttachmentBitKHR";
        case(FormatFeatureFlagBits::TransferSrc): return "TransferSrc";
        case(FormatFeatureFlagBits::TransferDst): return "TransferDst";
        case(FormatFeatureFlagBits::MidpointChromaSamples): return "MidpointChromaSamples";
        case(FormatFeatureFlagBits::SampledImageYcbcrConversionLinearFilter): return "SampledImageYcbcrConversionLinearFilter";
        case(FormatFeatureFlagBits::SampledImageYcbcrConversionSeparateReconstructionFilter): return "SampledImageYcbcrConversionSeparateReconstructionFilter";
        case(FormatFeatureFlagBits::SampledImageYcbcrConversionChromaReconstructionExplicit): return "SampledImageYcbcrConversionChromaReconstructionExplicit";
        case(FormatFeatureFlagBits::SampledImageYcbcrConversionChromaReconstructionExplicitForceable): return "SampledImageYcbcrConversionChromaReconstructionExplicitForceable";
        case(FormatFeatureFlagBits::Disjoint): return "Disjoint";
        case(FormatFeatureFlagBits::CositedChromaSamples): return "CositedChromaSamples";
        case(FormatFeatureFlagBits::SampledImageFilterMinmax): return "SampledImageFilterMinmax";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(FormatFeatureFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & FormatFeatureFlagBits::SampledImage) out += "SampledImage | ";
    if (flag & FormatFeatureFlagBits::StorageImage) out += "StorageImage | ";
    if (flag & FormatFeatureFlagBits::StorageImageAtomic) out += "StorageImageAtomic | ";
    if (flag & FormatFeatureFlagBits::UniformTexelBuffer) out += "UniformTexelBuffer | ";
    if (flag & FormatFeatureFlagBits::StorageTexelBuffer) out += "StorageTexelBuffer | ";
    if (flag & FormatFeatureFlagBits::StorageTexelBufferAtomic) out += "StorageTexelBufferAtomic | ";
    if (flag & FormatFeatureFlagBits::VertexBuffer) out += "VertexBuffer | ";
    if (flag & FormatFeatureFlagBits::ColorAttachment) out += "ColorAttachment | ";
    if (flag & FormatFeatureFlagBits::ColorAttachmentBlend) out += "ColorAttachmentBlend | ";
    if (flag & FormatFeatureFlagBits::DepthStencilAttachment) out += "DepthStencilAttachment | ";
    if (flag & FormatFeatureFlagBits::BlitSrc) out += "BlitSrc | ";
    if (flag & FormatFeatureFlagBits::BlitDst) out += "BlitDst | ";
    if (flag & FormatFeatureFlagBits::SampledImageFilterLinear) out += "SampledImageFilterLinear | ";
    if (flag & FormatFeatureFlagBits::SampledImageFilterCubicBitIMG) out += "SampledImageFilterCubicBitIMG | ";
    if (flag & FormatFeatureFlagBits::VideoDecodeOutputBitKHR) out += "VideoDecodeOutputBitKHR | ";
    if (flag & FormatFeatureFlagBits::VideoDecodeDpbBitKHR) out += "VideoDecodeDpbBitKHR | ";
    if (flag & FormatFeatureFlagBits::VideoEncodeInputBitKHR) out += "VideoEncodeInputBitKHR | ";
    if (flag & FormatFeatureFlagBits::VideoEncodeDpbBitKHR) out += "VideoEncodeDpbBitKHR | ";
    if (flag & FormatFeatureFlagBits::AccelerationStructureVertexBufferBitKHR) out += "AccelerationStructureVertexBufferBitKHR | ";
    if (flag & FormatFeatureFlagBits::FragmentDensityMapBitEXT) out += "FragmentDensityMapBitEXT | ";
    if (flag & FormatFeatureFlagBits::FragmentShadingRateAttachmentBitKHR) out += "FragmentShadingRateAttachmentBitKHR | ";
    if (flag & FormatFeatureFlagBits::TransferSrc) out += "TransferSrc | ";
    if (flag & FormatFeatureFlagBits::TransferDst) out += "TransferDst | ";
    if (flag & FormatFeatureFlagBits::MidpointChromaSamples) out += "MidpointChromaSamples | ";
    if (flag & FormatFeatureFlagBits::SampledImageYcbcrConversionLinearFilter) out += "SampledImageYcbcrConversionLinearFilter | ";
    if (flag & FormatFeatureFlagBits::SampledImageYcbcrConversionSeparateReconstructionFilter) out += "SampledImageYcbcrConversionSeparateReconstructionFilter | ";
    if (flag & FormatFeatureFlagBits::SampledImageYcbcrConversionChromaReconstructionExplicit) out += "SampledImageYcbcrConversionChromaReconstructionExplicit | ";
    if (flag & FormatFeatureFlagBits::SampledImageYcbcrConversionChromaReconstructionExplicitForceable) out += "SampledImageYcbcrConversionChromaReconstructionExplicitForceable | ";
    if (flag & FormatFeatureFlagBits::Disjoint) out += "Disjoint | ";
    if (flag & FormatFeatureFlagBits::CositedChromaSamples) out += "CositedChromaSamples | ";
    if (flag & FormatFeatureFlagBits::SampledImageFilterMinmax) out += "SampledImageFilterMinmax | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(QueryControlFlagBits val) {
    switch(val) {
        case(QueryControlFlagBits::Precise): return "Precise";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(QueryControlFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & QueryControlFlagBits::Precise) out += "Precise | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(QueryResultFlagBits val) {
    switch(val) {
        case(QueryResultFlagBits::e64): return "e64";
        case(QueryResultFlagBits::Wait): return "Wait";
        case(QueryResultFlagBits::WithAvailability): return "WithAvailability";
        case(QueryResultFlagBits::Partial): return "Partial";
        case(QueryResultFlagBits::WithStatusBitKHR): return "WithStatusBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(QueryResultFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & QueryResultFlagBits::e64) out += "e64 | ";
    if (flag & QueryResultFlagBits::Wait) out += "Wait | ";
    if (flag & QueryResultFlagBits::WithAvailability) out += "WithAvailability | ";
    if (flag & QueryResultFlagBits::Partial) out += "Partial | ";
    if (flag & QueryResultFlagBits::WithStatusBitKHR) out += "WithStatusBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(CommandBufferUsageFlagBits val) {
    switch(val) {
        case(CommandBufferUsageFlagBits::OneTimeSubmit): return "OneTimeSubmit";
        case(CommandBufferUsageFlagBits::RenderPassContinue): return "RenderPassContinue";
        case(CommandBufferUsageFlagBits::SimultaneousUse): return "SimultaneousUse";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(CommandBufferUsageFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & CommandBufferUsageFlagBits::OneTimeSubmit) out += "OneTimeSubmit | ";
    if (flag & CommandBufferUsageFlagBits::RenderPassContinue) out += "RenderPassContinue | ";
    if (flag & CommandBufferUsageFlagBits::SimultaneousUse) out += "SimultaneousUse | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(QueryPipelineStatisticFlagBits val) {
    switch(val) {
        case(QueryPipelineStatisticFlagBits::InputAssemblyVertices): return "InputAssemblyVertices";
        case(QueryPipelineStatisticFlagBits::InputAssemblyPrimitives): return "InputAssemblyPrimitives";
        case(QueryPipelineStatisticFlagBits::VertexShaderInvocations): return "VertexShaderInvocations";
        case(QueryPipelineStatisticFlagBits::GeometryShaderInvocations): return "GeometryShaderInvocations";
        case(QueryPipelineStatisticFlagBits::GeometryShaderPrimitives): return "GeometryShaderPrimitives";
        case(QueryPipelineStatisticFlagBits::ClippingInvocations): return "ClippingInvocations";
        case(QueryPipelineStatisticFlagBits::ClippingPrimitives): return "ClippingPrimitives";
        case(QueryPipelineStatisticFlagBits::FragmentShaderInvocations): return "FragmentShaderInvocations";
        case(QueryPipelineStatisticFlagBits::TessellationControlShaderPatches): return "TessellationControlShaderPatches";
        case(QueryPipelineStatisticFlagBits::TessellationEvaluationShaderInvocations): return "TessellationEvaluationShaderInvocations";
        case(QueryPipelineStatisticFlagBits::ComputeShaderInvocations): return "ComputeShaderInvocations";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(QueryPipelineStatisticFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & QueryPipelineStatisticFlagBits::InputAssemblyVertices) out += "InputAssemblyVertices | ";
    if (flag & QueryPipelineStatisticFlagBits::InputAssemblyPrimitives) out += "InputAssemblyPrimitives | ";
    if (flag & QueryPipelineStatisticFlagBits::VertexShaderInvocations) out += "VertexShaderInvocations | ";
    if (flag & QueryPipelineStatisticFlagBits::GeometryShaderInvocations) out += "GeometryShaderInvocations | ";
    if (flag & QueryPipelineStatisticFlagBits::GeometryShaderPrimitives) out += "GeometryShaderPrimitives | ";
    if (flag & QueryPipelineStatisticFlagBits::ClippingInvocations) out += "ClippingInvocations | ";
    if (flag & QueryPipelineStatisticFlagBits::ClippingPrimitives) out += "ClippingPrimitives | ";
    if (flag & QueryPipelineStatisticFlagBits::FragmentShaderInvocations) out += "FragmentShaderInvocations | ";
    if (flag & QueryPipelineStatisticFlagBits::TessellationControlShaderPatches) out += "TessellationControlShaderPatches | ";
    if (flag & QueryPipelineStatisticFlagBits::TessellationEvaluationShaderInvocations) out += "TessellationEvaluationShaderInvocations | ";
    if (flag & QueryPipelineStatisticFlagBits::ComputeShaderInvocations) out += "ComputeShaderInvocations | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ImageAspectFlagBits val) {
    switch(val) {
        case(ImageAspectFlagBits::Color): return "Color";
        case(ImageAspectFlagBits::Depth): return "Depth";
        case(ImageAspectFlagBits::Stencil): return "Stencil";
        case(ImageAspectFlagBits::Metadata): return "Metadata";
        case(ImageAspectFlagBits::MemoryPlane0BitEXT): return "MemoryPlane0BitEXT";
        case(ImageAspectFlagBits::MemoryPlane1BitEXT): return "MemoryPlane1BitEXT";
        case(ImageAspectFlagBits::MemoryPlane2BitEXT): return "MemoryPlane2BitEXT";
        case(ImageAspectFlagBits::MemoryPlane3BitEXT): return "MemoryPlane3BitEXT";
        case(ImageAspectFlagBits::Plane0): return "Plane0";
        case(ImageAspectFlagBits::Plane1): return "Plane1";
        case(ImageAspectFlagBits::Plane2): return "Plane2";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ImageAspectFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ImageAspectFlagBits::Color) out += "Color | ";
    if (flag & ImageAspectFlagBits::Depth) out += "Depth | ";
    if (flag & ImageAspectFlagBits::Stencil) out += "Stencil | ";
    if (flag & ImageAspectFlagBits::Metadata) out += "Metadata | ";
    if (flag & ImageAspectFlagBits::MemoryPlane0BitEXT) out += "MemoryPlane0BitEXT | ";
    if (flag & ImageAspectFlagBits::MemoryPlane1BitEXT) out += "MemoryPlane1BitEXT | ";
    if (flag & ImageAspectFlagBits::MemoryPlane2BitEXT) out += "MemoryPlane2BitEXT | ";
    if (flag & ImageAspectFlagBits::MemoryPlane3BitEXT) out += "MemoryPlane3BitEXT | ";
    if (flag & ImageAspectFlagBits::Plane0) out += "Plane0 | ";
    if (flag & ImageAspectFlagBits::Plane1) out += "Plane1 | ";
    if (flag & ImageAspectFlagBits::Plane2) out += "Plane2 | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SparseImageFormatFlagBits val) {
    switch(val) {
        case(SparseImageFormatFlagBits::SingleMiptail): return "SingleMiptail";
        case(SparseImageFormatFlagBits::AlignedMipSize): return "AlignedMipSize";
        case(SparseImageFormatFlagBits::NonstandardBlockSize): return "NonstandardBlockSize";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SparseImageFormatFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SparseImageFormatFlagBits::SingleMiptail) out += "SingleMiptail | ";
    if (flag & SparseImageFormatFlagBits::AlignedMipSize) out += "AlignedMipSize | ";
    if (flag & SparseImageFormatFlagBits::NonstandardBlockSize) out += "NonstandardBlockSize | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SparseMemoryBindFlagBits val) {
    switch(val) {
        case(SparseMemoryBindFlagBits::Metadata): return "Metadata";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SparseMemoryBindFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SparseMemoryBindFlagBits::Metadata) out += "Metadata | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PipelineStageFlagBits val) {
    switch(val) {
        case(PipelineStageFlagBits::NoneKHR): return "NoneKHR";
        case(PipelineStageFlagBits::DrawIndirect): return "DrawIndirect";
        case(PipelineStageFlagBits::VertexInput): return "VertexInput";
        case(PipelineStageFlagBits::VertexShader): return "VertexShader";
        case(PipelineStageFlagBits::TessellationControlShader): return "TessellationControlShader";
        case(PipelineStageFlagBits::TessellationEvaluationShader): return "TessellationEvaluationShader";
        case(PipelineStageFlagBits::GeometryShader): return "GeometryShader";
        case(PipelineStageFlagBits::FragmentShader): return "FragmentShader";
        case(PipelineStageFlagBits::EarlyFragmentTests): return "EarlyFragmentTests";
        case(PipelineStageFlagBits::LateFragmentTests): return "LateFragmentTests";
        case(PipelineStageFlagBits::ColorAttachmentOutput): return "ColorAttachmentOutput";
        case(PipelineStageFlagBits::ComputeShader): return "ComputeShader";
        case(PipelineStageFlagBits::Transfer): return "Transfer";
        case(PipelineStageFlagBits::BottomOfPipe): return "BottomOfPipe";
        case(PipelineStageFlagBits::Host): return "Host";
        case(PipelineStageFlagBits::AllGraphics): return "AllGraphics";
        case(PipelineStageFlagBits::AllCommands): return "AllCommands";
        case(PipelineStageFlagBits::TransformFeedbackBitEXT): return "TransformFeedbackBitEXT";
        case(PipelineStageFlagBits::ConditionalRenderingBitEXT): return "ConditionalRenderingBitEXT";
        case(PipelineStageFlagBits::AccelerationStructureBuildBitKHR): return "AccelerationStructureBuildBitKHR";
        case(PipelineStageFlagBits::RayTracingShaderBitKHR): return "RayTracingShaderBitKHR";
        case(PipelineStageFlagBits::ShadingRateImageBitNV): return "ShadingRateImageBitNV";
        case(PipelineStageFlagBits::TaskShaderBitNV): return "TaskShaderBitNV";
        case(PipelineStageFlagBits::MeshShaderBitNV): return "MeshShaderBitNV";
        case(PipelineStageFlagBits::FragmentDensityProcessBitEXT): return "FragmentDensityProcessBitEXT";
        case(PipelineStageFlagBits::CommandPreprocessBitNV): return "CommandPreprocessBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PipelineStageFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PipelineStageFlagBits::NoneKHR) out += "NoneKHR | ";
    if (flag & PipelineStageFlagBits::DrawIndirect) out += "DrawIndirect | ";
    if (flag & PipelineStageFlagBits::VertexInput) out += "VertexInput | ";
    if (flag & PipelineStageFlagBits::VertexShader) out += "VertexShader | ";
    if (flag & PipelineStageFlagBits::TessellationControlShader) out += "TessellationControlShader | ";
    if (flag & PipelineStageFlagBits::TessellationEvaluationShader) out += "TessellationEvaluationShader | ";
    if (flag & PipelineStageFlagBits::GeometryShader) out += "GeometryShader | ";
    if (flag & PipelineStageFlagBits::FragmentShader) out += "FragmentShader | ";
    if (flag & PipelineStageFlagBits::EarlyFragmentTests) out += "EarlyFragmentTests | ";
    if (flag & PipelineStageFlagBits::LateFragmentTests) out += "LateFragmentTests | ";
    if (flag & PipelineStageFlagBits::ColorAttachmentOutput) out += "ColorAttachmentOutput | ";
    if (flag & PipelineStageFlagBits::ComputeShader) out += "ComputeShader | ";
    if (flag & PipelineStageFlagBits::Transfer) out += "Transfer | ";
    if (flag & PipelineStageFlagBits::BottomOfPipe) out += "BottomOfPipe | ";
    if (flag & PipelineStageFlagBits::Host) out += "Host | ";
    if (flag & PipelineStageFlagBits::AllGraphics) out += "AllGraphics | ";
    if (flag & PipelineStageFlagBits::AllCommands) out += "AllCommands | ";
    if (flag & PipelineStageFlagBits::TransformFeedbackBitEXT) out += "TransformFeedbackBitEXT | ";
    if (flag & PipelineStageFlagBits::ConditionalRenderingBitEXT) out += "ConditionalRenderingBitEXT | ";
    if (flag & PipelineStageFlagBits::AccelerationStructureBuildBitKHR) out += "AccelerationStructureBuildBitKHR | ";
    if (flag & PipelineStageFlagBits::RayTracingShaderBitKHR) out += "RayTracingShaderBitKHR | ";
    if (flag & PipelineStageFlagBits::ShadingRateImageBitNV) out += "ShadingRateImageBitNV | ";
    if (flag & PipelineStageFlagBits::TaskShaderBitNV) out += "TaskShaderBitNV | ";
    if (flag & PipelineStageFlagBits::MeshShaderBitNV) out += "MeshShaderBitNV | ";
    if (flag & PipelineStageFlagBits::FragmentDensityProcessBitEXT) out += "FragmentDensityProcessBitEXT | ";
    if (flag & PipelineStageFlagBits::CommandPreprocessBitNV) out += "CommandPreprocessBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(CommandPoolCreateFlagBits val) {
    switch(val) {
        case(CommandPoolCreateFlagBits::Transient): return "Transient";
        case(CommandPoolCreateFlagBits::ResetCommandBuffer): return "ResetCommandBuffer";
        case(CommandPoolCreateFlagBits::Protected): return "Protected";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(CommandPoolCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & CommandPoolCreateFlagBits::Transient) out += "Transient | ";
    if (flag & CommandPoolCreateFlagBits::ResetCommandBuffer) out += "ResetCommandBuffer | ";
    if (flag & CommandPoolCreateFlagBits::Protected) out += "Protected | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(CommandPoolResetFlagBits val) {
    switch(val) {
        case(CommandPoolResetFlagBits::ReleaseResources): return "ReleaseResources";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(CommandPoolResetFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & CommandPoolResetFlagBits::ReleaseResources) out += "ReleaseResources | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(CommandBufferResetFlagBits val) {
    switch(val) {
        case(CommandBufferResetFlagBits::ReleaseResources): return "ReleaseResources";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(CommandBufferResetFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & CommandBufferResetFlagBits::ReleaseResources) out += "ReleaseResources | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SampleCountFlagBits val) {
    switch(val) {
        case(SampleCountFlagBits::e1): return "e1";
        case(SampleCountFlagBits::e2): return "e2";
        case(SampleCountFlagBits::e4): return "e4";
        case(SampleCountFlagBits::e8): return "e8";
        case(SampleCountFlagBits::e16): return "e16";
        case(SampleCountFlagBits::e32): return "e32";
        case(SampleCountFlagBits::e64): return "e64";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SampleCountFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SampleCountFlagBits::e1) out += "e1 | ";
    if (flag & SampleCountFlagBits::e2) out += "e2 | ";
    if (flag & SampleCountFlagBits::e4) out += "e4 | ";
    if (flag & SampleCountFlagBits::e8) out += "e8 | ";
    if (flag & SampleCountFlagBits::e16) out += "e16 | ";
    if (flag & SampleCountFlagBits::e32) out += "e32 | ";
    if (flag & SampleCountFlagBits::e64) out += "e64 | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(AttachmentDescriptionFlagBits val) {
    switch(val) {
        case(AttachmentDescriptionFlagBits::MayAlias): return "MayAlias";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(AttachmentDescriptionFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & AttachmentDescriptionFlagBits::MayAlias) out += "MayAlias | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(StencilFaceFlagBits val) {
    switch(val) {
        case(StencilFaceFlagBits::Front): return "Front";
        case(StencilFaceFlagBits::Back): return "Back";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(StencilFaceFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & StencilFaceFlagBits::Front) out += "Front | ";
    if (flag & StencilFaceFlagBits::Back) out += "Back | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DescriptorPoolCreateFlagBits val) {
    switch(val) {
        case(DescriptorPoolCreateFlagBits::FreeDescriptorSet): return "FreeDescriptorSet";
        case(DescriptorPoolCreateFlagBits::HostOnlyBitVALVE): return "HostOnlyBitVALVE";
        case(DescriptorPoolCreateFlagBits::UpdateAfterBind): return "UpdateAfterBind";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DescriptorPoolCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DescriptorPoolCreateFlagBits::FreeDescriptorSet) out += "FreeDescriptorSet | ";
    if (flag & DescriptorPoolCreateFlagBits::HostOnlyBitVALVE) out += "HostOnlyBitVALVE | ";
    if (flag & DescriptorPoolCreateFlagBits::UpdateAfterBind) out += "UpdateAfterBind | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DependencyFlagBits val) {
    switch(val) {
        case(DependencyFlagBits::ByRegion): return "ByRegion";
        case(DependencyFlagBits::DeviceGroup): return "DeviceGroup";
        case(DependencyFlagBits::ViewLocal): return "ViewLocal";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DependencyFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DependencyFlagBits::ByRegion) out += "ByRegion | ";
    if (flag & DependencyFlagBits::DeviceGroup) out += "DeviceGroup | ";
    if (flag & DependencyFlagBits::ViewLocal) out += "ViewLocal | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SemaphoreWaitFlagBits val) {
    switch(val) {
        case(SemaphoreWaitFlagBits::Any): return "Any";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SemaphoreWaitFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SemaphoreWaitFlagBits::Any) out += "Any | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DisplayPlaneAlphaFlagBitsKHR val) {
    switch(val) {
        case(DisplayPlaneAlphaFlagBitsKHR::OpaqueBitKHR): return "OpaqueBitKHR";
        case(DisplayPlaneAlphaFlagBitsKHR::GlobalBitKHR): return "GlobalBitKHR";
        case(DisplayPlaneAlphaFlagBitsKHR::PerPixelBitKHR): return "PerPixelBitKHR";
        case(DisplayPlaneAlphaFlagBitsKHR::PerPixelPremultipliedBitKHR): return "PerPixelPremultipliedBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DisplayPlaneAlphaFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DisplayPlaneAlphaFlagBitsKHR::OpaqueBitKHR) out += "OpaqueBitKHR | ";
    if (flag & DisplayPlaneAlphaFlagBitsKHR::GlobalBitKHR) out += "GlobalBitKHR | ";
    if (flag & DisplayPlaneAlphaFlagBitsKHR::PerPixelBitKHR) out += "PerPixelBitKHR | ";
    if (flag & DisplayPlaneAlphaFlagBitsKHR::PerPixelPremultipliedBitKHR) out += "PerPixelPremultipliedBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(CompositeAlphaFlagBitsKHR val) {
    switch(val) {
        case(CompositeAlphaFlagBitsKHR::OpaqueBitKHR): return "OpaqueBitKHR";
        case(CompositeAlphaFlagBitsKHR::PreMultipliedBitKHR): return "PreMultipliedBitKHR";
        case(CompositeAlphaFlagBitsKHR::PostMultipliedBitKHR): return "PostMultipliedBitKHR";
        case(CompositeAlphaFlagBitsKHR::InheritBitKHR): return "InheritBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(CompositeAlphaFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & CompositeAlphaFlagBitsKHR::OpaqueBitKHR) out += "OpaqueBitKHR | ";
    if (flag & CompositeAlphaFlagBitsKHR::PreMultipliedBitKHR) out += "PreMultipliedBitKHR | ";
    if (flag & CompositeAlphaFlagBitsKHR::PostMultipliedBitKHR) out += "PostMultipliedBitKHR | ";
    if (flag & CompositeAlphaFlagBitsKHR::InheritBitKHR) out += "InheritBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SurfaceTransformFlagBitsKHR val) {
    switch(val) {
        case(SurfaceTransformFlagBitsKHR::IdentityBitKHR): return "IdentityBitKHR";
        case(SurfaceTransformFlagBitsKHR::Rotate90BitKHR): return "Rotate90BitKHR";
        case(SurfaceTransformFlagBitsKHR::Rotate180BitKHR): return "Rotate180BitKHR";
        case(SurfaceTransformFlagBitsKHR::Rotate270BitKHR): return "Rotate270BitKHR";
        case(SurfaceTransformFlagBitsKHR::HorizontalMirrorBitKHR): return "HorizontalMirrorBitKHR";
        case(SurfaceTransformFlagBitsKHR::HorizontalMirrorRotate90BitKHR): return "HorizontalMirrorRotate90BitKHR";
        case(SurfaceTransformFlagBitsKHR::HorizontalMirrorRotate180BitKHR): return "HorizontalMirrorRotate180BitKHR";
        case(SurfaceTransformFlagBitsKHR::HorizontalMirrorRotate270BitKHR): return "HorizontalMirrorRotate270BitKHR";
        case(SurfaceTransformFlagBitsKHR::InheritBitKHR): return "InheritBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SurfaceTransformFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SurfaceTransformFlagBitsKHR::IdentityBitKHR) out += "IdentityBitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::Rotate90BitKHR) out += "Rotate90BitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::Rotate180BitKHR) out += "Rotate180BitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::Rotate270BitKHR) out += "Rotate270BitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::HorizontalMirrorBitKHR) out += "HorizontalMirrorBitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::HorizontalMirrorRotate90BitKHR) out += "HorizontalMirrorRotate90BitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::HorizontalMirrorRotate180BitKHR) out += "HorizontalMirrorRotate180BitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::HorizontalMirrorRotate270BitKHR) out += "HorizontalMirrorRotate270BitKHR | ";
    if (flag & SurfaceTransformFlagBitsKHR::InheritBitKHR) out += "InheritBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DebugReportFlagBitsEXT val) {
    switch(val) {
        case(DebugReportFlagBitsEXT::InformationBitEXT): return "InformationBitEXT";
        case(DebugReportFlagBitsEXT::WarningBitEXT): return "WarningBitEXT";
        case(DebugReportFlagBitsEXT::PerformanceWarningBitEXT): return "PerformanceWarningBitEXT";
        case(DebugReportFlagBitsEXT::ErrorBitEXT): return "ErrorBitEXT";
        case(DebugReportFlagBitsEXT::DebugBitEXT): return "DebugBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DebugReportFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DebugReportFlagBitsEXT::InformationBitEXT) out += "InformationBitEXT | ";
    if (flag & DebugReportFlagBitsEXT::WarningBitEXT) out += "WarningBitEXT | ";
    if (flag & DebugReportFlagBitsEXT::PerformanceWarningBitEXT) out += "PerformanceWarningBitEXT | ";
    if (flag & DebugReportFlagBitsEXT::ErrorBitEXT) out += "ErrorBitEXT | ";
    if (flag & DebugReportFlagBitsEXT::DebugBitEXT) out += "DebugBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalMemoryHandleTypeFlagBitsNV val) {
    switch(val) {
        case(ExternalMemoryHandleTypeFlagBitsNV::OpaqueWin32BitNV): return "OpaqueWin32BitNV";
        case(ExternalMemoryHandleTypeFlagBitsNV::OpaqueWin32KmtBitNV): return "OpaqueWin32KmtBitNV";
        case(ExternalMemoryHandleTypeFlagBitsNV::D3D11ImageBitNV): return "D3D11ImageBitNV";
        case(ExternalMemoryHandleTypeFlagBitsNV::D3D11ImageKmtBitNV): return "D3D11ImageKmtBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalMemoryHandleTypeFlagsNV flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalMemoryHandleTypeFlagBitsNV::OpaqueWin32BitNV) out += "OpaqueWin32BitNV | ";
    if (flag & ExternalMemoryHandleTypeFlagBitsNV::OpaqueWin32KmtBitNV) out += "OpaqueWin32KmtBitNV | ";
    if (flag & ExternalMemoryHandleTypeFlagBitsNV::D3D11ImageBitNV) out += "D3D11ImageBitNV | ";
    if (flag & ExternalMemoryHandleTypeFlagBitsNV::D3D11ImageKmtBitNV) out += "D3D11ImageKmtBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalMemoryFeatureFlagBitsNV val) {
    switch(val) {
        case(ExternalMemoryFeatureFlagBitsNV::DedicatedOnlyBitNV): return "DedicatedOnlyBitNV";
        case(ExternalMemoryFeatureFlagBitsNV::ExportableBitNV): return "ExportableBitNV";
        case(ExternalMemoryFeatureFlagBitsNV::ImportableBitNV): return "ImportableBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalMemoryFeatureFlagsNV flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalMemoryFeatureFlagBitsNV::DedicatedOnlyBitNV) out += "DedicatedOnlyBitNV | ";
    if (flag & ExternalMemoryFeatureFlagBitsNV::ExportableBitNV) out += "ExportableBitNV | ";
    if (flag & ExternalMemoryFeatureFlagBitsNV::ImportableBitNV) out += "ImportableBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SubgroupFeatureFlagBits val) {
    switch(val) {
        case(SubgroupFeatureFlagBits::Basic): return "Basic";
        case(SubgroupFeatureFlagBits::Vote): return "Vote";
        case(SubgroupFeatureFlagBits::Arithmetic): return "Arithmetic";
        case(SubgroupFeatureFlagBits::Ballot): return "Ballot";
        case(SubgroupFeatureFlagBits::Shuffle): return "Shuffle";
        case(SubgroupFeatureFlagBits::ShuffleRelative): return "ShuffleRelative";
        case(SubgroupFeatureFlagBits::Clustered): return "Clustered";
        case(SubgroupFeatureFlagBits::Quad): return "Quad";
        case(SubgroupFeatureFlagBits::PartitionedBitNV): return "PartitionedBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SubgroupFeatureFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SubgroupFeatureFlagBits::Basic) out += "Basic | ";
    if (flag & SubgroupFeatureFlagBits::Vote) out += "Vote | ";
    if (flag & SubgroupFeatureFlagBits::Arithmetic) out += "Arithmetic | ";
    if (flag & SubgroupFeatureFlagBits::Ballot) out += "Ballot | ";
    if (flag & SubgroupFeatureFlagBits::Shuffle) out += "Shuffle | ";
    if (flag & SubgroupFeatureFlagBits::ShuffleRelative) out += "ShuffleRelative | ";
    if (flag & SubgroupFeatureFlagBits::Clustered) out += "Clustered | ";
    if (flag & SubgroupFeatureFlagBits::Quad) out += "Quad | ";
    if (flag & SubgroupFeatureFlagBits::PartitionedBitNV) out += "PartitionedBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(IndirectCommandsLayoutUsageFlagBitsNV val) {
    switch(val) {
        case(IndirectCommandsLayoutUsageFlagBitsNV::ExplicitPreprocessBitNV): return "ExplicitPreprocessBitNV";
        case(IndirectCommandsLayoutUsageFlagBitsNV::IndexedSequencesBitNV): return "IndexedSequencesBitNV";
        case(IndirectCommandsLayoutUsageFlagBitsNV::UnorderedSequencesBitNV): return "UnorderedSequencesBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(IndirectCommandsLayoutUsageFlagsNV flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & IndirectCommandsLayoutUsageFlagBitsNV::ExplicitPreprocessBitNV) out += "ExplicitPreprocessBitNV | ";
    if (flag & IndirectCommandsLayoutUsageFlagBitsNV::IndexedSequencesBitNV) out += "IndexedSequencesBitNV | ";
    if (flag & IndirectCommandsLayoutUsageFlagBitsNV::UnorderedSequencesBitNV) out += "UnorderedSequencesBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(IndirectStateFlagBitsNV val) {
    switch(val) {
        case(IndirectStateFlagBitsNV::FlagFrontfaceBitNV): return "FlagFrontfaceBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(IndirectStateFlagsNV flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & IndirectStateFlagBitsNV::FlagFrontfaceBitNV) out += "FlagFrontfaceBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string([[maybe_unused]] PrivateDataSlotCreateFlagBitsEXT val) { return "UNKNOWN"; }
inline std::string to_string([[maybe_unused]] PrivateDataSlotCreateFlagsEXT flag){ return "UNKNOWN"; }
inline const char * to_string(DescriptorSetLayoutCreateFlagBits val) {
    switch(val) {
        case(DescriptorSetLayoutCreateFlagBits::PushDescriptorBitKHR): return "PushDescriptorBitKHR";
        case(DescriptorSetLayoutCreateFlagBits::HostOnlyPoolBitVALVE): return "HostOnlyPoolBitVALVE";
        case(DescriptorSetLayoutCreateFlagBits::UpdateAfterBindPool): return "UpdateAfterBindPool";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DescriptorSetLayoutCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DescriptorSetLayoutCreateFlagBits::PushDescriptorBitKHR) out += "PushDescriptorBitKHR | ";
    if (flag & DescriptorSetLayoutCreateFlagBits::HostOnlyPoolBitVALVE) out += "HostOnlyPoolBitVALVE | ";
    if (flag & DescriptorSetLayoutCreateFlagBits::UpdateAfterBindPool) out += "UpdateAfterBindPool | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalMemoryHandleTypeFlagBits val) {
    switch(val) {
        case(ExternalMemoryHandleTypeFlagBits::OpaqueFd): return "OpaqueFd";
        case(ExternalMemoryHandleTypeFlagBits::OpaqueWin32): return "OpaqueWin32";
        case(ExternalMemoryHandleTypeFlagBits::OpaqueWin32Kmt): return "OpaqueWin32Kmt";
        case(ExternalMemoryHandleTypeFlagBits::D3D11Texture): return "D3D11Texture";
        case(ExternalMemoryHandleTypeFlagBits::D3D11TextureKmt): return "D3D11TextureKmt";
        case(ExternalMemoryHandleTypeFlagBits::D3D12Heap): return "D3D12Heap";
        case(ExternalMemoryHandleTypeFlagBits::D3D12Resource): return "D3D12Resource";
        case(ExternalMemoryHandleTypeFlagBits::DmaBufBitEXT): return "DmaBufBitEXT";
        case(ExternalMemoryHandleTypeFlagBits::AndroidHardwareBufferBitANDROID): return "AndroidHardwareBufferBitANDROID";
        case(ExternalMemoryHandleTypeFlagBits::HostAllocationBitEXT): return "HostAllocationBitEXT";
        case(ExternalMemoryHandleTypeFlagBits::HostMappedForeignMemoryBitEXT): return "HostMappedForeignMemoryBitEXT";
        case(ExternalMemoryHandleTypeFlagBits::ZirconVmoBitFUCHSIA): return "ZirconVmoBitFUCHSIA";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalMemoryHandleTypeFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalMemoryHandleTypeFlagBits::OpaqueFd) out += "OpaqueFd | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::OpaqueWin32) out += "OpaqueWin32 | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::OpaqueWin32Kmt) out += "OpaqueWin32Kmt | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::D3D11Texture) out += "D3D11Texture | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::D3D11TextureKmt) out += "D3D11TextureKmt | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::D3D12Heap) out += "D3D12Heap | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::D3D12Resource) out += "D3D12Resource | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::DmaBufBitEXT) out += "DmaBufBitEXT | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::AndroidHardwareBufferBitANDROID) out += "AndroidHardwareBufferBitANDROID | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::HostAllocationBitEXT) out += "HostAllocationBitEXT | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::HostMappedForeignMemoryBitEXT) out += "HostMappedForeignMemoryBitEXT | ";
    if (flag & ExternalMemoryHandleTypeFlagBits::ZirconVmoBitFUCHSIA) out += "ZirconVmoBitFUCHSIA | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalMemoryFeatureFlagBits val) {
    switch(val) {
        case(ExternalMemoryFeatureFlagBits::DedicatedOnly): return "DedicatedOnly";
        case(ExternalMemoryFeatureFlagBits::Exportable): return "Exportable";
        case(ExternalMemoryFeatureFlagBits::Importable): return "Importable";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalMemoryFeatureFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalMemoryFeatureFlagBits::DedicatedOnly) out += "DedicatedOnly | ";
    if (flag & ExternalMemoryFeatureFlagBits::Exportable) out += "Exportable | ";
    if (flag & ExternalMemoryFeatureFlagBits::Importable) out += "Importable | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalSemaphoreHandleTypeFlagBits val) {
    switch(val) {
        case(ExternalSemaphoreHandleTypeFlagBits::OpaqueFd): return "OpaqueFd";
        case(ExternalSemaphoreHandleTypeFlagBits::OpaqueWin32): return "OpaqueWin32";
        case(ExternalSemaphoreHandleTypeFlagBits::OpaqueWin32Kmt): return "OpaqueWin32Kmt";
        case(ExternalSemaphoreHandleTypeFlagBits::D3D12Fence): return "D3D12Fence";
        case(ExternalSemaphoreHandleTypeFlagBits::SyncFd): return "SyncFd";
        case(ExternalSemaphoreHandleTypeFlagBits::ZirconEventBitFUCHSIA): return "ZirconEventBitFUCHSIA";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalSemaphoreHandleTypeFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalSemaphoreHandleTypeFlagBits::OpaqueFd) out += "OpaqueFd | ";
    if (flag & ExternalSemaphoreHandleTypeFlagBits::OpaqueWin32) out += "OpaqueWin32 | ";
    if (flag & ExternalSemaphoreHandleTypeFlagBits::OpaqueWin32Kmt) out += "OpaqueWin32Kmt | ";
    if (flag & ExternalSemaphoreHandleTypeFlagBits::D3D12Fence) out += "D3D12Fence | ";
    if (flag & ExternalSemaphoreHandleTypeFlagBits::SyncFd) out += "SyncFd | ";
    if (flag & ExternalSemaphoreHandleTypeFlagBits::ZirconEventBitFUCHSIA) out += "ZirconEventBitFUCHSIA | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalSemaphoreFeatureFlagBits val) {
    switch(val) {
        case(ExternalSemaphoreFeatureFlagBits::Exportable): return "Exportable";
        case(ExternalSemaphoreFeatureFlagBits::Importable): return "Importable";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalSemaphoreFeatureFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalSemaphoreFeatureFlagBits::Exportable) out += "Exportable | ";
    if (flag & ExternalSemaphoreFeatureFlagBits::Importable) out += "Importable | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SemaphoreImportFlagBits val) {
    switch(val) {
        case(SemaphoreImportFlagBits::Temporary): return "Temporary";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SemaphoreImportFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SemaphoreImportFlagBits::Temporary) out += "Temporary | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalFenceHandleTypeFlagBits val) {
    switch(val) {
        case(ExternalFenceHandleTypeFlagBits::OpaqueFd): return "OpaqueFd";
        case(ExternalFenceHandleTypeFlagBits::OpaqueWin32): return "OpaqueWin32";
        case(ExternalFenceHandleTypeFlagBits::OpaqueWin32Kmt): return "OpaqueWin32Kmt";
        case(ExternalFenceHandleTypeFlagBits::SyncFd): return "SyncFd";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalFenceHandleTypeFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalFenceHandleTypeFlagBits::OpaqueFd) out += "OpaqueFd | ";
    if (flag & ExternalFenceHandleTypeFlagBits::OpaqueWin32) out += "OpaqueWin32 | ";
    if (flag & ExternalFenceHandleTypeFlagBits::OpaqueWin32Kmt) out += "OpaqueWin32Kmt | ";
    if (flag & ExternalFenceHandleTypeFlagBits::SyncFd) out += "SyncFd | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ExternalFenceFeatureFlagBits val) {
    switch(val) {
        case(ExternalFenceFeatureFlagBits::Exportable): return "Exportable";
        case(ExternalFenceFeatureFlagBits::Importable): return "Importable";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ExternalFenceFeatureFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ExternalFenceFeatureFlagBits::Exportable) out += "Exportable | ";
    if (flag & ExternalFenceFeatureFlagBits::Importable) out += "Importable | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(FenceImportFlagBits val) {
    switch(val) {
        case(FenceImportFlagBits::Temporary): return "Temporary";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(FenceImportFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & FenceImportFlagBits::Temporary) out += "Temporary | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SurfaceCounterFlagBitsEXT val) {
    switch(val) {
        case(SurfaceCounterFlagBitsEXT::VblankBitEXT): return "VblankBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SurfaceCounterFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SurfaceCounterFlagBitsEXT::VblankBitEXT) out += "VblankBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PeerMemoryFeatureFlagBits val) {
    switch(val) {
        case(PeerMemoryFeatureFlagBits::CopySrc): return "CopySrc";
        case(PeerMemoryFeatureFlagBits::CopyDst): return "CopyDst";
        case(PeerMemoryFeatureFlagBits::GenericSrc): return "GenericSrc";
        case(PeerMemoryFeatureFlagBits::GenericDst): return "GenericDst";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PeerMemoryFeatureFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PeerMemoryFeatureFlagBits::CopySrc) out += "CopySrc | ";
    if (flag & PeerMemoryFeatureFlagBits::CopyDst) out += "CopyDst | ";
    if (flag & PeerMemoryFeatureFlagBits::GenericSrc) out += "GenericSrc | ";
    if (flag & PeerMemoryFeatureFlagBits::GenericDst) out += "GenericDst | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(MemoryAllocateFlagBits val) {
    switch(val) {
        case(MemoryAllocateFlagBits::DeviceMask): return "DeviceMask";
        case(MemoryAllocateFlagBits::DeviceAddress): return "DeviceAddress";
        case(MemoryAllocateFlagBits::DeviceAddressCaptureReplay): return "DeviceAddressCaptureReplay";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(MemoryAllocateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & MemoryAllocateFlagBits::DeviceMask) out += "DeviceMask | ";
    if (flag & MemoryAllocateFlagBits::DeviceAddress) out += "DeviceAddress | ";
    if (flag & MemoryAllocateFlagBits::DeviceAddressCaptureReplay) out += "DeviceAddressCaptureReplay | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DeviceGroupPresentModeFlagBitsKHR val) {
    switch(val) {
        case(DeviceGroupPresentModeFlagBitsKHR::LocalBitKHR): return "LocalBitKHR";
        case(DeviceGroupPresentModeFlagBitsKHR::RemoteBitKHR): return "RemoteBitKHR";
        case(DeviceGroupPresentModeFlagBitsKHR::SumBitKHR): return "SumBitKHR";
        case(DeviceGroupPresentModeFlagBitsKHR::LocalMultiDeviceBitKHR): return "LocalMultiDeviceBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DeviceGroupPresentModeFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DeviceGroupPresentModeFlagBitsKHR::LocalBitKHR) out += "LocalBitKHR | ";
    if (flag & DeviceGroupPresentModeFlagBitsKHR::RemoteBitKHR) out += "RemoteBitKHR | ";
    if (flag & DeviceGroupPresentModeFlagBitsKHR::SumBitKHR) out += "SumBitKHR | ";
    if (flag & DeviceGroupPresentModeFlagBitsKHR::LocalMultiDeviceBitKHR) out += "LocalMultiDeviceBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SwapchainCreateFlagBitsKHR val) {
    switch(val) {
        case(SwapchainCreateFlagBitsKHR::SplitInstanceBindRegionsBitKHR): return "SplitInstanceBindRegionsBitKHR";
        case(SwapchainCreateFlagBitsKHR::ProtectedBitKHR): return "ProtectedBitKHR";
        case(SwapchainCreateFlagBitsKHR::MutableFormatBitKHR): return "MutableFormatBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SwapchainCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SwapchainCreateFlagBitsKHR::SplitInstanceBindRegionsBitKHR) out += "SplitInstanceBindRegionsBitKHR | ";
    if (flag & SwapchainCreateFlagBitsKHR::ProtectedBitKHR) out += "ProtectedBitKHR | ";
    if (flag & SwapchainCreateFlagBitsKHR::MutableFormatBitKHR) out += "MutableFormatBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SubpassDescriptionFlagBits val) {
    switch(val) {
        case(SubpassDescriptionFlagBits::PerViewAttributesBitNVX): return "PerViewAttributesBitNVX";
        case(SubpassDescriptionFlagBits::PerViewPositionXOnlyBitNVX): return "PerViewPositionXOnlyBitNVX";
        case(SubpassDescriptionFlagBits::FragmentRegionBitQCOM): return "FragmentRegionBitQCOM";
        case(SubpassDescriptionFlagBits::ShaderResolveBitQCOM): return "ShaderResolveBitQCOM";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SubpassDescriptionFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SubpassDescriptionFlagBits::PerViewAttributesBitNVX) out += "PerViewAttributesBitNVX | ";
    if (flag & SubpassDescriptionFlagBits::PerViewPositionXOnlyBitNVX) out += "PerViewPositionXOnlyBitNVX | ";
    if (flag & SubpassDescriptionFlagBits::FragmentRegionBitQCOM) out += "FragmentRegionBitQCOM | ";
    if (flag & SubpassDescriptionFlagBits::ShaderResolveBitQCOM) out += "ShaderResolveBitQCOM | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DebugUtilsMessageSeverityFlagBitsEXT val) {
    switch(val) {
        case(DebugUtilsMessageSeverityFlagBitsEXT::VerboseBitEXT): return "VerboseBitEXT";
        case(DebugUtilsMessageSeverityFlagBitsEXT::InfoBitEXT): return "InfoBitEXT";
        case(DebugUtilsMessageSeverityFlagBitsEXT::WarningBitEXT): return "WarningBitEXT";
        case(DebugUtilsMessageSeverityFlagBitsEXT::ErrorBitEXT): return "ErrorBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DebugUtilsMessageSeverityFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DebugUtilsMessageSeverityFlagBitsEXT::VerboseBitEXT) out += "VerboseBitEXT | ";
    if (flag & DebugUtilsMessageSeverityFlagBitsEXT::InfoBitEXT) out += "InfoBitEXT | ";
    if (flag & DebugUtilsMessageSeverityFlagBitsEXT::WarningBitEXT) out += "WarningBitEXT | ";
    if (flag & DebugUtilsMessageSeverityFlagBitsEXT::ErrorBitEXT) out += "ErrorBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DebugUtilsMessageTypeFlagBitsEXT val) {
    switch(val) {
        case(DebugUtilsMessageTypeFlagBitsEXT::GeneralBitEXT): return "GeneralBitEXT";
        case(DebugUtilsMessageTypeFlagBitsEXT::ValidationBitEXT): return "ValidationBitEXT";
        case(DebugUtilsMessageTypeFlagBitsEXT::PerformanceBitEXT): return "PerformanceBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DebugUtilsMessageTypeFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DebugUtilsMessageTypeFlagBitsEXT::GeneralBitEXT) out += "GeneralBitEXT | ";
    if (flag & DebugUtilsMessageTypeFlagBitsEXT::ValidationBitEXT) out += "ValidationBitEXT | ";
    if (flag & DebugUtilsMessageTypeFlagBitsEXT::PerformanceBitEXT) out += "PerformanceBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DescriptorBindingFlagBits val) {
    switch(val) {
        case(DescriptorBindingFlagBits::UpdateAfterBind): return "UpdateAfterBind";
        case(DescriptorBindingFlagBits::UpdateUnusedWhilePending): return "UpdateUnusedWhilePending";
        case(DescriptorBindingFlagBits::PartiallyBound): return "PartiallyBound";
        case(DescriptorBindingFlagBits::VariableDescriptorCount): return "VariableDescriptorCount";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DescriptorBindingFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DescriptorBindingFlagBits::UpdateAfterBind) out += "UpdateAfterBind | ";
    if (flag & DescriptorBindingFlagBits::UpdateUnusedWhilePending) out += "UpdateUnusedWhilePending | ";
    if (flag & DescriptorBindingFlagBits::PartiallyBound) out += "PartiallyBound | ";
    if (flag & DescriptorBindingFlagBits::VariableDescriptorCount) out += "VariableDescriptorCount | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ConditionalRenderingFlagBitsEXT val) {
    switch(val) {
        case(ConditionalRenderingFlagBitsEXT::InvertedBitEXT): return "InvertedBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ConditionalRenderingFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ConditionalRenderingFlagBitsEXT::InvertedBitEXT) out += "InvertedBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(ResolveModeFlagBits val) {
    switch(val) {
        case(ResolveModeFlagBits::None): return "None";
        case(ResolveModeFlagBits::SampleZero): return "SampleZero";
        case(ResolveModeFlagBits::Average): return "Average";
        case(ResolveModeFlagBits::Min): return "Min";
        case(ResolveModeFlagBits::Max): return "Max";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ResolveModeFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ResolveModeFlagBits::None) out += "None | ";
    if (flag & ResolveModeFlagBits::SampleZero) out += "SampleZero | ";
    if (flag & ResolveModeFlagBits::Average) out += "Average | ";
    if (flag & ResolveModeFlagBits::Min) out += "Min | ";
    if (flag & ResolveModeFlagBits::Max) out += "Max | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(GeometryInstanceFlagBitsKHR val) {
    switch(val) {
        case(GeometryInstanceFlagBitsKHR::TriangleFacingCullDisableBitKHR): return "TriangleFacingCullDisableBitKHR";
        case(GeometryInstanceFlagBitsKHR::TriangleFrontCounterclockwiseBitKHR): return "TriangleFrontCounterclockwiseBitKHR";
        case(GeometryInstanceFlagBitsKHR::ForceOpaqueBitKHR): return "ForceOpaqueBitKHR";
        case(GeometryInstanceFlagBitsKHR::ForceNoOpaqueBitKHR): return "ForceNoOpaqueBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(GeometryInstanceFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & GeometryInstanceFlagBitsKHR::TriangleFacingCullDisableBitKHR) out += "TriangleFacingCullDisableBitKHR | ";
    if (flag & GeometryInstanceFlagBitsKHR::TriangleFrontCounterclockwiseBitKHR) out += "TriangleFrontCounterclockwiseBitKHR | ";
    if (flag & GeometryInstanceFlagBitsKHR::ForceOpaqueBitKHR) out += "ForceOpaqueBitKHR | ";
    if (flag & GeometryInstanceFlagBitsKHR::ForceNoOpaqueBitKHR) out += "ForceNoOpaqueBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(GeometryFlagBitsKHR val) {
    switch(val) {
        case(GeometryFlagBitsKHR::OpaqueBitKHR): return "OpaqueBitKHR";
        case(GeometryFlagBitsKHR::NoDuplicateAnyHitInvocationBitKHR): return "NoDuplicateAnyHitInvocationBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(GeometryFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & GeometryFlagBitsKHR::OpaqueBitKHR) out += "OpaqueBitKHR | ";
    if (flag & GeometryFlagBitsKHR::NoDuplicateAnyHitInvocationBitKHR) out += "NoDuplicateAnyHitInvocationBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(BuildAccelerationStructureFlagBitsKHR val) {
    switch(val) {
        case(BuildAccelerationStructureFlagBitsKHR::AllowUpdateBitKHR): return "AllowUpdateBitKHR";
        case(BuildAccelerationStructureFlagBitsKHR::AllowCompactionBitKHR): return "AllowCompactionBitKHR";
        case(BuildAccelerationStructureFlagBitsKHR::PreferFastTraceBitKHR): return "PreferFastTraceBitKHR";
        case(BuildAccelerationStructureFlagBitsKHR::PreferFastBuildBitKHR): return "PreferFastBuildBitKHR";
        case(BuildAccelerationStructureFlagBitsKHR::LowMemoryBitKHR): return "LowMemoryBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(BuildAccelerationStructureFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & BuildAccelerationStructureFlagBitsKHR::AllowUpdateBitKHR) out += "AllowUpdateBitKHR | ";
    if (flag & BuildAccelerationStructureFlagBitsKHR::AllowCompactionBitKHR) out += "AllowCompactionBitKHR | ";
    if (flag & BuildAccelerationStructureFlagBitsKHR::PreferFastTraceBitKHR) out += "PreferFastTraceBitKHR | ";
    if (flag & BuildAccelerationStructureFlagBitsKHR::PreferFastBuildBitKHR) out += "PreferFastBuildBitKHR | ";
    if (flag & BuildAccelerationStructureFlagBitsKHR::LowMemoryBitKHR) out += "LowMemoryBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(AccelerationStructureCreateFlagBitsKHR val) {
    switch(val) {
        case(AccelerationStructureCreateFlagBitsKHR::DeviceAddressCaptureReplayBitKHR): return "DeviceAddressCaptureReplayBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(AccelerationStructureCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & AccelerationStructureCreateFlagBitsKHR::DeviceAddressCaptureReplayBitKHR) out += "DeviceAddressCaptureReplayBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(FramebufferCreateFlagBits val) {
    switch(val) {
        case(FramebufferCreateFlagBits::Imageless): return "Imageless";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(FramebufferCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & FramebufferCreateFlagBits::Imageless) out += "Imageless | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(DeviceDiagnosticsConfigFlagBitsNV val) {
    switch(val) {
        case(DeviceDiagnosticsConfigFlagBitsNV::EnableShaderDebugInfoBitNV): return "EnableShaderDebugInfoBitNV";
        case(DeviceDiagnosticsConfigFlagBitsNV::EnableResourceTrackingBitNV): return "EnableResourceTrackingBitNV";
        case(DeviceDiagnosticsConfigFlagBitsNV::EnableAutomaticCheckpointsBitNV): return "EnableAutomaticCheckpointsBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(DeviceDiagnosticsConfigFlagsNV flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & DeviceDiagnosticsConfigFlagBitsNV::EnableShaderDebugInfoBitNV) out += "EnableShaderDebugInfoBitNV | ";
    if (flag & DeviceDiagnosticsConfigFlagBitsNV::EnableResourceTrackingBitNV) out += "EnableResourceTrackingBitNV | ";
    if (flag & DeviceDiagnosticsConfigFlagBitsNV::EnableAutomaticCheckpointsBitNV) out += "EnableAutomaticCheckpointsBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PipelineCreationFeedbackFlagBitsEXT val) {
    switch(val) {
        case(PipelineCreationFeedbackFlagBitsEXT::ValidBitEXT): return "ValidBitEXT";
        case(PipelineCreationFeedbackFlagBitsEXT::ApplicationPipelineCacheHitBitEXT): return "ApplicationPipelineCacheHitBitEXT";
        case(PipelineCreationFeedbackFlagBitsEXT::BasePipelineAccelerationBitEXT): return "BasePipelineAccelerationBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PipelineCreationFeedbackFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PipelineCreationFeedbackFlagBitsEXT::ValidBitEXT) out += "ValidBitEXT | ";
    if (flag & PipelineCreationFeedbackFlagBitsEXT::ApplicationPipelineCacheHitBitEXT) out += "ApplicationPipelineCacheHitBitEXT | ";
    if (flag & PipelineCreationFeedbackFlagBitsEXT::BasePipelineAccelerationBitEXT) out += "BasePipelineAccelerationBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PerformanceCounterDescriptionFlagBitsKHR val) {
    switch(val) {
        case(PerformanceCounterDescriptionFlagBitsKHR::PerformanceImpactingBitKHR): return "PerformanceImpactingBitKHR";
        case(PerformanceCounterDescriptionFlagBitsKHR::ConcurrentlyImpactedBitKHR): return "ConcurrentlyImpactedBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PerformanceCounterDescriptionFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PerformanceCounterDescriptionFlagBitsKHR::PerformanceImpactingBitKHR) out += "PerformanceImpactingBitKHR | ";
    if (flag & PerformanceCounterDescriptionFlagBitsKHR::ConcurrentlyImpactedBitKHR) out += "ConcurrentlyImpactedBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string([[maybe_unused]] AcquireProfilingLockFlagBitsKHR val) { return "UNKNOWN"; }
inline std::string to_string([[maybe_unused]] AcquireProfilingLockFlagsKHR flag){ return "UNKNOWN"; }
inline const char * to_string([[maybe_unused]] ShaderCorePropertiesFlagBitsAMD val) { return "UNKNOWN"; }
inline std::string to_string([[maybe_unused]] ShaderCorePropertiesFlagsAMD flag){ return "UNKNOWN"; }
inline const char * to_string([[maybe_unused]] ShaderModuleCreateFlagBits val) { return "UNKNOWN"; }
inline std::string to_string([[maybe_unused]] ShaderModuleCreateFlags flag){ return "UNKNOWN"; }
inline const char * to_string([[maybe_unused]] PipelineCompilerControlFlagBitsAMD val) { return "UNKNOWN"; }
inline std::string to_string([[maybe_unused]] PipelineCompilerControlFlagsAMD flag){ return "UNKNOWN"; }
inline const char * to_string(ToolPurposeFlagBitsEXT val) {
    switch(val) {
        case(ToolPurposeFlagBitsEXT::ValidationBitEXT): return "ValidationBitEXT";
        case(ToolPurposeFlagBitsEXT::ProfilingBitEXT): return "ProfilingBitEXT";
        case(ToolPurposeFlagBitsEXT::TracingBitEXT): return "TracingBitEXT";
        case(ToolPurposeFlagBitsEXT::AdditionalFeaturesBitEXT): return "AdditionalFeaturesBitEXT";
        case(ToolPurposeFlagBitsEXT::ModifyingFeaturesBitEXT): return "ModifyingFeaturesBitEXT";
        case(ToolPurposeFlagBitsEXT::DebugReportingBitEXT): return "DebugReportingBitEXT";
        case(ToolPurposeFlagBitsEXT::DebugMarkersBitEXT): return "DebugMarkersBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(ToolPurposeFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & ToolPurposeFlagBitsEXT::ValidationBitEXT) out += "ValidationBitEXT | ";
    if (flag & ToolPurposeFlagBitsEXT::ProfilingBitEXT) out += "ProfilingBitEXT | ";
    if (flag & ToolPurposeFlagBitsEXT::TracingBitEXT) out += "TracingBitEXT | ";
    if (flag & ToolPurposeFlagBitsEXT::AdditionalFeaturesBitEXT) out += "AdditionalFeaturesBitEXT | ";
    if (flag & ToolPurposeFlagBitsEXT::ModifyingFeaturesBitEXT) out += "ModifyingFeaturesBitEXT | ";
    if (flag & ToolPurposeFlagBitsEXT::DebugReportingBitEXT) out += "DebugReportingBitEXT | ";
    if (flag & ToolPurposeFlagBitsEXT::DebugMarkersBitEXT) out += "DebugMarkersBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(AccessFlagBits2KHR val) {
    switch(val) {
        case(AccessFlagBits2KHR::e2NoneKHR): return "e2NoneKHR";
        case(AccessFlagBits2KHR::e2IndirectCommandReadBitKHR): return "e2IndirectCommandReadBitKHR";
        case(AccessFlagBits2KHR::e2IndexReadBitKHR): return "e2IndexReadBitKHR";
        case(AccessFlagBits2KHR::e2VertexAttributeReadBitKHR): return "e2VertexAttributeReadBitKHR";
        case(AccessFlagBits2KHR::e2UniformReadBitKHR): return "e2UniformReadBitKHR";
        case(AccessFlagBits2KHR::e2InputAttachmentReadBitKHR): return "e2InputAttachmentReadBitKHR";
        case(AccessFlagBits2KHR::e2ShaderReadBitKHR): return "e2ShaderReadBitKHR";
        case(AccessFlagBits2KHR::e2ShaderWriteBitKHR): return "e2ShaderWriteBitKHR";
        case(AccessFlagBits2KHR::e2ColorAttachmentReadBitKHR): return "e2ColorAttachmentReadBitKHR";
        case(AccessFlagBits2KHR::e2ColorAttachmentWriteBitKHR): return "e2ColorAttachmentWriteBitKHR";
        case(AccessFlagBits2KHR::e2DepthStencilAttachmentReadBitKHR): return "e2DepthStencilAttachmentReadBitKHR";
        case(AccessFlagBits2KHR::e2DepthStencilAttachmentWriteBitKHR): return "e2DepthStencilAttachmentWriteBitKHR";
        case(AccessFlagBits2KHR::e2TransferReadBitKHR): return "e2TransferReadBitKHR";
        case(AccessFlagBits2KHR::e2TransferWriteBitKHR): return "e2TransferWriteBitKHR";
        case(AccessFlagBits2KHR::e2HostReadBitKHR): return "e2HostReadBitKHR";
        case(AccessFlagBits2KHR::e2HostWriteBitKHR): return "e2HostWriteBitKHR";
        case(AccessFlagBits2KHR::e2MemoryReadBitKHR): return "e2MemoryReadBitKHR";
        case(AccessFlagBits2KHR::e2MemoryWriteBitKHR): return "e2MemoryWriteBitKHR";
        case(AccessFlagBits2KHR::e2ShaderSampledReadBitKHR): return "e2ShaderSampledReadBitKHR";
        case(AccessFlagBits2KHR::e2ShaderStorageReadBitKHR): return "e2ShaderStorageReadBitKHR";
        case(AccessFlagBits2KHR::e2ShaderStorageWriteBitKHR): return "e2ShaderStorageWriteBitKHR";
        case(AccessFlagBits2KHR::e2VideoDecodeReadBitKHR): return "e2VideoDecodeReadBitKHR";
        case(AccessFlagBits2KHR::e2VideoDecodeWriteBitKHR): return "e2VideoDecodeWriteBitKHR";
        case(AccessFlagBits2KHR::e2VideoEncodeReadBitKHR): return "e2VideoEncodeReadBitKHR";
        case(AccessFlagBits2KHR::e2VideoEncodeWriteBitKHR): return "e2VideoEncodeWriteBitKHR";
        case(AccessFlagBits2KHR::e2TransformFeedbackWriteBitEXT): return "e2TransformFeedbackWriteBitEXT";
        case(AccessFlagBits2KHR::e2TransformFeedbackCounterReadBitEXT): return "e2TransformFeedbackCounterReadBitEXT";
        case(AccessFlagBits2KHR::e2TransformFeedbackCounterWriteBitEXT): return "e2TransformFeedbackCounterWriteBitEXT";
        case(AccessFlagBits2KHR::e2ConditionalRenderingReadBitEXT): return "e2ConditionalRenderingReadBitEXT";
        case(AccessFlagBits2KHR::e2CommandPreprocessReadBitNV): return "e2CommandPreprocessReadBitNV";
        case(AccessFlagBits2KHR::e2CommandPreprocessWriteBitNV): return "e2CommandPreprocessWriteBitNV";
        case(AccessFlagBits2KHR::e2FragmentShadingRateAttachmentReadBitKHR): return "e2FragmentShadingRateAttachmentReadBitKHR";
        case(AccessFlagBits2KHR::e2AccelerationStructureReadBitKHR): return "e2AccelerationStructureReadBitKHR";
        case(AccessFlagBits2KHR::e2AccelerationStructureWriteBitKHR): return "e2AccelerationStructureWriteBitKHR";
        case(AccessFlagBits2KHR::e2FragmentDensityMapReadBitEXT): return "e2FragmentDensityMapReadBitEXT";
        case(AccessFlagBits2KHR::e2ColorAttachmentReadNoncoherentBitEXT): return "e2ColorAttachmentReadNoncoherentBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(AccessFlags2KHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & AccessFlagBits2KHR::e2NoneKHR) out += "e2NoneKHR | ";
    if (flag & AccessFlagBits2KHR::e2IndirectCommandReadBitKHR) out += "e2IndirectCommandReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2IndexReadBitKHR) out += "e2IndexReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2VertexAttributeReadBitKHR) out += "e2VertexAttributeReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2UniformReadBitKHR) out += "e2UniformReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2InputAttachmentReadBitKHR) out += "e2InputAttachmentReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ShaderReadBitKHR) out += "e2ShaderReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ShaderWriteBitKHR) out += "e2ShaderWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ColorAttachmentReadBitKHR) out += "e2ColorAttachmentReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ColorAttachmentWriteBitKHR) out += "e2ColorAttachmentWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2DepthStencilAttachmentReadBitKHR) out += "e2DepthStencilAttachmentReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2DepthStencilAttachmentWriteBitKHR) out += "e2DepthStencilAttachmentWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2TransferReadBitKHR) out += "e2TransferReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2TransferWriteBitKHR) out += "e2TransferWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2HostReadBitKHR) out += "e2HostReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2HostWriteBitKHR) out += "e2HostWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2MemoryReadBitKHR) out += "e2MemoryReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2MemoryWriteBitKHR) out += "e2MemoryWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ShaderSampledReadBitKHR) out += "e2ShaderSampledReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ShaderStorageReadBitKHR) out += "e2ShaderStorageReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2ShaderStorageWriteBitKHR) out += "e2ShaderStorageWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2VideoDecodeReadBitKHR) out += "e2VideoDecodeReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2VideoDecodeWriteBitKHR) out += "e2VideoDecodeWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2VideoEncodeReadBitKHR) out += "e2VideoEncodeReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2VideoEncodeWriteBitKHR) out += "e2VideoEncodeWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2TransformFeedbackWriteBitEXT) out += "e2TransformFeedbackWriteBitEXT | ";
    if (flag & AccessFlagBits2KHR::e2TransformFeedbackCounterReadBitEXT) out += "e2TransformFeedbackCounterReadBitEXT | ";
    if (flag & AccessFlagBits2KHR::e2TransformFeedbackCounterWriteBitEXT) out += "e2TransformFeedbackCounterWriteBitEXT | ";
    if (flag & AccessFlagBits2KHR::e2ConditionalRenderingReadBitEXT) out += "e2ConditionalRenderingReadBitEXT | ";
    if (flag & AccessFlagBits2KHR::e2CommandPreprocessReadBitNV) out += "e2CommandPreprocessReadBitNV | ";
    if (flag & AccessFlagBits2KHR::e2CommandPreprocessWriteBitNV) out += "e2CommandPreprocessWriteBitNV | ";
    if (flag & AccessFlagBits2KHR::e2FragmentShadingRateAttachmentReadBitKHR) out += "e2FragmentShadingRateAttachmentReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2AccelerationStructureReadBitKHR) out += "e2AccelerationStructureReadBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2AccelerationStructureWriteBitKHR) out += "e2AccelerationStructureWriteBitKHR | ";
    if (flag & AccessFlagBits2KHR::e2FragmentDensityMapReadBitEXT) out += "e2FragmentDensityMapReadBitEXT | ";
    if (flag & AccessFlagBits2KHR::e2ColorAttachmentReadNoncoherentBitEXT) out += "e2ColorAttachmentReadNoncoherentBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(PipelineStageFlagBits2KHR val) {
    switch(val) {
        case(PipelineStageFlagBits2KHR::e2NoneKHR): return "e2NoneKHR";
        case(PipelineStageFlagBits2KHR::e2TopOfPipeBitKHR): return "e2TopOfPipeBitKHR";
        case(PipelineStageFlagBits2KHR::e2DrawIndirectBitKHR): return "e2DrawIndirectBitKHR";
        case(PipelineStageFlagBits2KHR::e2VertexInputBitKHR): return "e2VertexInputBitKHR";
        case(PipelineStageFlagBits2KHR::e2VertexShaderBitKHR): return "e2VertexShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2TessellationControlShaderBitKHR): return "e2TessellationControlShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2TessellationEvaluationShaderBitKHR): return "e2TessellationEvaluationShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2GeometryShaderBitKHR): return "e2GeometryShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2FragmentShaderBitKHR): return "e2FragmentShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2EarlyFragmentTestsBitKHR): return "e2EarlyFragmentTestsBitKHR";
        case(PipelineStageFlagBits2KHR::e2LateFragmentTestsBitKHR): return "e2LateFragmentTestsBitKHR";
        case(PipelineStageFlagBits2KHR::e2ColorAttachmentOutputBitKHR): return "e2ColorAttachmentOutputBitKHR";
        case(PipelineStageFlagBits2KHR::e2ComputeShaderBitKHR): return "e2ComputeShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2AllTransferBitKHR): return "e2AllTransferBitKHR";
        case(PipelineStageFlagBits2KHR::e2BottomOfPipeBitKHR): return "e2BottomOfPipeBitKHR";
        case(PipelineStageFlagBits2KHR::e2HostBitKHR): return "e2HostBitKHR";
        case(PipelineStageFlagBits2KHR::e2AllGraphicsBitKHR): return "e2AllGraphicsBitKHR";
        case(PipelineStageFlagBits2KHR::e2AllCommandsBitKHR): return "e2AllCommandsBitKHR";
        case(PipelineStageFlagBits2KHR::e2CopyBitKHR): return "e2CopyBitKHR";
        case(PipelineStageFlagBits2KHR::e2ResolveBitKHR): return "e2ResolveBitKHR";
        case(PipelineStageFlagBits2KHR::e2BlitBitKHR): return "e2BlitBitKHR";
        case(PipelineStageFlagBits2KHR::e2ClearBitKHR): return "e2ClearBitKHR";
        case(PipelineStageFlagBits2KHR::e2IndexInputBitKHR): return "e2IndexInputBitKHR";
        case(PipelineStageFlagBits2KHR::e2VertexAttributeInputBitKHR): return "e2VertexAttributeInputBitKHR";
        case(PipelineStageFlagBits2KHR::e2PreRasterizationShadersBitKHR): return "e2PreRasterizationShadersBitKHR";
        case(PipelineStageFlagBits2KHR::e2VideoDecodeBitKHR): return "e2VideoDecodeBitKHR";
        case(PipelineStageFlagBits2KHR::e2VideoEncodeBitKHR): return "e2VideoEncodeBitKHR";
        case(PipelineStageFlagBits2KHR::e2TransformFeedbackBitEXT): return "e2TransformFeedbackBitEXT";
        case(PipelineStageFlagBits2KHR::e2ConditionalRenderingBitEXT): return "e2ConditionalRenderingBitEXT";
        case(PipelineStageFlagBits2KHR::e2CommandPreprocessBitNV): return "e2CommandPreprocessBitNV";
        case(PipelineStageFlagBits2KHR::e2FragmentShadingRateAttachmentBitKHR): return "e2FragmentShadingRateAttachmentBitKHR";
        case(PipelineStageFlagBits2KHR::e2AccelerationStructureBuildBitKHR): return "e2AccelerationStructureBuildBitKHR";
        case(PipelineStageFlagBits2KHR::e2RayTracingShaderBitKHR): return "e2RayTracingShaderBitKHR";
        case(PipelineStageFlagBits2KHR::e2FragmentDensityProcessBitEXT): return "e2FragmentDensityProcessBitEXT";
        case(PipelineStageFlagBits2KHR::e2TaskShaderBitNV): return "e2TaskShaderBitNV";
        case(PipelineStageFlagBits2KHR::e2MeshShaderBitNV): return "e2MeshShaderBitNV";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(PipelineStageFlags2KHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & PipelineStageFlagBits2KHR::e2NoneKHR) out += "e2NoneKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2TopOfPipeBitKHR) out += "e2TopOfPipeBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2DrawIndirectBitKHR) out += "e2DrawIndirectBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2VertexInputBitKHR) out += "e2VertexInputBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2VertexShaderBitKHR) out += "e2VertexShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2TessellationControlShaderBitKHR) out += "e2TessellationControlShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2TessellationEvaluationShaderBitKHR) out += "e2TessellationEvaluationShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2GeometryShaderBitKHR) out += "e2GeometryShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2FragmentShaderBitKHR) out += "e2FragmentShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2EarlyFragmentTestsBitKHR) out += "e2EarlyFragmentTestsBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2LateFragmentTestsBitKHR) out += "e2LateFragmentTestsBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2ColorAttachmentOutputBitKHR) out += "e2ColorAttachmentOutputBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2ComputeShaderBitKHR) out += "e2ComputeShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2AllTransferBitKHR) out += "e2AllTransferBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2BottomOfPipeBitKHR) out += "e2BottomOfPipeBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2HostBitKHR) out += "e2HostBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2AllGraphicsBitKHR) out += "e2AllGraphicsBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2AllCommandsBitKHR) out += "e2AllCommandsBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2CopyBitKHR) out += "e2CopyBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2ResolveBitKHR) out += "e2ResolveBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2BlitBitKHR) out += "e2BlitBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2ClearBitKHR) out += "e2ClearBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2IndexInputBitKHR) out += "e2IndexInputBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2VertexAttributeInputBitKHR) out += "e2VertexAttributeInputBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2PreRasterizationShadersBitKHR) out += "e2PreRasterizationShadersBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2VideoDecodeBitKHR) out += "e2VideoDecodeBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2VideoEncodeBitKHR) out += "e2VideoEncodeBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2TransformFeedbackBitEXT) out += "e2TransformFeedbackBitEXT | ";
    if (flag & PipelineStageFlagBits2KHR::e2ConditionalRenderingBitEXT) out += "e2ConditionalRenderingBitEXT | ";
    if (flag & PipelineStageFlagBits2KHR::e2CommandPreprocessBitNV) out += "e2CommandPreprocessBitNV | ";
    if (flag & PipelineStageFlagBits2KHR::e2FragmentShadingRateAttachmentBitKHR) out += "e2FragmentShadingRateAttachmentBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2AccelerationStructureBuildBitKHR) out += "e2AccelerationStructureBuildBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2RayTracingShaderBitKHR) out += "e2RayTracingShaderBitKHR | ";
    if (flag & PipelineStageFlagBits2KHR::e2FragmentDensityProcessBitEXT) out += "e2FragmentDensityProcessBitEXT | ";
    if (flag & PipelineStageFlagBits2KHR::e2TaskShaderBitNV) out += "e2TaskShaderBitNV | ";
    if (flag & PipelineStageFlagBits2KHR::e2MeshShaderBitNV) out += "e2MeshShaderBitNV | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(SubmitFlagBitsKHR val) {
    switch(val) {
        case(SubmitFlagBitsKHR::ProtectedBitKHR): return "ProtectedBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(SubmitFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & SubmitFlagBitsKHR::ProtectedBitKHR) out += "ProtectedBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(EventCreateFlagBits val) {
    switch(val) {
        case(EventCreateFlagBits::DeviceOnlyBitKHR): return "DeviceOnlyBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(EventCreateFlags flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & EventCreateFlagBits::DeviceOnlyBitKHR) out += "DeviceOnlyBitKHR | ";
    return out.substr(0, out.size() - 3);
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
inline const char * to_string(VideoCodecOperationFlagBitsKHR val) {
    switch(val) {
        case(VideoCodecOperationFlagBitsKHR::InvalidBitKHR): return "InvalidBitKHR";
        case(VideoCodecOperationFlagBitsKHR::EncodeH264BitEXT): return "EncodeH264BitEXT";
        case(VideoCodecOperationFlagBitsKHR::DecodeH264BitEXT): return "DecodeH264BitEXT";
        case(VideoCodecOperationFlagBitsKHR::DecodeH265BitEXT): return "DecodeH265BitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoCodecOperationFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoCodecOperationFlagBitsKHR::InvalidBitKHR) out += "InvalidBitKHR | ";
    if (flag & VideoCodecOperationFlagBitsKHR::EncodeH264BitEXT) out += "EncodeH264BitEXT | ";
    if (flag & VideoCodecOperationFlagBitsKHR::DecodeH264BitEXT) out += "DecodeH264BitEXT | ";
    if (flag & VideoCodecOperationFlagBitsKHR::DecodeH265BitEXT) out += "DecodeH265BitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoChromaSubsamplingFlagBitsKHR val) {
    switch(val) {
        case(VideoChromaSubsamplingFlagBitsKHR::InvalidBitKHR): return "InvalidBitKHR";
        case(VideoChromaSubsamplingFlagBitsKHR::MonochromeBitKHR): return "MonochromeBitKHR";
        case(VideoChromaSubsamplingFlagBitsKHR::e420BitKHR): return "e420BitKHR";
        case(VideoChromaSubsamplingFlagBitsKHR::e422BitKHR): return "e422BitKHR";
        case(VideoChromaSubsamplingFlagBitsKHR::e444BitKHR): return "e444BitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoChromaSubsamplingFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoChromaSubsamplingFlagBitsKHR::InvalidBitKHR) out += "InvalidBitKHR | ";
    if (flag & VideoChromaSubsamplingFlagBitsKHR::MonochromeBitKHR) out += "MonochromeBitKHR | ";
    if (flag & VideoChromaSubsamplingFlagBitsKHR::e420BitKHR) out += "e420BitKHR | ";
    if (flag & VideoChromaSubsamplingFlagBitsKHR::e422BitKHR) out += "e422BitKHR | ";
    if (flag & VideoChromaSubsamplingFlagBitsKHR::e444BitKHR) out += "e444BitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoComponentBitDepthFlagBitsKHR val) {
    switch(val) {
        case(VideoComponentBitDepthFlagBitsKHR::InvalidKHR): return "InvalidKHR";
        case(VideoComponentBitDepthFlagBitsKHR::e8BitKHR): return "e8BitKHR";
        case(VideoComponentBitDepthFlagBitsKHR::e10BitKHR): return "e10BitKHR";
        case(VideoComponentBitDepthFlagBitsKHR::e12BitKHR): return "e12BitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoComponentBitDepthFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoComponentBitDepthFlagBitsKHR::InvalidKHR) out += "InvalidKHR | ";
    if (flag & VideoComponentBitDepthFlagBitsKHR::e8BitKHR) out += "e8BitKHR | ";
    if (flag & VideoComponentBitDepthFlagBitsKHR::e10BitKHR) out += "e10BitKHR | ";
    if (flag & VideoComponentBitDepthFlagBitsKHR::e12BitKHR) out += "e12BitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoCapabilitiesFlagBitsKHR val) {
    switch(val) {
        case(VideoCapabilitiesFlagBitsKHR::ProtectedContentBitKHR): return "ProtectedContentBitKHR";
        case(VideoCapabilitiesFlagBitsKHR::SeparateReferenceImagesBitKHR): return "SeparateReferenceImagesBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoCapabilitiesFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoCapabilitiesFlagBitsKHR::ProtectedContentBitKHR) out += "ProtectedContentBitKHR | ";
    if (flag & VideoCapabilitiesFlagBitsKHR::SeparateReferenceImagesBitKHR) out += "SeparateReferenceImagesBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoSessionCreateFlagBitsKHR val) {
    switch(val) {
        case(VideoSessionCreateFlagBitsKHR::DefaultKHR): return "DefaultKHR";
        case(VideoSessionCreateFlagBitsKHR::ProtectedContentBitKHR): return "ProtectedContentBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoSessionCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoSessionCreateFlagBitsKHR::DefaultKHR) out += "DefaultKHR | ";
    if (flag & VideoSessionCreateFlagBitsKHR::ProtectedContentBitKHR) out += "ProtectedContentBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoCodingQualityPresetFlagBitsKHR val) {
    switch(val) {
        case(VideoCodingQualityPresetFlagBitsKHR::DefaultBitKHR): return "DefaultBitKHR";
        case(VideoCodingQualityPresetFlagBitsKHR::NormalBitKHR): return "NormalBitKHR";
        case(VideoCodingQualityPresetFlagBitsKHR::PowerBitKHR): return "PowerBitKHR";
        case(VideoCodingQualityPresetFlagBitsKHR::QualityBitKHR): return "QualityBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoCodingQualityPresetFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoCodingQualityPresetFlagBitsKHR::DefaultBitKHR) out += "DefaultBitKHR | ";
    if (flag & VideoCodingQualityPresetFlagBitsKHR::NormalBitKHR) out += "NormalBitKHR | ";
    if (flag & VideoCodingQualityPresetFlagBitsKHR::PowerBitKHR) out += "PowerBitKHR | ";
    if (flag & VideoCodingQualityPresetFlagBitsKHR::QualityBitKHR) out += "QualityBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoDecodeH264FieldLayoutFlagBitsEXT val) {
    switch(val) {
        case(VideoDecodeH264FieldLayoutFlagBitsEXT::OnlyEXT): return "OnlyEXT";
        case(VideoDecodeH264FieldLayoutFlagBitsEXT::LineInterlacedPlaneBitEXT): return "LineInterlacedPlaneBitEXT";
        case(VideoDecodeH264FieldLayoutFlagBitsEXT::SeparateInterlacedPlaneBitEXT): return "SeparateInterlacedPlaneBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoDecodeH264FieldLayoutFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoDecodeH264FieldLayoutFlagBitsEXT::OnlyEXT) out += "OnlyEXT | ";
    if (flag & VideoDecodeH264FieldLayoutFlagBitsEXT::LineInterlacedPlaneBitEXT) out += "LineInterlacedPlaneBitEXT | ";
    if (flag & VideoDecodeH264FieldLayoutFlagBitsEXT::SeparateInterlacedPlaneBitEXT) out += "SeparateInterlacedPlaneBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoCodingControlFlagBitsKHR val) {
    switch(val) {
        case(VideoCodingControlFlagBitsKHR::DefaultKHR): return "DefaultKHR";
        case(VideoCodingControlFlagBitsKHR::ResetBitKHR): return "ResetBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoCodingControlFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoCodingControlFlagBitsKHR::DefaultKHR) out += "DefaultKHR | ";
    if (flag & VideoCodingControlFlagBitsKHR::ResetBitKHR) out += "ResetBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoDecodeFlagBitsKHR val) {
    switch(val) {
        case(VideoDecodeFlagBitsKHR::DefaultKHR): return "DefaultKHR";
        case(VideoDecodeFlagBitsKHR::Reserved0BitKHR): return "Reserved0BitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoDecodeFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoDecodeFlagBitsKHR::DefaultKHR) out += "DefaultKHR | ";
    if (flag & VideoDecodeFlagBitsKHR::Reserved0BitKHR) out += "Reserved0BitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeFlagBitsKHR val) {
    switch(val) {
        case(VideoEncodeFlagBitsKHR::DefaultKHR): return "DefaultKHR";
        case(VideoEncodeFlagBitsKHR::Reserved0BitKHR): return "Reserved0BitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeFlagBitsKHR::DefaultKHR) out += "DefaultKHR | ";
    if (flag & VideoEncodeFlagBitsKHR::Reserved0BitKHR) out += "Reserved0BitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeRateControlFlagBitsKHR val) {
    switch(val) {
        case(VideoEncodeRateControlFlagBitsKHR::DefaultKHR): return "DefaultKHR";
        case(VideoEncodeRateControlFlagBitsKHR::ResetBitKHR): return "ResetBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeRateControlFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeRateControlFlagBitsKHR::DefaultKHR) out += "DefaultKHR | ";
    if (flag & VideoEncodeRateControlFlagBitsKHR::ResetBitKHR) out += "ResetBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeRateControlModeFlagBitsKHR val) {
    switch(val) {
        case(VideoEncodeRateControlModeFlagBitsKHR::NoneBitKHR): return "NoneBitKHR";
        case(VideoEncodeRateControlModeFlagBitsKHR::CbrBitKHR): return "CbrBitKHR";
        case(VideoEncodeRateControlModeFlagBitsKHR::VbrBitKHR): return "VbrBitKHR";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeRateControlModeFlagsKHR flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeRateControlModeFlagBitsKHR::NoneBitKHR) out += "NoneBitKHR | ";
    if (flag & VideoEncodeRateControlModeFlagBitsKHR::CbrBitKHR) out += "CbrBitKHR | ";
    if (flag & VideoEncodeRateControlModeFlagBitsKHR::VbrBitKHR) out += "VbrBitKHR | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeH264CapabilitiesFlagBitsEXT val) {
    switch(val) {
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::CabacBitEXT): return "CabacBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::CavlcBitEXT): return "CavlcBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::WeightedBiPredImplicitBitEXT): return "WeightedBiPredImplicitBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::Transform8X8BitEXT): return "Transform8X8BitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::ChromaQpOffsetBitEXT): return "ChromaQpOffsetBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::SecondChromaQpOffsetBitEXT): return "SecondChromaQpOffsetBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::DeblockingFilterDisabledBitEXT): return "DeblockingFilterDisabledBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::DeblockingFilterEnabledBitEXT): return "DeblockingFilterEnabledBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::DeblockingFilterPartialBitEXT): return "DeblockingFilterPartialBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::MultipleSlicePerFrameBitEXT): return "MultipleSlicePerFrameBitEXT";
        case(VideoEncodeH264CapabilitiesFlagBitsEXT::EvenlyDistributedSliceSizeBitEXT): return "EvenlyDistributedSliceSizeBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeH264CapabilitiesFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::CabacBitEXT) out += "CabacBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::CavlcBitEXT) out += "CavlcBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::WeightedBiPredImplicitBitEXT) out += "WeightedBiPredImplicitBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::Transform8X8BitEXT) out += "Transform8X8BitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::ChromaQpOffsetBitEXT) out += "ChromaQpOffsetBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::SecondChromaQpOffsetBitEXT) out += "SecondChromaQpOffsetBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::DeblockingFilterDisabledBitEXT) out += "DeblockingFilterDisabledBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::DeblockingFilterEnabledBitEXT) out += "DeblockingFilterEnabledBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::DeblockingFilterPartialBitEXT) out += "DeblockingFilterPartialBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::MultipleSlicePerFrameBitEXT) out += "MultipleSlicePerFrameBitEXT | ";
    if (flag & VideoEncodeH264CapabilitiesFlagBitsEXT::EvenlyDistributedSliceSizeBitEXT) out += "EvenlyDistributedSliceSizeBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeH264InputModeFlagBitsEXT val) {
    switch(val) {
        case(VideoEncodeH264InputModeFlagBitsEXT::FrameBitEXT): return "FrameBitEXT";
        case(VideoEncodeH264InputModeFlagBitsEXT::SliceBitEXT): return "SliceBitEXT";
        case(VideoEncodeH264InputModeFlagBitsEXT::NonVclBitEXT): return "NonVclBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeH264InputModeFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeH264InputModeFlagBitsEXT::FrameBitEXT) out += "FrameBitEXT | ";
    if (flag & VideoEncodeH264InputModeFlagBitsEXT::SliceBitEXT) out += "SliceBitEXT | ";
    if (flag & VideoEncodeH264InputModeFlagBitsEXT::NonVclBitEXT) out += "NonVclBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeH264OutputModeFlagBitsEXT val) {
    switch(val) {
        case(VideoEncodeH264OutputModeFlagBitsEXT::FrameBitEXT): return "FrameBitEXT";
        case(VideoEncodeH264OutputModeFlagBitsEXT::SliceBitEXT): return "SliceBitEXT";
        case(VideoEncodeH264OutputModeFlagBitsEXT::NonVclBitEXT): return "NonVclBitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeH264OutputModeFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeH264OutputModeFlagBitsEXT::FrameBitEXT) out += "FrameBitEXT | ";
    if (flag & VideoEncodeH264OutputModeFlagBitsEXT::SliceBitEXT) out += "SliceBitEXT | ";
    if (flag & VideoEncodeH264OutputModeFlagBitsEXT::NonVclBitEXT) out += "NonVclBitEXT | ";
    return out.substr(0, out.size() - 3);
}
inline const char * to_string(VideoEncodeH264CreateFlagBitsEXT val) {
    switch(val) {
        case(VideoEncodeH264CreateFlagBitsEXT::DefaultEXT): return "DefaultEXT";
        case(VideoEncodeH264CreateFlagBitsEXT::Reserved0BitEXT): return "Reserved0BitEXT";
        default: return "UNKNOWN";
    }
}
inline std::string to_string(VideoEncodeH264CreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    std::string out;
    if (flag & VideoEncodeH264CreateFlagBitsEXT::DefaultEXT) out += "DefaultEXT | ";
    if (flag & VideoEncodeH264CreateFlagBitsEXT::Reserved0BitEXT) out += "Reserved0BitEXT | ";
    return out.substr(0, out.size() - 3);
}
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
inline const char * to_string([[maybe_unused]] QueryPoolCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(QueryPoolCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineLayoutCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineLayoutCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineDepthStencilStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineDepthStencilStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineDynamicStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineDynamicStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineColorBlendStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineColorBlendStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineMultisampleStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineMultisampleStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineRasterizationStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineRasterizationStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineViewportStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineViewportStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineTessellationStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineTessellationStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineInputAssemblyStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineInputAssemblyStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineVertexInputStateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(PipelineVertexInputStateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] BufferViewCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(BufferViewCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] InstanceCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(InstanceCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DeviceCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(DeviceCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] SemaphoreCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(SemaphoreCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] MemoryMapFlagBits val) { return "Unknown"; } 
inline std::string to_string(MemoryMapFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DescriptorPoolResetFlagBits val) { return "Unknown"; } 
inline std::string to_string(DescriptorPoolResetFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DescriptorUpdateTemplateCreateFlagBits val) { return "Unknown"; } 
inline std::string to_string(DescriptorUpdateTemplateCreateFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DisplayModeCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(DisplayModeCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DisplaySurfaceCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(DisplaySurfaceCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
inline const char * to_string([[maybe_unused]] AndroidSurfaceCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(AndroidSurfaceCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_VI_NN)
inline const char * to_string([[maybe_unused]] ViSurfaceCreateFlagBitsNN val) { return "Unknown"; } 
inline std::string to_string(ViSurfaceCreateFlagsNN flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_VI_NN)
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
inline const char * to_string([[maybe_unused]] WaylandSurfaceCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(WaylandSurfaceCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_WAYLAND_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline const char * to_string([[maybe_unused]] Win32SurfaceCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(Win32SurfaceCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_XLIB_KHR)
inline const char * to_string([[maybe_unused]] XlibSurfaceCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(XlibSurfaceCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_XLIB_KHR)
#if defined(VK_USE_PLATFORM_XCB_KHR)
inline const char * to_string([[maybe_unused]] XcbSurfaceCreateFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(XcbSurfaceCreateFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_XCB_KHR)
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
inline const char * to_string([[maybe_unused]] DirectFBSurfaceCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(DirectFBSurfaceCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#if defined(VK_USE_PLATFORM_IOS_MVK)
inline const char * to_string([[maybe_unused]] IOSSurfaceCreateFlagBitsMVK val) { return "Unknown"; } 
inline std::string to_string(IOSSurfaceCreateFlagsMVK flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_IOS_MVK)
#if defined(VK_USE_PLATFORM_MACOS_MVK)
inline const char * to_string([[maybe_unused]] MacOSSurfaceCreateFlagBitsMVK val) { return "Unknown"; } 
inline std::string to_string(MacOSSurfaceCreateFlagsMVK flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_MACOS_MVK)
#if defined(VK_USE_PLATFORM_METAL_EXT)
inline const char * to_string([[maybe_unused]] MetalSurfaceCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(MetalSurfaceCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_METAL_EXT)
#if defined(VK_USE_PLATFORM_FUCHSIA)
inline const char * to_string([[maybe_unused]] ImagePipeSurfaceCreateFlagBitsFUCHSIA val) { return "Unknown"; } 
inline std::string to_string(ImagePipeSurfaceCreateFlagsFUCHSIA flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_FUCHSIA)
#if defined(VK_USE_PLATFORM_GGP)
inline const char * to_string([[maybe_unused]] StreamDescriptorSurfaceCreateFlagBitsGGP val) { return "Unknown"; } 
inline std::string to_string(StreamDescriptorSurfaceCreateFlagsGGP flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_GGP)
inline const char * to_string([[maybe_unused]] HeadlessSurfaceCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(HeadlessSurfaceCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
inline const char * to_string([[maybe_unused]] ScreenSurfaceCreateFlagBitsQNX val) { return "Unknown"; } 
inline std::string to_string(ScreenSurfaceCreateFlagsQNX flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_USE_PLATFORM_SCREEN_QNX)
inline const char * to_string([[maybe_unused]] CommandPoolTrimFlagBits val) { return "Unknown"; } 
inline std::string to_string(CommandPoolTrimFlags flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineViewportSwizzleStateCreateFlagBitsNV val) { return "Unknown"; } 
inline std::string to_string(PipelineViewportSwizzleStateCreateFlagsNV flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineDiscardRectangleStateCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(PipelineDiscardRectangleStateCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineCoverageToColorStateCreateFlagBitsNV val) { return "Unknown"; } 
inline std::string to_string(PipelineCoverageToColorStateCreateFlagsNV flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineCoverageModulationStateCreateFlagBitsNV val) { return "Unknown"; } 
inline std::string to_string(PipelineCoverageModulationStateCreateFlagsNV flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineCoverageReductionStateCreateFlagBitsNV val) { return "Unknown"; } 
inline std::string to_string(PipelineCoverageReductionStateCreateFlagsNV flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] ValidationCacheCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(ValidationCacheCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DebugUtilsMessengerCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(DebugUtilsMessengerCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DebugUtilsMessengerCallbackDataFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(DebugUtilsMessengerCallbackDataFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] DeviceMemoryReportFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(DeviceMemoryReportFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineRasterizationConservativeStateCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(PipelineRasterizationConservativeStateCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineRasterizationStateStreamCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(PipelineRasterizationStateStreamCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] PipelineRasterizationDepthClipStateCreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(PipelineRasterizationDepthClipStateCreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
inline const char * to_string([[maybe_unused]] VideoBeginCodingFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(VideoBeginCodingFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] VideoEndCodingFlagBitsKHR val) { return "Unknown"; } 
inline std::string to_string(VideoEndCodingFlagsKHR flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] VideoDecodeH264CreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(VideoDecodeH264CreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
inline const char * to_string([[maybe_unused]] VideoDecodeH265CreateFlagBitsEXT val) { return "Unknown"; } 
inline std::string to_string(VideoDecodeH265CreateFlagsEXT flag){
    if (flag.flags == 0) return "None";
    return "Unknown";
}
#endif // defined(VK_ENABLE_BETA_EXTENSIONS)
#if defined(_MSC_VER)
#pragma warning( pop )
#endif // defined(_MSC_VER)
} // namespace vk
// clang-format on
